
h750Loader.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   00000494  24000004  24000004  00010004  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .ARM          00000008  24000498  24000498  00010498  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .init_array   00000004  240004a0  240004a0  000104a0  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  3 .fini_array   00000004  240004a4  240004a4  000104a4  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  4 .data         0000007c  240004a8  240004a8  000104a8  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  5 .bss          00000090  24000524  24000524  00010524  2**2
                  ALLOC
  6 .text         000164ec  240005b4  240005b4  000105b4  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  7 .Dev_info     000000c8  24016aa0  24016aa0  00036aa0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  8 .rodata       0000001c  24016b68  24016b68  00026b68  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  9 ._user_heap_stack 00000a00  24016b84  24016b84  00026b84  2**0
                  ALLOC
 10 .ARM.attributes 0000002e  00000000  00000000  00036b68  2**0
                  CONTENTS, READONLY
 11 .debug_info   00023136  00000000  00000000  00036b96  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_abbrev 00004397  00000000  00000000  00059ccc  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_aranges 000011b8  00000000  00000000  0005e068  2**3
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_ranges 00000fd8  00000000  00000000  0005f220  2**3
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_macro  00038424  00000000  00000000  000601f8  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_line   0001384a  00000000  00000000  0009861c  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_str    001558bb  00000000  00000000  000abe66  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .comment      0000007b  00000000  00000000  00201721  2**0
                  CONTENTS, READONLY
 19 .debug_frame  000046fc  00000000  00000000  0020179c  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

240005b4 <__do_global_dtors_aux>:
240005b4:	b510      	push	{r4, lr}
240005b6:	4c05      	ldr	r4, [pc, #20]	; (240005cc <__bss_end__+0x18>)
240005b8:	7823      	ldrb	r3, [r4, #0]
240005ba:	b933      	cbnz	r3, 240005ca <__do_global_dtors_aux+0x16>
240005bc:	4b04      	ldr	r3, [pc, #16]	; (240005d0 <__bss_end__+0x1c>)
240005be:	b113      	cbz	r3, 240005c6 <__do_global_dtors_aux+0x12>
240005c0:	4804      	ldr	r0, [pc, #16]	; (240005d4 <__bss_end__+0x20>)
240005c2:	f3af 8000 	nop.w
240005c6:	2301      	movs	r3, #1
240005c8:	7023      	strb	r3, [r4, #0]
240005ca:	bd10      	pop	{r4, pc}
240005cc:	24000524 	.word	0x24000524
240005d0:	00000000 	.word	0x00000000
240005d4:	24016a84 	.word	0x24016a84

240005d8 <frame_dummy>:
240005d8:	b508      	push	{r3, lr}
240005da:	4b03      	ldr	r3, [pc, #12]	; (240005e8 <frame_dummy+0x10>)
240005dc:	b11b      	cbz	r3, 240005e6 <frame_dummy+0xe>
240005de:	4903      	ldr	r1, [pc, #12]	; (240005ec <frame_dummy+0x14>)
240005e0:	4803      	ldr	r0, [pc, #12]	; (240005f0 <frame_dummy+0x18>)
240005e2:	f3af 8000 	nop.w
240005e6:	bd08      	pop	{r3, pc}
240005e8:	00000000 	.word	0x00000000
240005ec:	24000528 	.word	0x24000528
240005f0:	24016a84 	.word	0x24016a84

240005f4 <_mainCRTStartup>:
240005f4:	4b15      	ldr	r3, [pc, #84]	; (2400064c <_mainCRTStartup+0x58>)
240005f6:	2b00      	cmp	r3, #0
240005f8:	bf08      	it	eq
240005fa:	4b13      	ldreq	r3, [pc, #76]	; (24000648 <_mainCRTStartup+0x54>)
240005fc:	469d      	mov	sp, r3
240005fe:	f5a3 3a80 	sub.w	sl, r3, #65536	; 0x10000
24000602:	2100      	movs	r1, #0
24000604:	468b      	mov	fp, r1
24000606:	460f      	mov	r7, r1
24000608:	4813      	ldr	r0, [pc, #76]	; (24000658 <_mainCRTStartup+0x64>)
2400060a:	4a14      	ldr	r2, [pc, #80]	; (2400065c <_mainCRTStartup+0x68>)
2400060c:	1a12      	subs	r2, r2, r0
2400060e:	f016 fa31 	bl	24016a74 <memset>
24000612:	4b0f      	ldr	r3, [pc, #60]	; (24000650 <_mainCRTStartup+0x5c>)
24000614:	2b00      	cmp	r3, #0
24000616:	d000      	beq.n	2400061a <_mainCRTStartup+0x26>
24000618:	4798      	blx	r3
2400061a:	4b0e      	ldr	r3, [pc, #56]	; (24000654 <_mainCRTStartup+0x60>)
2400061c:	2b00      	cmp	r3, #0
2400061e:	d000      	beq.n	24000622 <_mainCRTStartup+0x2e>
24000620:	4798      	blx	r3
24000622:	2000      	movs	r0, #0
24000624:	2100      	movs	r1, #0
24000626:	0004      	movs	r4, r0
24000628:	000d      	movs	r5, r1
2400062a:	480d      	ldr	r0, [pc, #52]	; (24000660 <_mainCRTStartup+0x6c>)
2400062c:	2800      	cmp	r0, #0
2400062e:	d002      	beq.n	24000636 <_mainCRTStartup+0x42>
24000630:	480c      	ldr	r0, [pc, #48]	; (24000664 <_mainCRTStartup+0x70>)
24000632:	f3af 8000 	nop.w
24000636:	f016 f9f9 	bl	24016a2c <__libc_init_array>
2400063a:	0020      	movs	r0, r4
2400063c:	0029      	movs	r1, r5
2400063e:	f015 f9b9 	bl	240159b4 <main>
24000642:	f016 f9df 	bl	24016a04 <exit>
24000646:	bf00      	nop
24000648:	00080000 	.word	0x00080000
	...
24000658:	24000524 	.word	0x24000524
2400065c:	240005b4 	.word	0x240005b4
	...
24000668:	240004a8 	.word	0x240004a8
2400066c:	240004a8 	.word	0x240004a8
24000670:	24000524 	.word	0x24000524
24000674:	24000524 	.word	0x24000524
24000678:	240005b4 	.word	0x240005b4

2400067c <HAL_Init>:
  *         need to ensure that the SysTick time base is always set to 1 millisecond
  *         to have correct HAL operation.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
2400067c:	b580      	push	{r7, lr}
2400067e:	b082      	sub	sp, #8
24000680:	af00      	add	r7, sp, #0
   __HAL_ART_CONFIG_BASE_ADDRESS(0x08100000UL);  /* Configure the Cortex-M4 ART Base address to the Flash Bank 2 : */
   __HAL_ART_ENABLE();                           /* Enable the Cortex-M4 ART */
#endif /* DUAL_CORE &&  CORE_CM4 */

  /* Set Interrupt Group Priority */
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
24000682:	2003      	movs	r0, #3
24000684:	f000 ff30 	bl	240014e8 <HAL_NVIC_SetPriorityGrouping>

  /* Update the SystemCoreClock global variable */
#if defined(RCC_D1CFGR_D1CPRE)
  common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos]) & 0x1FU);
24000688:	f012 f9ae 	bl	240129e8 <HAL_RCC_GetSysClockFreq>
2400068c:	4601      	mov	r1, r0
2400068e:	4b15      	ldr	r3, [pc, #84]	; (240006e4 <HAL_Init+0x68>)
24000690:	699b      	ldr	r3, [r3, #24]
24000692:	0a1b      	lsrs	r3, r3, #8
24000694:	f003 030f 	and.w	r3, r3, #15
24000698:	4a13      	ldr	r2, [pc, #76]	; (240006e8 <HAL_Init+0x6c>)
2400069a:	5cd3      	ldrb	r3, [r2, r3]
2400069c:	f003 031f 	and.w	r3, r3, #31
240006a0:	fa21 f303 	lsr.w	r3, r1, r3
240006a4:	607b      	str	r3, [r7, #4]
  common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->CDCFGR1 & RCC_CDCFGR1_CDCPRE)>> RCC_CDCFGR1_CDCPRE_Pos]) & 0x1FU);
#endif

  /* Update the SystemD2Clock global variable */
#if defined(RCC_D1CFGR_HPRE)
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
240006a6:	4b0f      	ldr	r3, [pc, #60]	; (240006e4 <HAL_Init+0x68>)
240006a8:	699b      	ldr	r3, [r3, #24]
240006aa:	f003 030f 	and.w	r3, r3, #15
240006ae:	4a0e      	ldr	r2, [pc, #56]	; (240006e8 <HAL_Init+0x6c>)
240006b0:	5cd3      	ldrb	r3, [r2, r3]
240006b2:	f003 031f 	and.w	r3, r3, #31
240006b6:	687a      	ldr	r2, [r7, #4]
240006b8:	fa22 f303 	lsr.w	r3, r2, r3
240006bc:	4a0b      	ldr	r2, [pc, #44]	; (240006ec <HAL_Init+0x70>)
240006be:	6013      	str	r3, [r2, #0]
#endif

#if defined(DUAL_CORE) && defined(CORE_CM4)
  SystemCoreClock = SystemD2Clock;
#else
  SystemCoreClock = common_system_clock;
240006c0:	4a0b      	ldr	r2, [pc, #44]	; (240006f0 <HAL_Init+0x74>)
240006c2:	687b      	ldr	r3, [r7, #4]
240006c4:	6013      	str	r3, [r2, #0]
#endif /* DUAL_CORE && CORE_CM4 */

  /* Use systick as time base source and configure 1ms tick (default clock after Reset is HSI) */
  if(HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
240006c6:	2000      	movs	r0, #0
240006c8:	f000 f87a 	bl	240007c0 <HAL_InitTick>
240006cc:	4603      	mov	r3, r0
240006ce:	2b00      	cmp	r3, #0
240006d0:	d001      	beq.n	240006d6 <HAL_Init+0x5a>
  {
    return HAL_ERROR;
240006d2:	2301      	movs	r3, #1
240006d4:	e002      	b.n	240006dc <HAL_Init+0x60>
  }

  /* Init the low level hardware */
  HAL_MspInit();
240006d6:	f015 fe23 	bl	24016320 <HAL_MspInit>

  /* Return function status */
  return HAL_OK;
240006da:	2300      	movs	r3, #0
}
240006dc:	4618      	mov	r0, r3
240006de:	3708      	adds	r7, #8
240006e0:	46bd      	mov	sp, r7
240006e2:	bd80      	pop	{r7, pc}
240006e4:	58024400 	.word	0x58024400
240006e8:	24016b70 	.word	0x24016b70
240006ec:	240004bc 	.word	0x240004bc
240006f0:	240004b8 	.word	0x240004b8

240006f4 <HAL_DeInit>:
  * @brief  This function de-Initializes common part of the HAL and stops the systick.
  *         This function is optional.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DeInit(void)
{
240006f4:	b580      	push	{r7, lr}
240006f6:	af00      	add	r7, sp, #0
  /* Reset of all peripherals */
  __HAL_RCC_AHB3_FORCE_RESET();
240006f8:	4b29      	ldr	r3, [pc, #164]	; (240007a0 <HAL_DeInit+0xac>)
240006fa:	f06f 4200 	mvn.w	r2, #2147483648	; 0x80000000
240006fe:	67da      	str	r2, [r3, #124]	; 0x7c
  __HAL_RCC_AHB3_RELEASE_RESET();
24000700:	4b27      	ldr	r3, [pc, #156]	; (240007a0 <HAL_DeInit+0xac>)
24000702:	2200      	movs	r2, #0
24000704:	67da      	str	r2, [r3, #124]	; 0x7c

  __HAL_RCC_AHB1_FORCE_RESET();
24000706:	4b26      	ldr	r3, [pc, #152]	; (240007a0 <HAL_DeInit+0xac>)
24000708:	f04f 32ff 	mov.w	r2, #4294967295
2400070c:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
  __HAL_RCC_AHB1_RELEASE_RESET();
24000710:	4b23      	ldr	r3, [pc, #140]	; (240007a0 <HAL_DeInit+0xac>)
24000712:	2200      	movs	r2, #0
24000714:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80

  __HAL_RCC_AHB2_FORCE_RESET();
24000718:	4b21      	ldr	r3, [pc, #132]	; (240007a0 <HAL_DeInit+0xac>)
2400071a:	f04f 32ff 	mov.w	r2, #4294967295
2400071e:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
  __HAL_RCC_AHB2_RELEASE_RESET();
24000722:	4b1f      	ldr	r3, [pc, #124]	; (240007a0 <HAL_DeInit+0xac>)
24000724:	2200      	movs	r2, #0
24000726:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84

  __HAL_RCC_AHB4_FORCE_RESET();
2400072a:	4b1d      	ldr	r3, [pc, #116]	; (240007a0 <HAL_DeInit+0xac>)
2400072c:	f04f 32ff 	mov.w	r2, #4294967295
24000730:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
 __HAL_RCC_AHB4_RELEASE_RESET();
24000734:	4b1a      	ldr	r3, [pc, #104]	; (240007a0 <HAL_DeInit+0xac>)
24000736:	2200      	movs	r2, #0
24000738:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88

  __HAL_RCC_APB3_FORCE_RESET();
2400073c:	4b18      	ldr	r3, [pc, #96]	; (240007a0 <HAL_DeInit+0xac>)
2400073e:	f04f 32ff 	mov.w	r2, #4294967295
24000742:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
  __HAL_RCC_APB3_RELEASE_RESET();
24000746:	4b16      	ldr	r3, [pc, #88]	; (240007a0 <HAL_DeInit+0xac>)
24000748:	2200      	movs	r2, #0
2400074a:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c

  __HAL_RCC_APB1L_FORCE_RESET();
2400074e:	4b14      	ldr	r3, [pc, #80]	; (240007a0 <HAL_DeInit+0xac>)
24000750:	f04f 32ff 	mov.w	r2, #4294967295
24000754:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
  __HAL_RCC_APB1L_RELEASE_RESET();
24000758:	4b11      	ldr	r3, [pc, #68]	; (240007a0 <HAL_DeInit+0xac>)
2400075a:	2200      	movs	r2, #0
2400075c:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90

  __HAL_RCC_APB1H_FORCE_RESET();
24000760:	4b0f      	ldr	r3, [pc, #60]	; (240007a0 <HAL_DeInit+0xac>)
24000762:	f04f 32ff 	mov.w	r2, #4294967295
24000766:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
  __HAL_RCC_APB1H_RELEASE_RESET();
2400076a:	4b0d      	ldr	r3, [pc, #52]	; (240007a0 <HAL_DeInit+0xac>)
2400076c:	2200      	movs	r2, #0
2400076e:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94

   __HAL_RCC_APB2_FORCE_RESET();
24000772:	4b0b      	ldr	r3, [pc, #44]	; (240007a0 <HAL_DeInit+0xac>)
24000774:	f04f 32ff 	mov.w	r2, #4294967295
24000778:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
   __HAL_RCC_APB2_RELEASE_RESET();
2400077c:	4b08      	ldr	r3, [pc, #32]	; (240007a0 <HAL_DeInit+0xac>)
2400077e:	2200      	movs	r2, #0
24000780:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98

  __HAL_RCC_APB4_FORCE_RESET();
24000784:	4b06      	ldr	r3, [pc, #24]	; (240007a0 <HAL_DeInit+0xac>)
24000786:	f04f 32ff 	mov.w	r2, #4294967295
2400078a:	f8c3 209c 	str.w	r2, [r3, #156]	; 0x9c
  __HAL_RCC_APB4_RELEASE_RESET();
2400078e:	4b04      	ldr	r3, [pc, #16]	; (240007a0 <HAL_DeInit+0xac>)
24000790:	2200      	movs	r2, #0
24000792:	f8c3 209c 	str.w	r2, [r3, #156]	; 0x9c

  /* De-Init the low level hardware */
  HAL_MspDeInit();
24000796:	f000 f80c 	bl	240007b2 <HAL_MspDeInit>

  /* Return function status */
  return HAL_OK;
2400079a:	2300      	movs	r3, #0
}
2400079c:	4618      	mov	r0, r3
2400079e:	bd80      	pop	{r7, pc}
240007a0:	58024400 	.word	0x58024400
/**
  * @brief  Initializes the MSP.
  * @retval None
  */
__weak void HAL_MspInit(void)
{
240007a4:	b480      	push	{r7}
240007a6:	af00      	add	r7, sp, #0
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_MspInit could be implemented in the user file
   */
}
240007a8:	bf00      	nop
240007aa:	46bd      	mov	sp, r7
240007ac:	f85d 7b04 	ldr.w	r7, [sp], #4
240007b0:	4770      	bx	lr

240007b2 <HAL_MspDeInit>:
/**
  * @brief  DeInitializes the MSP.
  * @retval None
  */
__weak void HAL_MspDeInit(void)
{
240007b2:	b480      	push	{r7}
240007b4:	af00      	add	r7, sp, #0
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_MspDeInit could be implemented in the user file
   */
}
240007b6:	bf00      	nop
240007b8:	46bd      	mov	sp, r7
240007ba:	f85d 7b04 	ldr.w	r7, [sp], #4
240007be:	4770      	bx	lr

240007c0 <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority: Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
240007c0:	b580      	push	{r7, lr}
240007c2:	b082      	sub	sp, #8
240007c4:	af00      	add	r7, sp, #0
240007c6:	6078      	str	r0, [r7, #4]
  /* Check uwTickFreq for MisraC 2012 (even if uwTickFreq is a enum type that don't take the value zero)*/
  if((uint32_t)uwTickFreq == 0UL)
240007c8:	4b15      	ldr	r3, [pc, #84]	; (24000820 <HAL_InitTick+0x60>)
240007ca:	781b      	ldrb	r3, [r3, #0]
240007cc:	2b00      	cmp	r3, #0
240007ce:	d101      	bne.n	240007d4 <HAL_InitTick+0x14>
  {
    return HAL_ERROR;
240007d0:	2301      	movs	r3, #1
240007d2:	e021      	b.n	24000818 <HAL_InitTick+0x58>
  }

  /* Configure the SysTick to have interrupt in 1ms time basis*/
  if (HAL_SYSTICK_Config(SystemCoreClock / (1000UL / (uint32_t)uwTickFreq)) > 0U)
240007d4:	4b13      	ldr	r3, [pc, #76]	; (24000824 <HAL_InitTick+0x64>)
240007d6:	681a      	ldr	r2, [r3, #0]
240007d8:	4b11      	ldr	r3, [pc, #68]	; (24000820 <HAL_InitTick+0x60>)
240007da:	781b      	ldrb	r3, [r3, #0]
240007dc:	4619      	mov	r1, r3
240007de:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
240007e2:	fbb3 f3f1 	udiv	r3, r3, r1
240007e6:	fbb2 f3f3 	udiv	r3, r2, r3
240007ea:	4618      	mov	r0, r3
240007ec:	f000 fec1 	bl	24001572 <HAL_SYSTICK_Config>
240007f0:	4603      	mov	r3, r0
240007f2:	2b00      	cmp	r3, #0
240007f4:	d001      	beq.n	240007fa <HAL_InitTick+0x3a>
  {
    return HAL_ERROR;
240007f6:	2301      	movs	r3, #1
240007f8:	e00e      	b.n	24000818 <HAL_InitTick+0x58>
  }

  /* Configure the SysTick IRQ priority */
  if (TickPriority < (1UL << __NVIC_PRIO_BITS))
240007fa:	687b      	ldr	r3, [r7, #4]
240007fc:	2b0f      	cmp	r3, #15
240007fe:	d80a      	bhi.n	24000816 <HAL_InitTick+0x56>
  {
    HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
24000800:	2200      	movs	r2, #0
24000802:	6879      	ldr	r1, [r7, #4]
24000804:	f04f 30ff 	mov.w	r0, #4294967295
24000808:	f000 fe79 	bl	240014fe <HAL_NVIC_SetPriority>
    uwTickPrio = TickPriority;
2400080c:	4a06      	ldr	r2, [pc, #24]	; (24000828 <HAL_InitTick+0x68>)
2400080e:	687b      	ldr	r3, [r7, #4]
24000810:	6013      	str	r3, [r2, #0]
  {
    return HAL_ERROR;
  }

  /* Return function status */
  return HAL_OK;
24000812:	2300      	movs	r3, #0
24000814:	e000      	b.n	24000818 <HAL_InitTick+0x58>
    return HAL_ERROR;
24000816:	2301      	movs	r3, #1
}
24000818:	4618      	mov	r0, r3
2400081a:	3708      	adds	r7, #8
2400081c:	46bd      	mov	sp, r7
2400081e:	bd80      	pop	{r7, pc}
24000820:	240004b0 	.word	0x240004b0
24000824:	240004b8 	.word	0x240004b8
24000828:	240004ac 	.word	0x240004ac

2400082c <HAL_IncTick>:
 * @note This function is declared as __weak to be overwritten in case of other
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
2400082c:	b480      	push	{r7}
2400082e:	af00      	add	r7, sp, #0
  uwTick += (uint32_t)uwTickFreq;
24000830:	4b06      	ldr	r3, [pc, #24]	; (2400084c <HAL_IncTick+0x20>)
24000832:	781b      	ldrb	r3, [r3, #0]
24000834:	461a      	mov	r2, r3
24000836:	4b06      	ldr	r3, [pc, #24]	; (24000850 <HAL_IncTick+0x24>)
24000838:	681b      	ldr	r3, [r3, #0]
2400083a:	4413      	add	r3, r2
2400083c:	4a04      	ldr	r2, [pc, #16]	; (24000850 <HAL_IncTick+0x24>)
2400083e:	6013      	str	r3, [r2, #0]
}
24000840:	bf00      	nop
24000842:	46bd      	mov	sp, r7
24000844:	f85d 7b04 	ldr.w	r7, [sp], #4
24000848:	4770      	bx	lr
2400084a:	bf00      	nop
2400084c:	240004b0 	.word	0x240004b0
24000850:	24000548 	.word	0x24000548

24000854 <HAL_GetTick>:
  * @note This function is declared as __weak to be overwritten in case of other
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
24000854:	b480      	push	{r7}
24000856:	af00      	add	r7, sp, #0
  return uwTick;
24000858:	4b03      	ldr	r3, [pc, #12]	; (24000868 <HAL_GetTick+0x14>)
2400085a:	681b      	ldr	r3, [r3, #0]
}
2400085c:	4618      	mov	r0, r3
2400085e:	46bd      	mov	sp, r7
24000860:	f85d 7b04 	ldr.w	r7, [sp], #4
24000864:	4770      	bx	lr
24000866:	bf00      	nop
24000868:	24000548 	.word	0x24000548

2400086c <HAL_GetTickPrio>:
/**
  * @brief This function returns a tick priority.
  * @retval tick priority
  */
uint32_t HAL_GetTickPrio(void)
{
2400086c:	b480      	push	{r7}
2400086e:	af00      	add	r7, sp, #0
  return uwTickPrio;
24000870:	4b03      	ldr	r3, [pc, #12]	; (24000880 <HAL_GetTickPrio+0x14>)
24000872:	681b      	ldr	r3, [r3, #0]
}
24000874:	4618      	mov	r0, r3
24000876:	46bd      	mov	sp, r7
24000878:	f85d 7b04 	ldr.w	r7, [sp], #4
2400087c:	4770      	bx	lr
2400087e:	bf00      	nop
24000880:	240004ac 	.word	0x240004ac

24000884 <HAL_SetTickFreq>:
/**
  * @brief Set new tick Freq.
  * @retval Status
  */
HAL_StatusTypeDef HAL_SetTickFreq(HAL_TickFreqTypeDef Freq)
{
24000884:	b580      	push	{r7, lr}
24000886:	b084      	sub	sp, #16
24000888:	af00      	add	r7, sp, #0
2400088a:	4603      	mov	r3, r0
2400088c:	71fb      	strb	r3, [r7, #7]
  HAL_StatusTypeDef status  = HAL_OK;
2400088e:	2300      	movs	r3, #0
24000890:	73fb      	strb	r3, [r7, #15]
  HAL_TickFreqTypeDef prevTickFreq;

  assert_param(IS_TICKFREQ(Freq));

  if (uwTickFreq != Freq)
24000892:	4b0e      	ldr	r3, [pc, #56]	; (240008cc <HAL_SetTickFreq+0x48>)
24000894:	781b      	ldrb	r3, [r3, #0]
24000896:	79fa      	ldrb	r2, [r7, #7]
24000898:	429a      	cmp	r2, r3
2400089a:	d012      	beq.n	240008c2 <HAL_SetTickFreq+0x3e>
  {

    /* Back up uwTickFreq frequency */
    prevTickFreq = uwTickFreq;
2400089c:	4b0b      	ldr	r3, [pc, #44]	; (240008cc <HAL_SetTickFreq+0x48>)
2400089e:	781b      	ldrb	r3, [r3, #0]
240008a0:	73bb      	strb	r3, [r7, #14]

    /* Update uwTickFreq global variable used by HAL_InitTick() */
    uwTickFreq = Freq;
240008a2:	4a0a      	ldr	r2, [pc, #40]	; (240008cc <HAL_SetTickFreq+0x48>)
240008a4:	79fb      	ldrb	r3, [r7, #7]
240008a6:	7013      	strb	r3, [r2, #0]

    /* Apply the new tick Freq  */
    status = HAL_InitTick(uwTickPrio);
240008a8:	4b09      	ldr	r3, [pc, #36]	; (240008d0 <HAL_SetTickFreq+0x4c>)
240008aa:	681b      	ldr	r3, [r3, #0]
240008ac:	4618      	mov	r0, r3
240008ae:	f7ff ff87 	bl	240007c0 <HAL_InitTick>
240008b2:	4603      	mov	r3, r0
240008b4:	73fb      	strb	r3, [r7, #15]
    if (status != HAL_OK)
240008b6:	7bfb      	ldrb	r3, [r7, #15]
240008b8:	2b00      	cmp	r3, #0
240008ba:	d002      	beq.n	240008c2 <HAL_SetTickFreq+0x3e>
    {
      /* Restore previous tick frequency */
      uwTickFreq = prevTickFreq;
240008bc:	4a03      	ldr	r2, [pc, #12]	; (240008cc <HAL_SetTickFreq+0x48>)
240008be:	7bbb      	ldrb	r3, [r7, #14]
240008c0:	7013      	strb	r3, [r2, #0]
    }
  }

  return status;
240008c2:	7bfb      	ldrb	r3, [r7, #15]
}
240008c4:	4618      	mov	r0, r3
240008c6:	3710      	adds	r7, #16
240008c8:	46bd      	mov	sp, r7
240008ca:	bd80      	pop	{r7, pc}
240008cc:	240004b0 	.word	0x240004b0
240008d0:	240004ac 	.word	0x240004ac

240008d4 <HAL_GetTickFreq>:
/**
  * @brief Return tick frequency.
  * @retval tick period in Hz
  */
HAL_TickFreqTypeDef HAL_GetTickFreq(void)
{
240008d4:	b480      	push	{r7}
240008d6:	af00      	add	r7, sp, #0
  return uwTickFreq;
240008d8:	4b03      	ldr	r3, [pc, #12]	; (240008e8 <HAL_GetTickFreq+0x14>)
240008da:	781b      	ldrb	r3, [r3, #0]
}
240008dc:	4618      	mov	r0, r3
240008de:	46bd      	mov	sp, r7
240008e0:	f85d 7b04 	ldr.w	r7, [sp], #4
240008e4:	4770      	bx	lr
240008e6:	bf00      	nop
240008e8:	240004b0 	.word	0x240004b0

240008ec <HAL_Delay>:
  *       implementations in user file.
  * @param Delay  specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(uint32_t Delay)
{
240008ec:	b580      	push	{r7, lr}
240008ee:	b084      	sub	sp, #16
240008f0:	af00      	add	r7, sp, #0
240008f2:	6078      	str	r0, [r7, #4]
  uint32_t tickstart = HAL_GetTick();
240008f4:	f7ff ffae 	bl	24000854 <HAL_GetTick>
240008f8:	60b8      	str	r0, [r7, #8]
  uint32_t wait = Delay;
240008fa:	687b      	ldr	r3, [r7, #4]
240008fc:	60fb      	str	r3, [r7, #12]

  /* Add a freq to guarantee minimum wait */
  if (wait < HAL_MAX_DELAY)
240008fe:	68fb      	ldr	r3, [r7, #12]
24000900:	f1b3 3fff 	cmp.w	r3, #4294967295
24000904:	d005      	beq.n	24000912 <HAL_Delay+0x26>
  {
    wait += (uint32_t)(uwTickFreq);
24000906:	4b09      	ldr	r3, [pc, #36]	; (2400092c <HAL_Delay+0x40>)
24000908:	781b      	ldrb	r3, [r3, #0]
2400090a:	461a      	mov	r2, r3
2400090c:	68fb      	ldr	r3, [r7, #12]
2400090e:	4413      	add	r3, r2
24000910:	60fb      	str	r3, [r7, #12]
  }

  while ((HAL_GetTick() - tickstart) < wait)
24000912:	bf00      	nop
24000914:	f7ff ff9e 	bl	24000854 <HAL_GetTick>
24000918:	4602      	mov	r2, r0
2400091a:	68bb      	ldr	r3, [r7, #8]
2400091c:	1ad3      	subs	r3, r2, r3
2400091e:	68fa      	ldr	r2, [r7, #12]
24000920:	429a      	cmp	r2, r3
24000922:	d8f7      	bhi.n	24000914 <HAL_Delay+0x28>
  {
  }
}
24000924:	bf00      	nop
24000926:	3710      	adds	r7, #16
24000928:	46bd      	mov	sp, r7
2400092a:	bd80      	pop	{r7, pc}
2400092c:	240004b0 	.word	0x240004b0

24000930 <HAL_SuspendTick>:
  * @note This function is declared as __weak to be overwritten in case of other
  *       implementations in user file.
  * @retval None
  */
__weak void HAL_SuspendTick(void)
{
24000930:	b480      	push	{r7}
24000932:	af00      	add	r7, sp, #0
  /* Disable SysTick Interrupt */
  SysTick->CTRL &= ~SysTick_CTRL_TICKINT_Msk;
24000934:	4b05      	ldr	r3, [pc, #20]	; (2400094c <HAL_SuspendTick+0x1c>)
24000936:	681b      	ldr	r3, [r3, #0]
24000938:	4a04      	ldr	r2, [pc, #16]	; (2400094c <HAL_SuspendTick+0x1c>)
2400093a:	f023 0302 	bic.w	r3, r3, #2
2400093e:	6013      	str	r3, [r2, #0]
}
24000940:	bf00      	nop
24000942:	46bd      	mov	sp, r7
24000944:	f85d 7b04 	ldr.w	r7, [sp], #4
24000948:	4770      	bx	lr
2400094a:	bf00      	nop
2400094c:	e000e010 	.word	0xe000e010

24000950 <HAL_ResumeTick>:
  * @note This function is declared as __weak to be overwritten in case of other
  *       implementations in user file.
  * @retval None
  */
__weak void HAL_ResumeTick(void)
{
24000950:	b480      	push	{r7}
24000952:	af00      	add	r7, sp, #0
  /* Enable SysTick Interrupt */
  SysTick->CTRL  |= SysTick_CTRL_TICKINT_Msk;
24000954:	4b05      	ldr	r3, [pc, #20]	; (2400096c <HAL_ResumeTick+0x1c>)
24000956:	681b      	ldr	r3, [r3, #0]
24000958:	4a04      	ldr	r2, [pc, #16]	; (2400096c <HAL_ResumeTick+0x1c>)
2400095a:	f043 0302 	orr.w	r3, r3, #2
2400095e:	6013      	str	r3, [r2, #0]
}
24000960:	bf00      	nop
24000962:	46bd      	mov	sp, r7
24000964:	f85d 7b04 	ldr.w	r7, [sp], #4
24000968:	4770      	bx	lr
2400096a:	bf00      	nop
2400096c:	e000e010 	.word	0xe000e010

24000970 <HAL_GetHalVersion>:
/**
  * @brief  Returns the HAL revision
  * @retval version : 0xXYZR (8bits for each decimal, R for RC)
  */
uint32_t HAL_GetHalVersion(void)
{
24000970:	b480      	push	{r7}
24000972:	af00      	add	r7, sp, #0
 return __STM32H7xx_HAL_VERSION;
24000974:	f04f 7384 	mov.w	r3, #17301504	; 0x1080000
}
24000978:	4618      	mov	r0, r3
2400097a:	46bd      	mov	sp, r7
2400097c:	f85d 7b04 	ldr.w	r7, [sp], #4
24000980:	4770      	bx	lr
	...

24000984 <HAL_GetREVID>:
/**
  * @brief  Returns the device revision identifier.
  * @retval Device revision identifier
  */
uint32_t HAL_GetREVID(void)
{
24000984:	b480      	push	{r7}
24000986:	af00      	add	r7, sp, #0
   return((DBGMCU->IDCODE) >> 16);
24000988:	4b03      	ldr	r3, [pc, #12]	; (24000998 <HAL_GetREVID+0x14>)
2400098a:	681b      	ldr	r3, [r3, #0]
2400098c:	0c1b      	lsrs	r3, r3, #16
}
2400098e:	4618      	mov	r0, r3
24000990:	46bd      	mov	sp, r7
24000992:	f85d 7b04 	ldr.w	r7, [sp], #4
24000996:	4770      	bx	lr
24000998:	5c001000 	.word	0x5c001000

2400099c <HAL_GetDEVID>:
/**
  * @brief  Returns the device identifier.
  * @retval Device identifier
  */
uint32_t HAL_GetDEVID(void)
{
2400099c:	b480      	push	{r7}
2400099e:	af00      	add	r7, sp, #0
   return((DBGMCU->IDCODE) & IDCODE_DEVID_MASK);
240009a0:	4b04      	ldr	r3, [pc, #16]	; (240009b4 <HAL_GetDEVID+0x18>)
240009a2:	681b      	ldr	r3, [r3, #0]
240009a4:	f3c3 030b 	ubfx	r3, r3, #0, #12
}
240009a8:	4618      	mov	r0, r3
240009aa:	46bd      	mov	sp, r7
240009ac:	f85d 7b04 	ldr.w	r7, [sp], #4
240009b0:	4770      	bx	lr
240009b2:	bf00      	nop
240009b4:	5c001000 	.word	0x5c001000

240009b8 <HAL_GetUIDw0>:
/**
  * @brief  Return the first word of the unique device identifier (UID based on 96 bits)
  * @retval Device identifier
  */
uint32_t HAL_GetUIDw0(void)
{
240009b8:	b480      	push	{r7}
240009ba:	af00      	add	r7, sp, #0
  return(READ_REG(*((uint32_t *)UID_BASE)));
240009bc:	4b03      	ldr	r3, [pc, #12]	; (240009cc <HAL_GetUIDw0+0x14>)
240009be:	681b      	ldr	r3, [r3, #0]
}
240009c0:	4618      	mov	r0, r3
240009c2:	46bd      	mov	sp, r7
240009c4:	f85d 7b04 	ldr.w	r7, [sp], #4
240009c8:	4770      	bx	lr
240009ca:	bf00      	nop
240009cc:	1ff1e800 	.word	0x1ff1e800

240009d0 <HAL_GetUIDw1>:
/**
  * @brief  Return the second word of the unique device identifier (UID based on 96 bits)
  * @retval Device identifier
  */
uint32_t HAL_GetUIDw1(void)
{
240009d0:	b480      	push	{r7}
240009d2:	af00      	add	r7, sp, #0
  return(READ_REG(*((uint32_t *)(UID_BASE + 4U))));
240009d4:	4b03      	ldr	r3, [pc, #12]	; (240009e4 <HAL_GetUIDw1+0x14>)
240009d6:	681b      	ldr	r3, [r3, #0]
}
240009d8:	4618      	mov	r0, r3
240009da:	46bd      	mov	sp, r7
240009dc:	f85d 7b04 	ldr.w	r7, [sp], #4
240009e0:	4770      	bx	lr
240009e2:	bf00      	nop
240009e4:	1ff1e804 	.word	0x1ff1e804

240009e8 <HAL_GetUIDw2>:
/**
  * @brief  Return the third word of the unique device identifier (UID based on 96 bits)
  * @retval Device identifier
  */
uint32_t HAL_GetUIDw2(void)
{
240009e8:	b480      	push	{r7}
240009ea:	af00      	add	r7, sp, #0
  return(READ_REG(*((uint32_t *)(UID_BASE + 8U))));
240009ec:	4b03      	ldr	r3, [pc, #12]	; (240009fc <HAL_GetUIDw2+0x14>)
240009ee:	681b      	ldr	r3, [r3, #0]
}
240009f0:	4618      	mov	r0, r3
240009f2:	46bd      	mov	sp, r7
240009f4:	f85d 7b04 	ldr.w	r7, [sp], #4
240009f8:	4770      	bx	lr
240009fa:	bf00      	nop
240009fc:	1ff1e808 	.word	0x1ff1e808

24000a00 <HAL_SYSCFG_VREFBUF_VoltageScalingConfig>:
  *            @arg SYSCFG_VREFBUF_VOLTAGE_SCALE3: VREF_OUT4 around 1.8 V.
  *                                                This requires VDDA equal to or higher than 2.1 V.
  * @retval None
  */
void HAL_SYSCFG_VREFBUF_VoltageScalingConfig(uint32_t VoltageScaling)
{
24000a00:	b480      	push	{r7}
24000a02:	b083      	sub	sp, #12
24000a04:	af00      	add	r7, sp, #0
24000a06:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_SYSCFG_VREFBUF_VOLTAGE_SCALE(VoltageScaling));

  MODIFY_REG(VREFBUF->CSR, VREFBUF_CSR_VRS, VoltageScaling);
24000a08:	4b06      	ldr	r3, [pc, #24]	; (24000a24 <HAL_SYSCFG_VREFBUF_VoltageScalingConfig+0x24>)
24000a0a:	681b      	ldr	r3, [r3, #0]
24000a0c:	f023 0270 	bic.w	r2, r3, #112	; 0x70
24000a10:	4904      	ldr	r1, [pc, #16]	; (24000a24 <HAL_SYSCFG_VREFBUF_VoltageScalingConfig+0x24>)
24000a12:	687b      	ldr	r3, [r7, #4]
24000a14:	4313      	orrs	r3, r2
24000a16:	600b      	str	r3, [r1, #0]
}
24000a18:	bf00      	nop
24000a1a:	370c      	adds	r7, #12
24000a1c:	46bd      	mov	sp, r7
24000a1e:	f85d 7b04 	ldr.w	r7, [sp], #4
24000a22:	4770      	bx	lr
24000a24:	58003c00 	.word	0x58003c00

24000a28 <HAL_SYSCFG_VREFBUF_HighImpedanceConfig>:
  *            @arg SYSCFG_VREFBUF_HIGH_IMPEDANCE_DISABLE: VREF+ pin is internally connect to VREFINT output.
  *            @arg SYSCFG_VREFBUF_HIGH_IMPEDANCE_ENABLE: VREF+ pin is high impedance.
  * @retval None
  */
void HAL_SYSCFG_VREFBUF_HighImpedanceConfig(uint32_t Mode)
{
24000a28:	b480      	push	{r7}
24000a2a:	b083      	sub	sp, #12
24000a2c:	af00      	add	r7, sp, #0
24000a2e:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_SYSCFG_VREFBUF_HIGH_IMPEDANCE(Mode));

  MODIFY_REG(VREFBUF->CSR, VREFBUF_CSR_HIZ, Mode);
24000a30:	4b06      	ldr	r3, [pc, #24]	; (24000a4c <HAL_SYSCFG_VREFBUF_HighImpedanceConfig+0x24>)
24000a32:	681b      	ldr	r3, [r3, #0]
24000a34:	f023 0202 	bic.w	r2, r3, #2
24000a38:	4904      	ldr	r1, [pc, #16]	; (24000a4c <HAL_SYSCFG_VREFBUF_HighImpedanceConfig+0x24>)
24000a3a:	687b      	ldr	r3, [r7, #4]
24000a3c:	4313      	orrs	r3, r2
24000a3e:	600b      	str	r3, [r1, #0]
}
24000a40:	bf00      	nop
24000a42:	370c      	adds	r7, #12
24000a44:	46bd      	mov	sp, r7
24000a46:	f85d 7b04 	ldr.w	r7, [sp], #4
24000a4a:	4770      	bx	lr
24000a4c:	58003c00 	.word	0x58003c00

24000a50 <HAL_SYSCFG_VREFBUF_TrimmingConfig>:
/**
  * @brief  Tune the Internal Voltage Reference buffer (VREFBUF).
  * @retval None
  */
void HAL_SYSCFG_VREFBUF_TrimmingConfig(uint32_t TrimmingValue)
{
24000a50:	b480      	push	{r7}
24000a52:	b083      	sub	sp, #12
24000a54:	af00      	add	r7, sp, #0
24000a56:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_SYSCFG_VREFBUF_TRIMMING(TrimmingValue));

  MODIFY_REG(VREFBUF->CCR, VREFBUF_CCR_TRIM, TrimmingValue);
24000a58:	4b06      	ldr	r3, [pc, #24]	; (24000a74 <HAL_SYSCFG_VREFBUF_TrimmingConfig+0x24>)
24000a5a:	685b      	ldr	r3, [r3, #4]
24000a5c:	f023 023f 	bic.w	r2, r3, #63	; 0x3f
24000a60:	4904      	ldr	r1, [pc, #16]	; (24000a74 <HAL_SYSCFG_VREFBUF_TrimmingConfig+0x24>)
24000a62:	687b      	ldr	r3, [r7, #4]
24000a64:	4313      	orrs	r3, r2
24000a66:	604b      	str	r3, [r1, #4]
}
24000a68:	bf00      	nop
24000a6a:	370c      	adds	r7, #12
24000a6c:	46bd      	mov	sp, r7
24000a6e:	f85d 7b04 	ldr.w	r7, [sp], #4
24000a72:	4770      	bx	lr
24000a74:	58003c00 	.word	0x58003c00

24000a78 <HAL_SYSCFG_EnableVREFBUF>:
/**
  * @brief  Enable the Internal Voltage Reference buffer (VREFBUF).
  * @retval HAL_OK/HAL_TIMEOUT
  */
HAL_StatusTypeDef HAL_SYSCFG_EnableVREFBUF(void)
{
24000a78:	b580      	push	{r7, lr}
24000a7a:	b082      	sub	sp, #8
24000a7c:	af00      	add	r7, sp, #0
  uint32_t  tickstart;

  SET_BIT(VREFBUF->CSR, VREFBUF_CSR_ENVR);
24000a7e:	4b0f      	ldr	r3, [pc, #60]	; (24000abc <HAL_SYSCFG_EnableVREFBUF+0x44>)
24000a80:	681b      	ldr	r3, [r3, #0]
24000a82:	4a0e      	ldr	r2, [pc, #56]	; (24000abc <HAL_SYSCFG_EnableVREFBUF+0x44>)
24000a84:	f043 0301 	orr.w	r3, r3, #1
24000a88:	6013      	str	r3, [r2, #0]

  /* Get Start Tick*/
  tickstart = HAL_GetTick();
24000a8a:	f7ff fee3 	bl	24000854 <HAL_GetTick>
24000a8e:	6078      	str	r0, [r7, #4]

  /* Wait for VRR bit  */
  while(READ_BIT(VREFBUF->CSR, VREFBUF_CSR_VRR) == 0UL)
24000a90:	e008      	b.n	24000aa4 <HAL_SYSCFG_EnableVREFBUF+0x2c>
  {
    if((HAL_GetTick() - tickstart) > VREFBUF_TIMEOUT_VALUE)
24000a92:	f7ff fedf 	bl	24000854 <HAL_GetTick>
24000a96:	4602      	mov	r2, r0
24000a98:	687b      	ldr	r3, [r7, #4]
24000a9a:	1ad3      	subs	r3, r2, r3
24000a9c:	2b0a      	cmp	r3, #10
24000a9e:	d901      	bls.n	24000aa4 <HAL_SYSCFG_EnableVREFBUF+0x2c>
    {
      return HAL_TIMEOUT;
24000aa0:	2303      	movs	r3, #3
24000aa2:	e006      	b.n	24000ab2 <HAL_SYSCFG_EnableVREFBUF+0x3a>
  while(READ_BIT(VREFBUF->CSR, VREFBUF_CSR_VRR) == 0UL)
24000aa4:	4b05      	ldr	r3, [pc, #20]	; (24000abc <HAL_SYSCFG_EnableVREFBUF+0x44>)
24000aa6:	681b      	ldr	r3, [r3, #0]
24000aa8:	f003 0308 	and.w	r3, r3, #8
24000aac:	2b00      	cmp	r3, #0
24000aae:	d0f0      	beq.n	24000a92 <HAL_SYSCFG_EnableVREFBUF+0x1a>
    }
  }

  return HAL_OK;
24000ab0:	2300      	movs	r3, #0
}
24000ab2:	4618      	mov	r0, r3
24000ab4:	3708      	adds	r7, #8
24000ab6:	46bd      	mov	sp, r7
24000ab8:	bd80      	pop	{r7, pc}
24000aba:	bf00      	nop
24000abc:	58003c00 	.word	0x58003c00

24000ac0 <HAL_SYSCFG_DisableVREFBUF>:
  * @brief  Disable the Internal Voltage Reference buffer (VREFBUF).
  *
  * @retval None
  */
void HAL_SYSCFG_DisableVREFBUF(void)
{
24000ac0:	b480      	push	{r7}
24000ac2:	af00      	add	r7, sp, #0
  CLEAR_BIT(VREFBUF->CSR, VREFBUF_CSR_ENVR);
24000ac4:	4b05      	ldr	r3, [pc, #20]	; (24000adc <HAL_SYSCFG_DisableVREFBUF+0x1c>)
24000ac6:	681b      	ldr	r3, [r3, #0]
24000ac8:	4a04      	ldr	r2, [pc, #16]	; (24000adc <HAL_SYSCFG_DisableVREFBUF+0x1c>)
24000aca:	f023 0301 	bic.w	r3, r3, #1
24000ace:	6013      	str	r3, [r2, #0]
}
24000ad0:	bf00      	nop
24000ad2:	46bd      	mov	sp, r7
24000ad4:	f85d 7b04 	ldr.w	r7, [sp], #4
24000ad8:	4770      	bx	lr
24000ada:	bf00      	nop
24000adc:	58003c00 	.word	0x58003c00

24000ae0 <HAL_SYSCFG_ETHInterfaceSelect>:
  *   @arg SYSCFG_ETH_MII : Select the Media Independent Interface
  *   @arg SYSCFG_ETH_RMII: Select the Reduced Media Independent Interface
  * @retval None
  */
void HAL_SYSCFG_ETHInterfaceSelect(uint32_t SYSCFG_ETHInterface)
{
24000ae0:	b480      	push	{r7}
24000ae2:	b083      	sub	sp, #12
24000ae4:	af00      	add	r7, sp, #0
24000ae6:	6078      	str	r0, [r7, #4]
  /* Check the parameter */
  assert_param(IS_SYSCFG_ETHERNET_CONFIG(SYSCFG_ETHInterface));

  MODIFY_REG(SYSCFG->PMCR, SYSCFG_PMCR_EPIS_SEL, (uint32_t)(SYSCFG_ETHInterface));
24000ae8:	4b06      	ldr	r3, [pc, #24]	; (24000b04 <HAL_SYSCFG_ETHInterfaceSelect+0x24>)
24000aea:	685b      	ldr	r3, [r3, #4]
24000aec:	f423 0260 	bic.w	r2, r3, #14680064	; 0xe00000
24000af0:	4904      	ldr	r1, [pc, #16]	; (24000b04 <HAL_SYSCFG_ETHInterfaceSelect+0x24>)
24000af2:	687b      	ldr	r3, [r7, #4]
24000af4:	4313      	orrs	r3, r2
24000af6:	604b      	str	r3, [r1, #4]
}
24000af8:	bf00      	nop
24000afa:	370c      	adds	r7, #12
24000afc:	46bd      	mov	sp, r7
24000afe:	f85d 7b04 	ldr.w	r7, [sp], #4
24000b02:	4770      	bx	lr
24000b04:	58000400 	.word	0x58000400

24000b08 <HAL_SYSCFG_AnalogSwitchConfig>:
  *   @arg SYSCFG_SWITCH_PC3_CLOSE
  * @retval None
  */

void HAL_SYSCFG_AnalogSwitchConfig(uint32_t SYSCFG_AnalogSwitch , uint32_t SYSCFG_SwitchState )
{
24000b08:	b480      	push	{r7}
24000b0a:	b083      	sub	sp, #12
24000b0c:	af00      	add	r7, sp, #0
24000b0e:	6078      	str	r0, [r7, #4]
24000b10:	6039      	str	r1, [r7, #0]
  /* Check the parameter */
  assert_param(IS_SYSCFG_ANALOG_SWITCH(SYSCFG_AnalogSwitch));
  assert_param(IS_SYSCFG_SWITCH_STATE(SYSCFG_SwitchState));

  MODIFY_REG(SYSCFG->PMCR, (uint32_t) SYSCFG_AnalogSwitch, (uint32_t)(SYSCFG_SwitchState));
24000b12:	4b07      	ldr	r3, [pc, #28]	; (24000b30 <HAL_SYSCFG_AnalogSwitchConfig+0x28>)
24000b14:	685a      	ldr	r2, [r3, #4]
24000b16:	687b      	ldr	r3, [r7, #4]
24000b18:	43db      	mvns	r3, r3
24000b1a:	401a      	ands	r2, r3
24000b1c:	4904      	ldr	r1, [pc, #16]	; (24000b30 <HAL_SYSCFG_AnalogSwitchConfig+0x28>)
24000b1e:	683b      	ldr	r3, [r7, #0]
24000b20:	4313      	orrs	r3, r2
24000b22:	604b      	str	r3, [r1, #4]
}
24000b24:	bf00      	nop
24000b26:	370c      	adds	r7, #12
24000b28:	46bd      	mov	sp, r7
24000b2a:	f85d 7b04 	ldr.w	r7, [sp], #4
24000b2e:	4770      	bx	lr
24000b30:	58000400 	.word	0x58000400

24000b34 <HAL_SYSCFG_EnableBOOST>:
  *         when the supply voltage is below 2.7 V: in this case, the analog switch
  *         performance is the same on the full voltage range
  * @retval None
  */
void HAL_SYSCFG_EnableBOOST(void)
{
24000b34:	b480      	push	{r7}
24000b36:	af00      	add	r7, sp, #0
 SET_BIT(SYSCFG->PMCR, SYSCFG_PMCR_BOOSTEN) ;
24000b38:	4b05      	ldr	r3, [pc, #20]	; (24000b50 <HAL_SYSCFG_EnableBOOST+0x1c>)
24000b3a:	685b      	ldr	r3, [r3, #4]
24000b3c:	4a04      	ldr	r2, [pc, #16]	; (24000b50 <HAL_SYSCFG_EnableBOOST+0x1c>)
24000b3e:	f443 7380 	orr.w	r3, r3, #256	; 0x100
24000b42:	6053      	str	r3, [r2, #4]
}
24000b44:	bf00      	nop
24000b46:	46bd      	mov	sp, r7
24000b48:	f85d 7b04 	ldr.w	r7, [sp], #4
24000b4c:	4770      	bx	lr
24000b4e:	bf00      	nop
24000b50:	58000400 	.word	0x58000400

24000b54 <HAL_SYSCFG_DisableBOOST>:
  *         when the supply voltage is below 2.7 V: in this case, the analog switch
  *         performance is the same on the full voltage range
  * @retval None
  */
void HAL_SYSCFG_DisableBOOST(void)
{
24000b54:	b480      	push	{r7}
24000b56:	af00      	add	r7, sp, #0
 CLEAR_BIT(SYSCFG->PMCR, SYSCFG_PMCR_BOOSTEN) ;
24000b58:	4b05      	ldr	r3, [pc, #20]	; (24000b70 <HAL_SYSCFG_DisableBOOST+0x1c>)
24000b5a:	685b      	ldr	r3, [r3, #4]
24000b5c:	4a04      	ldr	r2, [pc, #16]	; (24000b70 <HAL_SYSCFG_DisableBOOST+0x1c>)
24000b5e:	f423 7380 	bic.w	r3, r3, #256	; 0x100
24000b62:	6053      	str	r3, [r2, #4]
}
24000b64:	bf00      	nop
24000b66:	46bd      	mov	sp, r7
24000b68:	f85d 7b04 	ldr.w	r7, [sp], #4
24000b6c:	4770      	bx	lr
24000b6e:	bf00      	nop
24000b70:	58000400 	.word	0x58000400

24000b74 <HAL_SYSCFG_CM7BootAddConfig>:
  *   @arg SYSCFG_BOOT_ADDR1:  Select the boot address1
  * @param  BootAddress :Specifies the CM7 Boot Address to be loaded in Address0 or Address1
  * @retval None
  */
void HAL_SYSCFG_CM7BootAddConfig(uint32_t BootRegister, uint32_t BootAddress)
{
24000b74:	b480      	push	{r7}
24000b76:	b083      	sub	sp, #12
24000b78:	af00      	add	r7, sp, #0
24000b7a:	6078      	str	r0, [r7, #4]
24000b7c:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_SYSCFG_BOOT_REGISTER(BootRegister));
  assert_param(IS_SYSCFG_BOOT_ADDRESS(BootAddress));
  if ( BootRegister == SYSCFG_BOOT_ADDR0 )
24000b7e:	687b      	ldr	r3, [r7, #4]
24000b80:	2b00      	cmp	r3, #0
24000b82:	d10b      	bne.n	24000b9c <HAL_SYSCFG_CM7BootAddConfig+0x28>
  {
    /* Configure CM7 BOOT ADD0 */
#if defined(DUAL_CORE)
    MODIFY_REG(SYSCFG->UR2, SYSCFG_UR2_BCM7_ADD0, ((BootAddress >> 16) << SYSCFG_UR2_BCM7_ADD0_Pos));
#else
    MODIFY_REG(SYSCFG->UR2, SYSCFG_UR2_BOOT_ADD0, ((BootAddress >> 16) << SYSCFG_UR2_BOOT_ADD0_Pos));
24000b84:	4b0e      	ldr	r3, [pc, #56]	; (24000bc0 <HAL_SYSCFG_CM7BootAddConfig+0x4c>)
24000b86:	f8d3 3308 	ldr.w	r3, [r3, #776]	; 0x308
24000b8a:	b29a      	uxth	r2, r3
24000b8c:	683b      	ldr	r3, [r7, #0]
24000b8e:	0c1b      	lsrs	r3, r3, #16
24000b90:	041b      	lsls	r3, r3, #16
24000b92:	490b      	ldr	r1, [pc, #44]	; (24000bc0 <HAL_SYSCFG_CM7BootAddConfig+0x4c>)
24000b94:	4313      	orrs	r3, r2
24000b96:	f8c1 3308 	str.w	r3, [r1, #776]	; 0x308
    MODIFY_REG(SYSCFG->UR3, SYSCFG_UR3_BCM7_ADD1, (BootAddress >> 16));
#else
    MODIFY_REG(SYSCFG->UR3, SYSCFG_UR3_BOOT_ADD1, (BootAddress >> 16));
#endif /*DUAL_CORE*/
  }
}
24000b9a:	e00a      	b.n	24000bb2 <HAL_SYSCFG_CM7BootAddConfig+0x3e>
    MODIFY_REG(SYSCFG->UR3, SYSCFG_UR3_BOOT_ADD1, (BootAddress >> 16));
24000b9c:	4b08      	ldr	r3, [pc, #32]	; (24000bc0 <HAL_SYSCFG_CM7BootAddConfig+0x4c>)
24000b9e:	f8d3 230c 	ldr.w	r2, [r3, #780]	; 0x30c
24000ba2:	4b08      	ldr	r3, [pc, #32]	; (24000bc4 <HAL_SYSCFG_CM7BootAddConfig+0x50>)
24000ba4:	4013      	ands	r3, r2
24000ba6:	683a      	ldr	r2, [r7, #0]
24000ba8:	0c12      	lsrs	r2, r2, #16
24000baa:	4905      	ldr	r1, [pc, #20]	; (24000bc0 <HAL_SYSCFG_CM7BootAddConfig+0x4c>)
24000bac:	4313      	orrs	r3, r2
24000bae:	f8c1 330c 	str.w	r3, [r1, #780]	; 0x30c
}
24000bb2:	bf00      	nop
24000bb4:	370c      	adds	r7, #12
24000bb6:	46bd      	mov	sp, r7
24000bb8:	f85d 7b04 	ldr.w	r7, [sp], #4
24000bbc:	4770      	bx	lr
24000bbe:	bf00      	nop
24000bc0:	58000400 	.word	0x58000400
24000bc4:	ffff0000 	.word	0xffff0000

24000bc8 <HAL_EnableCompensationCell>:
  * @note   The I/O compensation cell can be used only when the device supply
  *         voltage ranges from 2.4 to 3.6 V.
  * @retval None
  */
void HAL_EnableCompensationCell(void)
{
24000bc8:	b480      	push	{r7}
24000bca:	af00      	add	r7, sp, #0
  SET_BIT(SYSCFG->CCCSR, SYSCFG_CCCSR_EN) ;
24000bcc:	4b05      	ldr	r3, [pc, #20]	; (24000be4 <HAL_EnableCompensationCell+0x1c>)
24000bce:	6a1b      	ldr	r3, [r3, #32]
24000bd0:	4a04      	ldr	r2, [pc, #16]	; (24000be4 <HAL_EnableCompensationCell+0x1c>)
24000bd2:	f043 0301 	orr.w	r3, r3, #1
24000bd6:	6213      	str	r3, [r2, #32]
}
24000bd8:	bf00      	nop
24000bda:	46bd      	mov	sp, r7
24000bdc:	f85d 7b04 	ldr.w	r7, [sp], #4
24000be0:	4770      	bx	lr
24000be2:	bf00      	nop
24000be4:	58000400 	.word	0x58000400

24000be8 <HAL_DisableCompensationCell>:
  * @note   The I/O compensation cell can be used only when the device supply
  *         voltage ranges from 2.4 to 3.6 V.
  * @retval None
  */
void HAL_DisableCompensationCell(void)
{
24000be8:	b480      	push	{r7}
24000bea:	af00      	add	r7, sp, #0
  CLEAR_BIT(SYSCFG->CCCSR, SYSCFG_CCCSR_EN);
24000bec:	4b05      	ldr	r3, [pc, #20]	; (24000c04 <HAL_DisableCompensationCell+0x1c>)
24000bee:	6a1b      	ldr	r3, [r3, #32]
24000bf0:	4a04      	ldr	r2, [pc, #16]	; (24000c04 <HAL_DisableCompensationCell+0x1c>)
24000bf2:	f023 0301 	bic.w	r3, r3, #1
24000bf6:	6213      	str	r3, [r2, #32]
}
24000bf8:	bf00      	nop
24000bfa:	46bd      	mov	sp, r7
24000bfc:	f85d 7b04 	ldr.w	r7, [sp], #4
24000c00:	4770      	bx	lr
24000c02:	bf00      	nop
24000c04:	58000400 	.word	0x58000400

24000c08 <HAL_SYSCFG_EnableIOSpeedOptimize>:
  *         used only if the product supply voltage is below 2.5 V. Setting this bit when VDD is
  *         higher than 2.5 V might be destructive.
  * @retval None
  */
void HAL_SYSCFG_EnableIOSpeedOptimize(void)
{
24000c08:	b480      	push	{r7}
24000c0a:	af00      	add	r7, sp, #0
#if defined(SYSCFG_CCCSR_HSLV)
  SET_BIT(SYSCFG->CCCSR, SYSCFG_CCCSR_HSLV);
24000c0c:	4b05      	ldr	r3, [pc, #20]	; (24000c24 <HAL_SYSCFG_EnableIOSpeedOptimize+0x1c>)
24000c0e:	6a1b      	ldr	r3, [r3, #32]
24000c10:	4a04      	ldr	r2, [pc, #16]	; (24000c24 <HAL_SYSCFG_EnableIOSpeedOptimize+0x1c>)
24000c12:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
24000c16:	6213      	str	r3, [r2, #32]
#else
  SET_BIT(SYSCFG->CCCSR, (SYSCFG_CCCSR_HSLV0| SYSCFG_CCCSR_HSLV1 | SYSCFG_CCCSR_HSLV2  | SYSCFG_CCCSR_HSLV3));
#endif   /* SYSCFG_CCCSR_HSLV */
}
24000c18:	bf00      	nop
24000c1a:	46bd      	mov	sp, r7
24000c1c:	f85d 7b04 	ldr.w	r7, [sp], #4
24000c20:	4770      	bx	lr
24000c22:	bf00      	nop
24000c24:	58000400 	.word	0x58000400

24000c28 <HAL_SYSCFG_DisableIOSpeedOptimize>:
  *         used only if the product supply voltage is below 2.5 V. Setting this bit when VDD is
  *         higher than 2.5 V might be destructive.
  * @retval None
  */
void HAL_SYSCFG_DisableIOSpeedOptimize(void)
{
24000c28:	b480      	push	{r7}
24000c2a:	af00      	add	r7, sp, #0
#if defined(SYSCFG_CCCSR_HSLV)
  CLEAR_BIT(SYSCFG->CCCSR, SYSCFG_CCCSR_HSLV);
24000c2c:	4b05      	ldr	r3, [pc, #20]	; (24000c44 <HAL_SYSCFG_DisableIOSpeedOptimize+0x1c>)
24000c2e:	6a1b      	ldr	r3, [r3, #32]
24000c30:	4a04      	ldr	r2, [pc, #16]	; (24000c44 <HAL_SYSCFG_DisableIOSpeedOptimize+0x1c>)
24000c32:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
24000c36:	6213      	str	r3, [r2, #32]
#else
  CLEAR_BIT(SYSCFG->CCCSR, (SYSCFG_CCCSR_HSLV0| SYSCFG_CCCSR_HSLV1 | SYSCFG_CCCSR_HSLV2  | SYSCFG_CCCSR_HSLV3));
#endif   /* SYSCFG_CCCSR_HSLV */
}
24000c38:	bf00      	nop
24000c3a:	46bd      	mov	sp, r7
24000c3c:	f85d 7b04 	ldr.w	r7, [sp], #4
24000c40:	4770      	bx	lr
24000c42:	bf00      	nop
24000c44:	58000400 	.word	0x58000400

24000c48 <HAL_SYSCFG_CompensationCodeSelect>:
  *   @arg SYSCFG_CELL_CODE : Select Code from the cell (available in the SYSCFG_CCVR)
  *   @arg SYSCFG_REGISTER_CODE: Select Code from the SYSCFG compensation cell code register (SYSCFG_CCCR)
  * @retval None
  */
void HAL_SYSCFG_CompensationCodeSelect(uint32_t SYSCFG_CompCode)
{
24000c48:	b480      	push	{r7}
24000c4a:	b083      	sub	sp, #12
24000c4c:	af00      	add	r7, sp, #0
24000c4e:	6078      	str	r0, [r7, #4]
  /* Check the parameter */
  assert_param(IS_SYSCFG_CODE_SELECT(SYSCFG_CompCode));
  MODIFY_REG(SYSCFG->CCCSR, SYSCFG_CCCSR_CS, (uint32_t)(SYSCFG_CompCode));
24000c50:	4b06      	ldr	r3, [pc, #24]	; (24000c6c <HAL_SYSCFG_CompensationCodeSelect+0x24>)
24000c52:	6a1b      	ldr	r3, [r3, #32]
24000c54:	f023 0202 	bic.w	r2, r3, #2
24000c58:	4904      	ldr	r1, [pc, #16]	; (24000c6c <HAL_SYSCFG_CompensationCodeSelect+0x24>)
24000c5a:	687b      	ldr	r3, [r7, #4]
24000c5c:	4313      	orrs	r3, r2
24000c5e:	620b      	str	r3, [r1, #32]
}
24000c60:	bf00      	nop
24000c62:	370c      	adds	r7, #12
24000c64:	46bd      	mov	sp, r7
24000c66:	f85d 7b04 	ldr.w	r7, [sp], #4
24000c6a:	4770      	bx	lr
24000c6c:	58000400 	.word	0x58000400

24000c70 <HAL_SYSCFG_CompensationCodeConfig>:
  *         This code is applied to the I/O compensation cell when the CS bit of the
  *          SYSCFG_CMPCR is set
  * @retval None
  */
void HAL_SYSCFG_CompensationCodeConfig(uint32_t SYSCFG_PMOSCode, uint32_t SYSCFG_NMOSCode )
{
24000c70:	b480      	push	{r7}
24000c72:	b083      	sub	sp, #12
24000c74:	af00      	add	r7, sp, #0
24000c76:	6078      	str	r0, [r7, #4]
24000c78:	6039      	str	r1, [r7, #0]
  /* Check the parameter */
  assert_param(IS_SYSCFG_CODE_CONFIG(SYSCFG_PMOSCode));
  assert_param(IS_SYSCFG_CODE_CONFIG(SYSCFG_NMOSCode));
  MODIFY_REG(SYSCFG->CCCR, SYSCFG_CCCR_NCC|SYSCFG_CCCR_PCC, (((uint32_t)(SYSCFG_PMOSCode)<< 4)|(uint32_t)(SYSCFG_NMOSCode)) );
24000c7a:	4b08      	ldr	r3, [pc, #32]	; (24000c9c <HAL_SYSCFG_CompensationCodeConfig+0x2c>)
24000c7c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
24000c7e:	f023 02ff 	bic.w	r2, r3, #255	; 0xff
24000c82:	687b      	ldr	r3, [r7, #4]
24000c84:	0119      	lsls	r1, r3, #4
24000c86:	683b      	ldr	r3, [r7, #0]
24000c88:	430b      	orrs	r3, r1
24000c8a:	4904      	ldr	r1, [pc, #16]	; (24000c9c <HAL_SYSCFG_CompensationCodeConfig+0x2c>)
24000c8c:	4313      	orrs	r3, r2
24000c8e:	628b      	str	r3, [r1, #40]	; 0x28
}
24000c90:	bf00      	nop
24000c92:	370c      	adds	r7, #12
24000c94:	46bd      	mov	sp, r7
24000c96:	f85d 7b04 	ldr.w	r7, [sp], #4
24000c9a:	4770      	bx	lr
24000c9c:	58000400 	.word	0x58000400

24000ca0 <HAL_DBGMCU_EnableDBGSleepMode>:
/**
  * @brief  Enable the Debug Module during Domain1/CDomain SLEEP mode
  * @retval None
  */
void HAL_EnableDBGSleepMode(void)
{
24000ca0:	b480      	push	{r7}
24000ca2:	af00      	add	r7, sp, #0
  SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_SLEEPD1);
24000ca4:	4b05      	ldr	r3, [pc, #20]	; (24000cbc <HAL_DBGMCU_EnableDBGSleepMode+0x1c>)
24000ca6:	685b      	ldr	r3, [r3, #4]
24000ca8:	4a04      	ldr	r2, [pc, #16]	; (24000cbc <HAL_DBGMCU_EnableDBGSleepMode+0x1c>)
24000caa:	f043 0301 	orr.w	r3, r3, #1
24000cae:	6053      	str	r3, [r2, #4]
}
24000cb0:	bf00      	nop
24000cb2:	46bd      	mov	sp, r7
24000cb4:	f85d 7b04 	ldr.w	r7, [sp], #4
24000cb8:	4770      	bx	lr
24000cba:	bf00      	nop
24000cbc:	5c001000 	.word	0x5c001000

24000cc0 <HAL_DBGMCU_DisableDBGSleepMode>:
/**
  * @brief  Disable the Debug Module during Domain1/CDomain SLEEP mode
  * @retval None
  */
void HAL_DisableDBGSleepMode(void)
{
24000cc0:	b480      	push	{r7}
24000cc2:	af00      	add	r7, sp, #0
  CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_SLEEPD1);
24000cc4:	4b05      	ldr	r3, [pc, #20]	; (24000cdc <HAL_DBGMCU_DisableDBGSleepMode+0x1c>)
24000cc6:	685b      	ldr	r3, [r3, #4]
24000cc8:	4a04      	ldr	r2, [pc, #16]	; (24000cdc <HAL_DBGMCU_DisableDBGSleepMode+0x1c>)
24000cca:	f023 0301 	bic.w	r3, r3, #1
24000cce:	6053      	str	r3, [r2, #4]
}
24000cd0:	bf00      	nop
24000cd2:	46bd      	mov	sp, r7
24000cd4:	f85d 7b04 	ldr.w	r7, [sp], #4
24000cd8:	4770      	bx	lr
24000cda:	bf00      	nop
24000cdc:	5c001000 	.word	0x5c001000

24000ce0 <HAL_DBGMCU_EnableDBGStopMode>:
/**
  * @brief  Enable the Debug Module during Domain1/CDomain STOP mode
  * @retval None
  */
void HAL_EnableDBGStopMode(void)
{
24000ce0:	b480      	push	{r7}
24000ce2:	af00      	add	r7, sp, #0
  SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STOPD1);
24000ce4:	4b05      	ldr	r3, [pc, #20]	; (24000cfc <HAL_DBGMCU_EnableDBGStopMode+0x1c>)
24000ce6:	685b      	ldr	r3, [r3, #4]
24000ce8:	4a04      	ldr	r2, [pc, #16]	; (24000cfc <HAL_DBGMCU_EnableDBGStopMode+0x1c>)
24000cea:	f043 0302 	orr.w	r3, r3, #2
24000cee:	6053      	str	r3, [r2, #4]
}
24000cf0:	bf00      	nop
24000cf2:	46bd      	mov	sp, r7
24000cf4:	f85d 7b04 	ldr.w	r7, [sp], #4
24000cf8:	4770      	bx	lr
24000cfa:	bf00      	nop
24000cfc:	5c001000 	.word	0x5c001000

24000d00 <HAL_DBGMCU_DisableDBGStopMode>:
/**
  * @brief  Disable the Debug Module during Domain1/CDomain STOP mode
  * @retval None
  */
void HAL_DisableDBGStopMode(void)
{
24000d00:	b480      	push	{r7}
24000d02:	af00      	add	r7, sp, #0
  CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STOPD1);
24000d04:	4b05      	ldr	r3, [pc, #20]	; (24000d1c <HAL_DBGMCU_DisableDBGStopMode+0x1c>)
24000d06:	685b      	ldr	r3, [r3, #4]
24000d08:	4a04      	ldr	r2, [pc, #16]	; (24000d1c <HAL_DBGMCU_DisableDBGStopMode+0x1c>)
24000d0a:	f023 0302 	bic.w	r3, r3, #2
24000d0e:	6053      	str	r3, [r2, #4]
}
24000d10:	bf00      	nop
24000d12:	46bd      	mov	sp, r7
24000d14:	f85d 7b04 	ldr.w	r7, [sp], #4
24000d18:	4770      	bx	lr
24000d1a:	bf00      	nop
24000d1c:	5c001000 	.word	0x5c001000

24000d20 <HAL_DBGMCU_EnableDBGStandbyMode>:
/**
  * @brief  Enable the Debug Module during Domain1/CDomain STANDBY mode
  * @retval None
  */
void HAL_EnableDBGStandbyMode(void)
{
24000d20:	b480      	push	{r7}
24000d22:	af00      	add	r7, sp, #0
  SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STANDBYD1);
24000d24:	4b05      	ldr	r3, [pc, #20]	; (24000d3c <HAL_DBGMCU_EnableDBGStandbyMode+0x1c>)
24000d26:	685b      	ldr	r3, [r3, #4]
24000d28:	4a04      	ldr	r2, [pc, #16]	; (24000d3c <HAL_DBGMCU_EnableDBGStandbyMode+0x1c>)
24000d2a:	f043 0304 	orr.w	r3, r3, #4
24000d2e:	6053      	str	r3, [r2, #4]
}
24000d30:	bf00      	nop
24000d32:	46bd      	mov	sp, r7
24000d34:	f85d 7b04 	ldr.w	r7, [sp], #4
24000d38:	4770      	bx	lr
24000d3a:	bf00      	nop
24000d3c:	5c001000 	.word	0x5c001000

24000d40 <HAL_DBGMCU_DisableDBGStandbyMode>:
/**
  * @brief  Disable the Debug Module during Domain1/CDomain STANDBY mode
  * @retval None
  */
void HAL_DisableDBGStandbyMode(void)
{
24000d40:	b480      	push	{r7}
24000d42:	af00      	add	r7, sp, #0
  CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STANDBYD1);
24000d44:	4b05      	ldr	r3, [pc, #20]	; (24000d5c <HAL_DBGMCU_DisableDBGStandbyMode+0x1c>)
24000d46:	685b      	ldr	r3, [r3, #4]
24000d48:	4a04      	ldr	r2, [pc, #16]	; (24000d5c <HAL_DBGMCU_DisableDBGStandbyMode+0x1c>)
24000d4a:	f023 0304 	bic.w	r3, r3, #4
24000d4e:	6053      	str	r3, [r2, #4]
}
24000d50:	bf00      	nop
24000d52:	46bd      	mov	sp, r7
24000d54:	f85d 7b04 	ldr.w	r7, [sp], #4
24000d58:	4770      	bx	lr
24000d5a:	bf00      	nop
24000d5c:	5c001000 	.word	0x5c001000

24000d60 <HAL_EnableDomain3DBGStopMode>:
/**
  * @brief  Enable the Debug Module during Domain3/SRDomain STOP mode
  * @retval None
  */
void HAL_EnableDomain3DBGStopMode(void)
{
24000d60:	b480      	push	{r7}
24000d62:	af00      	add	r7, sp, #0
  SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STOPD3);
24000d64:	4b05      	ldr	r3, [pc, #20]	; (24000d7c <HAL_EnableDomain3DBGStopMode+0x1c>)
24000d66:	685b      	ldr	r3, [r3, #4]
24000d68:	4a04      	ldr	r2, [pc, #16]	; (24000d7c <HAL_EnableDomain3DBGStopMode+0x1c>)
24000d6a:	f043 0380 	orr.w	r3, r3, #128	; 0x80
24000d6e:	6053      	str	r3, [r2, #4]
}
24000d70:	bf00      	nop
24000d72:	46bd      	mov	sp, r7
24000d74:	f85d 7b04 	ldr.w	r7, [sp], #4
24000d78:	4770      	bx	lr
24000d7a:	bf00      	nop
24000d7c:	5c001000 	.word	0x5c001000

24000d80 <HAL_DisableDomain3DBGStopMode>:
/**
  * @brief  Disable the Debug Module during Domain3/SRDomain STOP mode
  * @retval None
  */
void HAL_DisableDomain3DBGStopMode(void)
{
24000d80:	b480      	push	{r7}
24000d82:	af00      	add	r7, sp, #0
  CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STOPD3);
24000d84:	4b05      	ldr	r3, [pc, #20]	; (24000d9c <HAL_DisableDomain3DBGStopMode+0x1c>)
24000d86:	685b      	ldr	r3, [r3, #4]
24000d88:	4a04      	ldr	r2, [pc, #16]	; (24000d9c <HAL_DisableDomain3DBGStopMode+0x1c>)
24000d8a:	f023 0380 	bic.w	r3, r3, #128	; 0x80
24000d8e:	6053      	str	r3, [r2, #4]
}
24000d90:	bf00      	nop
24000d92:	46bd      	mov	sp, r7
24000d94:	f85d 7b04 	ldr.w	r7, [sp], #4
24000d98:	4770      	bx	lr
24000d9a:	bf00      	nop
24000d9c:	5c001000 	.word	0x5c001000

24000da0 <HAL_EnableDomain3DBGStandbyMode>:
/**
  * @brief  Enable the Debug Module during Domain3/SRDomain STANDBY mode
  * @retval None
  */
void HAL_EnableDomain3DBGStandbyMode(void)
{
24000da0:	b480      	push	{r7}
24000da2:	af00      	add	r7, sp, #0
  SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STANDBYD3);
24000da4:	4b05      	ldr	r3, [pc, #20]	; (24000dbc <HAL_EnableDomain3DBGStandbyMode+0x1c>)
24000da6:	685b      	ldr	r3, [r3, #4]
24000da8:	4a04      	ldr	r2, [pc, #16]	; (24000dbc <HAL_EnableDomain3DBGStandbyMode+0x1c>)
24000daa:	f443 7380 	orr.w	r3, r3, #256	; 0x100
24000dae:	6053      	str	r3, [r2, #4]
}
24000db0:	bf00      	nop
24000db2:	46bd      	mov	sp, r7
24000db4:	f85d 7b04 	ldr.w	r7, [sp], #4
24000db8:	4770      	bx	lr
24000dba:	bf00      	nop
24000dbc:	5c001000 	.word	0x5c001000

24000dc0 <HAL_DisableDomain3DBGStandbyMode>:
/**
  * @brief  Disable the Debug Module during Domain3/SRDomain STANDBY mode
  * @retval None
  */
void HAL_DisableDomain3DBGStandbyMode(void)
{
24000dc0:	b480      	push	{r7}
24000dc2:	af00      	add	r7, sp, #0
  CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STANDBYD3);
24000dc4:	4b05      	ldr	r3, [pc, #20]	; (24000ddc <HAL_DisableDomain3DBGStandbyMode+0x1c>)
24000dc6:	685b      	ldr	r3, [r3, #4]
24000dc8:	4a04      	ldr	r2, [pc, #16]	; (24000ddc <HAL_DisableDomain3DBGStandbyMode+0x1c>)
24000dca:	f423 7380 	bic.w	r3, r3, #256	; 0x100
24000dce:	6053      	str	r3, [r2, #4]
}
24000dd0:	bf00      	nop
24000dd2:	46bd      	mov	sp, r7
24000dd4:	f85d 7b04 	ldr.w	r7, [sp], #4
24000dd8:	4770      	bx	lr
24000dda:	bf00      	nop
24000ddc:	5c001000 	.word	0x5c001000

24000de0 <HAL_SetFMCMemorySwappingConfig>:
  * @param  BankMapConfig: Defines the FMC Bank mapping configuration. This parameter can be
            FMC_SWAPBMAP_DISABLE, FMC_SWAPBMAP_SDRAM_SRAM, FMC_SWAPBMAP_SDRAMB2
  * @retval HAL state
  */
void HAL_SetFMCMemorySwappingConfig(uint32_t BankMapConfig)
{
24000de0:	b480      	push	{r7}
24000de2:	b083      	sub	sp, #12
24000de4:	af00      	add	r7, sp, #0
24000de6:	6078      	str	r0, [r7, #4]
  /* Check the parameter */
  assert_param(IS_FMC_SWAPBMAP_MODE(BankMapConfig));
  MODIFY_REG(FMC_Bank1_R->BTCR[0], FMC_BCR1_BMAP, BankMapConfig);
24000de8:	4b06      	ldr	r3, [pc, #24]	; (24000e04 <HAL_SetFMCMemorySwappingConfig+0x24>)
24000dea:	681b      	ldr	r3, [r3, #0]
24000dec:	f023 7240 	bic.w	r2, r3, #50331648	; 0x3000000
24000df0:	4904      	ldr	r1, [pc, #16]	; (24000e04 <HAL_SetFMCMemorySwappingConfig+0x24>)
24000df2:	687b      	ldr	r3, [r7, #4]
24000df4:	4313      	orrs	r3, r2
24000df6:	600b      	str	r3, [r1, #0]
}
24000df8:	bf00      	nop
24000dfa:	370c      	adds	r7, #12
24000dfc:	46bd      	mov	sp, r7
24000dfe:	f85d 7b04 	ldr.w	r7, [sp], #4
24000e02:	4770      	bx	lr
24000e04:	52004000 	.word	0x52004000

24000e08 <HAL_GetFMCMemorySwappingConfig>:
  * @brief  Get FMC Bank mapping mode.
  * @retval The FMC Bank mapping mode. This parameter can be
            FMC_SWAPBMAP_DISABLE, FMC_SWAPBMAP_SDRAM_SRAM, FMC_SWAPBMAP_SDRAMB2
*/
uint32_t HAL_GetFMCMemorySwappingConfig(void)
{
24000e08:	b480      	push	{r7}
24000e0a:	af00      	add	r7, sp, #0
  return READ_BIT(FMC_Bank1_R->BTCR[0], FMC_BCR1_BMAP);
24000e0c:	4b04      	ldr	r3, [pc, #16]	; (24000e20 <HAL_GetFMCMemorySwappingConfig+0x18>)
24000e0e:	681b      	ldr	r3, [r3, #0]
24000e10:	f003 7340 	and.w	r3, r3, #50331648	; 0x3000000
}
24000e14:	4618      	mov	r0, r3
24000e16:	46bd      	mov	sp, r7
24000e18:	f85d 7b04 	ldr.w	r7, [sp], #4
24000e1c:	4770      	bx	lr
24000e1e:	bf00      	nop
24000e20:	52004000 	.word	0x52004000

24000e24 <HAL_EXTI_EdgeConfig>:
  *   @arg EXTI_RISING_EDGE : Configurable line, with Rising edge trigger detection
  *   @arg EXTI_FALLING_EDGE: Configurable line, with Falling edge trigger detection
  * @retval None
  */
void HAL_EXTI_EdgeConfig(uint32_t EXTI_Line , uint32_t EXTI_Edge )
{
24000e24:	b480      	push	{r7}
24000e26:	b083      	sub	sp, #12
24000e28:	af00      	add	r7, sp, #0
24000e2a:	6078      	str	r0, [r7, #4]
24000e2c:	6039      	str	r1, [r7, #0]
  /* Check the parameter */
  assert_param(IS_HAL_EXTI_CONFIG_LINE(EXTI_Line));
  assert_param(IS_EXTI_EDGE_LINE(EXTI_Edge));

  /* Clear Rising Falling edge configuration */
  CLEAR_BIT(*(__IO uint32_t *) (((uint32_t) &(EXTI->FTSR1)) + ((EXTI_Line >> 5 ) * 0x20UL)), (uint32_t)(1UL << (EXTI_Line & 0x1FUL)));
24000e2e:	687b      	ldr	r3, [r7, #4]
24000e30:	095b      	lsrs	r3, r3, #5
24000e32:	015a      	lsls	r2, r3, #5
24000e34:	4b2e      	ldr	r3, [pc, #184]	; (24000ef0 <HAL_EXTI_EdgeConfig+0xcc>)
24000e36:	4413      	add	r3, r2
24000e38:	6819      	ldr	r1, [r3, #0]
24000e3a:	687b      	ldr	r3, [r7, #4]
24000e3c:	f003 031f 	and.w	r3, r3, #31
24000e40:	2201      	movs	r2, #1
24000e42:	fa02 f303 	lsl.w	r3, r2, r3
24000e46:	43da      	mvns	r2, r3
24000e48:	687b      	ldr	r3, [r7, #4]
24000e4a:	095b      	lsrs	r3, r3, #5
24000e4c:	0158      	lsls	r0, r3, #5
24000e4e:	4b28      	ldr	r3, [pc, #160]	; (24000ef0 <HAL_EXTI_EdgeConfig+0xcc>)
24000e50:	4403      	add	r3, r0
24000e52:	4618      	mov	r0, r3
24000e54:	ea01 0302 	and.w	r3, r1, r2
24000e58:	6003      	str	r3, [r0, #0]
  CLEAR_BIT( *(__IO uint32_t *) (((uint32_t) &(EXTI->RTSR1)) + ((EXTI_Line >> 5 ) * 0x20UL)), (uint32_t)(1UL << (EXTI_Line & 0x1FUL)));
24000e5a:	687b      	ldr	r3, [r7, #4]
24000e5c:	095b      	lsrs	r3, r3, #5
24000e5e:	f103 7330 	add.w	r3, r3, #46137344	; 0x2c00000
24000e62:	015b      	lsls	r3, r3, #5
24000e64:	681a      	ldr	r2, [r3, #0]
24000e66:	687b      	ldr	r3, [r7, #4]
24000e68:	f003 031f 	and.w	r3, r3, #31
24000e6c:	2101      	movs	r1, #1
24000e6e:	fa01 f303 	lsl.w	r3, r1, r3
24000e72:	43db      	mvns	r3, r3
24000e74:	6879      	ldr	r1, [r7, #4]
24000e76:	0949      	lsrs	r1, r1, #5
24000e78:	f101 7130 	add.w	r1, r1, #46137344	; 0x2c00000
24000e7c:	0149      	lsls	r1, r1, #5
24000e7e:	4013      	ands	r3, r2
24000e80:	600b      	str	r3, [r1, #0]

  if( (EXTI_Edge & EXTI_RISING_EDGE) == EXTI_RISING_EDGE)
24000e82:	683b      	ldr	r3, [r7, #0]
24000e84:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
24000e88:	2b00      	cmp	r3, #0
24000e8a:	d012      	beq.n	24000eb2 <HAL_EXTI_EdgeConfig+0x8e>
  {
   SET_BIT( *(__IO uint32_t *) (((uint32_t) &(EXTI->RTSR1)) + ((EXTI_Line >> 5 ) * 0x20UL)), (uint32_t)(1UL << (EXTI_Line & 0x1FUL)));
24000e8c:	687b      	ldr	r3, [r7, #4]
24000e8e:	095b      	lsrs	r3, r3, #5
24000e90:	f103 7330 	add.w	r3, r3, #46137344	; 0x2c00000
24000e94:	015b      	lsls	r3, r3, #5
24000e96:	681a      	ldr	r2, [r3, #0]
24000e98:	687b      	ldr	r3, [r7, #4]
24000e9a:	f003 031f 	and.w	r3, r3, #31
24000e9e:	2101      	movs	r1, #1
24000ea0:	fa01 f303 	lsl.w	r3, r1, r3
24000ea4:	6879      	ldr	r1, [r7, #4]
24000ea6:	0949      	lsrs	r1, r1, #5
24000ea8:	f101 7130 	add.w	r1, r1, #46137344	; 0x2c00000
24000eac:	0149      	lsls	r1, r1, #5
24000eae:	4313      	orrs	r3, r2
24000eb0:	600b      	str	r3, [r1, #0]
  }
  if( (EXTI_Edge & EXTI_FALLING_EDGE) == EXTI_FALLING_EDGE)
24000eb2:	683b      	ldr	r3, [r7, #0]
24000eb4:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
24000eb8:	2b00      	cmp	r3, #0
24000eba:	d013      	beq.n	24000ee4 <HAL_EXTI_EdgeConfig+0xc0>
  {
   SET_BIT(*(__IO uint32_t *) (((uint32_t) &(EXTI->FTSR1)) + ((EXTI_Line >> 5 ) * 0x20UL)), (uint32_t)(1UL << (EXTI_Line & 0x1FUL)));
24000ebc:	687b      	ldr	r3, [r7, #4]
24000ebe:	095b      	lsrs	r3, r3, #5
24000ec0:	015a      	lsls	r2, r3, #5
24000ec2:	4b0b      	ldr	r3, [pc, #44]	; (24000ef0 <HAL_EXTI_EdgeConfig+0xcc>)
24000ec4:	4413      	add	r3, r2
24000ec6:	6819      	ldr	r1, [r3, #0]
24000ec8:	687b      	ldr	r3, [r7, #4]
24000eca:	f003 031f 	and.w	r3, r3, #31
24000ece:	2201      	movs	r2, #1
24000ed0:	409a      	lsls	r2, r3
24000ed2:	687b      	ldr	r3, [r7, #4]
24000ed4:	095b      	lsrs	r3, r3, #5
24000ed6:	0158      	lsls	r0, r3, #5
24000ed8:	4b05      	ldr	r3, [pc, #20]	; (24000ef0 <HAL_EXTI_EdgeConfig+0xcc>)
24000eda:	4403      	add	r3, r0
24000edc:	4618      	mov	r0, r3
24000ede:	ea41 0302 	orr.w	r3, r1, r2
24000ee2:	6003      	str	r3, [r0, #0]
  }
}
24000ee4:	bf00      	nop
24000ee6:	370c      	adds	r7, #12
24000ee8:	46bd      	mov	sp, r7
24000eea:	f85d 7b04 	ldr.w	r7, [sp], #4
24000eee:	4770      	bx	lr
24000ef0:	58000004 	.word	0x58000004

24000ef4 <HAL_EXTI_GenerateSWInterrupt>:
  * @param   EXTI_Line: Specifies the EXTI LINE, it can be one of the following values,
  *          (EXTI_LINE0..EXTI_LINE21),EXTI_LINE49,EXTI_LINE51,EXTI_LINE82,EXTI_LINE84,EXTI_LINE85 and EXTI_LINE86.
  * @retval None
  */
void HAL_EXTI_GenerateSWInterrupt(uint32_t EXTI_Line)
{
24000ef4:	b480      	push	{r7}
24000ef6:	b083      	sub	sp, #12
24000ef8:	af00      	add	r7, sp, #0
24000efa:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_HAL_EXTI_CONFIG_LINE(EXTI_Line));

  SET_BIT(*(__IO uint32_t *) (((uint32_t) &(EXTI->SWIER1)) + ((EXTI_Line >> 5 ) * 0x20UL)), (uint32_t)(1UL << (EXTI_Line & 0x1FUL)));
24000efc:	687b      	ldr	r3, [r7, #4]
24000efe:	095b      	lsrs	r3, r3, #5
24000f00:	015a      	lsls	r2, r3, #5
24000f02:	4b0b      	ldr	r3, [pc, #44]	; (24000f30 <HAL_EXTI_GenerateSWInterrupt+0x3c>)
24000f04:	4413      	add	r3, r2
24000f06:	6819      	ldr	r1, [r3, #0]
24000f08:	687b      	ldr	r3, [r7, #4]
24000f0a:	f003 031f 	and.w	r3, r3, #31
24000f0e:	2201      	movs	r2, #1
24000f10:	409a      	lsls	r2, r3
24000f12:	687b      	ldr	r3, [r7, #4]
24000f14:	095b      	lsrs	r3, r3, #5
24000f16:	0158      	lsls	r0, r3, #5
24000f18:	4b05      	ldr	r3, [pc, #20]	; (24000f30 <HAL_EXTI_GenerateSWInterrupt+0x3c>)
24000f1a:	4403      	add	r3, r0
24000f1c:	4618      	mov	r0, r3
24000f1e:	ea41 0302 	orr.w	r3, r1, r2
24000f22:	6003      	str	r3, [r0, #0]
}
24000f24:	bf00      	nop
24000f26:	370c      	adds	r7, #12
24000f28:	46bd      	mov	sp, r7
24000f2a:	f85d 7b04 	ldr.w	r7, [sp], #4
24000f2e:	4770      	bx	lr
24000f30:	58000008 	.word	0x58000008

24000f34 <HAL_EXTI_D1_ClearFlag>:
  * @param   EXTI_Line: Specifies the EXTI LINE, it can be one of the following values,
  *         (EXTI_LINE0....EXTI_LINE87)excluding :line45, line81,line83 which are reserved
  * @retval None
  */
void HAL_EXTI_D1_ClearFlag(uint32_t EXTI_Line)
{
24000f34:	b480      	push	{r7}
24000f36:	b083      	sub	sp, #12
24000f38:	af00      	add	r7, sp, #0
24000f3a:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
 assert_param(IS_EXTI_D1_LINE(EXTI_Line));
 WRITE_REG(*(__IO uint32_t *) (((uint32_t) &(EXTI_D1->PR1)) + ((EXTI_Line >> 5 ) * 0x10UL)), (uint32_t)(1UL << (EXTI_Line & 0x1FUL)));
24000f3c:	687b      	ldr	r3, [r7, #4]
24000f3e:	f003 021f 	and.w	r2, r3, #31
24000f42:	687b      	ldr	r3, [r7, #4]
24000f44:	095b      	lsrs	r3, r3, #5
24000f46:	0119      	lsls	r1, r3, #4
24000f48:	4b05      	ldr	r3, [pc, #20]	; (24000f60 <HAL_EXTI_D1_ClearFlag+0x2c>)
24000f4a:	440b      	add	r3, r1
24000f4c:	4619      	mov	r1, r3
24000f4e:	2301      	movs	r3, #1
24000f50:	4093      	lsls	r3, r2
24000f52:	600b      	str	r3, [r1, #0]

}
24000f54:	bf00      	nop
24000f56:	370c      	adds	r7, #12
24000f58:	46bd      	mov	sp, r7
24000f5a:	f85d 7b04 	ldr.w	r7, [sp], #4
24000f5e:	4770      	bx	lr
24000f60:	58000088 	.word	0x58000088

24000f64 <HAL_EXTI_D1_EventInputConfig>:
  * @param   EXTI_LineCmd controls (Enable/Disable) the EXTI line.

  * @retval None
  */
void HAL_EXTI_D1_EventInputConfig(uint32_t EXTI_Line , uint32_t EXTI_Mode,  uint32_t EXTI_LineCmd )
{
24000f64:	b480      	push	{r7}
24000f66:	b085      	sub	sp, #20
24000f68:	af00      	add	r7, sp, #0
24000f6a:	60f8      	str	r0, [r7, #12]
24000f6c:	60b9      	str	r1, [r7, #8]
24000f6e:	607a      	str	r2, [r7, #4]
  /* Check the parameter */
  assert_param(IS_EXTI_D1_LINE(EXTI_Line));
  assert_param(IS_EXTI_MODE_LINE(EXTI_Mode));

  if( (EXTI_Mode & EXTI_MODE_IT) == EXTI_MODE_IT)
24000f70:	68bb      	ldr	r3, [r7, #8]
24000f72:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
24000f76:	2b00      	cmp	r3, #0
24000f78:	d02d      	beq.n	24000fd6 <HAL_EXTI_D1_EventInputConfig+0x72>
  {
     if( EXTI_LineCmd == 0UL)
24000f7a:	687b      	ldr	r3, [r7, #4]
24000f7c:	2b00      	cmp	r3, #0
24000f7e:	d116      	bne.n	24000fae <HAL_EXTI_D1_EventInputConfig+0x4a>
     {
       /* Clear EXTI line configuration */
        CLEAR_BIT(*(__IO uint32_t *) (((uint32_t) &(EXTI_D1->IMR1)) + ((EXTI_Line >> 5 ) * 0x10UL)),(uint32_t)(1UL << (EXTI_Line & 0x1FUL)) );
24000f80:	68fb      	ldr	r3, [r7, #12]
24000f82:	095a      	lsrs	r2, r3, #5
24000f84:	4b30      	ldr	r3, [pc, #192]	; (24001048 <HAL_EXTI_D1_EventInputConfig+0xe4>)
24000f86:	4413      	add	r3, r2
24000f88:	011b      	lsls	r3, r3, #4
24000f8a:	6819      	ldr	r1, [r3, #0]
24000f8c:	68fb      	ldr	r3, [r7, #12]
24000f8e:	f003 031f 	and.w	r3, r3, #31
24000f92:	2201      	movs	r2, #1
24000f94:	fa02 f303 	lsl.w	r3, r2, r3
24000f98:	43da      	mvns	r2, r3
24000f9a:	68fb      	ldr	r3, [r7, #12]
24000f9c:	0958      	lsrs	r0, r3, #5
24000f9e:	4b2a      	ldr	r3, [pc, #168]	; (24001048 <HAL_EXTI_D1_EventInputConfig+0xe4>)
24000fa0:	4403      	add	r3, r0
24000fa2:	011b      	lsls	r3, r3, #4
24000fa4:	4618      	mov	r0, r3
24000fa6:	ea01 0302 	and.w	r3, r1, r2
24000faa:	6003      	str	r3, [r0, #0]
24000fac:	e013      	b.n	24000fd6 <HAL_EXTI_D1_EventInputConfig+0x72>
     }
     else
     {
        SET_BIT(*(__IO uint32_t *) (((uint32_t) &(EXTI_D1->IMR1)) + ((EXTI_Line >> 5 ) * 0x10UL)), (uint32_t)(1UL << (EXTI_Line & 0x1FUL)));
24000fae:	68fb      	ldr	r3, [r7, #12]
24000fb0:	095a      	lsrs	r2, r3, #5
24000fb2:	4b25      	ldr	r3, [pc, #148]	; (24001048 <HAL_EXTI_D1_EventInputConfig+0xe4>)
24000fb4:	4413      	add	r3, r2
24000fb6:	011b      	lsls	r3, r3, #4
24000fb8:	6819      	ldr	r1, [r3, #0]
24000fba:	68fb      	ldr	r3, [r7, #12]
24000fbc:	f003 031f 	and.w	r3, r3, #31
24000fc0:	2201      	movs	r2, #1
24000fc2:	409a      	lsls	r2, r3
24000fc4:	68fb      	ldr	r3, [r7, #12]
24000fc6:	0958      	lsrs	r0, r3, #5
24000fc8:	4b1f      	ldr	r3, [pc, #124]	; (24001048 <HAL_EXTI_D1_EventInputConfig+0xe4>)
24000fca:	4403      	add	r3, r0
24000fcc:	011b      	lsls	r3, r3, #4
24000fce:	4618      	mov	r0, r3
24000fd0:	ea41 0302 	orr.w	r3, r1, r2
24000fd4:	6003      	str	r3, [r0, #0]
     }
  }

  if( (EXTI_Mode & EXTI_MODE_EVT) == EXTI_MODE_EVT)
24000fd6:	68bb      	ldr	r3, [r7, #8]
24000fd8:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
24000fdc:	2b00      	cmp	r3, #0
24000fde:	d02d      	beq.n	2400103c <HAL_EXTI_D1_EventInputConfig+0xd8>
  {
    if( EXTI_LineCmd == 0UL)
24000fe0:	687b      	ldr	r3, [r7, #4]
24000fe2:	2b00      	cmp	r3, #0
24000fe4:	d116      	bne.n	24001014 <HAL_EXTI_D1_EventInputConfig+0xb0>
    {
      /* Clear EXTI line configuration */
      CLEAR_BIT(  *(__IO uint32_t *) (((uint32_t) &(EXTI_D1->EMR1)) + ((EXTI_Line >> 5 ) * 0x10UL)), (uint32_t)(1UL << (EXTI_Line & 0x1FUL)));
24000fe6:	68fb      	ldr	r3, [r7, #12]
24000fe8:	095b      	lsrs	r3, r3, #5
24000fea:	011a      	lsls	r2, r3, #4
24000fec:	4b17      	ldr	r3, [pc, #92]	; (2400104c <HAL_EXTI_D1_EventInputConfig+0xe8>)
24000fee:	4413      	add	r3, r2
24000ff0:	6819      	ldr	r1, [r3, #0]
24000ff2:	68fb      	ldr	r3, [r7, #12]
24000ff4:	f003 031f 	and.w	r3, r3, #31
24000ff8:	2201      	movs	r2, #1
24000ffa:	fa02 f303 	lsl.w	r3, r2, r3
24000ffe:	43da      	mvns	r2, r3
24001000:	68fb      	ldr	r3, [r7, #12]
24001002:	095b      	lsrs	r3, r3, #5
24001004:	0118      	lsls	r0, r3, #4
24001006:	4b11      	ldr	r3, [pc, #68]	; (2400104c <HAL_EXTI_D1_EventInputConfig+0xe8>)
24001008:	4403      	add	r3, r0
2400100a:	4618      	mov	r0, r3
2400100c:	ea01 0302 	and.w	r3, r1, r2
24001010:	6003      	str	r3, [r0, #0]
    else
    {
      SET_BIT(  *(__IO uint32_t *) (((uint32_t) &(EXTI_D1->EMR1)) + ((EXTI_Line >> 5 ) * 0x10UL)), (uint32_t)(1UL << (EXTI_Line & 0x1FUL)));
    }
  }
}
24001012:	e013      	b.n	2400103c <HAL_EXTI_D1_EventInputConfig+0xd8>
      SET_BIT(  *(__IO uint32_t *) (((uint32_t) &(EXTI_D1->EMR1)) + ((EXTI_Line >> 5 ) * 0x10UL)), (uint32_t)(1UL << (EXTI_Line & 0x1FUL)));
24001014:	68fb      	ldr	r3, [r7, #12]
24001016:	095b      	lsrs	r3, r3, #5
24001018:	011a      	lsls	r2, r3, #4
2400101a:	4b0c      	ldr	r3, [pc, #48]	; (2400104c <HAL_EXTI_D1_EventInputConfig+0xe8>)
2400101c:	4413      	add	r3, r2
2400101e:	6819      	ldr	r1, [r3, #0]
24001020:	68fb      	ldr	r3, [r7, #12]
24001022:	f003 031f 	and.w	r3, r3, #31
24001026:	2201      	movs	r2, #1
24001028:	409a      	lsls	r2, r3
2400102a:	68fb      	ldr	r3, [r7, #12]
2400102c:	095b      	lsrs	r3, r3, #5
2400102e:	0118      	lsls	r0, r3, #4
24001030:	4b06      	ldr	r3, [pc, #24]	; (2400104c <HAL_EXTI_D1_EventInputConfig+0xe8>)
24001032:	4403      	add	r3, r0
24001034:	4618      	mov	r0, r3
24001036:	ea41 0302 	orr.w	r3, r1, r2
2400103a:	6003      	str	r3, [r0, #0]
}
2400103c:	bf00      	nop
2400103e:	3714      	adds	r7, #20
24001040:	46bd      	mov	sp, r7
24001042:	f85d 7b04 	ldr.w	r7, [sp], #4
24001046:	4770      	bx	lr
24001048:	05800008 	.word	0x05800008
2400104c:	58000084 	.word	0x58000084

24001050 <HAL_EXTI_D3_EventInputConfig>:
  *   @arg LPTIM4_OUT_CLEAR : LPTIM4 out selected as D3 domain pendclear source
  *   @arg LPTIM5_OUT_CLEAR : LPTIM5 out selected as D3 domain pendclear source
  * @retval None
  */
void HAL_EXTI_D3_EventInputConfig(uint32_t EXTI_Line, uint32_t EXTI_LineCmd , uint32_t EXTI_ClearSrc  )
{
24001050:	b480      	push	{r7}
24001052:	b087      	sub	sp, #28
24001054:	af00      	add	r7, sp, #0
24001056:	60f8      	str	r0, [r7, #12]
24001058:	60b9      	str	r1, [r7, #8]
2400105a:	607a      	str	r2, [r7, #4]

  /* Check the parameter */
  assert_param(IS_EXTI_D3_LINE(EXTI_Line));
  assert_param(IS_EXTI_D3_CLEAR(EXTI_ClearSrc));

  if( EXTI_LineCmd == 0UL)
2400105c:	68bb      	ldr	r3, [r7, #8]
2400105e:	2b00      	cmp	r3, #0
24001060:	d116      	bne.n	24001090 <HAL_EXTI_D3_EventInputConfig+0x40>
  {
    /* Clear EXTI line configuration */
    CLEAR_BIT(*(__IO uint32_t *) (((uint32_t) &(EXTI->D3PMR1)) + ((EXTI_Line >> 5 ) * 0x20UL)),(uint32_t)(1UL << (EXTI_Line & 0x1FUL)) );
24001062:	68fb      	ldr	r3, [r7, #12]
24001064:	095b      	lsrs	r3, r3, #5
24001066:	015a      	lsls	r2, r3, #5
24001068:	4b2a      	ldr	r3, [pc, #168]	; (24001114 <HAL_EXTI_D3_EventInputConfig+0xc4>)
2400106a:	4413      	add	r3, r2
2400106c:	6819      	ldr	r1, [r3, #0]
2400106e:	68fb      	ldr	r3, [r7, #12]
24001070:	f003 031f 	and.w	r3, r3, #31
24001074:	2201      	movs	r2, #1
24001076:	fa02 f303 	lsl.w	r3, r2, r3
2400107a:	43da      	mvns	r2, r3
2400107c:	68fb      	ldr	r3, [r7, #12]
2400107e:	095b      	lsrs	r3, r3, #5
24001080:	0158      	lsls	r0, r3, #5
24001082:	4b24      	ldr	r3, [pc, #144]	; (24001114 <HAL_EXTI_D3_EventInputConfig+0xc4>)
24001084:	4403      	add	r3, r0
24001086:	4618      	mov	r0, r3
24001088:	ea01 0302 	and.w	r3, r1, r2
2400108c:	6003      	str	r3, [r0, #0]
2400108e:	e013      	b.n	240010b8 <HAL_EXTI_D3_EventInputConfig+0x68>
  }
  else
  {
    SET_BIT(*(__IO uint32_t *) (((uint32_t) &(EXTI->D3PMR1)) +((EXTI_Line >> 5 ) * 0x20UL)), (uint32_t)(1UL << (EXTI_Line & 0x1FUL)));
24001090:	68fb      	ldr	r3, [r7, #12]
24001092:	095b      	lsrs	r3, r3, #5
24001094:	015a      	lsls	r2, r3, #5
24001096:	4b1f      	ldr	r3, [pc, #124]	; (24001114 <HAL_EXTI_D3_EventInputConfig+0xc4>)
24001098:	4413      	add	r3, r2
2400109a:	6819      	ldr	r1, [r3, #0]
2400109c:	68fb      	ldr	r3, [r7, #12]
2400109e:	f003 031f 	and.w	r3, r3, #31
240010a2:	2201      	movs	r2, #1
240010a4:	409a      	lsls	r2, r3
240010a6:	68fb      	ldr	r3, [r7, #12]
240010a8:	095b      	lsrs	r3, r3, #5
240010aa:	0158      	lsls	r0, r3, #5
240010ac:	4b19      	ldr	r3, [pc, #100]	; (24001114 <HAL_EXTI_D3_EventInputConfig+0xc4>)
240010ae:	4403      	add	r3, r0
240010b0:	4618      	mov	r0, r3
240010b2:	ea41 0302 	orr.w	r3, r1, r2
240010b6:	6003      	str	r3, [r0, #0]
  }

  if(((EXTI_Line>>4)%2UL) == 0UL)
240010b8:	68fb      	ldr	r3, [r7, #12]
240010ba:	091b      	lsrs	r3, r3, #4
240010bc:	f003 0301 	and.w	r3, r3, #1
240010c0:	2b00      	cmp	r3, #0
240010c2:	d106      	bne.n	240010d2 <HAL_EXTI_D3_EventInputConfig+0x82>
  {
    pRegv = (__IO uint32_t *) (((uint32_t) &(EXTI->D3PCR1L)) + ((EXTI_Line >> 5 ) * 0x20UL));
240010c4:	68fb      	ldr	r3, [r7, #12]
240010c6:	095b      	lsrs	r3, r3, #5
240010c8:	015a      	lsls	r2, r3, #5
240010ca:	4b13      	ldr	r3, [pc, #76]	; (24001118 <HAL_EXTI_D3_EventInputConfig+0xc8>)
240010cc:	4413      	add	r3, r2
240010ce:	617b      	str	r3, [r7, #20]
240010d0:	e005      	b.n	240010de <HAL_EXTI_D3_EventInputConfig+0x8e>
  }
  else
  {
    pRegv = (__IO uint32_t *) (((uint32_t) &(EXTI->D3PCR1H)) + ((EXTI_Line >> 5 ) * 0x20UL));
240010d2:	68fb      	ldr	r3, [r7, #12]
240010d4:	095b      	lsrs	r3, r3, #5
240010d6:	015a      	lsls	r2, r3, #5
240010d8:	4b10      	ldr	r3, [pc, #64]	; (2400111c <HAL_EXTI_D3_EventInputConfig+0xcc>)
240010da:	4413      	add	r3, r2
240010dc:	617b      	str	r3, [r7, #20]
  }
  MODIFY_REG(*pRegv, (uint32_t)(3UL << ((EXTI_Line*2UL) & 0x1FUL)), (uint32_t)(EXTI_ClearSrc << ((EXTI_Line*2UL) & 0x1FUL)));
240010de:	697b      	ldr	r3, [r7, #20]
240010e0:	681a      	ldr	r2, [r3, #0]
240010e2:	68fb      	ldr	r3, [r7, #12]
240010e4:	005b      	lsls	r3, r3, #1
240010e6:	f003 031e 	and.w	r3, r3, #30
240010ea:	2103      	movs	r1, #3
240010ec:	fa01 f303 	lsl.w	r3, r1, r3
240010f0:	43db      	mvns	r3, r3
240010f2:	401a      	ands	r2, r3
240010f4:	68fb      	ldr	r3, [r7, #12]
240010f6:	005b      	lsls	r3, r3, #1
240010f8:	f003 031e 	and.w	r3, r3, #30
240010fc:	6879      	ldr	r1, [r7, #4]
240010fe:	fa01 f303 	lsl.w	r3, r1, r3
24001102:	431a      	orrs	r2, r3
24001104:	697b      	ldr	r3, [r7, #20]
24001106:	601a      	str	r2, [r3, #0]

}
24001108:	bf00      	nop
2400110a:	371c      	adds	r7, #28
2400110c:	46bd      	mov	sp, r7
2400110e:	f85d 7b04 	ldr.w	r7, [sp], #4
24001112:	4770      	bx	lr
24001114:	5800000c 	.word	0x5800000c
24001118:	58000010 	.word	0x58000010
2400111c:	58000014 	.word	0x58000014

24001120 <__NVIC_SetPriorityGrouping>:
           In case of a conflict between priority grouping and available
           priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
  \param [in]      PriorityGroup  Priority grouping field.
 */
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
24001120:	b480      	push	{r7}
24001122:	b085      	sub	sp, #20
24001124:	af00      	add	r7, sp, #0
24001126:	6078      	str	r0, [r7, #4]
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
24001128:	687b      	ldr	r3, [r7, #4]
2400112a:	f003 0307 	and.w	r3, r3, #7
2400112e:	60fb      	str	r3, [r7, #12]

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
24001130:	4b0b      	ldr	r3, [pc, #44]	; (24001160 <__NVIC_SetPriorityGrouping+0x40>)
24001132:	68db      	ldr	r3, [r3, #12]
24001134:	60bb      	str	r3, [r7, #8]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
24001136:	68ba      	ldr	r2, [r7, #8]
24001138:	f64f 03ff 	movw	r3, #63743	; 0xf8ff
2400113c:	4013      	ands	r3, r2
2400113e:	60bb      	str	r3, [r7, #8]
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
24001140:	68fb      	ldr	r3, [r7, #12]
24001142:	021a      	lsls	r2, r3, #8
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
24001144:	68bb      	ldr	r3, [r7, #8]
24001146:	431a      	orrs	r2, r3
  reg_value  =  (reg_value                                   |
24001148:	4b06      	ldr	r3, [pc, #24]	; (24001164 <__NVIC_SetPriorityGrouping+0x44>)
2400114a:	4313      	orrs	r3, r2
2400114c:	60bb      	str	r3, [r7, #8]
  SCB->AIRCR =  reg_value;
2400114e:	4a04      	ldr	r2, [pc, #16]	; (24001160 <__NVIC_SetPriorityGrouping+0x40>)
24001150:	68bb      	ldr	r3, [r7, #8]
24001152:	60d3      	str	r3, [r2, #12]
}
24001154:	bf00      	nop
24001156:	3714      	adds	r7, #20
24001158:	46bd      	mov	sp, r7
2400115a:	f85d 7b04 	ldr.w	r7, [sp], #4
2400115e:	4770      	bx	lr
24001160:	e000ed00 	.word	0xe000ed00
24001164:	05fa0000 	.word	0x05fa0000

24001168 <__NVIC_GetPriorityGrouping>:
  \brief   Get Priority Grouping
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
24001168:	b480      	push	{r7}
2400116a:	af00      	add	r7, sp, #0
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
2400116c:	4b04      	ldr	r3, [pc, #16]	; (24001180 <__NVIC_GetPriorityGrouping+0x18>)
2400116e:	68db      	ldr	r3, [r3, #12]
24001170:	0a1b      	lsrs	r3, r3, #8
24001172:	f003 0307 	and.w	r3, r3, #7
}
24001176:	4618      	mov	r0, r3
24001178:	46bd      	mov	sp, r7
2400117a:	f85d 7b04 	ldr.w	r7, [sp], #4
2400117e:	4770      	bx	lr
24001180:	e000ed00 	.word	0xe000ed00

24001184 <__NVIC_EnableIRQ>:
  \details Enables a device specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
24001184:	b480      	push	{r7}
24001186:	b083      	sub	sp, #12
24001188:	af00      	add	r7, sp, #0
2400118a:	4603      	mov	r3, r0
2400118c:	80fb      	strh	r3, [r7, #6]
  if ((int32_t)(IRQn) >= 0)
2400118e:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
24001192:	2b00      	cmp	r3, #0
24001194:	db0b      	blt.n	240011ae <__NVIC_EnableIRQ+0x2a>
  {
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
24001196:	88fb      	ldrh	r3, [r7, #6]
24001198:	f003 021f 	and.w	r2, r3, #31
2400119c:	4907      	ldr	r1, [pc, #28]	; (240011bc <__NVIC_EnableIRQ+0x38>)
2400119e:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
240011a2:	095b      	lsrs	r3, r3, #5
240011a4:	2001      	movs	r0, #1
240011a6:	fa00 f202 	lsl.w	r2, r0, r2
240011aa:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  }
}
240011ae:	bf00      	nop
240011b0:	370c      	adds	r7, #12
240011b2:	46bd      	mov	sp, r7
240011b4:	f85d 7b04 	ldr.w	r7, [sp], #4
240011b8:	4770      	bx	lr
240011ba:	bf00      	nop
240011bc:	e000e100 	.word	0xe000e100

240011c0 <__NVIC_DisableIRQ>:
  \details Disables a device specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_DisableIRQ(IRQn_Type IRQn)
{
240011c0:	b480      	push	{r7}
240011c2:	b083      	sub	sp, #12
240011c4:	af00      	add	r7, sp, #0
240011c6:	4603      	mov	r3, r0
240011c8:	80fb      	strh	r3, [r7, #6]
  if ((int32_t)(IRQn) >= 0)
240011ca:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
240011ce:	2b00      	cmp	r3, #0
240011d0:	db10      	blt.n	240011f4 <__NVIC_DisableIRQ+0x34>
  {
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
240011d2:	88fb      	ldrh	r3, [r7, #6]
240011d4:	f003 021f 	and.w	r2, r3, #31
240011d8:	4909      	ldr	r1, [pc, #36]	; (24001200 <__NVIC_DisableIRQ+0x40>)
240011da:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
240011de:	095b      	lsrs	r3, r3, #5
240011e0:	2001      	movs	r0, #1
240011e2:	fa00 f202 	lsl.w	r2, r0, r2
240011e6:	3320      	adds	r3, #32
240011e8:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
240011ec:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
240011f0:	f3bf 8f6f 	isb	sy
    __DSB();
    __ISB();
  }
}
240011f4:	bf00      	nop
240011f6:	370c      	adds	r7, #12
240011f8:	46bd      	mov	sp, r7
240011fa:	f85d 7b04 	ldr.w	r7, [sp], #4
240011fe:	4770      	bx	lr
24001200:	e000e100 	.word	0xe000e100

24001204 <__NVIC_GetPendingIRQ>:
  \return             0  Interrupt status is not pending.
  \return             1  Interrupt status is pending.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE uint32_t __NVIC_GetPendingIRQ(IRQn_Type IRQn)
{
24001204:	b480      	push	{r7}
24001206:	b083      	sub	sp, #12
24001208:	af00      	add	r7, sp, #0
2400120a:	4603      	mov	r3, r0
2400120c:	80fb      	strh	r3, [r7, #6]
  if ((int32_t)(IRQn) >= 0)
2400120e:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
24001212:	2b00      	cmp	r3, #0
24001214:	db0e      	blt.n	24001234 <__NVIC_GetPendingIRQ+0x30>
  {
    return((uint32_t)(((NVIC->ISPR[(((uint32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
24001216:	4a0b      	ldr	r2, [pc, #44]	; (24001244 <__NVIC_GetPendingIRQ+0x40>)
24001218:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
2400121c:	095b      	lsrs	r3, r3, #5
2400121e:	3340      	adds	r3, #64	; 0x40
24001220:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
24001224:	88fb      	ldrh	r3, [r7, #6]
24001226:	f003 031f 	and.w	r3, r3, #31
2400122a:	fa22 f303 	lsr.w	r3, r2, r3
2400122e:	f003 0301 	and.w	r3, r3, #1
24001232:	e000      	b.n	24001236 <__NVIC_GetPendingIRQ+0x32>
  }
  else
  {
    return(0U);
24001234:	2300      	movs	r3, #0
  }
}
24001236:	4618      	mov	r0, r3
24001238:	370c      	adds	r7, #12
2400123a:	46bd      	mov	sp, r7
2400123c:	f85d 7b04 	ldr.w	r7, [sp], #4
24001240:	4770      	bx	lr
24001242:	bf00      	nop
24001244:	e000e100 	.word	0xe000e100

24001248 <__NVIC_SetPendingIRQ>:
  \details Sets the pending bit of a device specific interrupt in the NVIC pending register.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_SetPendingIRQ(IRQn_Type IRQn)
{
24001248:	b480      	push	{r7}
2400124a:	b083      	sub	sp, #12
2400124c:	af00      	add	r7, sp, #0
2400124e:	4603      	mov	r3, r0
24001250:	80fb      	strh	r3, [r7, #6]
  if ((int32_t)(IRQn) >= 0)
24001252:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
24001256:	2b00      	cmp	r3, #0
24001258:	db0c      	blt.n	24001274 <__NVIC_SetPendingIRQ+0x2c>
  {
    NVIC->ISPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
2400125a:	88fb      	ldrh	r3, [r7, #6]
2400125c:	f003 021f 	and.w	r2, r3, #31
24001260:	4907      	ldr	r1, [pc, #28]	; (24001280 <__NVIC_SetPendingIRQ+0x38>)
24001262:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
24001266:	095b      	lsrs	r3, r3, #5
24001268:	2001      	movs	r0, #1
2400126a:	fa00 f202 	lsl.w	r2, r0, r2
2400126e:	3340      	adds	r3, #64	; 0x40
24001270:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  }
}
24001274:	bf00      	nop
24001276:	370c      	adds	r7, #12
24001278:	46bd      	mov	sp, r7
2400127a:	f85d 7b04 	ldr.w	r7, [sp], #4
2400127e:	4770      	bx	lr
24001280:	e000e100 	.word	0xe000e100

24001284 <__NVIC_ClearPendingIRQ>:
  \details Clears the pending bit of a device specific interrupt in the NVIC pending register.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
24001284:	b480      	push	{r7}
24001286:	b083      	sub	sp, #12
24001288:	af00      	add	r7, sp, #0
2400128a:	4603      	mov	r3, r0
2400128c:	80fb      	strh	r3, [r7, #6]
  if ((int32_t)(IRQn) >= 0)
2400128e:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
24001292:	2b00      	cmp	r3, #0
24001294:	db0c      	blt.n	240012b0 <__NVIC_ClearPendingIRQ+0x2c>
  {
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
24001296:	88fb      	ldrh	r3, [r7, #6]
24001298:	f003 021f 	and.w	r2, r3, #31
2400129c:	4907      	ldr	r1, [pc, #28]	; (240012bc <__NVIC_ClearPendingIRQ+0x38>)
2400129e:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
240012a2:	095b      	lsrs	r3, r3, #5
240012a4:	2001      	movs	r0, #1
240012a6:	fa00 f202 	lsl.w	r2, r0, r2
240012aa:	3360      	adds	r3, #96	; 0x60
240012ac:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  }
}
240012b0:	bf00      	nop
240012b2:	370c      	adds	r7, #12
240012b4:	46bd      	mov	sp, r7
240012b6:	f85d 7b04 	ldr.w	r7, [sp], #4
240012ba:	4770      	bx	lr
240012bc:	e000e100 	.word	0xe000e100

240012c0 <__NVIC_GetActive>:
  \return             0  Interrupt status is not active.
  \return             1  Interrupt status is active.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE uint32_t __NVIC_GetActive(IRQn_Type IRQn)
{
240012c0:	b480      	push	{r7}
240012c2:	b083      	sub	sp, #12
240012c4:	af00      	add	r7, sp, #0
240012c6:	4603      	mov	r3, r0
240012c8:	80fb      	strh	r3, [r7, #6]
  if ((int32_t)(IRQn) >= 0)
240012ca:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
240012ce:	2b00      	cmp	r3, #0
240012d0:	db0e      	blt.n	240012f0 <__NVIC_GetActive+0x30>
  {
    return((uint32_t)(((NVIC->IABR[(((uint32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
240012d2:	4a0b      	ldr	r2, [pc, #44]	; (24001300 <__NVIC_GetActive+0x40>)
240012d4:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
240012d8:	095b      	lsrs	r3, r3, #5
240012da:	3380      	adds	r3, #128	; 0x80
240012dc:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
240012e0:	88fb      	ldrh	r3, [r7, #6]
240012e2:	f003 031f 	and.w	r3, r3, #31
240012e6:	fa22 f303 	lsr.w	r3, r2, r3
240012ea:	f003 0301 	and.w	r3, r3, #1
240012ee:	e000      	b.n	240012f2 <__NVIC_GetActive+0x32>
  }
  else
  {
    return(0U);
240012f0:	2300      	movs	r3, #0
  }
}
240012f2:	4618      	mov	r0, r3
240012f4:	370c      	adds	r7, #12
240012f6:	46bd      	mov	sp, r7
240012f8:	f85d 7b04 	ldr.w	r7, [sp], #4
240012fc:	4770      	bx	lr
240012fe:	bf00      	nop
24001300:	e000e100 	.word	0xe000e100

24001304 <__NVIC_SetPriority>:
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
24001304:	b480      	push	{r7}
24001306:	b083      	sub	sp, #12
24001308:	af00      	add	r7, sp, #0
2400130a:	4603      	mov	r3, r0
2400130c:	6039      	str	r1, [r7, #0]
2400130e:	80fb      	strh	r3, [r7, #6]
  if ((int32_t)(IRQn) >= 0)
24001310:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
24001314:	2b00      	cmp	r3, #0
24001316:	db0a      	blt.n	2400132e <__NVIC_SetPriority+0x2a>
  {
    NVIC->IP[((uint32_t)IRQn)]                = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
24001318:	683b      	ldr	r3, [r7, #0]
2400131a:	b2da      	uxtb	r2, r3
2400131c:	490c      	ldr	r1, [pc, #48]	; (24001350 <__NVIC_SetPriority+0x4c>)
2400131e:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
24001322:	0112      	lsls	r2, r2, #4
24001324:	b2d2      	uxtb	r2, r2
24001326:	440b      	add	r3, r1
24001328:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
  }
  else
  {
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
}
2400132c:	e00a      	b.n	24001344 <__NVIC_SetPriority+0x40>
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
2400132e:	683b      	ldr	r3, [r7, #0]
24001330:	b2da      	uxtb	r2, r3
24001332:	4908      	ldr	r1, [pc, #32]	; (24001354 <__NVIC_SetPriority+0x50>)
24001334:	88fb      	ldrh	r3, [r7, #6]
24001336:	f003 030f 	and.w	r3, r3, #15
2400133a:	3b04      	subs	r3, #4
2400133c:	0112      	lsls	r2, r2, #4
2400133e:	b2d2      	uxtb	r2, r2
24001340:	440b      	add	r3, r1
24001342:	761a      	strb	r2, [r3, #24]
}
24001344:	bf00      	nop
24001346:	370c      	adds	r7, #12
24001348:	46bd      	mov	sp, r7
2400134a:	f85d 7b04 	ldr.w	r7, [sp], #4
2400134e:	4770      	bx	lr
24001350:	e000e100 	.word	0xe000e100
24001354:	e000ed00 	.word	0xe000ed00

24001358 <__NVIC_GetPriority>:
  \param [in]   IRQn  Interrupt number.
  \return             Interrupt Priority.
                      Value is aligned automatically to the implemented priority bits of the microcontroller.
 */
__STATIC_INLINE uint32_t __NVIC_GetPriority(IRQn_Type IRQn)
{
24001358:	b480      	push	{r7}
2400135a:	b083      	sub	sp, #12
2400135c:	af00      	add	r7, sp, #0
2400135e:	4603      	mov	r3, r0
24001360:	80fb      	strh	r3, [r7, #6]

  if ((int32_t)(IRQn) >= 0)
24001362:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
24001366:	2b00      	cmp	r3, #0
24001368:	db09      	blt.n	2400137e <__NVIC_GetPriority+0x26>
  {
    return(((uint32_t)NVIC->IP[((uint32_t)IRQn)]                >> (8U - __NVIC_PRIO_BITS)));
2400136a:	4a0d      	ldr	r2, [pc, #52]	; (240013a0 <__NVIC_GetPriority+0x48>)
2400136c:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
24001370:	4413      	add	r3, r2
24001372:	f893 3300 	ldrb.w	r3, [r3, #768]	; 0x300
24001376:	b2db      	uxtb	r3, r3
24001378:	091b      	lsrs	r3, r3, #4
2400137a:	b2db      	uxtb	r3, r3
2400137c:	e009      	b.n	24001392 <__NVIC_GetPriority+0x3a>
  }
  else
  {
    return(((uint32_t)SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] >> (8U - __NVIC_PRIO_BITS)));
2400137e:	4a09      	ldr	r2, [pc, #36]	; (240013a4 <__NVIC_GetPriority+0x4c>)
24001380:	88fb      	ldrh	r3, [r7, #6]
24001382:	f003 030f 	and.w	r3, r3, #15
24001386:	3b04      	subs	r3, #4
24001388:	4413      	add	r3, r2
2400138a:	7e1b      	ldrb	r3, [r3, #24]
2400138c:	b2db      	uxtb	r3, r3
2400138e:	091b      	lsrs	r3, r3, #4
24001390:	b2db      	uxtb	r3, r3
  }
}
24001392:	4618      	mov	r0, r3
24001394:	370c      	adds	r7, #12
24001396:	46bd      	mov	sp, r7
24001398:	f85d 7b04 	ldr.w	r7, [sp], #4
2400139c:	4770      	bx	lr
2400139e:	bf00      	nop
240013a0:	e000e100 	.word	0xe000e100
240013a4:	e000ed00 	.word	0xe000ed00

240013a8 <NVIC_EncodePriority>:
  \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
  \param [in]       SubPriority  Subpriority value (starting from 0).
  \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
 */
__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
{
240013a8:	b480      	push	{r7}
240013aa:	b089      	sub	sp, #36	; 0x24
240013ac:	af00      	add	r7, sp, #0
240013ae:	60f8      	str	r0, [r7, #12]
240013b0:	60b9      	str	r1, [r7, #8]
240013b2:	607a      	str	r2, [r7, #4]
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
240013b4:	68fb      	ldr	r3, [r7, #12]
240013b6:	f003 0307 	and.w	r3, r3, #7
240013ba:	61fb      	str	r3, [r7, #28]
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
240013bc:	69fb      	ldr	r3, [r7, #28]
240013be:	f1c3 0307 	rsb	r3, r3, #7
240013c2:	2b04      	cmp	r3, #4
240013c4:	bf28      	it	cs
240013c6:	2304      	movcs	r3, #4
240013c8:	61bb      	str	r3, [r7, #24]
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
240013ca:	69fb      	ldr	r3, [r7, #28]
240013cc:	3304      	adds	r3, #4
240013ce:	2b06      	cmp	r3, #6
240013d0:	d902      	bls.n	240013d8 <NVIC_EncodePriority+0x30>
240013d2:	69fb      	ldr	r3, [r7, #28]
240013d4:	3b03      	subs	r3, #3
240013d6:	e000      	b.n	240013da <NVIC_EncodePriority+0x32>
240013d8:	2300      	movs	r3, #0
240013da:	617b      	str	r3, [r7, #20]

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
240013dc:	f04f 32ff 	mov.w	r2, #4294967295
240013e0:	69bb      	ldr	r3, [r7, #24]
240013e2:	fa02 f303 	lsl.w	r3, r2, r3
240013e6:	43da      	mvns	r2, r3
240013e8:	68bb      	ldr	r3, [r7, #8]
240013ea:	401a      	ands	r2, r3
240013ec:	697b      	ldr	r3, [r7, #20]
240013ee:	409a      	lsls	r2, r3
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
240013f0:	f04f 31ff 	mov.w	r1, #4294967295
240013f4:	697b      	ldr	r3, [r7, #20]
240013f6:	fa01 f303 	lsl.w	r3, r1, r3
240013fa:	43d9      	mvns	r1, r3
240013fc:	687b      	ldr	r3, [r7, #4]
240013fe:	400b      	ands	r3, r1
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
24001400:	4313      	orrs	r3, r2
         );
}
24001402:	4618      	mov	r0, r3
24001404:	3724      	adds	r7, #36	; 0x24
24001406:	46bd      	mov	sp, r7
24001408:	f85d 7b04 	ldr.w	r7, [sp], #4
2400140c:	4770      	bx	lr

2400140e <NVIC_DecodePriority>:
  \param [in]     PriorityGroup  Used priority group.
  \param [out] pPreemptPriority  Preemptive priority value (starting from 0).
  \param [out]     pSubPriority  Subpriority value (starting from 0).
 */
__STATIC_INLINE void NVIC_DecodePriority (uint32_t Priority, uint32_t PriorityGroup, uint32_t* const pPreemptPriority, uint32_t* const pSubPriority)
{
2400140e:	b480      	push	{r7}
24001410:	b089      	sub	sp, #36	; 0x24
24001412:	af00      	add	r7, sp, #0
24001414:	60f8      	str	r0, [r7, #12]
24001416:	60b9      	str	r1, [r7, #8]
24001418:	607a      	str	r2, [r7, #4]
2400141a:	603b      	str	r3, [r7, #0]
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
2400141c:	68bb      	ldr	r3, [r7, #8]
2400141e:	f003 0307 	and.w	r3, r3, #7
24001422:	61fb      	str	r3, [r7, #28]
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
24001424:	69fb      	ldr	r3, [r7, #28]
24001426:	f1c3 0307 	rsb	r3, r3, #7
2400142a:	2b04      	cmp	r3, #4
2400142c:	bf28      	it	cs
2400142e:	2304      	movcs	r3, #4
24001430:	61bb      	str	r3, [r7, #24]
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
24001432:	69fb      	ldr	r3, [r7, #28]
24001434:	3304      	adds	r3, #4
24001436:	2b06      	cmp	r3, #6
24001438:	d902      	bls.n	24001440 <NVIC_DecodePriority+0x32>
2400143a:	69fb      	ldr	r3, [r7, #28]
2400143c:	3b03      	subs	r3, #3
2400143e:	e000      	b.n	24001442 <NVIC_DecodePriority+0x34>
24001440:	2300      	movs	r3, #0
24001442:	617b      	str	r3, [r7, #20]

  *pPreemptPriority = (Priority >> SubPriorityBits) & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL);
24001444:	68fa      	ldr	r2, [r7, #12]
24001446:	697b      	ldr	r3, [r7, #20]
24001448:	40da      	lsrs	r2, r3
2400144a:	f04f 31ff 	mov.w	r1, #4294967295
2400144e:	69bb      	ldr	r3, [r7, #24]
24001450:	fa01 f303 	lsl.w	r3, r1, r3
24001454:	43db      	mvns	r3, r3
24001456:	401a      	ands	r2, r3
24001458:	687b      	ldr	r3, [r7, #4]
2400145a:	601a      	str	r2, [r3, #0]
  *pSubPriority     = (Priority                   ) & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL);
2400145c:	f04f 32ff 	mov.w	r2, #4294967295
24001460:	697b      	ldr	r3, [r7, #20]
24001462:	fa02 f303 	lsl.w	r3, r2, r3
24001466:	43da      	mvns	r2, r3
24001468:	68fb      	ldr	r3, [r7, #12]
2400146a:	401a      	ands	r2, r3
2400146c:	683b      	ldr	r3, [r7, #0]
2400146e:	601a      	str	r2, [r3, #0]
}
24001470:	bf00      	nop
24001472:	3724      	adds	r7, #36	; 0x24
24001474:	46bd      	mov	sp, r7
24001476:	f85d 7b04 	ldr.w	r7, [sp], #4
2400147a:	4770      	bx	lr

2400147c <__NVIC_SystemReset>:
/**
  \brief   System Reset
  \details Initiates a system reset request to reset the MCU.
 */
__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
{
2400147c:	b480      	push	{r7}
2400147e:	af00      	add	r7, sp, #0
  __ASM volatile ("dsb 0xF":::"memory");
24001480:	f3bf 8f4f 	dsb	sy
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
24001484:	4b05      	ldr	r3, [pc, #20]	; (2400149c <__NVIC_SystemReset+0x20>)
24001486:	68db      	ldr	r3, [r3, #12]
24001488:	f403 62e0 	and.w	r2, r3, #1792	; 0x700
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
2400148c:	4903      	ldr	r1, [pc, #12]	; (2400149c <__NVIC_SystemReset+0x20>)
2400148e:	4b04      	ldr	r3, [pc, #16]	; (240014a0 <__NVIC_SystemReset+0x24>)
24001490:	4313      	orrs	r3, r2
24001492:	60cb      	str	r3, [r1, #12]
24001494:	f3bf 8f4f 	dsb	sy
                            SCB_AIRCR_SYSRESETREQ_Msk    );         /* Keep priority group unchanged */
  __DSB();                                                          /* Ensure completion of memory access */

  for(;;)                                                           /* wait until reset */
  {
    __NOP();
24001498:	bf00      	nop
2400149a:	e7fd      	b.n	24001498 <__NVIC_SystemReset+0x1c>
2400149c:	e000ed00 	.word	0xe000ed00
240014a0:	05fa0004 	.word	0x05fa0004

240014a4 <SysTick_Config>:
  \note    When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
240014a4:	b580      	push	{r7, lr}
240014a6:	b082      	sub	sp, #8
240014a8:	af00      	add	r7, sp, #0
240014aa:	6078      	str	r0, [r7, #4]
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
240014ac:	687b      	ldr	r3, [r7, #4]
240014ae:	3b01      	subs	r3, #1
240014b0:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
240014b4:	d301      	bcc.n	240014ba <SysTick_Config+0x16>
  {
    return (1UL);                                                   /* Reload value impossible */
240014b6:	2301      	movs	r3, #1
240014b8:	e00f      	b.n	240014da <SysTick_Config+0x36>
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
240014ba:	4a0a      	ldr	r2, [pc, #40]	; (240014e4 <SysTick_Config+0x40>)
240014bc:	687b      	ldr	r3, [r7, #4]
240014be:	3b01      	subs	r3, #1
240014c0:	6053      	str	r3, [r2, #4]
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
240014c2:	210f      	movs	r1, #15
240014c4:	f04f 30ff 	mov.w	r0, #4294967295
240014c8:	f7ff ff1c 	bl	24001304 <__NVIC_SetPriority>
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
240014cc:	4b05      	ldr	r3, [pc, #20]	; (240014e4 <SysTick_Config+0x40>)
240014ce:	2200      	movs	r2, #0
240014d0:	609a      	str	r2, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
240014d2:	4b04      	ldr	r3, [pc, #16]	; (240014e4 <SysTick_Config+0x40>)
240014d4:	2207      	movs	r2, #7
240014d6:	601a      	str	r2, [r3, #0]
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
240014d8:	2300      	movs	r3, #0
}
240014da:	4618      	mov	r0, r3
240014dc:	3708      	adds	r7, #8
240014de:	46bd      	mov	sp, r7
240014e0:	bd80      	pop	{r7, pc}
240014e2:	bf00      	nop
240014e4:	e000e010 	.word	0xe000e010

240014e8 <HAL_NVIC_SetPriorityGrouping>:
  * @note   When the NVIC_PriorityGroup_0 is selected, IRQ preemption is no more possible.
  *         The pending IRQ priority will be managed only by the subpriority.
  * @retval None
  */
void HAL_NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
240014e8:	b580      	push	{r7, lr}
240014ea:	b082      	sub	sp, #8
240014ec:	af00      	add	r7, sp, #0
240014ee:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));

  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
240014f0:	6878      	ldr	r0, [r7, #4]
240014f2:	f7ff fe15 	bl	24001120 <__NVIC_SetPriorityGrouping>
}
240014f6:	bf00      	nop
240014f8:	3708      	adds	r7, #8
240014fa:	46bd      	mov	sp, r7
240014fc:	bd80      	pop	{r7, pc}

240014fe <HAL_NVIC_SetPriority>:
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{
240014fe:	b580      	push	{r7, lr}
24001500:	b086      	sub	sp, #24
24001502:	af00      	add	r7, sp, #0
24001504:	4603      	mov	r3, r0
24001506:	60b9      	str	r1, [r7, #8]
24001508:	607a      	str	r2, [r7, #4]
2400150a:	81fb      	strh	r3, [r7, #14]

  /* Check the parameters */
  assert_param(IS_NVIC_SUB_PRIORITY(SubPriority));
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));

  prioritygroup = NVIC_GetPriorityGrouping();
2400150c:	f7ff fe2c 	bl	24001168 <__NVIC_GetPriorityGrouping>
24001510:	6178      	str	r0, [r7, #20]

  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
24001512:	687a      	ldr	r2, [r7, #4]
24001514:	68b9      	ldr	r1, [r7, #8]
24001516:	6978      	ldr	r0, [r7, #20]
24001518:	f7ff ff46 	bl	240013a8 <NVIC_EncodePriority>
2400151c:	4602      	mov	r2, r0
2400151e:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
24001522:	4611      	mov	r1, r2
24001524:	4618      	mov	r0, r3
24001526:	f7ff feed 	bl	24001304 <__NVIC_SetPriority>
}
2400152a:	bf00      	nop
2400152c:	3718      	adds	r7, #24
2400152e:	46bd      	mov	sp, r7
24001530:	bd80      	pop	{r7, pc}

24001532 <HAL_NVIC_EnableIRQ>:
  *         This parameter can be an enumerator of IRQn_Type enumeration
  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32h7xxxx.h))
  * @retval None
  */
void HAL_NVIC_EnableIRQ(IRQn_Type IRQn)
{
24001532:	b580      	push	{r7, lr}
24001534:	b082      	sub	sp, #8
24001536:	af00      	add	r7, sp, #0
24001538:	4603      	mov	r3, r0
2400153a:	80fb      	strh	r3, [r7, #6]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));

  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
2400153c:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
24001540:	4618      	mov	r0, r3
24001542:	f7ff fe1f 	bl	24001184 <__NVIC_EnableIRQ>
}
24001546:	bf00      	nop
24001548:	3708      	adds	r7, #8
2400154a:	46bd      	mov	sp, r7
2400154c:	bd80      	pop	{r7, pc}

2400154e <HAL_NVIC_DisableIRQ>:
  *         This parameter can be an enumerator of IRQn_Type enumeration
  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32h7xxxx.h))
  * @retval None
  */
void HAL_NVIC_DisableIRQ(IRQn_Type IRQn)
{
2400154e:	b580      	push	{r7, lr}
24001550:	b082      	sub	sp, #8
24001552:	af00      	add	r7, sp, #0
24001554:	4603      	mov	r3, r0
24001556:	80fb      	strh	r3, [r7, #6]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));

  /* Disable interrupt */
  NVIC_DisableIRQ(IRQn);
24001558:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
2400155c:	4618      	mov	r0, r3
2400155e:	f7ff fe2f 	bl	240011c0 <__NVIC_DisableIRQ>
}
24001562:	bf00      	nop
24001564:	3708      	adds	r7, #8
24001566:	46bd      	mov	sp, r7
24001568:	bd80      	pop	{r7, pc}

2400156a <HAL_NVIC_SystemReset>:
/**
  * @brief  Initiates a system reset request to reset the MCU.
  * @retval None
  */
void HAL_NVIC_SystemReset(void)
{
2400156a:	b580      	push	{r7, lr}
2400156c:	af00      	add	r7, sp, #0
  /* System Reset */
  NVIC_SystemReset();
2400156e:	f7ff ff85 	bl	2400147c <__NVIC_SystemReset>

24001572 <HAL_SYSTICK_Config>:
  * @param  TicksNumb Specifies the ticks Number of ticks between two interrupts.
  * @retval status   - 0  Function succeeded.
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
24001572:	b580      	push	{r7, lr}
24001574:	b082      	sub	sp, #8
24001576:	af00      	add	r7, sp, #0
24001578:	6078      	str	r0, [r7, #4]
   return SysTick_Config(TicksNumb);
2400157a:	6878      	ldr	r0, [r7, #4]
2400157c:	f7ff ff92 	bl	240014a4 <SysTick_Config>
24001580:	4603      	mov	r3, r0
}
24001582:	4618      	mov	r0, r3
24001584:	3708      	adds	r7, #8
24001586:	46bd      	mov	sp, r7
24001588:	bd80      	pop	{r7, pc}
	...

2400158c <HAL_MPU_Disable>:
/**
  * @brief  Disables the MPU
  * @retval None
  */
void HAL_MPU_Disable(void)
{
2400158c:	b480      	push	{r7}
2400158e:	af00      	add	r7, sp, #0
  \details Ensures the apparent order of the explicit memory operations before
           and after the instruction, without ensuring their completion.
 */
__STATIC_FORCEINLINE void __DMB(void)
{
  __ASM volatile ("dmb 0xF":::"memory");
24001590:	f3bf 8f5f 	dmb	sy
  /* Make sure outstanding transfers are done */
  __DMB();

  /* Disable fault exceptions */
  SCB->SHCSR &= ~SCB_SHCSR_MEMFAULTENA_Msk;
24001594:	4b06      	ldr	r3, [pc, #24]	; (240015b0 <HAL_MPU_Disable+0x24>)
24001596:	6a5b      	ldr	r3, [r3, #36]	; 0x24
24001598:	4a05      	ldr	r2, [pc, #20]	; (240015b0 <HAL_MPU_Disable+0x24>)
2400159a:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
2400159e:	6253      	str	r3, [r2, #36]	; 0x24

  /* Disable the MPU and clear the control register*/
  MPU->CTRL = 0;
240015a0:	4b04      	ldr	r3, [pc, #16]	; (240015b4 <HAL_MPU_Disable+0x28>)
240015a2:	2200      	movs	r2, #0
240015a4:	605a      	str	r2, [r3, #4]
}
240015a6:	bf00      	nop
240015a8:	46bd      	mov	sp, r7
240015aa:	f85d 7b04 	ldr.w	r7, [sp], #4
240015ae:	4770      	bx	lr
240015b0:	e000ed00 	.word	0xe000ed00
240015b4:	e000ed90 	.word	0xe000ed90

240015b8 <HAL_MPU_Enable>:
  *            @arg MPU_PRIVILEGED_DEFAULT
  *            @arg MPU_HFNMI_PRIVDEF
  * @retval None
  */
void HAL_MPU_Enable(uint32_t MPU_Control)
{
240015b8:	b480      	push	{r7}
240015ba:	b083      	sub	sp, #12
240015bc:	af00      	add	r7, sp, #0
240015be:	6078      	str	r0, [r7, #4]
  /* Enable the MPU */
  MPU->CTRL = MPU_Control | MPU_CTRL_ENABLE_Msk;
240015c0:	4a0a      	ldr	r2, [pc, #40]	; (240015ec <HAL_MPU_Enable+0x34>)
240015c2:	687b      	ldr	r3, [r7, #4]
240015c4:	f043 0301 	orr.w	r3, r3, #1
240015c8:	6053      	str	r3, [r2, #4]

  /* Enable fault exceptions */
  SCB->SHCSR |= SCB_SHCSR_MEMFAULTENA_Msk;
240015ca:	4b09      	ldr	r3, [pc, #36]	; (240015f0 <HAL_MPU_Enable+0x38>)
240015cc:	6a5b      	ldr	r3, [r3, #36]	; 0x24
240015ce:	4a08      	ldr	r2, [pc, #32]	; (240015f0 <HAL_MPU_Enable+0x38>)
240015d0:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
240015d4:	6253      	str	r3, [r2, #36]	; 0x24
  __ASM volatile ("dsb 0xF":::"memory");
240015d6:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
240015da:	f3bf 8f6f 	isb	sy

  /* Ensure MPU setting take effects */
  __DSB();
  __ISB();
}
240015de:	bf00      	nop
240015e0:	370c      	adds	r7, #12
240015e2:	46bd      	mov	sp, r7
240015e4:	f85d 7b04 	ldr.w	r7, [sp], #4
240015e8:	4770      	bx	lr
240015ea:	bf00      	nop
240015ec:	e000ed90 	.word	0xe000ed90
240015f0:	e000ed00 	.word	0xe000ed00

240015f4 <HAL_MPU_ConfigRegion>:
  * @param  MPU_Init Pointer to a MPU_Region_InitTypeDef structure that contains
  *                  the initialization and configuration information.
  * @retval None
  */
void HAL_MPU_ConfigRegion(MPU_Region_InitTypeDef *MPU_Init)
{
240015f4:	b480      	push	{r7}
240015f6:	b083      	sub	sp, #12
240015f8:	af00      	add	r7, sp, #0
240015fa:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_MPU_REGION_NUMBER(MPU_Init->Number));
  assert_param(IS_MPU_REGION_ENABLE(MPU_Init->Enable));

  /* Set the Region number */
  MPU->RNR = MPU_Init->Number;
240015fc:	687b      	ldr	r3, [r7, #4]
240015fe:	785a      	ldrb	r2, [r3, #1]
24001600:	4b1d      	ldr	r3, [pc, #116]	; (24001678 <HAL_MPU_ConfigRegion+0x84>)
24001602:	609a      	str	r2, [r3, #8]

  if ((MPU_Init->Enable) != 0UL)
24001604:	687b      	ldr	r3, [r7, #4]
24001606:	781b      	ldrb	r3, [r3, #0]
24001608:	2b00      	cmp	r3, #0
2400160a:	d029      	beq.n	24001660 <HAL_MPU_ConfigRegion+0x6c>
    assert_param(IS_MPU_ACCESS_CACHEABLE(MPU_Init->IsCacheable));
    assert_param(IS_MPU_ACCESS_BUFFERABLE(MPU_Init->IsBufferable));
    assert_param(IS_MPU_SUB_REGION_DISABLE(MPU_Init->SubRegionDisable));
    assert_param(IS_MPU_REGION_SIZE(MPU_Init->Size));

    MPU->RBAR = MPU_Init->BaseAddress;
2400160c:	4a1a      	ldr	r2, [pc, #104]	; (24001678 <HAL_MPU_ConfigRegion+0x84>)
2400160e:	687b      	ldr	r3, [r7, #4]
24001610:	685b      	ldr	r3, [r3, #4]
24001612:	60d3      	str	r3, [r2, #12]
    MPU->RASR = ((uint32_t)MPU_Init->DisableExec             << MPU_RASR_XN_Pos)   |
24001614:	687b      	ldr	r3, [r7, #4]
24001616:	7b1b      	ldrb	r3, [r3, #12]
24001618:	071a      	lsls	r2, r3, #28
                ((uint32_t)MPU_Init->AccessPermission        << MPU_RASR_AP_Pos)   |
2400161a:	687b      	ldr	r3, [r7, #4]
2400161c:	7adb      	ldrb	r3, [r3, #11]
2400161e:	061b      	lsls	r3, r3, #24
    MPU->RASR = ((uint32_t)MPU_Init->DisableExec             << MPU_RASR_XN_Pos)   |
24001620:	431a      	orrs	r2, r3
                ((uint32_t)MPU_Init->TypeExtField            << MPU_RASR_TEX_Pos)  |
24001622:	687b      	ldr	r3, [r7, #4]
24001624:	7a9b      	ldrb	r3, [r3, #10]
24001626:	04db      	lsls	r3, r3, #19
                ((uint32_t)MPU_Init->AccessPermission        << MPU_RASR_AP_Pos)   |
24001628:	431a      	orrs	r2, r3
                ((uint32_t)MPU_Init->IsShareable             << MPU_RASR_S_Pos)    |
2400162a:	687b      	ldr	r3, [r7, #4]
2400162c:	7b5b      	ldrb	r3, [r3, #13]
2400162e:	049b      	lsls	r3, r3, #18
                ((uint32_t)MPU_Init->TypeExtField            << MPU_RASR_TEX_Pos)  |
24001630:	431a      	orrs	r2, r3
                ((uint32_t)MPU_Init->IsCacheable             << MPU_RASR_C_Pos)    |
24001632:	687b      	ldr	r3, [r7, #4]
24001634:	7b9b      	ldrb	r3, [r3, #14]
24001636:	045b      	lsls	r3, r3, #17
                ((uint32_t)MPU_Init->IsShareable             << MPU_RASR_S_Pos)    |
24001638:	431a      	orrs	r2, r3
                ((uint32_t)MPU_Init->IsBufferable            << MPU_RASR_B_Pos)    |
2400163a:	687b      	ldr	r3, [r7, #4]
2400163c:	7bdb      	ldrb	r3, [r3, #15]
2400163e:	041b      	lsls	r3, r3, #16
                ((uint32_t)MPU_Init->IsCacheable             << MPU_RASR_C_Pos)    |
24001640:	431a      	orrs	r2, r3
                ((uint32_t)MPU_Init->SubRegionDisable        << MPU_RASR_SRD_Pos)  |
24001642:	687b      	ldr	r3, [r7, #4]
24001644:	7a5b      	ldrb	r3, [r3, #9]
24001646:	021b      	lsls	r3, r3, #8
                ((uint32_t)MPU_Init->IsBufferable            << MPU_RASR_B_Pos)    |
24001648:	431a      	orrs	r2, r3
                ((uint32_t)MPU_Init->Size                    << MPU_RASR_SIZE_Pos) |
2400164a:	687b      	ldr	r3, [r7, #4]
2400164c:	7a1b      	ldrb	r3, [r3, #8]
2400164e:	005b      	lsls	r3, r3, #1
                ((uint32_t)MPU_Init->SubRegionDisable        << MPU_RASR_SRD_Pos)  |
24001650:	4313      	orrs	r3, r2
                ((uint32_t)MPU_Init->Enable                  << MPU_RASR_ENABLE_Pos);
24001652:	687a      	ldr	r2, [r7, #4]
24001654:	7812      	ldrb	r2, [r2, #0]
24001656:	4611      	mov	r1, r2
    MPU->RASR = ((uint32_t)MPU_Init->DisableExec             << MPU_RASR_XN_Pos)   |
24001658:	4a07      	ldr	r2, [pc, #28]	; (24001678 <HAL_MPU_ConfigRegion+0x84>)
                ((uint32_t)MPU_Init->Size                    << MPU_RASR_SIZE_Pos) |
2400165a:	430b      	orrs	r3, r1
    MPU->RASR = ((uint32_t)MPU_Init->DisableExec             << MPU_RASR_XN_Pos)   |
2400165c:	6113      	str	r3, [r2, #16]
  else
  {
    MPU->RBAR = 0x00;
    MPU->RASR = 0x00;
  }
}
2400165e:	e005      	b.n	2400166c <HAL_MPU_ConfigRegion+0x78>
    MPU->RBAR = 0x00;
24001660:	4b05      	ldr	r3, [pc, #20]	; (24001678 <HAL_MPU_ConfigRegion+0x84>)
24001662:	2200      	movs	r2, #0
24001664:	60da      	str	r2, [r3, #12]
    MPU->RASR = 0x00;
24001666:	4b04      	ldr	r3, [pc, #16]	; (24001678 <HAL_MPU_ConfigRegion+0x84>)
24001668:	2200      	movs	r2, #0
2400166a:	611a      	str	r2, [r3, #16]
}
2400166c:	bf00      	nop
2400166e:	370c      	adds	r7, #12
24001670:	46bd      	mov	sp, r7
24001672:	f85d 7b04 	ldr.w	r7, [sp], #4
24001676:	4770      	bx	lr
24001678:	e000ed90 	.word	0xe000ed90

2400167c <HAL_NVIC_GetPriorityGrouping>:
/**
  * @brief  Gets the priority grouping field from the NVIC Interrupt Controller.
  * @retval Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field)
  */
uint32_t HAL_NVIC_GetPriorityGrouping(void)
{
2400167c:	b580      	push	{r7, lr}
2400167e:	af00      	add	r7, sp, #0
  /* Get the PRIGROUP[10:8] field value */
  return NVIC_GetPriorityGrouping();
24001680:	f7ff fd72 	bl	24001168 <__NVIC_GetPriorityGrouping>
24001684:	4603      	mov	r3, r0
}
24001686:	4618      	mov	r0, r3
24001688:	bd80      	pop	{r7, pc}

2400168a <HAL_NVIC_GetPriority>:
  * @param  pPreemptPriority Pointer on the Preemptive priority value (starting from 0).
  * @param  pSubPriority Pointer on the Subpriority value (starting from 0).
  * @retval None
  */
void HAL_NVIC_GetPriority(IRQn_Type IRQn, uint32_t PriorityGroup, uint32_t *pPreemptPriority, uint32_t *pSubPriority)
{
2400168a:	b580      	push	{r7, lr}
2400168c:	b084      	sub	sp, #16
2400168e:	af00      	add	r7, sp, #0
24001690:	60b9      	str	r1, [r7, #8]
24001692:	607a      	str	r2, [r7, #4]
24001694:	603b      	str	r3, [r7, #0]
24001696:	4603      	mov	r3, r0
24001698:	81fb      	strh	r3, [r7, #14]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));
 /* Get priority for Cortex-M system or device specific interrupts */
  NVIC_DecodePriority(NVIC_GetPriority(IRQn), PriorityGroup, pPreemptPriority, pSubPriority);
2400169a:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
2400169e:	4618      	mov	r0, r3
240016a0:	f7ff fe5a 	bl	24001358 <__NVIC_GetPriority>
240016a4:	683b      	ldr	r3, [r7, #0]
240016a6:	687a      	ldr	r2, [r7, #4]
240016a8:	68b9      	ldr	r1, [r7, #8]
240016aa:	f7ff feb0 	bl	2400140e <NVIC_DecodePriority>
}
240016ae:	bf00      	nop
240016b0:	3710      	adds	r7, #16
240016b2:	46bd      	mov	sp, r7
240016b4:	bd80      	pop	{r7, pc}

240016b6 <HAL_NVIC_SetPendingIRQ>:
  *         This parameter can be an enumerator of IRQn_Type enumeration
  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32h7xxxx.h))
  * @retval None
  */
void HAL_NVIC_SetPendingIRQ(IRQn_Type IRQn)
{
240016b6:	b580      	push	{r7, lr}
240016b8:	b082      	sub	sp, #8
240016ba:	af00      	add	r7, sp, #0
240016bc:	4603      	mov	r3, r0
240016be:	80fb      	strh	r3, [r7, #6]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));

  /* Set interrupt pending */
  NVIC_SetPendingIRQ(IRQn);
240016c0:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
240016c4:	4618      	mov	r0, r3
240016c6:	f7ff fdbf 	bl	24001248 <__NVIC_SetPendingIRQ>
}
240016ca:	bf00      	nop
240016cc:	3708      	adds	r7, #8
240016ce:	46bd      	mov	sp, r7
240016d0:	bd80      	pop	{r7, pc}

240016d2 <HAL_NVIC_GetPendingIRQ>:
  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32h7xxxx.h))
  * @retval status  - 0  Interrupt status is not pending.
  *                 - 1  Interrupt status is pending.
  */
uint32_t HAL_NVIC_GetPendingIRQ(IRQn_Type IRQn)
{
240016d2:	b580      	push	{r7, lr}
240016d4:	b082      	sub	sp, #8
240016d6:	af00      	add	r7, sp, #0
240016d8:	4603      	mov	r3, r0
240016da:	80fb      	strh	r3, [r7, #6]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));

  /* Return 1 if pending else 0 */
  return NVIC_GetPendingIRQ(IRQn);
240016dc:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
240016e0:	4618      	mov	r0, r3
240016e2:	f7ff fd8f 	bl	24001204 <__NVIC_GetPendingIRQ>
240016e6:	4603      	mov	r3, r0
}
240016e8:	4618      	mov	r0, r3
240016ea:	3708      	adds	r7, #8
240016ec:	46bd      	mov	sp, r7
240016ee:	bd80      	pop	{r7, pc}

240016f0 <HAL_NVIC_ClearPendingIRQ>:
  *         This parameter can be an enumerator of IRQn_Type enumeration
  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32h7xxxx.h))
  * @retval None
  */
void HAL_NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
240016f0:	b580      	push	{r7, lr}
240016f2:	b082      	sub	sp, #8
240016f4:	af00      	add	r7, sp, #0
240016f6:	4603      	mov	r3, r0
240016f8:	80fb      	strh	r3, [r7, #6]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));

  /* Clear pending interrupt */
  NVIC_ClearPendingIRQ(IRQn);
240016fa:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
240016fe:	4618      	mov	r0, r3
24001700:	f7ff fdc0 	bl	24001284 <__NVIC_ClearPendingIRQ>
}
24001704:	bf00      	nop
24001706:	3708      	adds	r7, #8
24001708:	46bd      	mov	sp, r7
2400170a:	bd80      	pop	{r7, pc}

2400170c <HAL_NVIC_GetActive>:
  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32h7xxxx.h))
  * @retval status  - 0  Interrupt status is not pending.
  *                 - 1  Interrupt status is pending.
  */
uint32_t HAL_NVIC_GetActive(IRQn_Type IRQn)
{
2400170c:	b580      	push	{r7, lr}
2400170e:	b082      	sub	sp, #8
24001710:	af00      	add	r7, sp, #0
24001712:	4603      	mov	r3, r0
24001714:	80fb      	strh	r3, [r7, #6]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));

  /* Return 1 if active else 0 */
  return NVIC_GetActive(IRQn);
24001716:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
2400171a:	4618      	mov	r0, r3
2400171c:	f7ff fdd0 	bl	240012c0 <__NVIC_GetActive>
24001720:	4603      	mov	r3, r0
}
24001722:	4618      	mov	r0, r3
24001724:	3708      	adds	r7, #8
24001726:	46bd      	mov	sp, r7
24001728:	bd80      	pop	{r7, pc}
	...

2400172c <HAL_SYSTICK_CLKSourceConfig>:
  *             @arg SYSTICK_CLKSOURCE_HCLK_DIV8: AHB clock divided by 8 selected as SysTick clock source.
  *             @arg SYSTICK_CLKSOURCE_HCLK: AHB clock selected as SysTick clock source.
  * @retval None
  */
void HAL_SYSTICK_CLKSourceConfig(uint32_t CLKSource)
{
2400172c:	b480      	push	{r7}
2400172e:	b083      	sub	sp, #12
24001730:	af00      	add	r7, sp, #0
24001732:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_SYSTICK_CLK_SOURCE(CLKSource));
  if (CLKSource == SYSTICK_CLKSOURCE_HCLK)
24001734:	687b      	ldr	r3, [r7, #4]
24001736:	2b04      	cmp	r3, #4
24001738:	d106      	bne.n	24001748 <HAL_SYSTICK_CLKSourceConfig+0x1c>
  {
    SysTick->CTRL |= SYSTICK_CLKSOURCE_HCLK;
2400173a:	4b09      	ldr	r3, [pc, #36]	; (24001760 <HAL_SYSTICK_CLKSourceConfig+0x34>)
2400173c:	681b      	ldr	r3, [r3, #0]
2400173e:	4a08      	ldr	r2, [pc, #32]	; (24001760 <HAL_SYSTICK_CLKSourceConfig+0x34>)
24001740:	f043 0304 	orr.w	r3, r3, #4
24001744:	6013      	str	r3, [r2, #0]
  }
  else
  {
    SysTick->CTRL &= ~SYSTICK_CLKSOURCE_HCLK;
  }
}
24001746:	e005      	b.n	24001754 <HAL_SYSTICK_CLKSourceConfig+0x28>
    SysTick->CTRL &= ~SYSTICK_CLKSOURCE_HCLK;
24001748:	4b05      	ldr	r3, [pc, #20]	; (24001760 <HAL_SYSTICK_CLKSourceConfig+0x34>)
2400174a:	681b      	ldr	r3, [r3, #0]
2400174c:	4a04      	ldr	r2, [pc, #16]	; (24001760 <HAL_SYSTICK_CLKSourceConfig+0x34>)
2400174e:	f023 0304 	bic.w	r3, r3, #4
24001752:	6013      	str	r3, [r2, #0]
}
24001754:	bf00      	nop
24001756:	370c      	adds	r7, #12
24001758:	46bd      	mov	sp, r7
2400175a:	f85d 7b04 	ldr.w	r7, [sp], #4
2400175e:	4770      	bx	lr
24001760:	e000e010 	.word	0xe000e010

24001764 <HAL_SYSTICK_IRQHandler>:
/**
  * @brief  This function handles SYSTICK interrupt request.
  * @retval None
  */
void HAL_SYSTICK_IRQHandler(void)
{
24001764:	b580      	push	{r7, lr}
24001766:	af00      	add	r7, sp, #0
  HAL_SYSTICK_Callback();
24001768:	f000 f802 	bl	24001770 <HAL_SYSTICK_Callback>
}
2400176c:	bf00      	nop
2400176e:	bd80      	pop	{r7, pc}

24001770 <HAL_SYSTICK_Callback>:
/**
  * @brief  SYSTICK callback.
  * @retval None
  */
__weak void HAL_SYSTICK_Callback(void)
{
24001770:	b480      	push	{r7}
24001772:	af00      	add	r7, sp, #0
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_SYSTICK_Callback could be implemented in the user file
   */
}
24001774:	bf00      	nop
24001776:	46bd      	mov	sp, r7
24001778:	f85d 7b04 	ldr.w	r7, [sp], #4
2400177c:	4770      	bx	lr

2400177e <HAL_GetCurrentCPUID>:
/**
* @brief  Returns the current CPU ID.
* @retval CPU identifier
*/
uint32_t HAL_GetCurrentCPUID(void)
{
2400177e:	b480      	push	{r7}
24001780:	af00      	add	r7, sp, #0
  return  CM7_CPUID;
24001782:	2303      	movs	r3, #3
}
24001784:	4618      	mov	r0, r3
24001786:	46bd      	mov	sp, r7
24001788:	f85d 7b04 	ldr.w	r7, [sp], #4
2400178c:	4770      	bx	lr
	...

24001790 <HAL_DMA_Init>:
  * @param  hdma: Pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Stream.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Init(DMA_HandleTypeDef *hdma)
{
24001790:	b580      	push	{r7, lr}
24001792:	b086      	sub	sp, #24
24001794:	af00      	add	r7, sp, #0
24001796:	6078      	str	r0, [r7, #4]
  uint32_t registerValue;
  uint32_t tickstart = HAL_GetTick();
24001798:	f7ff f85c 	bl	24000854 <HAL_GetTick>
2400179c:	6138      	str	r0, [r7, #16]
  DMA_Base_Registers *regs_dma;
  BDMA_Base_Registers *regs_bdma;

  /* Check the DMA peripheral handle */
  if(hdma == NULL)
2400179e:	687b      	ldr	r3, [r7, #4]
240017a0:	2b00      	cmp	r3, #0
240017a2:	d101      	bne.n	240017a8 <HAL_DMA_Init+0x18>
  {
    return HAL_ERROR;
240017a4:	2301      	movs	r3, #1
240017a6:	e316      	b.n	24001dd6 <HAL_DMA_Init+0x646>
  assert_param(IS_DMA_PERIPHERAL_DATA_SIZE(hdma->Init.PeriphDataAlignment));
  assert_param(IS_DMA_MEMORY_DATA_SIZE(hdma->Init.MemDataAlignment));
  assert_param(IS_DMA_MODE(hdma->Init.Mode));
  assert_param(IS_DMA_PRIORITY(hdma->Init.Priority));

  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
240017a8:	687b      	ldr	r3, [r7, #4]
240017aa:	681b      	ldr	r3, [r3, #0]
240017ac:	4a66      	ldr	r2, [pc, #408]	; (24001948 <HAL_DMA_Init+0x1b8>)
240017ae:	4293      	cmp	r3, r2
240017b0:	d04a      	beq.n	24001848 <HAL_DMA_Init+0xb8>
240017b2:	687b      	ldr	r3, [r7, #4]
240017b4:	681b      	ldr	r3, [r3, #0]
240017b6:	4a65      	ldr	r2, [pc, #404]	; (2400194c <HAL_DMA_Init+0x1bc>)
240017b8:	4293      	cmp	r3, r2
240017ba:	d045      	beq.n	24001848 <HAL_DMA_Init+0xb8>
240017bc:	687b      	ldr	r3, [r7, #4]
240017be:	681b      	ldr	r3, [r3, #0]
240017c0:	4a63      	ldr	r2, [pc, #396]	; (24001950 <HAL_DMA_Init+0x1c0>)
240017c2:	4293      	cmp	r3, r2
240017c4:	d040      	beq.n	24001848 <HAL_DMA_Init+0xb8>
240017c6:	687b      	ldr	r3, [r7, #4]
240017c8:	681b      	ldr	r3, [r3, #0]
240017ca:	4a62      	ldr	r2, [pc, #392]	; (24001954 <HAL_DMA_Init+0x1c4>)
240017cc:	4293      	cmp	r3, r2
240017ce:	d03b      	beq.n	24001848 <HAL_DMA_Init+0xb8>
240017d0:	687b      	ldr	r3, [r7, #4]
240017d2:	681b      	ldr	r3, [r3, #0]
240017d4:	4a60      	ldr	r2, [pc, #384]	; (24001958 <HAL_DMA_Init+0x1c8>)
240017d6:	4293      	cmp	r3, r2
240017d8:	d036      	beq.n	24001848 <HAL_DMA_Init+0xb8>
240017da:	687b      	ldr	r3, [r7, #4]
240017dc:	681b      	ldr	r3, [r3, #0]
240017de:	4a5f      	ldr	r2, [pc, #380]	; (2400195c <HAL_DMA_Init+0x1cc>)
240017e0:	4293      	cmp	r3, r2
240017e2:	d031      	beq.n	24001848 <HAL_DMA_Init+0xb8>
240017e4:	687b      	ldr	r3, [r7, #4]
240017e6:	681b      	ldr	r3, [r3, #0]
240017e8:	4a5d      	ldr	r2, [pc, #372]	; (24001960 <HAL_DMA_Init+0x1d0>)
240017ea:	4293      	cmp	r3, r2
240017ec:	d02c      	beq.n	24001848 <HAL_DMA_Init+0xb8>
240017ee:	687b      	ldr	r3, [r7, #4]
240017f0:	681b      	ldr	r3, [r3, #0]
240017f2:	4a5c      	ldr	r2, [pc, #368]	; (24001964 <HAL_DMA_Init+0x1d4>)
240017f4:	4293      	cmp	r3, r2
240017f6:	d027      	beq.n	24001848 <HAL_DMA_Init+0xb8>
240017f8:	687b      	ldr	r3, [r7, #4]
240017fa:	681b      	ldr	r3, [r3, #0]
240017fc:	4a5a      	ldr	r2, [pc, #360]	; (24001968 <HAL_DMA_Init+0x1d8>)
240017fe:	4293      	cmp	r3, r2
24001800:	d022      	beq.n	24001848 <HAL_DMA_Init+0xb8>
24001802:	687b      	ldr	r3, [r7, #4]
24001804:	681b      	ldr	r3, [r3, #0]
24001806:	4a59      	ldr	r2, [pc, #356]	; (2400196c <HAL_DMA_Init+0x1dc>)
24001808:	4293      	cmp	r3, r2
2400180a:	d01d      	beq.n	24001848 <HAL_DMA_Init+0xb8>
2400180c:	687b      	ldr	r3, [r7, #4]
2400180e:	681b      	ldr	r3, [r3, #0]
24001810:	4a57      	ldr	r2, [pc, #348]	; (24001970 <HAL_DMA_Init+0x1e0>)
24001812:	4293      	cmp	r3, r2
24001814:	d018      	beq.n	24001848 <HAL_DMA_Init+0xb8>
24001816:	687b      	ldr	r3, [r7, #4]
24001818:	681b      	ldr	r3, [r3, #0]
2400181a:	4a56      	ldr	r2, [pc, #344]	; (24001974 <HAL_DMA_Init+0x1e4>)
2400181c:	4293      	cmp	r3, r2
2400181e:	d013      	beq.n	24001848 <HAL_DMA_Init+0xb8>
24001820:	687b      	ldr	r3, [r7, #4]
24001822:	681b      	ldr	r3, [r3, #0]
24001824:	4a54      	ldr	r2, [pc, #336]	; (24001978 <HAL_DMA_Init+0x1e8>)
24001826:	4293      	cmp	r3, r2
24001828:	d00e      	beq.n	24001848 <HAL_DMA_Init+0xb8>
2400182a:	687b      	ldr	r3, [r7, #4]
2400182c:	681b      	ldr	r3, [r3, #0]
2400182e:	4a53      	ldr	r2, [pc, #332]	; (2400197c <HAL_DMA_Init+0x1ec>)
24001830:	4293      	cmp	r3, r2
24001832:	d009      	beq.n	24001848 <HAL_DMA_Init+0xb8>
24001834:	687b      	ldr	r3, [r7, #4]
24001836:	681b      	ldr	r3, [r3, #0]
24001838:	4a51      	ldr	r2, [pc, #324]	; (24001980 <HAL_DMA_Init+0x1f0>)
2400183a:	4293      	cmp	r3, r2
2400183c:	d004      	beq.n	24001848 <HAL_DMA_Init+0xb8>
2400183e:	687b      	ldr	r3, [r7, #4]
24001840:	681b      	ldr	r3, [r3, #0]
24001842:	4a50      	ldr	r2, [pc, #320]	; (24001984 <HAL_DMA_Init+0x1f4>)
24001844:	4293      	cmp	r3, r2
24001846:	d101      	bne.n	2400184c <HAL_DMA_Init+0xbc>
24001848:	2301      	movs	r3, #1
2400184a:	e000      	b.n	2400184e <HAL_DMA_Init+0xbe>
2400184c:	2300      	movs	r3, #0
2400184e:	2b00      	cmp	r3, #0
24001850:	f000 813b 	beq.w	24001aca <HAL_DMA_Init+0x33a>
      assert_param(IS_DMA_MEMORY_BURST(hdma->Init.MemBurst));
      assert_param(IS_DMA_PERIPHERAL_BURST(hdma->Init.PeriphBurst));
    }

    /* Allocate lock resource */
    __HAL_UNLOCK(hdma);
24001854:	687b      	ldr	r3, [r7, #4]
24001856:	2200      	movs	r2, #0
24001858:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

    /* Change DMA peripheral state */
    hdma->State = HAL_DMA_STATE_BUSY;
2400185c:	687b      	ldr	r3, [r7, #4]
2400185e:	2202      	movs	r2, #2
24001860:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

    /* Disable the peripheral */
    __HAL_DMA_DISABLE(hdma);
24001864:	687b      	ldr	r3, [r7, #4]
24001866:	681b      	ldr	r3, [r3, #0]
24001868:	4a37      	ldr	r2, [pc, #220]	; (24001948 <HAL_DMA_Init+0x1b8>)
2400186a:	4293      	cmp	r3, r2
2400186c:	d04a      	beq.n	24001904 <HAL_DMA_Init+0x174>
2400186e:	687b      	ldr	r3, [r7, #4]
24001870:	681b      	ldr	r3, [r3, #0]
24001872:	4a36      	ldr	r2, [pc, #216]	; (2400194c <HAL_DMA_Init+0x1bc>)
24001874:	4293      	cmp	r3, r2
24001876:	d045      	beq.n	24001904 <HAL_DMA_Init+0x174>
24001878:	687b      	ldr	r3, [r7, #4]
2400187a:	681b      	ldr	r3, [r3, #0]
2400187c:	4a34      	ldr	r2, [pc, #208]	; (24001950 <HAL_DMA_Init+0x1c0>)
2400187e:	4293      	cmp	r3, r2
24001880:	d040      	beq.n	24001904 <HAL_DMA_Init+0x174>
24001882:	687b      	ldr	r3, [r7, #4]
24001884:	681b      	ldr	r3, [r3, #0]
24001886:	4a33      	ldr	r2, [pc, #204]	; (24001954 <HAL_DMA_Init+0x1c4>)
24001888:	4293      	cmp	r3, r2
2400188a:	d03b      	beq.n	24001904 <HAL_DMA_Init+0x174>
2400188c:	687b      	ldr	r3, [r7, #4]
2400188e:	681b      	ldr	r3, [r3, #0]
24001890:	4a31      	ldr	r2, [pc, #196]	; (24001958 <HAL_DMA_Init+0x1c8>)
24001892:	4293      	cmp	r3, r2
24001894:	d036      	beq.n	24001904 <HAL_DMA_Init+0x174>
24001896:	687b      	ldr	r3, [r7, #4]
24001898:	681b      	ldr	r3, [r3, #0]
2400189a:	4a30      	ldr	r2, [pc, #192]	; (2400195c <HAL_DMA_Init+0x1cc>)
2400189c:	4293      	cmp	r3, r2
2400189e:	d031      	beq.n	24001904 <HAL_DMA_Init+0x174>
240018a0:	687b      	ldr	r3, [r7, #4]
240018a2:	681b      	ldr	r3, [r3, #0]
240018a4:	4a2e      	ldr	r2, [pc, #184]	; (24001960 <HAL_DMA_Init+0x1d0>)
240018a6:	4293      	cmp	r3, r2
240018a8:	d02c      	beq.n	24001904 <HAL_DMA_Init+0x174>
240018aa:	687b      	ldr	r3, [r7, #4]
240018ac:	681b      	ldr	r3, [r3, #0]
240018ae:	4a2d      	ldr	r2, [pc, #180]	; (24001964 <HAL_DMA_Init+0x1d4>)
240018b0:	4293      	cmp	r3, r2
240018b2:	d027      	beq.n	24001904 <HAL_DMA_Init+0x174>
240018b4:	687b      	ldr	r3, [r7, #4]
240018b6:	681b      	ldr	r3, [r3, #0]
240018b8:	4a2b      	ldr	r2, [pc, #172]	; (24001968 <HAL_DMA_Init+0x1d8>)
240018ba:	4293      	cmp	r3, r2
240018bc:	d022      	beq.n	24001904 <HAL_DMA_Init+0x174>
240018be:	687b      	ldr	r3, [r7, #4]
240018c0:	681b      	ldr	r3, [r3, #0]
240018c2:	4a2a      	ldr	r2, [pc, #168]	; (2400196c <HAL_DMA_Init+0x1dc>)
240018c4:	4293      	cmp	r3, r2
240018c6:	d01d      	beq.n	24001904 <HAL_DMA_Init+0x174>
240018c8:	687b      	ldr	r3, [r7, #4]
240018ca:	681b      	ldr	r3, [r3, #0]
240018cc:	4a28      	ldr	r2, [pc, #160]	; (24001970 <HAL_DMA_Init+0x1e0>)
240018ce:	4293      	cmp	r3, r2
240018d0:	d018      	beq.n	24001904 <HAL_DMA_Init+0x174>
240018d2:	687b      	ldr	r3, [r7, #4]
240018d4:	681b      	ldr	r3, [r3, #0]
240018d6:	4a27      	ldr	r2, [pc, #156]	; (24001974 <HAL_DMA_Init+0x1e4>)
240018d8:	4293      	cmp	r3, r2
240018da:	d013      	beq.n	24001904 <HAL_DMA_Init+0x174>
240018dc:	687b      	ldr	r3, [r7, #4]
240018de:	681b      	ldr	r3, [r3, #0]
240018e0:	4a25      	ldr	r2, [pc, #148]	; (24001978 <HAL_DMA_Init+0x1e8>)
240018e2:	4293      	cmp	r3, r2
240018e4:	d00e      	beq.n	24001904 <HAL_DMA_Init+0x174>
240018e6:	687b      	ldr	r3, [r7, #4]
240018e8:	681b      	ldr	r3, [r3, #0]
240018ea:	4a24      	ldr	r2, [pc, #144]	; (2400197c <HAL_DMA_Init+0x1ec>)
240018ec:	4293      	cmp	r3, r2
240018ee:	d009      	beq.n	24001904 <HAL_DMA_Init+0x174>
240018f0:	687b      	ldr	r3, [r7, #4]
240018f2:	681b      	ldr	r3, [r3, #0]
240018f4:	4a22      	ldr	r2, [pc, #136]	; (24001980 <HAL_DMA_Init+0x1f0>)
240018f6:	4293      	cmp	r3, r2
240018f8:	d004      	beq.n	24001904 <HAL_DMA_Init+0x174>
240018fa:	687b      	ldr	r3, [r7, #4]
240018fc:	681b      	ldr	r3, [r3, #0]
240018fe:	4a21      	ldr	r2, [pc, #132]	; (24001984 <HAL_DMA_Init+0x1f4>)
24001900:	4293      	cmp	r3, r2
24001902:	d108      	bne.n	24001916 <HAL_DMA_Init+0x186>
24001904:	687b      	ldr	r3, [r7, #4]
24001906:	681b      	ldr	r3, [r3, #0]
24001908:	681a      	ldr	r2, [r3, #0]
2400190a:	687b      	ldr	r3, [r7, #4]
2400190c:	681b      	ldr	r3, [r3, #0]
2400190e:	f022 0201 	bic.w	r2, r2, #1
24001912:	601a      	str	r2, [r3, #0]
24001914:	e007      	b.n	24001926 <HAL_DMA_Init+0x196>
24001916:	687b      	ldr	r3, [r7, #4]
24001918:	681b      	ldr	r3, [r3, #0]
2400191a:	681a      	ldr	r2, [r3, #0]
2400191c:	687b      	ldr	r3, [r7, #4]
2400191e:	681b      	ldr	r3, [r3, #0]
24001920:	f022 0201 	bic.w	r2, r2, #1
24001924:	601a      	str	r2, [r3, #0]

    /* Check if the DMA Stream is effectively disabled */
    while((((DMA_Stream_TypeDef   *)hdma->Instance)->CR & DMA_SxCR_EN) != 0U)
24001926:	e02f      	b.n	24001988 <HAL_DMA_Init+0x1f8>
    {
      /* Check for the Timeout */
      if((HAL_GetTick() - tickstart ) > HAL_TIMEOUT_DMA_ABORT)
24001928:	f7fe ff94 	bl	24000854 <HAL_GetTick>
2400192c:	4602      	mov	r2, r0
2400192e:	693b      	ldr	r3, [r7, #16]
24001930:	1ad3      	subs	r3, r2, r3
24001932:	2b05      	cmp	r3, #5
24001934:	d928      	bls.n	24001988 <HAL_DMA_Init+0x1f8>
      {
        /* Update error code */
        hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
24001936:	687b      	ldr	r3, [r7, #4]
24001938:	2220      	movs	r2, #32
2400193a:	655a      	str	r2, [r3, #84]	; 0x54

        /* Change the DMA state */
        hdma->State = HAL_DMA_STATE_ERROR;
2400193c:	687b      	ldr	r3, [r7, #4]
2400193e:	2203      	movs	r2, #3
24001940:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

        return HAL_ERROR;
24001944:	2301      	movs	r3, #1
24001946:	e246      	b.n	24001dd6 <HAL_DMA_Init+0x646>
24001948:	40020010 	.word	0x40020010
2400194c:	40020028 	.word	0x40020028
24001950:	40020040 	.word	0x40020040
24001954:	40020058 	.word	0x40020058
24001958:	40020070 	.word	0x40020070
2400195c:	40020088 	.word	0x40020088
24001960:	400200a0 	.word	0x400200a0
24001964:	400200b8 	.word	0x400200b8
24001968:	40020410 	.word	0x40020410
2400196c:	40020428 	.word	0x40020428
24001970:	40020440 	.word	0x40020440
24001974:	40020458 	.word	0x40020458
24001978:	40020470 	.word	0x40020470
2400197c:	40020488 	.word	0x40020488
24001980:	400204a0 	.word	0x400204a0
24001984:	400204b8 	.word	0x400204b8
    while((((DMA_Stream_TypeDef   *)hdma->Instance)->CR & DMA_SxCR_EN) != 0U)
24001988:	687b      	ldr	r3, [r7, #4]
2400198a:	681b      	ldr	r3, [r3, #0]
2400198c:	681b      	ldr	r3, [r3, #0]
2400198e:	f003 0301 	and.w	r3, r3, #1
24001992:	2b00      	cmp	r3, #0
24001994:	d1c8      	bne.n	24001928 <HAL_DMA_Init+0x198>
      }
    }

    /* Get the CR register value */
    registerValue = ((DMA_Stream_TypeDef   *)hdma->Instance)->CR;
24001996:	687b      	ldr	r3, [r7, #4]
24001998:	681b      	ldr	r3, [r3, #0]
2400199a:	681b      	ldr	r3, [r3, #0]
2400199c:	617b      	str	r3, [r7, #20]

    /* Clear CHSEL, MBURST, PBURST, PL, MSIZE, PSIZE, MINC, PINC, CIRC, DIR, CT and DBM bits */
    registerValue &= ((uint32_t)~(DMA_SxCR_MBURST | DMA_SxCR_PBURST | \
2400199e:	697a      	ldr	r2, [r7, #20]
240019a0:	4b83      	ldr	r3, [pc, #524]	; (24001bb0 <HAL_DMA_Init+0x420>)
240019a2:	4013      	ands	r3, r2
240019a4:	617b      	str	r3, [r7, #20]
                        DMA_SxCR_PL    | DMA_SxCR_MSIZE  | DMA_SxCR_PSIZE  | \
                        DMA_SxCR_MINC  | DMA_SxCR_PINC   | DMA_SxCR_CIRC   | \
                        DMA_SxCR_DIR   | DMA_SxCR_CT     | DMA_SxCR_DBM));

    /* Prepare the DMA Stream configuration */
    registerValue |=  hdma->Init.Direction           |
240019a6:	687b      	ldr	r3, [r7, #4]
240019a8:	689a      	ldr	r2, [r3, #8]
            hdma->Init.PeriphInc           | hdma->Init.MemInc           |
240019aa:	687b      	ldr	r3, [r7, #4]
240019ac:	68db      	ldr	r3, [r3, #12]
    registerValue |=  hdma->Init.Direction           |
240019ae:	431a      	orrs	r2, r3
            hdma->Init.PeriphInc           | hdma->Init.MemInc           |
240019b0:	687b      	ldr	r3, [r7, #4]
240019b2:	691b      	ldr	r3, [r3, #16]
240019b4:	431a      	orrs	r2, r3
            hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
240019b6:	687b      	ldr	r3, [r7, #4]
240019b8:	695b      	ldr	r3, [r3, #20]
            hdma->Init.PeriphInc           | hdma->Init.MemInc           |
240019ba:	431a      	orrs	r2, r3
            hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
240019bc:	687b      	ldr	r3, [r7, #4]
240019be:	699b      	ldr	r3, [r3, #24]
240019c0:	431a      	orrs	r2, r3
            hdma->Init.Mode                | hdma->Init.Priority;
240019c2:	687b      	ldr	r3, [r7, #4]
240019c4:	69db      	ldr	r3, [r3, #28]
            hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
240019c6:	431a      	orrs	r2, r3
            hdma->Init.Mode                | hdma->Init.Priority;
240019c8:	687b      	ldr	r3, [r7, #4]
240019ca:	6a1b      	ldr	r3, [r3, #32]
240019cc:	4313      	orrs	r3, r2
    registerValue |=  hdma->Init.Direction           |
240019ce:	697a      	ldr	r2, [r7, #20]
240019d0:	4313      	orrs	r3, r2
240019d2:	617b      	str	r3, [r7, #20]

    /* the Memory burst and peripheral burst are not used when the FIFO is disabled */
    if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
240019d4:	687b      	ldr	r3, [r7, #4]
240019d6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
240019d8:	2b04      	cmp	r3, #4
240019da:	d107      	bne.n	240019ec <HAL_DMA_Init+0x25c>
    {
      /* Get memory burst and peripheral burst */
      registerValue |=  hdma->Init.MemBurst | hdma->Init.PeriphBurst;
240019dc:	687b      	ldr	r3, [r7, #4]
240019de:	6ada      	ldr	r2, [r3, #44]	; 0x2c
240019e0:	687b      	ldr	r3, [r7, #4]
240019e2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
240019e4:	4313      	orrs	r3, r2
240019e6:	697a      	ldr	r2, [r7, #20]
240019e8:	4313      	orrs	r3, r2
240019ea:	617b      	str	r3, [r7, #20]
    }

    /* Work around for Errata 2.22: UART/USART- DMA transfer lock: DMA stream could be
                                    lock when transfering data to/from USART/UART */
#if (STM32H7_DEV_ID == 0x450UL)
    if((DBGMCU->IDCODE & 0xFFFF0000U) >= 0x20000000U)
240019ec:	4b71      	ldr	r3, [pc, #452]	; (24001bb4 <HAL_DMA_Init+0x424>)
240019ee:	681a      	ldr	r2, [r3, #0]
240019f0:	4b71      	ldr	r3, [pc, #452]	; (24001bb8 <HAL_DMA_Init+0x428>)
240019f2:	4013      	ands	r3, r2
240019f4:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
240019f8:	d328      	bcc.n	24001a4c <HAL_DMA_Init+0x2bc>
    {
#endif /* STM32H7_DEV_ID == 0x450UL */
      if(IS_DMA_UART_USART_REQUEST(hdma->Init.Request) != 0U)
240019fa:	687b      	ldr	r3, [r7, #4]
240019fc:	685b      	ldr	r3, [r3, #4]
240019fe:	2b28      	cmp	r3, #40	; 0x28
24001a00:	d903      	bls.n	24001a0a <HAL_DMA_Init+0x27a>
24001a02:	687b      	ldr	r3, [r7, #4]
24001a04:	685b      	ldr	r3, [r3, #4]
24001a06:	2b2e      	cmp	r3, #46	; 0x2e
24001a08:	d917      	bls.n	24001a3a <HAL_DMA_Init+0x2aa>
24001a0a:	687b      	ldr	r3, [r7, #4]
24001a0c:	685b      	ldr	r3, [r3, #4]
24001a0e:	2b3e      	cmp	r3, #62	; 0x3e
24001a10:	d903      	bls.n	24001a1a <HAL_DMA_Init+0x28a>
24001a12:	687b      	ldr	r3, [r7, #4]
24001a14:	685b      	ldr	r3, [r3, #4]
24001a16:	2b42      	cmp	r3, #66	; 0x42
24001a18:	d90f      	bls.n	24001a3a <HAL_DMA_Init+0x2aa>
24001a1a:	687b      	ldr	r3, [r7, #4]
24001a1c:	685b      	ldr	r3, [r3, #4]
24001a1e:	2b46      	cmp	r3, #70	; 0x46
24001a20:	d903      	bls.n	24001a2a <HAL_DMA_Init+0x29a>
24001a22:	687b      	ldr	r3, [r7, #4]
24001a24:	685b      	ldr	r3, [r3, #4]
24001a26:	2b48      	cmp	r3, #72	; 0x48
24001a28:	d907      	bls.n	24001a3a <HAL_DMA_Init+0x2aa>
24001a2a:	687b      	ldr	r3, [r7, #4]
24001a2c:	685b      	ldr	r3, [r3, #4]
24001a2e:	2b4e      	cmp	r3, #78	; 0x4e
24001a30:	d905      	bls.n	24001a3e <HAL_DMA_Init+0x2ae>
24001a32:	687b      	ldr	r3, [r7, #4]
24001a34:	685b      	ldr	r3, [r3, #4]
24001a36:	2b52      	cmp	r3, #82	; 0x52
24001a38:	d801      	bhi.n	24001a3e <HAL_DMA_Init+0x2ae>
24001a3a:	2301      	movs	r3, #1
24001a3c:	e000      	b.n	24001a40 <HAL_DMA_Init+0x2b0>
24001a3e:	2300      	movs	r3, #0
24001a40:	2b00      	cmp	r3, #0
24001a42:	d003      	beq.n	24001a4c <HAL_DMA_Init+0x2bc>
      {
        registerValue |= DMA_SxCR_TRBUFF;
24001a44:	697b      	ldr	r3, [r7, #20]
24001a46:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
24001a4a:	617b      	str	r3, [r7, #20]
#if (STM32H7_DEV_ID == 0x450UL)
    }
#endif /* STM32H7_DEV_ID == 0x450UL */

    /* Write to DMA Stream CR register */
    ((DMA_Stream_TypeDef   *)hdma->Instance)->CR = registerValue;
24001a4c:	687b      	ldr	r3, [r7, #4]
24001a4e:	681b      	ldr	r3, [r3, #0]
24001a50:	697a      	ldr	r2, [r7, #20]
24001a52:	601a      	str	r2, [r3, #0]

    /* Get the FCR register value */
    registerValue = ((DMA_Stream_TypeDef   *)hdma->Instance)->FCR;
24001a54:	687b      	ldr	r3, [r7, #4]
24001a56:	681b      	ldr	r3, [r3, #0]
24001a58:	695b      	ldr	r3, [r3, #20]
24001a5a:	617b      	str	r3, [r7, #20]

    /* Clear Direct mode and FIFO threshold bits */
    registerValue &= (uint32_t)~(DMA_SxFCR_DMDIS | DMA_SxFCR_FTH);
24001a5c:	697b      	ldr	r3, [r7, #20]
24001a5e:	f023 0307 	bic.w	r3, r3, #7
24001a62:	617b      	str	r3, [r7, #20]

    /* Prepare the DMA Stream FIFO configuration */
    registerValue |= hdma->Init.FIFOMode;
24001a64:	687b      	ldr	r3, [r7, #4]
24001a66:	6a5b      	ldr	r3, [r3, #36]	; 0x24
24001a68:	697a      	ldr	r2, [r7, #20]
24001a6a:	4313      	orrs	r3, r2
24001a6c:	617b      	str	r3, [r7, #20]

    /* the FIFO threshold is not used when the FIFO mode is disabled */
    if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
24001a6e:	687b      	ldr	r3, [r7, #4]
24001a70:	6a5b      	ldr	r3, [r3, #36]	; 0x24
24001a72:	2b04      	cmp	r3, #4
24001a74:	d117      	bne.n	24001aa6 <HAL_DMA_Init+0x316>
    {
      /* Get the FIFO threshold */
      registerValue |= hdma->Init.FIFOThreshold;
24001a76:	687b      	ldr	r3, [r7, #4]
24001a78:	6a9b      	ldr	r3, [r3, #40]	; 0x28
24001a7a:	697a      	ldr	r2, [r7, #20]
24001a7c:	4313      	orrs	r3, r2
24001a7e:	617b      	str	r3, [r7, #20]

      /* Check compatibility between FIFO threshold level and size of the memory burst */
      /* for INCR4, INCR8, INCR16 */
      if(hdma->Init.MemBurst != DMA_MBURST_SINGLE)
24001a80:	687b      	ldr	r3, [r7, #4]
24001a82:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24001a84:	2b00      	cmp	r3, #0
24001a86:	d00e      	beq.n	24001aa6 <HAL_DMA_Init+0x316>
      {
        if (DMA_CheckFifoParam(hdma) != HAL_OK)
24001a88:	6878      	ldr	r0, [r7, #4]
24001a8a:	f003 fb41 	bl	24005110 <DMA_CheckFifoParam>
24001a8e:	4603      	mov	r3, r0
24001a90:	2b00      	cmp	r3, #0
24001a92:	d008      	beq.n	24001aa6 <HAL_DMA_Init+0x316>
        {
          /* Update error code */
          hdma->ErrorCode = HAL_DMA_ERROR_PARAM;
24001a94:	687b      	ldr	r3, [r7, #4]
24001a96:	2240      	movs	r2, #64	; 0x40
24001a98:	655a      	str	r2, [r3, #84]	; 0x54

          /* Change the DMA state */
          hdma->State = HAL_DMA_STATE_READY;
24001a9a:	687b      	ldr	r3, [r7, #4]
24001a9c:	2201      	movs	r2, #1
24001a9e:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

          return HAL_ERROR;
24001aa2:	2301      	movs	r3, #1
24001aa4:	e197      	b.n	24001dd6 <HAL_DMA_Init+0x646>
        }
      }
    }

    /* Write to DMA Stream FCR */
    ((DMA_Stream_TypeDef   *)hdma->Instance)->FCR = registerValue;
24001aa6:	687b      	ldr	r3, [r7, #4]
24001aa8:	681b      	ldr	r3, [r3, #0]
24001aaa:	697a      	ldr	r2, [r7, #20]
24001aac:	615a      	str	r2, [r3, #20]

    /* Initialize StreamBaseAddress and StreamIndex parameters to be used to calculate
       DMA steam Base Address needed by HAL_DMA_IRQHandler() and HAL_DMA_PollForTransfer() */
    regs_dma = (DMA_Base_Registers *)DMA_CalcBaseAndBitshift(hdma);
24001aae:	6878      	ldr	r0, [r7, #4]
24001ab0:	f003 fa7c 	bl	24004fac <DMA_CalcBaseAndBitshift>
24001ab4:	4603      	mov	r3, r0
24001ab6:	60bb      	str	r3, [r7, #8]

    /* Clear all interrupt flags */
    regs_dma->IFCR = 0x3FUL << (hdma->StreamIndex & 0x1FU);
24001ab8:	687b      	ldr	r3, [r7, #4]
24001aba:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
24001abc:	f003 031f 	and.w	r3, r3, #31
24001ac0:	223f      	movs	r2, #63	; 0x3f
24001ac2:	409a      	lsls	r2, r3
24001ac4:	68bb      	ldr	r3, [r7, #8]
24001ac6:	609a      	str	r2, [r3, #8]
24001ac8:	e0cd      	b.n	24001c66 <HAL_DMA_Init+0x4d6>
  }
  else if(IS_BDMA_CHANNEL_INSTANCE(hdma->Instance) != 0U) /* BDMA instance(s) */
24001aca:	687b      	ldr	r3, [r7, #4]
24001acc:	681b      	ldr	r3, [r3, #0]
24001ace:	4a3b      	ldr	r2, [pc, #236]	; (24001bbc <HAL_DMA_Init+0x42c>)
24001ad0:	4293      	cmp	r3, r2
24001ad2:	d022      	beq.n	24001b1a <HAL_DMA_Init+0x38a>
24001ad4:	687b      	ldr	r3, [r7, #4]
24001ad6:	681b      	ldr	r3, [r3, #0]
24001ad8:	4a39      	ldr	r2, [pc, #228]	; (24001bc0 <HAL_DMA_Init+0x430>)
24001ada:	4293      	cmp	r3, r2
24001adc:	d01d      	beq.n	24001b1a <HAL_DMA_Init+0x38a>
24001ade:	687b      	ldr	r3, [r7, #4]
24001ae0:	681b      	ldr	r3, [r3, #0]
24001ae2:	4a38      	ldr	r2, [pc, #224]	; (24001bc4 <HAL_DMA_Init+0x434>)
24001ae4:	4293      	cmp	r3, r2
24001ae6:	d018      	beq.n	24001b1a <HAL_DMA_Init+0x38a>
24001ae8:	687b      	ldr	r3, [r7, #4]
24001aea:	681b      	ldr	r3, [r3, #0]
24001aec:	4a36      	ldr	r2, [pc, #216]	; (24001bc8 <HAL_DMA_Init+0x438>)
24001aee:	4293      	cmp	r3, r2
24001af0:	d013      	beq.n	24001b1a <HAL_DMA_Init+0x38a>
24001af2:	687b      	ldr	r3, [r7, #4]
24001af4:	681b      	ldr	r3, [r3, #0]
24001af6:	4a35      	ldr	r2, [pc, #212]	; (24001bcc <HAL_DMA_Init+0x43c>)
24001af8:	4293      	cmp	r3, r2
24001afa:	d00e      	beq.n	24001b1a <HAL_DMA_Init+0x38a>
24001afc:	687b      	ldr	r3, [r7, #4]
24001afe:	681b      	ldr	r3, [r3, #0]
24001b00:	4a33      	ldr	r2, [pc, #204]	; (24001bd0 <HAL_DMA_Init+0x440>)
24001b02:	4293      	cmp	r3, r2
24001b04:	d009      	beq.n	24001b1a <HAL_DMA_Init+0x38a>
24001b06:	687b      	ldr	r3, [r7, #4]
24001b08:	681b      	ldr	r3, [r3, #0]
24001b0a:	4a32      	ldr	r2, [pc, #200]	; (24001bd4 <HAL_DMA_Init+0x444>)
24001b0c:	4293      	cmp	r3, r2
24001b0e:	d004      	beq.n	24001b1a <HAL_DMA_Init+0x38a>
24001b10:	687b      	ldr	r3, [r7, #4]
24001b12:	681b      	ldr	r3, [r3, #0]
24001b14:	4a30      	ldr	r2, [pc, #192]	; (24001bd8 <HAL_DMA_Init+0x448>)
24001b16:	4293      	cmp	r3, r2
24001b18:	d101      	bne.n	24001b1e <HAL_DMA_Init+0x38e>
24001b1a:	2301      	movs	r3, #1
24001b1c:	e000      	b.n	24001b20 <HAL_DMA_Init+0x390>
24001b1e:	2300      	movs	r3, #0
24001b20:	2b00      	cmp	r3, #0
24001b22:	f000 8097 	beq.w	24001c54 <HAL_DMA_Init+0x4c4>
  {
    if(IS_BDMA_CHANNEL_DMAMUX_INSTANCE(hdma->Instance) != 0U)
24001b26:	687b      	ldr	r3, [r7, #4]
24001b28:	681b      	ldr	r3, [r3, #0]
24001b2a:	4a24      	ldr	r2, [pc, #144]	; (24001bbc <HAL_DMA_Init+0x42c>)
24001b2c:	4293      	cmp	r3, r2
24001b2e:	d021      	beq.n	24001b74 <HAL_DMA_Init+0x3e4>
24001b30:	687b      	ldr	r3, [r7, #4]
24001b32:	681b      	ldr	r3, [r3, #0]
24001b34:	4a22      	ldr	r2, [pc, #136]	; (24001bc0 <HAL_DMA_Init+0x430>)
24001b36:	4293      	cmp	r3, r2
24001b38:	d01c      	beq.n	24001b74 <HAL_DMA_Init+0x3e4>
24001b3a:	687b      	ldr	r3, [r7, #4]
24001b3c:	681b      	ldr	r3, [r3, #0]
24001b3e:	4a21      	ldr	r2, [pc, #132]	; (24001bc4 <HAL_DMA_Init+0x434>)
24001b40:	4293      	cmp	r3, r2
24001b42:	d017      	beq.n	24001b74 <HAL_DMA_Init+0x3e4>
24001b44:	687b      	ldr	r3, [r7, #4]
24001b46:	681b      	ldr	r3, [r3, #0]
24001b48:	4a1f      	ldr	r2, [pc, #124]	; (24001bc8 <HAL_DMA_Init+0x438>)
24001b4a:	4293      	cmp	r3, r2
24001b4c:	d012      	beq.n	24001b74 <HAL_DMA_Init+0x3e4>
24001b4e:	687b      	ldr	r3, [r7, #4]
24001b50:	681b      	ldr	r3, [r3, #0]
24001b52:	4a1e      	ldr	r2, [pc, #120]	; (24001bcc <HAL_DMA_Init+0x43c>)
24001b54:	4293      	cmp	r3, r2
24001b56:	d00d      	beq.n	24001b74 <HAL_DMA_Init+0x3e4>
24001b58:	687b      	ldr	r3, [r7, #4]
24001b5a:	681b      	ldr	r3, [r3, #0]
24001b5c:	4a1c      	ldr	r2, [pc, #112]	; (24001bd0 <HAL_DMA_Init+0x440>)
24001b5e:	4293      	cmp	r3, r2
24001b60:	d008      	beq.n	24001b74 <HAL_DMA_Init+0x3e4>
24001b62:	687b      	ldr	r3, [r7, #4]
24001b64:	681b      	ldr	r3, [r3, #0]
24001b66:	4a1b      	ldr	r2, [pc, #108]	; (24001bd4 <HAL_DMA_Init+0x444>)
24001b68:	4293      	cmp	r3, r2
24001b6a:	d003      	beq.n	24001b74 <HAL_DMA_Init+0x3e4>
24001b6c:	687b      	ldr	r3, [r7, #4]
24001b6e:	681b      	ldr	r3, [r3, #0]
24001b70:	4a19      	ldr	r2, [pc, #100]	; (24001bd8 <HAL_DMA_Init+0x448>)
24001b72:	4293      	cmp	r3, r2
24001b74:	bf00      	nop
      /* Check the request parameter */
      assert_param(IS_BDMA_REQUEST(hdma->Init.Request));
    }

    /* Allocate lock resource */
    __HAL_UNLOCK(hdma);
24001b76:	687b      	ldr	r3, [r7, #4]
24001b78:	2200      	movs	r2, #0
24001b7a:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

    /* Change DMA peripheral state */
    hdma->State = HAL_DMA_STATE_BUSY;
24001b7e:	687b      	ldr	r3, [r7, #4]
24001b80:	2202      	movs	r2, #2
24001b82:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

    /* Get the CR register value */
    registerValue = ((BDMA_Channel_TypeDef *)hdma->Instance)->CCR;
24001b86:	687b      	ldr	r3, [r7, #4]
24001b88:	681b      	ldr	r3, [r3, #0]
24001b8a:	681b      	ldr	r3, [r3, #0]
24001b8c:	617b      	str	r3, [r7, #20]

    /* Clear PL, MSIZE, PSIZE, MINC, PINC, CIRC, DIR, MEM2MEM, DBM and CT bits */
    registerValue &= ((uint32_t)~(BDMA_CCR_PL    | BDMA_CCR_MSIZE   | BDMA_CCR_PSIZE  | \
24001b8e:	697a      	ldr	r2, [r7, #20]
24001b90:	4b12      	ldr	r3, [pc, #72]	; (24001bdc <HAL_DMA_Init+0x44c>)
24001b92:	4013      	ands	r3, r2
24001b94:	617b      	str	r3, [r7, #20]
                                  BDMA_CCR_MINC  | BDMA_CCR_PINC    | BDMA_CCR_CIRC   | \
                                  BDMA_CCR_DIR   | BDMA_CCR_MEM2MEM | BDMA_CCR_DBM    | \
                                  BDMA_CCR_CT));

    /* Prepare the DMA Channel configuration */
    registerValue |=  DMA_TO_BDMA_DIRECTION(hdma->Init.Direction)            |
24001b96:	687b      	ldr	r3, [r7, #4]
24001b98:	689b      	ldr	r3, [r3, #8]
24001b9a:	2b40      	cmp	r3, #64	; 0x40
24001b9c:	d020      	beq.n	24001be0 <HAL_DMA_Init+0x450>
24001b9e:	687b      	ldr	r3, [r7, #4]
24001ba0:	689b      	ldr	r3, [r3, #8]
24001ba2:	2b80      	cmp	r3, #128	; 0x80
24001ba4:	d102      	bne.n	24001bac <HAL_DMA_Init+0x41c>
24001ba6:	f44f 4380 	mov.w	r3, #16384	; 0x4000
24001baa:	e01a      	b.n	24001be2 <HAL_DMA_Init+0x452>
24001bac:	2300      	movs	r3, #0
24001bae:	e018      	b.n	24001be2 <HAL_DMA_Init+0x452>
24001bb0:	fe10803f 	.word	0xfe10803f
24001bb4:	5c001000 	.word	0x5c001000
24001bb8:	ffff0000 	.word	0xffff0000
24001bbc:	58025408 	.word	0x58025408
24001bc0:	5802541c 	.word	0x5802541c
24001bc4:	58025430 	.word	0x58025430
24001bc8:	58025444 	.word	0x58025444
24001bcc:	58025458 	.word	0x58025458
24001bd0:	5802546c 	.word	0x5802546c
24001bd4:	58025480 	.word	0x58025480
24001bd8:	58025494 	.word	0x58025494
24001bdc:	fffe000f 	.word	0xfffe000f
24001be0:	2310      	movs	r3, #16
                      DMA_TO_BDMA_PERIPHERAL_INC(hdma->Init.PeriphInc)       |
24001be2:	687a      	ldr	r2, [r7, #4]
24001be4:	68d2      	ldr	r2, [r2, #12]
24001be6:	08d2      	lsrs	r2, r2, #3
    registerValue |=  DMA_TO_BDMA_DIRECTION(hdma->Init.Direction)            |
24001be8:	431a      	orrs	r2, r3
                      DMA_TO_BDMA_MEMORY_INC(hdma->Init.MemInc)              |
24001bea:	687b      	ldr	r3, [r7, #4]
24001bec:	691b      	ldr	r3, [r3, #16]
24001bee:	08db      	lsrs	r3, r3, #3
                      DMA_TO_BDMA_PERIPHERAL_INC(hdma->Init.PeriphInc)       |
24001bf0:	431a      	orrs	r2, r3
                      DMA_TO_BDMA_PDATA_SIZE(hdma->Init.PeriphDataAlignment) |
24001bf2:	687b      	ldr	r3, [r7, #4]
24001bf4:	695b      	ldr	r3, [r3, #20]
24001bf6:	08db      	lsrs	r3, r3, #3
                      DMA_TO_BDMA_MEMORY_INC(hdma->Init.MemInc)              |
24001bf8:	431a      	orrs	r2, r3
                      DMA_TO_BDMA_MDATA_SIZE(hdma->Init.MemDataAlignment)    |
24001bfa:	687b      	ldr	r3, [r7, #4]
24001bfc:	699b      	ldr	r3, [r3, #24]
24001bfe:	08db      	lsrs	r3, r3, #3
                      DMA_TO_BDMA_PDATA_SIZE(hdma->Init.PeriphDataAlignment) |
24001c00:	431a      	orrs	r2, r3
                      DMA_TO_BDMA_MODE(hdma->Init.Mode)                      |
24001c02:	687b      	ldr	r3, [r7, #4]
24001c04:	69db      	ldr	r3, [r3, #28]
24001c06:	08db      	lsrs	r3, r3, #3
                      DMA_TO_BDMA_MDATA_SIZE(hdma->Init.MemDataAlignment)    |
24001c08:	431a      	orrs	r2, r3
                      DMA_TO_BDMA_PRIORITY(hdma->Init.Priority);
24001c0a:	687b      	ldr	r3, [r7, #4]
24001c0c:	6a1b      	ldr	r3, [r3, #32]
24001c0e:	091b      	lsrs	r3, r3, #4
                      DMA_TO_BDMA_MODE(hdma->Init.Mode)                      |
24001c10:	4313      	orrs	r3, r2
    registerValue |=  DMA_TO_BDMA_DIRECTION(hdma->Init.Direction)            |
24001c12:	697a      	ldr	r2, [r7, #20]
24001c14:	4313      	orrs	r3, r2
24001c16:	617b      	str	r3, [r7, #20]

    /* Write to DMA Channel CR register */
    ((BDMA_Channel_TypeDef *)hdma->Instance)->CCR = registerValue;
24001c18:	687b      	ldr	r3, [r7, #4]
24001c1a:	681b      	ldr	r3, [r3, #0]
24001c1c:	697a      	ldr	r2, [r7, #20]
24001c1e:	601a      	str	r2, [r3, #0]

    /* calculation of the channel index */
    hdma->StreamIndex = (((uint32_t)((uint32_t*)hdma->Instance) - (uint32_t)BDMA_Channel0) / ((uint32_t)BDMA_Channel1 - (uint32_t)BDMA_Channel0)) << 2U;
24001c20:	687b      	ldr	r3, [r7, #4]
24001c22:	681b      	ldr	r3, [r3, #0]
24001c24:	461a      	mov	r2, r3
24001c26:	4b6e      	ldr	r3, [pc, #440]	; (24001de0 <HAL_DMA_Init+0x650>)
24001c28:	4413      	add	r3, r2
24001c2a:	4a6e      	ldr	r2, [pc, #440]	; (24001de4 <HAL_DMA_Init+0x654>)
24001c2c:	fba2 2303 	umull	r2, r3, r2, r3
24001c30:	091b      	lsrs	r3, r3, #4
24001c32:	009a      	lsls	r2, r3, #2
24001c34:	687b      	ldr	r3, [r7, #4]
24001c36:	65da      	str	r2, [r3, #92]	; 0x5c

    /* Initialize StreamBaseAddress and StreamIndex parameters to be used to calculate
    DMA steam Base Address needed by HAL_DMA_IRQHandler() and HAL_DMA_PollForTransfer() */
    regs_bdma = (BDMA_Base_Registers *)DMA_CalcBaseAndBitshift(hdma);
24001c38:	6878      	ldr	r0, [r7, #4]
24001c3a:	f003 f9b7 	bl	24004fac <DMA_CalcBaseAndBitshift>
24001c3e:	4603      	mov	r3, r0
24001c40:	60fb      	str	r3, [r7, #12]

    /* Clear all interrupt flags */
    regs_bdma->IFCR = ((BDMA_IFCR_CGIF0) << (hdma->StreamIndex & 0x1FU));
24001c42:	687b      	ldr	r3, [r7, #4]
24001c44:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
24001c46:	f003 031f 	and.w	r3, r3, #31
24001c4a:	2201      	movs	r2, #1
24001c4c:	409a      	lsls	r2, r3
24001c4e:	68fb      	ldr	r3, [r7, #12]
24001c50:	605a      	str	r2, [r3, #4]
24001c52:	e008      	b.n	24001c66 <HAL_DMA_Init+0x4d6>
  }
  else
  {
    hdma->ErrorCode = HAL_DMA_ERROR_PARAM;
24001c54:	687b      	ldr	r3, [r7, #4]
24001c56:	2240      	movs	r2, #64	; 0x40
24001c58:	655a      	str	r2, [r3, #84]	; 0x54
    hdma->State     = HAL_DMA_STATE_ERROR;
24001c5a:	687b      	ldr	r3, [r7, #4]
24001c5c:	2203      	movs	r2, #3
24001c5e:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

    return HAL_ERROR;
24001c62:	2301      	movs	r3, #1
24001c64:	e0b7      	b.n	24001dd6 <HAL_DMA_Init+0x646>
  }

  if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
24001c66:	687b      	ldr	r3, [r7, #4]
24001c68:	681b      	ldr	r3, [r3, #0]
24001c6a:	4a5f      	ldr	r2, [pc, #380]	; (24001de8 <HAL_DMA_Init+0x658>)
24001c6c:	4293      	cmp	r3, r2
24001c6e:	d072      	beq.n	24001d56 <HAL_DMA_Init+0x5c6>
24001c70:	687b      	ldr	r3, [r7, #4]
24001c72:	681b      	ldr	r3, [r3, #0]
24001c74:	4a5d      	ldr	r2, [pc, #372]	; (24001dec <HAL_DMA_Init+0x65c>)
24001c76:	4293      	cmp	r3, r2
24001c78:	d06d      	beq.n	24001d56 <HAL_DMA_Init+0x5c6>
24001c7a:	687b      	ldr	r3, [r7, #4]
24001c7c:	681b      	ldr	r3, [r3, #0]
24001c7e:	4a5c      	ldr	r2, [pc, #368]	; (24001df0 <HAL_DMA_Init+0x660>)
24001c80:	4293      	cmp	r3, r2
24001c82:	d068      	beq.n	24001d56 <HAL_DMA_Init+0x5c6>
24001c84:	687b      	ldr	r3, [r7, #4]
24001c86:	681b      	ldr	r3, [r3, #0]
24001c88:	4a5a      	ldr	r2, [pc, #360]	; (24001df4 <HAL_DMA_Init+0x664>)
24001c8a:	4293      	cmp	r3, r2
24001c8c:	d063      	beq.n	24001d56 <HAL_DMA_Init+0x5c6>
24001c8e:	687b      	ldr	r3, [r7, #4]
24001c90:	681b      	ldr	r3, [r3, #0]
24001c92:	4a59      	ldr	r2, [pc, #356]	; (24001df8 <HAL_DMA_Init+0x668>)
24001c94:	4293      	cmp	r3, r2
24001c96:	d05e      	beq.n	24001d56 <HAL_DMA_Init+0x5c6>
24001c98:	687b      	ldr	r3, [r7, #4]
24001c9a:	681b      	ldr	r3, [r3, #0]
24001c9c:	4a57      	ldr	r2, [pc, #348]	; (24001dfc <HAL_DMA_Init+0x66c>)
24001c9e:	4293      	cmp	r3, r2
24001ca0:	d059      	beq.n	24001d56 <HAL_DMA_Init+0x5c6>
24001ca2:	687b      	ldr	r3, [r7, #4]
24001ca4:	681b      	ldr	r3, [r3, #0]
24001ca6:	4a56      	ldr	r2, [pc, #344]	; (24001e00 <HAL_DMA_Init+0x670>)
24001ca8:	4293      	cmp	r3, r2
24001caa:	d054      	beq.n	24001d56 <HAL_DMA_Init+0x5c6>
24001cac:	687b      	ldr	r3, [r7, #4]
24001cae:	681b      	ldr	r3, [r3, #0]
24001cb0:	4a54      	ldr	r2, [pc, #336]	; (24001e04 <HAL_DMA_Init+0x674>)
24001cb2:	4293      	cmp	r3, r2
24001cb4:	d04f      	beq.n	24001d56 <HAL_DMA_Init+0x5c6>
24001cb6:	687b      	ldr	r3, [r7, #4]
24001cb8:	681b      	ldr	r3, [r3, #0]
24001cba:	4a53      	ldr	r2, [pc, #332]	; (24001e08 <HAL_DMA_Init+0x678>)
24001cbc:	4293      	cmp	r3, r2
24001cbe:	d04a      	beq.n	24001d56 <HAL_DMA_Init+0x5c6>
24001cc0:	687b      	ldr	r3, [r7, #4]
24001cc2:	681b      	ldr	r3, [r3, #0]
24001cc4:	4a51      	ldr	r2, [pc, #324]	; (24001e0c <HAL_DMA_Init+0x67c>)
24001cc6:	4293      	cmp	r3, r2
24001cc8:	d045      	beq.n	24001d56 <HAL_DMA_Init+0x5c6>
24001cca:	687b      	ldr	r3, [r7, #4]
24001ccc:	681b      	ldr	r3, [r3, #0]
24001cce:	4a50      	ldr	r2, [pc, #320]	; (24001e10 <HAL_DMA_Init+0x680>)
24001cd0:	4293      	cmp	r3, r2
24001cd2:	d040      	beq.n	24001d56 <HAL_DMA_Init+0x5c6>
24001cd4:	687b      	ldr	r3, [r7, #4]
24001cd6:	681b      	ldr	r3, [r3, #0]
24001cd8:	4a4e      	ldr	r2, [pc, #312]	; (24001e14 <HAL_DMA_Init+0x684>)
24001cda:	4293      	cmp	r3, r2
24001cdc:	d03b      	beq.n	24001d56 <HAL_DMA_Init+0x5c6>
24001cde:	687b      	ldr	r3, [r7, #4]
24001ce0:	681b      	ldr	r3, [r3, #0]
24001ce2:	4a4d      	ldr	r2, [pc, #308]	; (24001e18 <HAL_DMA_Init+0x688>)
24001ce4:	4293      	cmp	r3, r2
24001ce6:	d036      	beq.n	24001d56 <HAL_DMA_Init+0x5c6>
24001ce8:	687b      	ldr	r3, [r7, #4]
24001cea:	681b      	ldr	r3, [r3, #0]
24001cec:	4a4b      	ldr	r2, [pc, #300]	; (24001e1c <HAL_DMA_Init+0x68c>)
24001cee:	4293      	cmp	r3, r2
24001cf0:	d031      	beq.n	24001d56 <HAL_DMA_Init+0x5c6>
24001cf2:	687b      	ldr	r3, [r7, #4]
24001cf4:	681b      	ldr	r3, [r3, #0]
24001cf6:	4a4a      	ldr	r2, [pc, #296]	; (24001e20 <HAL_DMA_Init+0x690>)
24001cf8:	4293      	cmp	r3, r2
24001cfa:	d02c      	beq.n	24001d56 <HAL_DMA_Init+0x5c6>
24001cfc:	687b      	ldr	r3, [r7, #4]
24001cfe:	681b      	ldr	r3, [r3, #0]
24001d00:	4a48      	ldr	r2, [pc, #288]	; (24001e24 <HAL_DMA_Init+0x694>)
24001d02:	4293      	cmp	r3, r2
24001d04:	d027      	beq.n	24001d56 <HAL_DMA_Init+0x5c6>
24001d06:	687b      	ldr	r3, [r7, #4]
24001d08:	681b      	ldr	r3, [r3, #0]
24001d0a:	4a47      	ldr	r2, [pc, #284]	; (24001e28 <HAL_DMA_Init+0x698>)
24001d0c:	4293      	cmp	r3, r2
24001d0e:	d022      	beq.n	24001d56 <HAL_DMA_Init+0x5c6>
24001d10:	687b      	ldr	r3, [r7, #4]
24001d12:	681b      	ldr	r3, [r3, #0]
24001d14:	4a45      	ldr	r2, [pc, #276]	; (24001e2c <HAL_DMA_Init+0x69c>)
24001d16:	4293      	cmp	r3, r2
24001d18:	d01d      	beq.n	24001d56 <HAL_DMA_Init+0x5c6>
24001d1a:	687b      	ldr	r3, [r7, #4]
24001d1c:	681b      	ldr	r3, [r3, #0]
24001d1e:	4a44      	ldr	r2, [pc, #272]	; (24001e30 <HAL_DMA_Init+0x6a0>)
24001d20:	4293      	cmp	r3, r2
24001d22:	d018      	beq.n	24001d56 <HAL_DMA_Init+0x5c6>
24001d24:	687b      	ldr	r3, [r7, #4]
24001d26:	681b      	ldr	r3, [r3, #0]
24001d28:	4a42      	ldr	r2, [pc, #264]	; (24001e34 <HAL_DMA_Init+0x6a4>)
24001d2a:	4293      	cmp	r3, r2
24001d2c:	d013      	beq.n	24001d56 <HAL_DMA_Init+0x5c6>
24001d2e:	687b      	ldr	r3, [r7, #4]
24001d30:	681b      	ldr	r3, [r3, #0]
24001d32:	4a41      	ldr	r2, [pc, #260]	; (24001e38 <HAL_DMA_Init+0x6a8>)
24001d34:	4293      	cmp	r3, r2
24001d36:	d00e      	beq.n	24001d56 <HAL_DMA_Init+0x5c6>
24001d38:	687b      	ldr	r3, [r7, #4]
24001d3a:	681b      	ldr	r3, [r3, #0]
24001d3c:	4a3f      	ldr	r2, [pc, #252]	; (24001e3c <HAL_DMA_Init+0x6ac>)
24001d3e:	4293      	cmp	r3, r2
24001d40:	d009      	beq.n	24001d56 <HAL_DMA_Init+0x5c6>
24001d42:	687b      	ldr	r3, [r7, #4]
24001d44:	681b      	ldr	r3, [r3, #0]
24001d46:	4a3e      	ldr	r2, [pc, #248]	; (24001e40 <HAL_DMA_Init+0x6b0>)
24001d48:	4293      	cmp	r3, r2
24001d4a:	d004      	beq.n	24001d56 <HAL_DMA_Init+0x5c6>
24001d4c:	687b      	ldr	r3, [r7, #4]
24001d4e:	681b      	ldr	r3, [r3, #0]
24001d50:	4a3c      	ldr	r2, [pc, #240]	; (24001e44 <HAL_DMA_Init+0x6b4>)
24001d52:	4293      	cmp	r3, r2
24001d54:	d101      	bne.n	24001d5a <HAL_DMA_Init+0x5ca>
24001d56:	2301      	movs	r3, #1
24001d58:	e000      	b.n	24001d5c <HAL_DMA_Init+0x5cc>
24001d5a:	2300      	movs	r3, #0
24001d5c:	2b00      	cmp	r3, #0
24001d5e:	d032      	beq.n	24001dc6 <HAL_DMA_Init+0x636>
  {
    /* Initialize parameters for DMAMUX channel :
    DMAmuxChannel, DMAmuxChannelStatus and DMAmuxChannelStatusMask
    */
    DMA_CalcDMAMUXChannelBaseAndMask(hdma);
24001d60:	6878      	ldr	r0, [r7, #4]
24001d62:	f003 fa51 	bl	24005208 <DMA_CalcDMAMUXChannelBaseAndMask>

    if(hdma->Init.Direction == DMA_MEMORY_TO_MEMORY)
24001d66:	687b      	ldr	r3, [r7, #4]
24001d68:	689b      	ldr	r3, [r3, #8]
24001d6a:	2b80      	cmp	r3, #128	; 0x80
24001d6c:	d102      	bne.n	24001d74 <HAL_DMA_Init+0x5e4>
    {
      /* if memory to memory force the request to 0*/
      hdma->Init.Request = DMA_REQUEST_MEM2MEM;
24001d6e:	687b      	ldr	r3, [r7, #4]
24001d70:	2200      	movs	r2, #0
24001d72:	605a      	str	r2, [r3, #4]
    }

    /* Set peripheral request  to DMAMUX channel */
    hdma->DMAmuxChannel->CCR = (hdma->Init.Request & DMAMUX_CxCR_DMAREQ_ID);
24001d74:	687b      	ldr	r3, [r7, #4]
24001d76:	685a      	ldr	r2, [r3, #4]
24001d78:	687b      	ldr	r3, [r7, #4]
24001d7a:	6e1b      	ldr	r3, [r3, #96]	; 0x60
24001d7c:	b2d2      	uxtb	r2, r2
24001d7e:	601a      	str	r2, [r3, #0]

    /* Clear the DMAMUX synchro overrun flag */
    hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
24001d80:	687b      	ldr	r3, [r7, #4]
24001d82:	6e5b      	ldr	r3, [r3, #100]	; 0x64
24001d84:	687a      	ldr	r2, [r7, #4]
24001d86:	6e92      	ldr	r2, [r2, #104]	; 0x68
24001d88:	605a      	str	r2, [r3, #4]

    /* Initialize parameters for DMAMUX request generator :
    if the DMA request is DMA_REQUEST_GENERATOR0 to DMA_REQUEST_GENERATOR7
    */
    if((hdma->Init.Request >= DMA_REQUEST_GENERATOR0) && (hdma->Init.Request <= DMA_REQUEST_GENERATOR7))
24001d8a:	687b      	ldr	r3, [r7, #4]
24001d8c:	685b      	ldr	r3, [r3, #4]
24001d8e:	2b00      	cmp	r3, #0
24001d90:	d010      	beq.n	24001db4 <HAL_DMA_Init+0x624>
24001d92:	687b      	ldr	r3, [r7, #4]
24001d94:	685b      	ldr	r3, [r3, #4]
24001d96:	2b08      	cmp	r3, #8
24001d98:	d80c      	bhi.n	24001db4 <HAL_DMA_Init+0x624>
    {
      /* Initialize parameters for DMAMUX request generator :
      DMAmuxRequestGen, DMAmuxRequestGenStatus and DMAmuxRequestGenStatusMask */
      DMA_CalcDMAMUXRequestGenBaseAndMask(hdma);
24001d9a:	6878      	ldr	r0, [r7, #4]
24001d9c:	f003 face 	bl	2400533c <DMA_CalcDMAMUXRequestGenBaseAndMask>

      /* Reset the DMAMUX request generator register */
      hdma->DMAmuxRequestGen->RGCR = 0U;
24001da0:	687b      	ldr	r3, [r7, #4]
24001da2:	6edb      	ldr	r3, [r3, #108]	; 0x6c
24001da4:	2200      	movs	r2, #0
24001da6:	601a      	str	r2, [r3, #0]

      /* Clear the DMAMUX request generator overrun flag */
      hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
24001da8:	687b      	ldr	r3, [r7, #4]
24001daa:	6f1b      	ldr	r3, [r3, #112]	; 0x70
24001dac:	687a      	ldr	r2, [r7, #4]
24001dae:	6f52      	ldr	r2, [r2, #116]	; 0x74
24001db0:	605a      	str	r2, [r3, #4]
24001db2:	e008      	b.n	24001dc6 <HAL_DMA_Init+0x636>
    }
    else
    {
      hdma->DMAmuxRequestGen = 0U;
24001db4:	687b      	ldr	r3, [r7, #4]
24001db6:	2200      	movs	r2, #0
24001db8:	66da      	str	r2, [r3, #108]	; 0x6c
      hdma->DMAmuxRequestGenStatus = 0U;
24001dba:	687b      	ldr	r3, [r7, #4]
24001dbc:	2200      	movs	r2, #0
24001dbe:	671a      	str	r2, [r3, #112]	; 0x70
      hdma->DMAmuxRequestGenStatusMask = 0U;
24001dc0:	687b      	ldr	r3, [r7, #4]
24001dc2:	2200      	movs	r2, #0
24001dc4:	675a      	str	r2, [r3, #116]	; 0x74
    }
  }

  /* Initialize the error code */
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
24001dc6:	687b      	ldr	r3, [r7, #4]
24001dc8:	2200      	movs	r2, #0
24001dca:	655a      	str	r2, [r3, #84]	; 0x54

  /* Initialize the DMA state */
  hdma->State = HAL_DMA_STATE_READY;
24001dcc:	687b      	ldr	r3, [r7, #4]
24001dce:	2201      	movs	r2, #1
24001dd0:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

  return HAL_OK;
24001dd4:	2300      	movs	r3, #0
}
24001dd6:	4618      	mov	r0, r3
24001dd8:	3718      	adds	r7, #24
24001dda:	46bd      	mov	sp, r7
24001ddc:	bd80      	pop	{r7, pc}
24001dde:	bf00      	nop
24001de0:	a7fdabf8 	.word	0xa7fdabf8
24001de4:	cccccccd 	.word	0xcccccccd
24001de8:	40020010 	.word	0x40020010
24001dec:	40020028 	.word	0x40020028
24001df0:	40020040 	.word	0x40020040
24001df4:	40020058 	.word	0x40020058
24001df8:	40020070 	.word	0x40020070
24001dfc:	40020088 	.word	0x40020088
24001e00:	400200a0 	.word	0x400200a0
24001e04:	400200b8 	.word	0x400200b8
24001e08:	40020410 	.word	0x40020410
24001e0c:	40020428 	.word	0x40020428
24001e10:	40020440 	.word	0x40020440
24001e14:	40020458 	.word	0x40020458
24001e18:	40020470 	.word	0x40020470
24001e1c:	40020488 	.word	0x40020488
24001e20:	400204a0 	.word	0x400204a0
24001e24:	400204b8 	.word	0x400204b8
24001e28:	58025408 	.word	0x58025408
24001e2c:	5802541c 	.word	0x5802541c
24001e30:	58025430 	.word	0x58025430
24001e34:	58025444 	.word	0x58025444
24001e38:	58025458 	.word	0x58025458
24001e3c:	5802546c 	.word	0x5802546c
24001e40:	58025480 	.word	0x58025480
24001e44:	58025494 	.word	0x58025494

24001e48 <HAL_DMA_DeInit>:
  * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Stream.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_DeInit(DMA_HandleTypeDef *hdma)
{
24001e48:	b580      	push	{r7, lr}
24001e4a:	b084      	sub	sp, #16
24001e4c:	af00      	add	r7, sp, #0
24001e4e:	6078      	str	r0, [r7, #4]
  DMA_Base_Registers *regs_dma;
  BDMA_Base_Registers *regs_bdma;

  /* Check the DMA peripheral handle */
  if(hdma == NULL)
24001e50:	687b      	ldr	r3, [r7, #4]
24001e52:	2b00      	cmp	r3, #0
24001e54:	d101      	bne.n	24001e5a <HAL_DMA_DeInit+0x12>
  {
    return HAL_ERROR;
24001e56:	2301      	movs	r3, #1
24001e58:	e225      	b.n	240022a6 <HAL_DMA_DeInit+0x45e>
  }

  /* Disable the selected DMA Streamx */
  __HAL_DMA_DISABLE(hdma);
24001e5a:	687b      	ldr	r3, [r7, #4]
24001e5c:	681b      	ldr	r3, [r3, #0]
24001e5e:	4a82      	ldr	r2, [pc, #520]	; (24002068 <HAL_DMA_DeInit+0x220>)
24001e60:	4293      	cmp	r3, r2
24001e62:	d04a      	beq.n	24001efa <HAL_DMA_DeInit+0xb2>
24001e64:	687b      	ldr	r3, [r7, #4]
24001e66:	681b      	ldr	r3, [r3, #0]
24001e68:	4a80      	ldr	r2, [pc, #512]	; (2400206c <HAL_DMA_DeInit+0x224>)
24001e6a:	4293      	cmp	r3, r2
24001e6c:	d045      	beq.n	24001efa <HAL_DMA_DeInit+0xb2>
24001e6e:	687b      	ldr	r3, [r7, #4]
24001e70:	681b      	ldr	r3, [r3, #0]
24001e72:	4a7f      	ldr	r2, [pc, #508]	; (24002070 <HAL_DMA_DeInit+0x228>)
24001e74:	4293      	cmp	r3, r2
24001e76:	d040      	beq.n	24001efa <HAL_DMA_DeInit+0xb2>
24001e78:	687b      	ldr	r3, [r7, #4]
24001e7a:	681b      	ldr	r3, [r3, #0]
24001e7c:	4a7d      	ldr	r2, [pc, #500]	; (24002074 <HAL_DMA_DeInit+0x22c>)
24001e7e:	4293      	cmp	r3, r2
24001e80:	d03b      	beq.n	24001efa <HAL_DMA_DeInit+0xb2>
24001e82:	687b      	ldr	r3, [r7, #4]
24001e84:	681b      	ldr	r3, [r3, #0]
24001e86:	4a7c      	ldr	r2, [pc, #496]	; (24002078 <HAL_DMA_DeInit+0x230>)
24001e88:	4293      	cmp	r3, r2
24001e8a:	d036      	beq.n	24001efa <HAL_DMA_DeInit+0xb2>
24001e8c:	687b      	ldr	r3, [r7, #4]
24001e8e:	681b      	ldr	r3, [r3, #0]
24001e90:	4a7a      	ldr	r2, [pc, #488]	; (2400207c <HAL_DMA_DeInit+0x234>)
24001e92:	4293      	cmp	r3, r2
24001e94:	d031      	beq.n	24001efa <HAL_DMA_DeInit+0xb2>
24001e96:	687b      	ldr	r3, [r7, #4]
24001e98:	681b      	ldr	r3, [r3, #0]
24001e9a:	4a79      	ldr	r2, [pc, #484]	; (24002080 <HAL_DMA_DeInit+0x238>)
24001e9c:	4293      	cmp	r3, r2
24001e9e:	d02c      	beq.n	24001efa <HAL_DMA_DeInit+0xb2>
24001ea0:	687b      	ldr	r3, [r7, #4]
24001ea2:	681b      	ldr	r3, [r3, #0]
24001ea4:	4a77      	ldr	r2, [pc, #476]	; (24002084 <HAL_DMA_DeInit+0x23c>)
24001ea6:	4293      	cmp	r3, r2
24001ea8:	d027      	beq.n	24001efa <HAL_DMA_DeInit+0xb2>
24001eaa:	687b      	ldr	r3, [r7, #4]
24001eac:	681b      	ldr	r3, [r3, #0]
24001eae:	4a76      	ldr	r2, [pc, #472]	; (24002088 <HAL_DMA_DeInit+0x240>)
24001eb0:	4293      	cmp	r3, r2
24001eb2:	d022      	beq.n	24001efa <HAL_DMA_DeInit+0xb2>
24001eb4:	687b      	ldr	r3, [r7, #4]
24001eb6:	681b      	ldr	r3, [r3, #0]
24001eb8:	4a74      	ldr	r2, [pc, #464]	; (2400208c <HAL_DMA_DeInit+0x244>)
24001eba:	4293      	cmp	r3, r2
24001ebc:	d01d      	beq.n	24001efa <HAL_DMA_DeInit+0xb2>
24001ebe:	687b      	ldr	r3, [r7, #4]
24001ec0:	681b      	ldr	r3, [r3, #0]
24001ec2:	4a73      	ldr	r2, [pc, #460]	; (24002090 <HAL_DMA_DeInit+0x248>)
24001ec4:	4293      	cmp	r3, r2
24001ec6:	d018      	beq.n	24001efa <HAL_DMA_DeInit+0xb2>
24001ec8:	687b      	ldr	r3, [r7, #4]
24001eca:	681b      	ldr	r3, [r3, #0]
24001ecc:	4a71      	ldr	r2, [pc, #452]	; (24002094 <HAL_DMA_DeInit+0x24c>)
24001ece:	4293      	cmp	r3, r2
24001ed0:	d013      	beq.n	24001efa <HAL_DMA_DeInit+0xb2>
24001ed2:	687b      	ldr	r3, [r7, #4]
24001ed4:	681b      	ldr	r3, [r3, #0]
24001ed6:	4a70      	ldr	r2, [pc, #448]	; (24002098 <HAL_DMA_DeInit+0x250>)
24001ed8:	4293      	cmp	r3, r2
24001eda:	d00e      	beq.n	24001efa <HAL_DMA_DeInit+0xb2>
24001edc:	687b      	ldr	r3, [r7, #4]
24001ede:	681b      	ldr	r3, [r3, #0]
24001ee0:	4a6e      	ldr	r2, [pc, #440]	; (2400209c <HAL_DMA_DeInit+0x254>)
24001ee2:	4293      	cmp	r3, r2
24001ee4:	d009      	beq.n	24001efa <HAL_DMA_DeInit+0xb2>
24001ee6:	687b      	ldr	r3, [r7, #4]
24001ee8:	681b      	ldr	r3, [r3, #0]
24001eea:	4a6d      	ldr	r2, [pc, #436]	; (240020a0 <HAL_DMA_DeInit+0x258>)
24001eec:	4293      	cmp	r3, r2
24001eee:	d004      	beq.n	24001efa <HAL_DMA_DeInit+0xb2>
24001ef0:	687b      	ldr	r3, [r7, #4]
24001ef2:	681b      	ldr	r3, [r3, #0]
24001ef4:	4a6b      	ldr	r2, [pc, #428]	; (240020a4 <HAL_DMA_DeInit+0x25c>)
24001ef6:	4293      	cmp	r3, r2
24001ef8:	d108      	bne.n	24001f0c <HAL_DMA_DeInit+0xc4>
24001efa:	687b      	ldr	r3, [r7, #4]
24001efc:	681b      	ldr	r3, [r3, #0]
24001efe:	681a      	ldr	r2, [r3, #0]
24001f00:	687b      	ldr	r3, [r7, #4]
24001f02:	681b      	ldr	r3, [r3, #0]
24001f04:	f022 0201 	bic.w	r2, r2, #1
24001f08:	601a      	str	r2, [r3, #0]
24001f0a:	e007      	b.n	24001f1c <HAL_DMA_DeInit+0xd4>
24001f0c:	687b      	ldr	r3, [r7, #4]
24001f0e:	681b      	ldr	r3, [r3, #0]
24001f10:	681a      	ldr	r2, [r3, #0]
24001f12:	687b      	ldr	r3, [r7, #4]
24001f14:	681b      	ldr	r3, [r3, #0]
24001f16:	f022 0201 	bic.w	r2, r2, #1
24001f1a:	601a      	str	r2, [r3, #0]

  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
24001f1c:	687b      	ldr	r3, [r7, #4]
24001f1e:	681b      	ldr	r3, [r3, #0]
24001f20:	4a51      	ldr	r2, [pc, #324]	; (24002068 <HAL_DMA_DeInit+0x220>)
24001f22:	4293      	cmp	r3, r2
24001f24:	d04a      	beq.n	24001fbc <HAL_DMA_DeInit+0x174>
24001f26:	687b      	ldr	r3, [r7, #4]
24001f28:	681b      	ldr	r3, [r3, #0]
24001f2a:	4a50      	ldr	r2, [pc, #320]	; (2400206c <HAL_DMA_DeInit+0x224>)
24001f2c:	4293      	cmp	r3, r2
24001f2e:	d045      	beq.n	24001fbc <HAL_DMA_DeInit+0x174>
24001f30:	687b      	ldr	r3, [r7, #4]
24001f32:	681b      	ldr	r3, [r3, #0]
24001f34:	4a4e      	ldr	r2, [pc, #312]	; (24002070 <HAL_DMA_DeInit+0x228>)
24001f36:	4293      	cmp	r3, r2
24001f38:	d040      	beq.n	24001fbc <HAL_DMA_DeInit+0x174>
24001f3a:	687b      	ldr	r3, [r7, #4]
24001f3c:	681b      	ldr	r3, [r3, #0]
24001f3e:	4a4d      	ldr	r2, [pc, #308]	; (24002074 <HAL_DMA_DeInit+0x22c>)
24001f40:	4293      	cmp	r3, r2
24001f42:	d03b      	beq.n	24001fbc <HAL_DMA_DeInit+0x174>
24001f44:	687b      	ldr	r3, [r7, #4]
24001f46:	681b      	ldr	r3, [r3, #0]
24001f48:	4a4b      	ldr	r2, [pc, #300]	; (24002078 <HAL_DMA_DeInit+0x230>)
24001f4a:	4293      	cmp	r3, r2
24001f4c:	d036      	beq.n	24001fbc <HAL_DMA_DeInit+0x174>
24001f4e:	687b      	ldr	r3, [r7, #4]
24001f50:	681b      	ldr	r3, [r3, #0]
24001f52:	4a4a      	ldr	r2, [pc, #296]	; (2400207c <HAL_DMA_DeInit+0x234>)
24001f54:	4293      	cmp	r3, r2
24001f56:	d031      	beq.n	24001fbc <HAL_DMA_DeInit+0x174>
24001f58:	687b      	ldr	r3, [r7, #4]
24001f5a:	681b      	ldr	r3, [r3, #0]
24001f5c:	4a48      	ldr	r2, [pc, #288]	; (24002080 <HAL_DMA_DeInit+0x238>)
24001f5e:	4293      	cmp	r3, r2
24001f60:	d02c      	beq.n	24001fbc <HAL_DMA_DeInit+0x174>
24001f62:	687b      	ldr	r3, [r7, #4]
24001f64:	681b      	ldr	r3, [r3, #0]
24001f66:	4a47      	ldr	r2, [pc, #284]	; (24002084 <HAL_DMA_DeInit+0x23c>)
24001f68:	4293      	cmp	r3, r2
24001f6a:	d027      	beq.n	24001fbc <HAL_DMA_DeInit+0x174>
24001f6c:	687b      	ldr	r3, [r7, #4]
24001f6e:	681b      	ldr	r3, [r3, #0]
24001f70:	4a45      	ldr	r2, [pc, #276]	; (24002088 <HAL_DMA_DeInit+0x240>)
24001f72:	4293      	cmp	r3, r2
24001f74:	d022      	beq.n	24001fbc <HAL_DMA_DeInit+0x174>
24001f76:	687b      	ldr	r3, [r7, #4]
24001f78:	681b      	ldr	r3, [r3, #0]
24001f7a:	4a44      	ldr	r2, [pc, #272]	; (2400208c <HAL_DMA_DeInit+0x244>)
24001f7c:	4293      	cmp	r3, r2
24001f7e:	d01d      	beq.n	24001fbc <HAL_DMA_DeInit+0x174>
24001f80:	687b      	ldr	r3, [r7, #4]
24001f82:	681b      	ldr	r3, [r3, #0]
24001f84:	4a42      	ldr	r2, [pc, #264]	; (24002090 <HAL_DMA_DeInit+0x248>)
24001f86:	4293      	cmp	r3, r2
24001f88:	d018      	beq.n	24001fbc <HAL_DMA_DeInit+0x174>
24001f8a:	687b      	ldr	r3, [r7, #4]
24001f8c:	681b      	ldr	r3, [r3, #0]
24001f8e:	4a41      	ldr	r2, [pc, #260]	; (24002094 <HAL_DMA_DeInit+0x24c>)
24001f90:	4293      	cmp	r3, r2
24001f92:	d013      	beq.n	24001fbc <HAL_DMA_DeInit+0x174>
24001f94:	687b      	ldr	r3, [r7, #4]
24001f96:	681b      	ldr	r3, [r3, #0]
24001f98:	4a3f      	ldr	r2, [pc, #252]	; (24002098 <HAL_DMA_DeInit+0x250>)
24001f9a:	4293      	cmp	r3, r2
24001f9c:	d00e      	beq.n	24001fbc <HAL_DMA_DeInit+0x174>
24001f9e:	687b      	ldr	r3, [r7, #4]
24001fa0:	681b      	ldr	r3, [r3, #0]
24001fa2:	4a3e      	ldr	r2, [pc, #248]	; (2400209c <HAL_DMA_DeInit+0x254>)
24001fa4:	4293      	cmp	r3, r2
24001fa6:	d009      	beq.n	24001fbc <HAL_DMA_DeInit+0x174>
24001fa8:	687b      	ldr	r3, [r7, #4]
24001faa:	681b      	ldr	r3, [r3, #0]
24001fac:	4a3c      	ldr	r2, [pc, #240]	; (240020a0 <HAL_DMA_DeInit+0x258>)
24001fae:	4293      	cmp	r3, r2
24001fb0:	d004      	beq.n	24001fbc <HAL_DMA_DeInit+0x174>
24001fb2:	687b      	ldr	r3, [r7, #4]
24001fb4:	681b      	ldr	r3, [r3, #0]
24001fb6:	4a3b      	ldr	r2, [pc, #236]	; (240020a4 <HAL_DMA_DeInit+0x25c>)
24001fb8:	4293      	cmp	r3, r2
24001fba:	d101      	bne.n	24001fc0 <HAL_DMA_DeInit+0x178>
24001fbc:	2301      	movs	r3, #1
24001fbe:	e000      	b.n	24001fc2 <HAL_DMA_DeInit+0x17a>
24001fc0:	2300      	movs	r3, #0
24001fc2:	2b00      	cmp	r3, #0
24001fc4:	d025      	beq.n	24002012 <HAL_DMA_DeInit+0x1ca>
  {
    /* Reset DMA Streamx control register */
    ((DMA_Stream_TypeDef   *)hdma->Instance)->CR   = 0U;
24001fc6:	687b      	ldr	r3, [r7, #4]
24001fc8:	681b      	ldr	r3, [r3, #0]
24001fca:	2200      	movs	r2, #0
24001fcc:	601a      	str	r2, [r3, #0]

    /* Reset DMA Streamx number of data to transfer register */
    ((DMA_Stream_TypeDef   *)hdma->Instance)->NDTR = 0U;
24001fce:	687b      	ldr	r3, [r7, #4]
24001fd0:	681b      	ldr	r3, [r3, #0]
24001fd2:	2200      	movs	r2, #0
24001fd4:	605a      	str	r2, [r3, #4]

    /* Reset DMA Streamx peripheral address register */
    ((DMA_Stream_TypeDef   *)hdma->Instance)->PAR  = 0U;
24001fd6:	687b      	ldr	r3, [r7, #4]
24001fd8:	681b      	ldr	r3, [r3, #0]
24001fda:	2200      	movs	r2, #0
24001fdc:	609a      	str	r2, [r3, #8]

    /* Reset DMA Streamx memory 0 address register */
    ((DMA_Stream_TypeDef   *)hdma->Instance)->M0AR = 0U;
24001fde:	687b      	ldr	r3, [r7, #4]
24001fe0:	681b      	ldr	r3, [r3, #0]
24001fe2:	2200      	movs	r2, #0
24001fe4:	60da      	str	r2, [r3, #12]

    /* Reset DMA Streamx memory 1 address register */
    ((DMA_Stream_TypeDef   *)hdma->Instance)->M1AR = 0U;
24001fe6:	687b      	ldr	r3, [r7, #4]
24001fe8:	681b      	ldr	r3, [r3, #0]
24001fea:	2200      	movs	r2, #0
24001fec:	611a      	str	r2, [r3, #16]

    /* Reset DMA Streamx FIFO control register */
    ((DMA_Stream_TypeDef   *)hdma->Instance)->FCR  = (uint32_t)0x00000021U;
24001fee:	687b      	ldr	r3, [r7, #4]
24001ff0:	681b      	ldr	r3, [r3, #0]
24001ff2:	2221      	movs	r2, #33	; 0x21
24001ff4:	615a      	str	r2, [r3, #20]

    /* Get DMA steam Base Address */
    regs_dma = (DMA_Base_Registers *)DMA_CalcBaseAndBitshift(hdma);
24001ff6:	6878      	ldr	r0, [r7, #4]
24001ff8:	f002 ffd8 	bl	24004fac <DMA_CalcBaseAndBitshift>
24001ffc:	4603      	mov	r3, r0
24001ffe:	60bb      	str	r3, [r7, #8]

    /* Clear all interrupt flags at correct offset within the register */
    regs_dma->IFCR = 0x3FUL << (hdma->StreamIndex & 0x1FU);
24002000:	687b      	ldr	r3, [r7, #4]
24002002:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
24002004:	f003 031f 	and.w	r3, r3, #31
24002008:	223f      	movs	r2, #63	; 0x3f
2400200a:	409a      	lsls	r2, r3
2400200c:	68bb      	ldr	r3, [r7, #8]
2400200e:	609a      	str	r2, [r3, #8]
24002010:	e081      	b.n	24002116 <HAL_DMA_DeInit+0x2ce>
  }
  else if(IS_BDMA_CHANNEL_INSTANCE(hdma->Instance) != 0U) /* BDMA instance(s) */
24002012:	687b      	ldr	r3, [r7, #4]
24002014:	681b      	ldr	r3, [r3, #0]
24002016:	4a24      	ldr	r2, [pc, #144]	; (240020a8 <HAL_DMA_DeInit+0x260>)
24002018:	4293      	cmp	r3, r2
2400201a:	d022      	beq.n	24002062 <HAL_DMA_DeInit+0x21a>
2400201c:	687b      	ldr	r3, [r7, #4]
2400201e:	681b      	ldr	r3, [r3, #0]
24002020:	4a22      	ldr	r2, [pc, #136]	; (240020ac <HAL_DMA_DeInit+0x264>)
24002022:	4293      	cmp	r3, r2
24002024:	d01d      	beq.n	24002062 <HAL_DMA_DeInit+0x21a>
24002026:	687b      	ldr	r3, [r7, #4]
24002028:	681b      	ldr	r3, [r3, #0]
2400202a:	4a21      	ldr	r2, [pc, #132]	; (240020b0 <HAL_DMA_DeInit+0x268>)
2400202c:	4293      	cmp	r3, r2
2400202e:	d018      	beq.n	24002062 <HAL_DMA_DeInit+0x21a>
24002030:	687b      	ldr	r3, [r7, #4]
24002032:	681b      	ldr	r3, [r3, #0]
24002034:	4a1f      	ldr	r2, [pc, #124]	; (240020b4 <HAL_DMA_DeInit+0x26c>)
24002036:	4293      	cmp	r3, r2
24002038:	d013      	beq.n	24002062 <HAL_DMA_DeInit+0x21a>
2400203a:	687b      	ldr	r3, [r7, #4]
2400203c:	681b      	ldr	r3, [r3, #0]
2400203e:	4a1e      	ldr	r2, [pc, #120]	; (240020b8 <HAL_DMA_DeInit+0x270>)
24002040:	4293      	cmp	r3, r2
24002042:	d00e      	beq.n	24002062 <HAL_DMA_DeInit+0x21a>
24002044:	687b      	ldr	r3, [r7, #4]
24002046:	681b      	ldr	r3, [r3, #0]
24002048:	4a1c      	ldr	r2, [pc, #112]	; (240020bc <HAL_DMA_DeInit+0x274>)
2400204a:	4293      	cmp	r3, r2
2400204c:	d009      	beq.n	24002062 <HAL_DMA_DeInit+0x21a>
2400204e:	687b      	ldr	r3, [r7, #4]
24002050:	681b      	ldr	r3, [r3, #0]
24002052:	4a1b      	ldr	r2, [pc, #108]	; (240020c0 <HAL_DMA_DeInit+0x278>)
24002054:	4293      	cmp	r3, r2
24002056:	d004      	beq.n	24002062 <HAL_DMA_DeInit+0x21a>
24002058:	687b      	ldr	r3, [r7, #4]
2400205a:	681b      	ldr	r3, [r3, #0]
2400205c:	4a19      	ldr	r2, [pc, #100]	; (240020c4 <HAL_DMA_DeInit+0x27c>)
2400205e:	4293      	cmp	r3, r2
24002060:	d132      	bne.n	240020c8 <HAL_DMA_DeInit+0x280>
24002062:	2301      	movs	r3, #1
24002064:	e031      	b.n	240020ca <HAL_DMA_DeInit+0x282>
24002066:	bf00      	nop
24002068:	40020010 	.word	0x40020010
2400206c:	40020028 	.word	0x40020028
24002070:	40020040 	.word	0x40020040
24002074:	40020058 	.word	0x40020058
24002078:	40020070 	.word	0x40020070
2400207c:	40020088 	.word	0x40020088
24002080:	400200a0 	.word	0x400200a0
24002084:	400200b8 	.word	0x400200b8
24002088:	40020410 	.word	0x40020410
2400208c:	40020428 	.word	0x40020428
24002090:	40020440 	.word	0x40020440
24002094:	40020458 	.word	0x40020458
24002098:	40020470 	.word	0x40020470
2400209c:	40020488 	.word	0x40020488
240020a0:	400204a0 	.word	0x400204a0
240020a4:	400204b8 	.word	0x400204b8
240020a8:	58025408 	.word	0x58025408
240020ac:	5802541c 	.word	0x5802541c
240020b0:	58025430 	.word	0x58025430
240020b4:	58025444 	.word	0x58025444
240020b8:	58025458 	.word	0x58025458
240020bc:	5802546c 	.word	0x5802546c
240020c0:	58025480 	.word	0x58025480
240020c4:	58025494 	.word	0x58025494
240020c8:	2300      	movs	r3, #0
240020ca:	2b00      	cmp	r3, #0
240020cc:	d021      	beq.n	24002112 <HAL_DMA_DeInit+0x2ca>
  {
    /* Reset DMA Channel control register */
    ((BDMA_Channel_TypeDef *)hdma->Instance)->CCR  = 0U;
240020ce:	687b      	ldr	r3, [r7, #4]
240020d0:	681b      	ldr	r3, [r3, #0]
240020d2:	2200      	movs	r2, #0
240020d4:	601a      	str	r2, [r3, #0]

    /* Reset DMA Channel Number of Data to Transfer register */
    ((BDMA_Channel_TypeDef *)hdma->Instance)->CNDTR = 0U;
240020d6:	687b      	ldr	r3, [r7, #4]
240020d8:	681b      	ldr	r3, [r3, #0]
240020da:	2200      	movs	r2, #0
240020dc:	605a      	str	r2, [r3, #4]

    /* Reset DMA Channel peripheral address register */
    ((BDMA_Channel_TypeDef *)hdma->Instance)->CPAR  = 0U;
240020de:	687b      	ldr	r3, [r7, #4]
240020e0:	681b      	ldr	r3, [r3, #0]
240020e2:	2200      	movs	r2, #0
240020e4:	609a      	str	r2, [r3, #8]

    /* Reset DMA Channel memory 0 address register */
    ((BDMA_Channel_TypeDef *)hdma->Instance)->CM0AR = 0U;
240020e6:	687b      	ldr	r3, [r7, #4]
240020e8:	681b      	ldr	r3, [r3, #0]
240020ea:	2200      	movs	r2, #0
240020ec:	60da      	str	r2, [r3, #12]

    /* Reset DMA Channel memory 1 address register */
    ((BDMA_Channel_TypeDef *)hdma->Instance)->CM1AR = 0U;
240020ee:	687b      	ldr	r3, [r7, #4]
240020f0:	681b      	ldr	r3, [r3, #0]
240020f2:	2200      	movs	r2, #0
240020f4:	611a      	str	r2, [r3, #16]

    /* Get DMA steam Base Address */
    regs_bdma = (BDMA_Base_Registers *)DMA_CalcBaseAndBitshift(hdma);
240020f6:	6878      	ldr	r0, [r7, #4]
240020f8:	f002 ff58 	bl	24004fac <DMA_CalcBaseAndBitshift>
240020fc:	4603      	mov	r3, r0
240020fe:	60fb      	str	r3, [r7, #12]

    /* Clear all interrupt flags at correct offset within the register */
    regs_bdma->IFCR = ((BDMA_IFCR_CGIF0) << (hdma->StreamIndex & 0x1FU));
24002100:	687b      	ldr	r3, [r7, #4]
24002102:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
24002104:	f003 031f 	and.w	r3, r3, #31
24002108:	2201      	movs	r2, #1
2400210a:	409a      	lsls	r2, r3
2400210c:	68fb      	ldr	r3, [r7, #12]
2400210e:	605a      	str	r2, [r3, #4]
24002110:	e001      	b.n	24002116 <HAL_DMA_DeInit+0x2ce>
  }
  else
  {
    /* Return error status */
    return HAL_ERROR;
24002112:	2301      	movs	r3, #1
24002114:	e0c7      	b.n	240022a6 <HAL_DMA_DeInit+0x45e>
  }

  if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
24002116:	687b      	ldr	r3, [r7, #4]
24002118:	681b      	ldr	r3, [r3, #0]
2400211a:	4a65      	ldr	r2, [pc, #404]	; (240022b0 <HAL_DMA_DeInit+0x468>)
2400211c:	4293      	cmp	r3, r2
2400211e:	d072      	beq.n	24002206 <HAL_DMA_DeInit+0x3be>
24002120:	687b      	ldr	r3, [r7, #4]
24002122:	681b      	ldr	r3, [r3, #0]
24002124:	4a63      	ldr	r2, [pc, #396]	; (240022b4 <HAL_DMA_DeInit+0x46c>)
24002126:	4293      	cmp	r3, r2
24002128:	d06d      	beq.n	24002206 <HAL_DMA_DeInit+0x3be>
2400212a:	687b      	ldr	r3, [r7, #4]
2400212c:	681b      	ldr	r3, [r3, #0]
2400212e:	4a62      	ldr	r2, [pc, #392]	; (240022b8 <HAL_DMA_DeInit+0x470>)
24002130:	4293      	cmp	r3, r2
24002132:	d068      	beq.n	24002206 <HAL_DMA_DeInit+0x3be>
24002134:	687b      	ldr	r3, [r7, #4]
24002136:	681b      	ldr	r3, [r3, #0]
24002138:	4a60      	ldr	r2, [pc, #384]	; (240022bc <HAL_DMA_DeInit+0x474>)
2400213a:	4293      	cmp	r3, r2
2400213c:	d063      	beq.n	24002206 <HAL_DMA_DeInit+0x3be>
2400213e:	687b      	ldr	r3, [r7, #4]
24002140:	681b      	ldr	r3, [r3, #0]
24002142:	4a5f      	ldr	r2, [pc, #380]	; (240022c0 <HAL_DMA_DeInit+0x478>)
24002144:	4293      	cmp	r3, r2
24002146:	d05e      	beq.n	24002206 <HAL_DMA_DeInit+0x3be>
24002148:	687b      	ldr	r3, [r7, #4]
2400214a:	681b      	ldr	r3, [r3, #0]
2400214c:	4a5d      	ldr	r2, [pc, #372]	; (240022c4 <HAL_DMA_DeInit+0x47c>)
2400214e:	4293      	cmp	r3, r2
24002150:	d059      	beq.n	24002206 <HAL_DMA_DeInit+0x3be>
24002152:	687b      	ldr	r3, [r7, #4]
24002154:	681b      	ldr	r3, [r3, #0]
24002156:	4a5c      	ldr	r2, [pc, #368]	; (240022c8 <HAL_DMA_DeInit+0x480>)
24002158:	4293      	cmp	r3, r2
2400215a:	d054      	beq.n	24002206 <HAL_DMA_DeInit+0x3be>
2400215c:	687b      	ldr	r3, [r7, #4]
2400215e:	681b      	ldr	r3, [r3, #0]
24002160:	4a5a      	ldr	r2, [pc, #360]	; (240022cc <HAL_DMA_DeInit+0x484>)
24002162:	4293      	cmp	r3, r2
24002164:	d04f      	beq.n	24002206 <HAL_DMA_DeInit+0x3be>
24002166:	687b      	ldr	r3, [r7, #4]
24002168:	681b      	ldr	r3, [r3, #0]
2400216a:	4a59      	ldr	r2, [pc, #356]	; (240022d0 <HAL_DMA_DeInit+0x488>)
2400216c:	4293      	cmp	r3, r2
2400216e:	d04a      	beq.n	24002206 <HAL_DMA_DeInit+0x3be>
24002170:	687b      	ldr	r3, [r7, #4]
24002172:	681b      	ldr	r3, [r3, #0]
24002174:	4a57      	ldr	r2, [pc, #348]	; (240022d4 <HAL_DMA_DeInit+0x48c>)
24002176:	4293      	cmp	r3, r2
24002178:	d045      	beq.n	24002206 <HAL_DMA_DeInit+0x3be>
2400217a:	687b      	ldr	r3, [r7, #4]
2400217c:	681b      	ldr	r3, [r3, #0]
2400217e:	4a56      	ldr	r2, [pc, #344]	; (240022d8 <HAL_DMA_DeInit+0x490>)
24002180:	4293      	cmp	r3, r2
24002182:	d040      	beq.n	24002206 <HAL_DMA_DeInit+0x3be>
24002184:	687b      	ldr	r3, [r7, #4]
24002186:	681b      	ldr	r3, [r3, #0]
24002188:	4a54      	ldr	r2, [pc, #336]	; (240022dc <HAL_DMA_DeInit+0x494>)
2400218a:	4293      	cmp	r3, r2
2400218c:	d03b      	beq.n	24002206 <HAL_DMA_DeInit+0x3be>
2400218e:	687b      	ldr	r3, [r7, #4]
24002190:	681b      	ldr	r3, [r3, #0]
24002192:	4a53      	ldr	r2, [pc, #332]	; (240022e0 <HAL_DMA_DeInit+0x498>)
24002194:	4293      	cmp	r3, r2
24002196:	d036      	beq.n	24002206 <HAL_DMA_DeInit+0x3be>
24002198:	687b      	ldr	r3, [r7, #4]
2400219a:	681b      	ldr	r3, [r3, #0]
2400219c:	4a51      	ldr	r2, [pc, #324]	; (240022e4 <HAL_DMA_DeInit+0x49c>)
2400219e:	4293      	cmp	r3, r2
240021a0:	d031      	beq.n	24002206 <HAL_DMA_DeInit+0x3be>
240021a2:	687b      	ldr	r3, [r7, #4]
240021a4:	681b      	ldr	r3, [r3, #0]
240021a6:	4a50      	ldr	r2, [pc, #320]	; (240022e8 <HAL_DMA_DeInit+0x4a0>)
240021a8:	4293      	cmp	r3, r2
240021aa:	d02c      	beq.n	24002206 <HAL_DMA_DeInit+0x3be>
240021ac:	687b      	ldr	r3, [r7, #4]
240021ae:	681b      	ldr	r3, [r3, #0]
240021b0:	4a4e      	ldr	r2, [pc, #312]	; (240022ec <HAL_DMA_DeInit+0x4a4>)
240021b2:	4293      	cmp	r3, r2
240021b4:	d027      	beq.n	24002206 <HAL_DMA_DeInit+0x3be>
240021b6:	687b      	ldr	r3, [r7, #4]
240021b8:	681b      	ldr	r3, [r3, #0]
240021ba:	4a4d      	ldr	r2, [pc, #308]	; (240022f0 <HAL_DMA_DeInit+0x4a8>)
240021bc:	4293      	cmp	r3, r2
240021be:	d022      	beq.n	24002206 <HAL_DMA_DeInit+0x3be>
240021c0:	687b      	ldr	r3, [r7, #4]
240021c2:	681b      	ldr	r3, [r3, #0]
240021c4:	4a4b      	ldr	r2, [pc, #300]	; (240022f4 <HAL_DMA_DeInit+0x4ac>)
240021c6:	4293      	cmp	r3, r2
240021c8:	d01d      	beq.n	24002206 <HAL_DMA_DeInit+0x3be>
240021ca:	687b      	ldr	r3, [r7, #4]
240021cc:	681b      	ldr	r3, [r3, #0]
240021ce:	4a4a      	ldr	r2, [pc, #296]	; (240022f8 <HAL_DMA_DeInit+0x4b0>)
240021d0:	4293      	cmp	r3, r2
240021d2:	d018      	beq.n	24002206 <HAL_DMA_DeInit+0x3be>
240021d4:	687b      	ldr	r3, [r7, #4]
240021d6:	681b      	ldr	r3, [r3, #0]
240021d8:	4a48      	ldr	r2, [pc, #288]	; (240022fc <HAL_DMA_DeInit+0x4b4>)
240021da:	4293      	cmp	r3, r2
240021dc:	d013      	beq.n	24002206 <HAL_DMA_DeInit+0x3be>
240021de:	687b      	ldr	r3, [r7, #4]
240021e0:	681b      	ldr	r3, [r3, #0]
240021e2:	4a47      	ldr	r2, [pc, #284]	; (24002300 <HAL_DMA_DeInit+0x4b8>)
240021e4:	4293      	cmp	r3, r2
240021e6:	d00e      	beq.n	24002206 <HAL_DMA_DeInit+0x3be>
240021e8:	687b      	ldr	r3, [r7, #4]
240021ea:	681b      	ldr	r3, [r3, #0]
240021ec:	4a45      	ldr	r2, [pc, #276]	; (24002304 <HAL_DMA_DeInit+0x4bc>)
240021ee:	4293      	cmp	r3, r2
240021f0:	d009      	beq.n	24002206 <HAL_DMA_DeInit+0x3be>
240021f2:	687b      	ldr	r3, [r7, #4]
240021f4:	681b      	ldr	r3, [r3, #0]
240021f6:	4a44      	ldr	r2, [pc, #272]	; (24002308 <HAL_DMA_DeInit+0x4c0>)
240021f8:	4293      	cmp	r3, r2
240021fa:	d004      	beq.n	24002206 <HAL_DMA_DeInit+0x3be>
240021fc:	687b      	ldr	r3, [r7, #4]
240021fe:	681b      	ldr	r3, [r3, #0]
24002200:	4a42      	ldr	r2, [pc, #264]	; (2400230c <HAL_DMA_DeInit+0x4c4>)
24002202:	4293      	cmp	r3, r2
24002204:	d101      	bne.n	2400220a <HAL_DMA_DeInit+0x3c2>
24002206:	2301      	movs	r3, #1
24002208:	e000      	b.n	2400220c <HAL_DMA_DeInit+0x3c4>
2400220a:	2300      	movs	r3, #0
2400220c:	2b00      	cmp	r3, #0
2400220e:	d02c      	beq.n	2400226a <HAL_DMA_DeInit+0x422>
  {
    /* Initialize parameters for DMAMUX channel :
    DMAmuxChannel, DMAmuxChannelStatus and DMAmuxChannelStatusMask */
    DMA_CalcDMAMUXChannelBaseAndMask(hdma);
24002210:	6878      	ldr	r0, [r7, #4]
24002212:	f002 fff9 	bl	24005208 <DMA_CalcDMAMUXChannelBaseAndMask>

    if(hdma->DMAmuxChannel != 0U)
24002216:	687b      	ldr	r3, [r7, #4]
24002218:	6e1b      	ldr	r3, [r3, #96]	; 0x60
2400221a:	2b00      	cmp	r3, #0
2400221c:	d008      	beq.n	24002230 <HAL_DMA_DeInit+0x3e8>
    {
      /* Resett he DMAMUX channel that corresponds to the DMA stream */
      hdma->DMAmuxChannel->CCR = 0U;
2400221e:	687b      	ldr	r3, [r7, #4]
24002220:	6e1b      	ldr	r3, [r3, #96]	; 0x60
24002222:	2200      	movs	r2, #0
24002224:	601a      	str	r2, [r3, #0]

      /* Clear the DMAMUX synchro overrun flag */
      hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
24002226:	687b      	ldr	r3, [r7, #4]
24002228:	6e5b      	ldr	r3, [r3, #100]	; 0x64
2400222a:	687a      	ldr	r2, [r7, #4]
2400222c:	6e92      	ldr	r2, [r2, #104]	; 0x68
2400222e:	605a      	str	r2, [r3, #4]
    }

    if((hdma->Init.Request >= DMA_REQUEST_GENERATOR0) && (hdma->Init.Request <= DMA_REQUEST_GENERATOR7))
24002230:	687b      	ldr	r3, [r7, #4]
24002232:	685b      	ldr	r3, [r3, #4]
24002234:	2b00      	cmp	r3, #0
24002236:	d00f      	beq.n	24002258 <HAL_DMA_DeInit+0x410>
24002238:	687b      	ldr	r3, [r7, #4]
2400223a:	685b      	ldr	r3, [r3, #4]
2400223c:	2b08      	cmp	r3, #8
2400223e:	d80b      	bhi.n	24002258 <HAL_DMA_DeInit+0x410>
    {
      /* Initialize parameters for DMAMUX request generator :
      DMAmuxRequestGen, DMAmuxRequestGenStatus and DMAmuxRequestGenStatusMask */
      DMA_CalcDMAMUXRequestGenBaseAndMask(hdma);
24002240:	6878      	ldr	r0, [r7, #4]
24002242:	f003 f87b 	bl	2400533c <DMA_CalcDMAMUXRequestGenBaseAndMask>

      /* Reset the DMAMUX request generator register */
      hdma->DMAmuxRequestGen->RGCR = 0U;
24002246:	687b      	ldr	r3, [r7, #4]
24002248:	6edb      	ldr	r3, [r3, #108]	; 0x6c
2400224a:	2200      	movs	r2, #0
2400224c:	601a      	str	r2, [r3, #0]

      /* Clear the DMAMUX request generator overrun flag */
      hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
2400224e:	687b      	ldr	r3, [r7, #4]
24002250:	6f1b      	ldr	r3, [r3, #112]	; 0x70
24002252:	687a      	ldr	r2, [r7, #4]
24002254:	6f52      	ldr	r2, [r2, #116]	; 0x74
24002256:	605a      	str	r2, [r3, #4]
    }

    hdma->DMAmuxRequestGen = 0U;
24002258:	687b      	ldr	r3, [r7, #4]
2400225a:	2200      	movs	r2, #0
2400225c:	66da      	str	r2, [r3, #108]	; 0x6c
    hdma->DMAmuxRequestGenStatus = 0U;
2400225e:	687b      	ldr	r3, [r7, #4]
24002260:	2200      	movs	r2, #0
24002262:	671a      	str	r2, [r3, #112]	; 0x70
    hdma->DMAmuxRequestGenStatusMask = 0U;
24002264:	687b      	ldr	r3, [r7, #4]
24002266:	2200      	movs	r2, #0
24002268:	675a      	str	r2, [r3, #116]	; 0x74
  }


  /* Clean callbacks */
  hdma->XferCpltCallback       = NULL;
2400226a:	687b      	ldr	r3, [r7, #4]
2400226c:	2200      	movs	r2, #0
2400226e:	63da      	str	r2, [r3, #60]	; 0x3c
  hdma->XferHalfCpltCallback   = NULL;
24002270:	687b      	ldr	r3, [r7, #4]
24002272:	2200      	movs	r2, #0
24002274:	641a      	str	r2, [r3, #64]	; 0x40
  hdma->XferM1CpltCallback     = NULL;
24002276:	687b      	ldr	r3, [r7, #4]
24002278:	2200      	movs	r2, #0
2400227a:	645a      	str	r2, [r3, #68]	; 0x44
  hdma->XferM1HalfCpltCallback = NULL;
2400227c:	687b      	ldr	r3, [r7, #4]
2400227e:	2200      	movs	r2, #0
24002280:	649a      	str	r2, [r3, #72]	; 0x48
  hdma->XferErrorCallback      = NULL;
24002282:	687b      	ldr	r3, [r7, #4]
24002284:	2200      	movs	r2, #0
24002286:	64da      	str	r2, [r3, #76]	; 0x4c
  hdma->XferAbortCallback      = NULL;
24002288:	687b      	ldr	r3, [r7, #4]
2400228a:	2200      	movs	r2, #0
2400228c:	651a      	str	r2, [r3, #80]	; 0x50

  /* Initialize the error code */
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
2400228e:	687b      	ldr	r3, [r7, #4]
24002290:	2200      	movs	r2, #0
24002292:	655a      	str	r2, [r3, #84]	; 0x54

  /* Initialize the DMA state */
  hdma->State = HAL_DMA_STATE_RESET;
24002294:	687b      	ldr	r3, [r7, #4]
24002296:	2200      	movs	r2, #0
24002298:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

  /* Release Lock */
  __HAL_UNLOCK(hdma);
2400229c:	687b      	ldr	r3, [r7, #4]
2400229e:	2200      	movs	r2, #0
240022a0:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

  return HAL_OK;
240022a4:	2300      	movs	r3, #0
}
240022a6:	4618      	mov	r0, r3
240022a8:	3710      	adds	r7, #16
240022aa:	46bd      	mov	sp, r7
240022ac:	bd80      	pop	{r7, pc}
240022ae:	bf00      	nop
240022b0:	40020010 	.word	0x40020010
240022b4:	40020028 	.word	0x40020028
240022b8:	40020040 	.word	0x40020040
240022bc:	40020058 	.word	0x40020058
240022c0:	40020070 	.word	0x40020070
240022c4:	40020088 	.word	0x40020088
240022c8:	400200a0 	.word	0x400200a0
240022cc:	400200b8 	.word	0x400200b8
240022d0:	40020410 	.word	0x40020410
240022d4:	40020428 	.word	0x40020428
240022d8:	40020440 	.word	0x40020440
240022dc:	40020458 	.word	0x40020458
240022e0:	40020470 	.word	0x40020470
240022e4:	40020488 	.word	0x40020488
240022e8:	400204a0 	.word	0x400204a0
240022ec:	400204b8 	.word	0x400204b8
240022f0:	58025408 	.word	0x58025408
240022f4:	5802541c 	.word	0x5802541c
240022f8:	58025430 	.word	0x58025430
240022fc:	58025444 	.word	0x58025444
24002300:	58025458 	.word	0x58025458
24002304:	5802546c 	.word	0x5802546c
24002308:	58025480 	.word	0x58025480
2400230c:	58025494 	.word	0x58025494

24002310 <HAL_DMA_Start>:
  * @param  DstAddress: The destination memory Buffer address
  * @param  DataLength: The length of data to be transferred from source to destination
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Start(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
{
24002310:	b580      	push	{r7, lr}
24002312:	b086      	sub	sp, #24
24002314:	af00      	add	r7, sp, #0
24002316:	60f8      	str	r0, [r7, #12]
24002318:	60b9      	str	r1, [r7, #8]
2400231a:	607a      	str	r2, [r7, #4]
2400231c:	603b      	str	r3, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
2400231e:	2300      	movs	r3, #0
24002320:	75fb      	strb	r3, [r7, #23]

  /* Check the parameters */
  assert_param(IS_DMA_BUFFER_SIZE(DataLength));

  /* Check the DMA peripheral handle */
  if(hdma == NULL)
24002322:	68fb      	ldr	r3, [r7, #12]
24002324:	2b00      	cmp	r3, #0
24002326:	d101      	bne.n	2400232c <HAL_DMA_Start+0x1c>
  {
    return HAL_ERROR;
24002328:	2301      	movs	r3, #1
2400232a:	e0ec      	b.n	24002506 <HAL_DMA_Start+0x1f6>
  }

  /* Process locked */
  __HAL_LOCK(hdma);
2400232c:	68fb      	ldr	r3, [r7, #12]
2400232e:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
24002332:	2b01      	cmp	r3, #1
24002334:	d101      	bne.n	2400233a <HAL_DMA_Start+0x2a>
24002336:	2302      	movs	r3, #2
24002338:	e0e5      	b.n	24002506 <HAL_DMA_Start+0x1f6>
2400233a:	68fb      	ldr	r3, [r7, #12]
2400233c:	2201      	movs	r2, #1
2400233e:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

  if(HAL_DMA_STATE_READY == hdma->State)
24002342:	68fb      	ldr	r3, [r7, #12]
24002344:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
24002348:	b2db      	uxtb	r3, r3
2400234a:	2b01      	cmp	r3, #1
2400234c:	f040 80d0 	bne.w	240024f0 <HAL_DMA_Start+0x1e0>
  {
    /* Change DMA peripheral state */
    hdma->State = HAL_DMA_STATE_BUSY;
24002350:	68fb      	ldr	r3, [r7, #12]
24002352:	2202      	movs	r2, #2
24002354:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

    /* Initialize the error code */
    hdma->ErrorCode = HAL_DMA_ERROR_NONE;
24002358:	68fb      	ldr	r3, [r7, #12]
2400235a:	2200      	movs	r2, #0
2400235c:	655a      	str	r2, [r3, #84]	; 0x54

    /* Disable the peripheral */
    __HAL_DMA_DISABLE(hdma);
2400235e:	68fb      	ldr	r3, [r7, #12]
24002360:	681b      	ldr	r3, [r3, #0]
24002362:	4a6b      	ldr	r2, [pc, #428]	; (24002510 <HAL_DMA_Start+0x200>)
24002364:	4293      	cmp	r3, r2
24002366:	d04a      	beq.n	240023fe <HAL_DMA_Start+0xee>
24002368:	68fb      	ldr	r3, [r7, #12]
2400236a:	681b      	ldr	r3, [r3, #0]
2400236c:	4a69      	ldr	r2, [pc, #420]	; (24002514 <HAL_DMA_Start+0x204>)
2400236e:	4293      	cmp	r3, r2
24002370:	d045      	beq.n	240023fe <HAL_DMA_Start+0xee>
24002372:	68fb      	ldr	r3, [r7, #12]
24002374:	681b      	ldr	r3, [r3, #0]
24002376:	4a68      	ldr	r2, [pc, #416]	; (24002518 <HAL_DMA_Start+0x208>)
24002378:	4293      	cmp	r3, r2
2400237a:	d040      	beq.n	240023fe <HAL_DMA_Start+0xee>
2400237c:	68fb      	ldr	r3, [r7, #12]
2400237e:	681b      	ldr	r3, [r3, #0]
24002380:	4a66      	ldr	r2, [pc, #408]	; (2400251c <HAL_DMA_Start+0x20c>)
24002382:	4293      	cmp	r3, r2
24002384:	d03b      	beq.n	240023fe <HAL_DMA_Start+0xee>
24002386:	68fb      	ldr	r3, [r7, #12]
24002388:	681b      	ldr	r3, [r3, #0]
2400238a:	4a65      	ldr	r2, [pc, #404]	; (24002520 <HAL_DMA_Start+0x210>)
2400238c:	4293      	cmp	r3, r2
2400238e:	d036      	beq.n	240023fe <HAL_DMA_Start+0xee>
24002390:	68fb      	ldr	r3, [r7, #12]
24002392:	681b      	ldr	r3, [r3, #0]
24002394:	4a63      	ldr	r2, [pc, #396]	; (24002524 <HAL_DMA_Start+0x214>)
24002396:	4293      	cmp	r3, r2
24002398:	d031      	beq.n	240023fe <HAL_DMA_Start+0xee>
2400239a:	68fb      	ldr	r3, [r7, #12]
2400239c:	681b      	ldr	r3, [r3, #0]
2400239e:	4a62      	ldr	r2, [pc, #392]	; (24002528 <HAL_DMA_Start+0x218>)
240023a0:	4293      	cmp	r3, r2
240023a2:	d02c      	beq.n	240023fe <HAL_DMA_Start+0xee>
240023a4:	68fb      	ldr	r3, [r7, #12]
240023a6:	681b      	ldr	r3, [r3, #0]
240023a8:	4a60      	ldr	r2, [pc, #384]	; (2400252c <HAL_DMA_Start+0x21c>)
240023aa:	4293      	cmp	r3, r2
240023ac:	d027      	beq.n	240023fe <HAL_DMA_Start+0xee>
240023ae:	68fb      	ldr	r3, [r7, #12]
240023b0:	681b      	ldr	r3, [r3, #0]
240023b2:	4a5f      	ldr	r2, [pc, #380]	; (24002530 <HAL_DMA_Start+0x220>)
240023b4:	4293      	cmp	r3, r2
240023b6:	d022      	beq.n	240023fe <HAL_DMA_Start+0xee>
240023b8:	68fb      	ldr	r3, [r7, #12]
240023ba:	681b      	ldr	r3, [r3, #0]
240023bc:	4a5d      	ldr	r2, [pc, #372]	; (24002534 <HAL_DMA_Start+0x224>)
240023be:	4293      	cmp	r3, r2
240023c0:	d01d      	beq.n	240023fe <HAL_DMA_Start+0xee>
240023c2:	68fb      	ldr	r3, [r7, #12]
240023c4:	681b      	ldr	r3, [r3, #0]
240023c6:	4a5c      	ldr	r2, [pc, #368]	; (24002538 <HAL_DMA_Start+0x228>)
240023c8:	4293      	cmp	r3, r2
240023ca:	d018      	beq.n	240023fe <HAL_DMA_Start+0xee>
240023cc:	68fb      	ldr	r3, [r7, #12]
240023ce:	681b      	ldr	r3, [r3, #0]
240023d0:	4a5a      	ldr	r2, [pc, #360]	; (2400253c <HAL_DMA_Start+0x22c>)
240023d2:	4293      	cmp	r3, r2
240023d4:	d013      	beq.n	240023fe <HAL_DMA_Start+0xee>
240023d6:	68fb      	ldr	r3, [r7, #12]
240023d8:	681b      	ldr	r3, [r3, #0]
240023da:	4a59      	ldr	r2, [pc, #356]	; (24002540 <HAL_DMA_Start+0x230>)
240023dc:	4293      	cmp	r3, r2
240023de:	d00e      	beq.n	240023fe <HAL_DMA_Start+0xee>
240023e0:	68fb      	ldr	r3, [r7, #12]
240023e2:	681b      	ldr	r3, [r3, #0]
240023e4:	4a57      	ldr	r2, [pc, #348]	; (24002544 <HAL_DMA_Start+0x234>)
240023e6:	4293      	cmp	r3, r2
240023e8:	d009      	beq.n	240023fe <HAL_DMA_Start+0xee>
240023ea:	68fb      	ldr	r3, [r7, #12]
240023ec:	681b      	ldr	r3, [r3, #0]
240023ee:	4a56      	ldr	r2, [pc, #344]	; (24002548 <HAL_DMA_Start+0x238>)
240023f0:	4293      	cmp	r3, r2
240023f2:	d004      	beq.n	240023fe <HAL_DMA_Start+0xee>
240023f4:	68fb      	ldr	r3, [r7, #12]
240023f6:	681b      	ldr	r3, [r3, #0]
240023f8:	4a54      	ldr	r2, [pc, #336]	; (2400254c <HAL_DMA_Start+0x23c>)
240023fa:	4293      	cmp	r3, r2
240023fc:	d108      	bne.n	24002410 <HAL_DMA_Start+0x100>
240023fe:	68fb      	ldr	r3, [r7, #12]
24002400:	681b      	ldr	r3, [r3, #0]
24002402:	681a      	ldr	r2, [r3, #0]
24002404:	68fb      	ldr	r3, [r7, #12]
24002406:	681b      	ldr	r3, [r3, #0]
24002408:	f022 0201 	bic.w	r2, r2, #1
2400240c:	601a      	str	r2, [r3, #0]
2400240e:	e007      	b.n	24002420 <HAL_DMA_Start+0x110>
24002410:	68fb      	ldr	r3, [r7, #12]
24002412:	681b      	ldr	r3, [r3, #0]
24002414:	681a      	ldr	r2, [r3, #0]
24002416:	68fb      	ldr	r3, [r7, #12]
24002418:	681b      	ldr	r3, [r3, #0]
2400241a:	f022 0201 	bic.w	r2, r2, #1
2400241e:	601a      	str	r2, [r3, #0]

    /* Configure the source, destination address and the data length */
    DMA_SetConfig(hdma, SrcAddress, DstAddress, DataLength);
24002420:	683b      	ldr	r3, [r7, #0]
24002422:	687a      	ldr	r2, [r7, #4]
24002424:	68b9      	ldr	r1, [r7, #8]
24002426:	68f8      	ldr	r0, [r7, #12]
24002428:	f002 fc14 	bl	24004c54 <DMA_SetConfig>

    /* Enable the Peripheral */
    __HAL_DMA_ENABLE(hdma);
2400242c:	68fb      	ldr	r3, [r7, #12]
2400242e:	681b      	ldr	r3, [r3, #0]
24002430:	4a37      	ldr	r2, [pc, #220]	; (24002510 <HAL_DMA_Start+0x200>)
24002432:	4293      	cmp	r3, r2
24002434:	d04a      	beq.n	240024cc <HAL_DMA_Start+0x1bc>
24002436:	68fb      	ldr	r3, [r7, #12]
24002438:	681b      	ldr	r3, [r3, #0]
2400243a:	4a36      	ldr	r2, [pc, #216]	; (24002514 <HAL_DMA_Start+0x204>)
2400243c:	4293      	cmp	r3, r2
2400243e:	d045      	beq.n	240024cc <HAL_DMA_Start+0x1bc>
24002440:	68fb      	ldr	r3, [r7, #12]
24002442:	681b      	ldr	r3, [r3, #0]
24002444:	4a34      	ldr	r2, [pc, #208]	; (24002518 <HAL_DMA_Start+0x208>)
24002446:	4293      	cmp	r3, r2
24002448:	d040      	beq.n	240024cc <HAL_DMA_Start+0x1bc>
2400244a:	68fb      	ldr	r3, [r7, #12]
2400244c:	681b      	ldr	r3, [r3, #0]
2400244e:	4a33      	ldr	r2, [pc, #204]	; (2400251c <HAL_DMA_Start+0x20c>)
24002450:	4293      	cmp	r3, r2
24002452:	d03b      	beq.n	240024cc <HAL_DMA_Start+0x1bc>
24002454:	68fb      	ldr	r3, [r7, #12]
24002456:	681b      	ldr	r3, [r3, #0]
24002458:	4a31      	ldr	r2, [pc, #196]	; (24002520 <HAL_DMA_Start+0x210>)
2400245a:	4293      	cmp	r3, r2
2400245c:	d036      	beq.n	240024cc <HAL_DMA_Start+0x1bc>
2400245e:	68fb      	ldr	r3, [r7, #12]
24002460:	681b      	ldr	r3, [r3, #0]
24002462:	4a30      	ldr	r2, [pc, #192]	; (24002524 <HAL_DMA_Start+0x214>)
24002464:	4293      	cmp	r3, r2
24002466:	d031      	beq.n	240024cc <HAL_DMA_Start+0x1bc>
24002468:	68fb      	ldr	r3, [r7, #12]
2400246a:	681b      	ldr	r3, [r3, #0]
2400246c:	4a2e      	ldr	r2, [pc, #184]	; (24002528 <HAL_DMA_Start+0x218>)
2400246e:	4293      	cmp	r3, r2
24002470:	d02c      	beq.n	240024cc <HAL_DMA_Start+0x1bc>
24002472:	68fb      	ldr	r3, [r7, #12]
24002474:	681b      	ldr	r3, [r3, #0]
24002476:	4a2d      	ldr	r2, [pc, #180]	; (2400252c <HAL_DMA_Start+0x21c>)
24002478:	4293      	cmp	r3, r2
2400247a:	d027      	beq.n	240024cc <HAL_DMA_Start+0x1bc>
2400247c:	68fb      	ldr	r3, [r7, #12]
2400247e:	681b      	ldr	r3, [r3, #0]
24002480:	4a2b      	ldr	r2, [pc, #172]	; (24002530 <HAL_DMA_Start+0x220>)
24002482:	4293      	cmp	r3, r2
24002484:	d022      	beq.n	240024cc <HAL_DMA_Start+0x1bc>
24002486:	68fb      	ldr	r3, [r7, #12]
24002488:	681b      	ldr	r3, [r3, #0]
2400248a:	4a2a      	ldr	r2, [pc, #168]	; (24002534 <HAL_DMA_Start+0x224>)
2400248c:	4293      	cmp	r3, r2
2400248e:	d01d      	beq.n	240024cc <HAL_DMA_Start+0x1bc>
24002490:	68fb      	ldr	r3, [r7, #12]
24002492:	681b      	ldr	r3, [r3, #0]
24002494:	4a28      	ldr	r2, [pc, #160]	; (24002538 <HAL_DMA_Start+0x228>)
24002496:	4293      	cmp	r3, r2
24002498:	d018      	beq.n	240024cc <HAL_DMA_Start+0x1bc>
2400249a:	68fb      	ldr	r3, [r7, #12]
2400249c:	681b      	ldr	r3, [r3, #0]
2400249e:	4a27      	ldr	r2, [pc, #156]	; (2400253c <HAL_DMA_Start+0x22c>)
240024a0:	4293      	cmp	r3, r2
240024a2:	d013      	beq.n	240024cc <HAL_DMA_Start+0x1bc>
240024a4:	68fb      	ldr	r3, [r7, #12]
240024a6:	681b      	ldr	r3, [r3, #0]
240024a8:	4a25      	ldr	r2, [pc, #148]	; (24002540 <HAL_DMA_Start+0x230>)
240024aa:	4293      	cmp	r3, r2
240024ac:	d00e      	beq.n	240024cc <HAL_DMA_Start+0x1bc>
240024ae:	68fb      	ldr	r3, [r7, #12]
240024b0:	681b      	ldr	r3, [r3, #0]
240024b2:	4a24      	ldr	r2, [pc, #144]	; (24002544 <HAL_DMA_Start+0x234>)
240024b4:	4293      	cmp	r3, r2
240024b6:	d009      	beq.n	240024cc <HAL_DMA_Start+0x1bc>
240024b8:	68fb      	ldr	r3, [r7, #12]
240024ba:	681b      	ldr	r3, [r3, #0]
240024bc:	4a22      	ldr	r2, [pc, #136]	; (24002548 <HAL_DMA_Start+0x238>)
240024be:	4293      	cmp	r3, r2
240024c0:	d004      	beq.n	240024cc <HAL_DMA_Start+0x1bc>
240024c2:	68fb      	ldr	r3, [r7, #12]
240024c4:	681b      	ldr	r3, [r3, #0]
240024c6:	4a21      	ldr	r2, [pc, #132]	; (2400254c <HAL_DMA_Start+0x23c>)
240024c8:	4293      	cmp	r3, r2
240024ca:	d108      	bne.n	240024de <HAL_DMA_Start+0x1ce>
240024cc:	68fb      	ldr	r3, [r7, #12]
240024ce:	681b      	ldr	r3, [r3, #0]
240024d0:	681a      	ldr	r2, [r3, #0]
240024d2:	68fb      	ldr	r3, [r7, #12]
240024d4:	681b      	ldr	r3, [r3, #0]
240024d6:	f042 0201 	orr.w	r2, r2, #1
240024da:	601a      	str	r2, [r3, #0]
240024dc:	e012      	b.n	24002504 <HAL_DMA_Start+0x1f4>
240024de:	68fb      	ldr	r3, [r7, #12]
240024e0:	681b      	ldr	r3, [r3, #0]
240024e2:	681a      	ldr	r2, [r3, #0]
240024e4:	68fb      	ldr	r3, [r7, #12]
240024e6:	681b      	ldr	r3, [r3, #0]
240024e8:	f042 0201 	orr.w	r2, r2, #1
240024ec:	601a      	str	r2, [r3, #0]
240024ee:	e009      	b.n	24002504 <HAL_DMA_Start+0x1f4>
  }
  else
  {
    /* Process unlocked */
    __HAL_UNLOCK(hdma);
240024f0:	68fb      	ldr	r3, [r7, #12]
240024f2:	2200      	movs	r2, #0
240024f4:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

    /* Set the error code to busy */
    hdma->ErrorCode = HAL_DMA_ERROR_BUSY;
240024f8:	68fb      	ldr	r3, [r7, #12]
240024fa:	f44f 6200 	mov.w	r2, #2048	; 0x800
240024fe:	655a      	str	r2, [r3, #84]	; 0x54

    /* Return error status */
    status = HAL_ERROR;
24002500:	2301      	movs	r3, #1
24002502:	75fb      	strb	r3, [r7, #23]
  }
  return status;
24002504:	7dfb      	ldrb	r3, [r7, #23]
}
24002506:	4618      	mov	r0, r3
24002508:	3718      	adds	r7, #24
2400250a:	46bd      	mov	sp, r7
2400250c:	bd80      	pop	{r7, pc}
2400250e:	bf00      	nop
24002510:	40020010 	.word	0x40020010
24002514:	40020028 	.word	0x40020028
24002518:	40020040 	.word	0x40020040
2400251c:	40020058 	.word	0x40020058
24002520:	40020070 	.word	0x40020070
24002524:	40020088 	.word	0x40020088
24002528:	400200a0 	.word	0x400200a0
2400252c:	400200b8 	.word	0x400200b8
24002530:	40020410 	.word	0x40020410
24002534:	40020428 	.word	0x40020428
24002538:	40020440 	.word	0x40020440
2400253c:	40020458 	.word	0x40020458
24002540:	40020470 	.word	0x40020470
24002544:	40020488 	.word	0x40020488
24002548:	400204a0 	.word	0x400204a0
2400254c:	400204b8 	.word	0x400204b8

24002550 <HAL_DMA_Start_IT>:
  * @param  DstAddress: The destination memory Buffer address
  * @param  DataLength: The length of data to be transferred from source to destination
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Start_IT(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
{
24002550:	b580      	push	{r7, lr}
24002552:	b086      	sub	sp, #24
24002554:	af00      	add	r7, sp, #0
24002556:	60f8      	str	r0, [r7, #12]
24002558:	60b9      	str	r1, [r7, #8]
2400255a:	607a      	str	r2, [r7, #4]
2400255c:	603b      	str	r3, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
2400255e:	2300      	movs	r3, #0
24002560:	75fb      	strb	r3, [r7, #23]

  /* Check the parameters */
  assert_param(IS_DMA_BUFFER_SIZE(DataLength));

  /* Check the DMA peripheral handle */
  if(hdma == NULL)
24002562:	68fb      	ldr	r3, [r7, #12]
24002564:	2b00      	cmp	r3, #0
24002566:	d101      	bne.n	2400256c <HAL_DMA_Start_IT+0x1c>
  {
    return HAL_ERROR;
24002568:	2301      	movs	r3, #1
2400256a:	e226      	b.n	240029ba <HAL_DMA_Start_IT+0x46a>
  }

  /* Process locked */
  __HAL_LOCK(hdma);
2400256c:	68fb      	ldr	r3, [r7, #12]
2400256e:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
24002572:	2b01      	cmp	r3, #1
24002574:	d101      	bne.n	2400257a <HAL_DMA_Start_IT+0x2a>
24002576:	2302      	movs	r3, #2
24002578:	e21f      	b.n	240029ba <HAL_DMA_Start_IT+0x46a>
2400257a:	68fb      	ldr	r3, [r7, #12]
2400257c:	2201      	movs	r2, #1
2400257e:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

  if(HAL_DMA_STATE_READY == hdma->State)
24002582:	68fb      	ldr	r3, [r7, #12]
24002584:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
24002588:	b2db      	uxtb	r3, r3
2400258a:	2b01      	cmp	r3, #1
2400258c:	f040 820a 	bne.w	240029a4 <HAL_DMA_Start_IT+0x454>
  {
    /* Change DMA peripheral state */
    hdma->State = HAL_DMA_STATE_BUSY;
24002590:	68fb      	ldr	r3, [r7, #12]
24002592:	2202      	movs	r2, #2
24002594:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

    /* Initialize the error code */
    hdma->ErrorCode = HAL_DMA_ERROR_NONE;
24002598:	68fb      	ldr	r3, [r7, #12]
2400259a:	2200      	movs	r2, #0
2400259c:	655a      	str	r2, [r3, #84]	; 0x54

    /* Disable the peripheral */
    __HAL_DMA_DISABLE(hdma);
2400259e:	68fb      	ldr	r3, [r7, #12]
240025a0:	681b      	ldr	r3, [r3, #0]
240025a2:	4a68      	ldr	r2, [pc, #416]	; (24002744 <HAL_DMA_Start_IT+0x1f4>)
240025a4:	4293      	cmp	r3, r2
240025a6:	d04a      	beq.n	2400263e <HAL_DMA_Start_IT+0xee>
240025a8:	68fb      	ldr	r3, [r7, #12]
240025aa:	681b      	ldr	r3, [r3, #0]
240025ac:	4a66      	ldr	r2, [pc, #408]	; (24002748 <HAL_DMA_Start_IT+0x1f8>)
240025ae:	4293      	cmp	r3, r2
240025b0:	d045      	beq.n	2400263e <HAL_DMA_Start_IT+0xee>
240025b2:	68fb      	ldr	r3, [r7, #12]
240025b4:	681b      	ldr	r3, [r3, #0]
240025b6:	4a65      	ldr	r2, [pc, #404]	; (2400274c <HAL_DMA_Start_IT+0x1fc>)
240025b8:	4293      	cmp	r3, r2
240025ba:	d040      	beq.n	2400263e <HAL_DMA_Start_IT+0xee>
240025bc:	68fb      	ldr	r3, [r7, #12]
240025be:	681b      	ldr	r3, [r3, #0]
240025c0:	4a63      	ldr	r2, [pc, #396]	; (24002750 <HAL_DMA_Start_IT+0x200>)
240025c2:	4293      	cmp	r3, r2
240025c4:	d03b      	beq.n	2400263e <HAL_DMA_Start_IT+0xee>
240025c6:	68fb      	ldr	r3, [r7, #12]
240025c8:	681b      	ldr	r3, [r3, #0]
240025ca:	4a62      	ldr	r2, [pc, #392]	; (24002754 <HAL_DMA_Start_IT+0x204>)
240025cc:	4293      	cmp	r3, r2
240025ce:	d036      	beq.n	2400263e <HAL_DMA_Start_IT+0xee>
240025d0:	68fb      	ldr	r3, [r7, #12]
240025d2:	681b      	ldr	r3, [r3, #0]
240025d4:	4a60      	ldr	r2, [pc, #384]	; (24002758 <HAL_DMA_Start_IT+0x208>)
240025d6:	4293      	cmp	r3, r2
240025d8:	d031      	beq.n	2400263e <HAL_DMA_Start_IT+0xee>
240025da:	68fb      	ldr	r3, [r7, #12]
240025dc:	681b      	ldr	r3, [r3, #0]
240025de:	4a5f      	ldr	r2, [pc, #380]	; (2400275c <HAL_DMA_Start_IT+0x20c>)
240025e0:	4293      	cmp	r3, r2
240025e2:	d02c      	beq.n	2400263e <HAL_DMA_Start_IT+0xee>
240025e4:	68fb      	ldr	r3, [r7, #12]
240025e6:	681b      	ldr	r3, [r3, #0]
240025e8:	4a5d      	ldr	r2, [pc, #372]	; (24002760 <HAL_DMA_Start_IT+0x210>)
240025ea:	4293      	cmp	r3, r2
240025ec:	d027      	beq.n	2400263e <HAL_DMA_Start_IT+0xee>
240025ee:	68fb      	ldr	r3, [r7, #12]
240025f0:	681b      	ldr	r3, [r3, #0]
240025f2:	4a5c      	ldr	r2, [pc, #368]	; (24002764 <HAL_DMA_Start_IT+0x214>)
240025f4:	4293      	cmp	r3, r2
240025f6:	d022      	beq.n	2400263e <HAL_DMA_Start_IT+0xee>
240025f8:	68fb      	ldr	r3, [r7, #12]
240025fa:	681b      	ldr	r3, [r3, #0]
240025fc:	4a5a      	ldr	r2, [pc, #360]	; (24002768 <HAL_DMA_Start_IT+0x218>)
240025fe:	4293      	cmp	r3, r2
24002600:	d01d      	beq.n	2400263e <HAL_DMA_Start_IT+0xee>
24002602:	68fb      	ldr	r3, [r7, #12]
24002604:	681b      	ldr	r3, [r3, #0]
24002606:	4a59      	ldr	r2, [pc, #356]	; (2400276c <HAL_DMA_Start_IT+0x21c>)
24002608:	4293      	cmp	r3, r2
2400260a:	d018      	beq.n	2400263e <HAL_DMA_Start_IT+0xee>
2400260c:	68fb      	ldr	r3, [r7, #12]
2400260e:	681b      	ldr	r3, [r3, #0]
24002610:	4a57      	ldr	r2, [pc, #348]	; (24002770 <HAL_DMA_Start_IT+0x220>)
24002612:	4293      	cmp	r3, r2
24002614:	d013      	beq.n	2400263e <HAL_DMA_Start_IT+0xee>
24002616:	68fb      	ldr	r3, [r7, #12]
24002618:	681b      	ldr	r3, [r3, #0]
2400261a:	4a56      	ldr	r2, [pc, #344]	; (24002774 <HAL_DMA_Start_IT+0x224>)
2400261c:	4293      	cmp	r3, r2
2400261e:	d00e      	beq.n	2400263e <HAL_DMA_Start_IT+0xee>
24002620:	68fb      	ldr	r3, [r7, #12]
24002622:	681b      	ldr	r3, [r3, #0]
24002624:	4a54      	ldr	r2, [pc, #336]	; (24002778 <HAL_DMA_Start_IT+0x228>)
24002626:	4293      	cmp	r3, r2
24002628:	d009      	beq.n	2400263e <HAL_DMA_Start_IT+0xee>
2400262a:	68fb      	ldr	r3, [r7, #12]
2400262c:	681b      	ldr	r3, [r3, #0]
2400262e:	4a53      	ldr	r2, [pc, #332]	; (2400277c <HAL_DMA_Start_IT+0x22c>)
24002630:	4293      	cmp	r3, r2
24002632:	d004      	beq.n	2400263e <HAL_DMA_Start_IT+0xee>
24002634:	68fb      	ldr	r3, [r7, #12]
24002636:	681b      	ldr	r3, [r3, #0]
24002638:	4a51      	ldr	r2, [pc, #324]	; (24002780 <HAL_DMA_Start_IT+0x230>)
2400263a:	4293      	cmp	r3, r2
2400263c:	d108      	bne.n	24002650 <HAL_DMA_Start_IT+0x100>
2400263e:	68fb      	ldr	r3, [r7, #12]
24002640:	681b      	ldr	r3, [r3, #0]
24002642:	681a      	ldr	r2, [r3, #0]
24002644:	68fb      	ldr	r3, [r7, #12]
24002646:	681b      	ldr	r3, [r3, #0]
24002648:	f022 0201 	bic.w	r2, r2, #1
2400264c:	601a      	str	r2, [r3, #0]
2400264e:	e007      	b.n	24002660 <HAL_DMA_Start_IT+0x110>
24002650:	68fb      	ldr	r3, [r7, #12]
24002652:	681b      	ldr	r3, [r3, #0]
24002654:	681a      	ldr	r2, [r3, #0]
24002656:	68fb      	ldr	r3, [r7, #12]
24002658:	681b      	ldr	r3, [r3, #0]
2400265a:	f022 0201 	bic.w	r2, r2, #1
2400265e:	601a      	str	r2, [r3, #0]

    /* Configure the source, destination address and the data length */
    DMA_SetConfig(hdma, SrcAddress, DstAddress, DataLength);
24002660:	683b      	ldr	r3, [r7, #0]
24002662:	687a      	ldr	r2, [r7, #4]
24002664:	68b9      	ldr	r1, [r7, #8]
24002666:	68f8      	ldr	r0, [r7, #12]
24002668:	f002 faf4 	bl	24004c54 <DMA_SetConfig>

    if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
2400266c:	68fb      	ldr	r3, [r7, #12]
2400266e:	681b      	ldr	r3, [r3, #0]
24002670:	4a34      	ldr	r2, [pc, #208]	; (24002744 <HAL_DMA_Start_IT+0x1f4>)
24002672:	4293      	cmp	r3, r2
24002674:	d04a      	beq.n	2400270c <HAL_DMA_Start_IT+0x1bc>
24002676:	68fb      	ldr	r3, [r7, #12]
24002678:	681b      	ldr	r3, [r3, #0]
2400267a:	4a33      	ldr	r2, [pc, #204]	; (24002748 <HAL_DMA_Start_IT+0x1f8>)
2400267c:	4293      	cmp	r3, r2
2400267e:	d045      	beq.n	2400270c <HAL_DMA_Start_IT+0x1bc>
24002680:	68fb      	ldr	r3, [r7, #12]
24002682:	681b      	ldr	r3, [r3, #0]
24002684:	4a31      	ldr	r2, [pc, #196]	; (2400274c <HAL_DMA_Start_IT+0x1fc>)
24002686:	4293      	cmp	r3, r2
24002688:	d040      	beq.n	2400270c <HAL_DMA_Start_IT+0x1bc>
2400268a:	68fb      	ldr	r3, [r7, #12]
2400268c:	681b      	ldr	r3, [r3, #0]
2400268e:	4a30      	ldr	r2, [pc, #192]	; (24002750 <HAL_DMA_Start_IT+0x200>)
24002690:	4293      	cmp	r3, r2
24002692:	d03b      	beq.n	2400270c <HAL_DMA_Start_IT+0x1bc>
24002694:	68fb      	ldr	r3, [r7, #12]
24002696:	681b      	ldr	r3, [r3, #0]
24002698:	4a2e      	ldr	r2, [pc, #184]	; (24002754 <HAL_DMA_Start_IT+0x204>)
2400269a:	4293      	cmp	r3, r2
2400269c:	d036      	beq.n	2400270c <HAL_DMA_Start_IT+0x1bc>
2400269e:	68fb      	ldr	r3, [r7, #12]
240026a0:	681b      	ldr	r3, [r3, #0]
240026a2:	4a2d      	ldr	r2, [pc, #180]	; (24002758 <HAL_DMA_Start_IT+0x208>)
240026a4:	4293      	cmp	r3, r2
240026a6:	d031      	beq.n	2400270c <HAL_DMA_Start_IT+0x1bc>
240026a8:	68fb      	ldr	r3, [r7, #12]
240026aa:	681b      	ldr	r3, [r3, #0]
240026ac:	4a2b      	ldr	r2, [pc, #172]	; (2400275c <HAL_DMA_Start_IT+0x20c>)
240026ae:	4293      	cmp	r3, r2
240026b0:	d02c      	beq.n	2400270c <HAL_DMA_Start_IT+0x1bc>
240026b2:	68fb      	ldr	r3, [r7, #12]
240026b4:	681b      	ldr	r3, [r3, #0]
240026b6:	4a2a      	ldr	r2, [pc, #168]	; (24002760 <HAL_DMA_Start_IT+0x210>)
240026b8:	4293      	cmp	r3, r2
240026ba:	d027      	beq.n	2400270c <HAL_DMA_Start_IT+0x1bc>
240026bc:	68fb      	ldr	r3, [r7, #12]
240026be:	681b      	ldr	r3, [r3, #0]
240026c0:	4a28      	ldr	r2, [pc, #160]	; (24002764 <HAL_DMA_Start_IT+0x214>)
240026c2:	4293      	cmp	r3, r2
240026c4:	d022      	beq.n	2400270c <HAL_DMA_Start_IT+0x1bc>
240026c6:	68fb      	ldr	r3, [r7, #12]
240026c8:	681b      	ldr	r3, [r3, #0]
240026ca:	4a27      	ldr	r2, [pc, #156]	; (24002768 <HAL_DMA_Start_IT+0x218>)
240026cc:	4293      	cmp	r3, r2
240026ce:	d01d      	beq.n	2400270c <HAL_DMA_Start_IT+0x1bc>
240026d0:	68fb      	ldr	r3, [r7, #12]
240026d2:	681b      	ldr	r3, [r3, #0]
240026d4:	4a25      	ldr	r2, [pc, #148]	; (2400276c <HAL_DMA_Start_IT+0x21c>)
240026d6:	4293      	cmp	r3, r2
240026d8:	d018      	beq.n	2400270c <HAL_DMA_Start_IT+0x1bc>
240026da:	68fb      	ldr	r3, [r7, #12]
240026dc:	681b      	ldr	r3, [r3, #0]
240026de:	4a24      	ldr	r2, [pc, #144]	; (24002770 <HAL_DMA_Start_IT+0x220>)
240026e0:	4293      	cmp	r3, r2
240026e2:	d013      	beq.n	2400270c <HAL_DMA_Start_IT+0x1bc>
240026e4:	68fb      	ldr	r3, [r7, #12]
240026e6:	681b      	ldr	r3, [r3, #0]
240026e8:	4a22      	ldr	r2, [pc, #136]	; (24002774 <HAL_DMA_Start_IT+0x224>)
240026ea:	4293      	cmp	r3, r2
240026ec:	d00e      	beq.n	2400270c <HAL_DMA_Start_IT+0x1bc>
240026ee:	68fb      	ldr	r3, [r7, #12]
240026f0:	681b      	ldr	r3, [r3, #0]
240026f2:	4a21      	ldr	r2, [pc, #132]	; (24002778 <HAL_DMA_Start_IT+0x228>)
240026f4:	4293      	cmp	r3, r2
240026f6:	d009      	beq.n	2400270c <HAL_DMA_Start_IT+0x1bc>
240026f8:	68fb      	ldr	r3, [r7, #12]
240026fa:	681b      	ldr	r3, [r3, #0]
240026fc:	4a1f      	ldr	r2, [pc, #124]	; (2400277c <HAL_DMA_Start_IT+0x22c>)
240026fe:	4293      	cmp	r3, r2
24002700:	d004      	beq.n	2400270c <HAL_DMA_Start_IT+0x1bc>
24002702:	68fb      	ldr	r3, [r7, #12]
24002704:	681b      	ldr	r3, [r3, #0]
24002706:	4a1e      	ldr	r2, [pc, #120]	; (24002780 <HAL_DMA_Start_IT+0x230>)
24002708:	4293      	cmp	r3, r2
2400270a:	d101      	bne.n	24002710 <HAL_DMA_Start_IT+0x1c0>
2400270c:	2301      	movs	r3, #1
2400270e:	e000      	b.n	24002712 <HAL_DMA_Start_IT+0x1c2>
24002710:	2300      	movs	r3, #0
24002712:	2b00      	cmp	r3, #0
24002714:	d036      	beq.n	24002784 <HAL_DMA_Start_IT+0x234>
    {
      /* Enable Common interrupts*/
      MODIFY_REG(((DMA_Stream_TypeDef   *)hdma->Instance)->CR, (DMA_IT_TC | DMA_IT_TE | DMA_IT_DME | DMA_IT_HT), (DMA_IT_TC | DMA_IT_TE | DMA_IT_DME));
24002716:	68fb      	ldr	r3, [r7, #12]
24002718:	681b      	ldr	r3, [r3, #0]
2400271a:	681b      	ldr	r3, [r3, #0]
2400271c:	f023 021e 	bic.w	r2, r3, #30
24002720:	68fb      	ldr	r3, [r7, #12]
24002722:	681b      	ldr	r3, [r3, #0]
24002724:	f042 0216 	orr.w	r2, r2, #22
24002728:	601a      	str	r2, [r3, #0]

      if(hdma->XferHalfCpltCallback != NULL)
2400272a:	68fb      	ldr	r3, [r7, #12]
2400272c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
2400272e:	2b00      	cmp	r3, #0
24002730:	d03e      	beq.n	240027b0 <HAL_DMA_Start_IT+0x260>
      {
        /* Enable Half Transfer IT if corresponding Callback is set */
        ((DMA_Stream_TypeDef   *)hdma->Instance)->CR  |= DMA_IT_HT;
24002732:	68fb      	ldr	r3, [r7, #12]
24002734:	681b      	ldr	r3, [r3, #0]
24002736:	681a      	ldr	r2, [r3, #0]
24002738:	68fb      	ldr	r3, [r7, #12]
2400273a:	681b      	ldr	r3, [r3, #0]
2400273c:	f042 0208 	orr.w	r2, r2, #8
24002740:	601a      	str	r2, [r3, #0]
24002742:	e035      	b.n	240027b0 <HAL_DMA_Start_IT+0x260>
24002744:	40020010 	.word	0x40020010
24002748:	40020028 	.word	0x40020028
2400274c:	40020040 	.word	0x40020040
24002750:	40020058 	.word	0x40020058
24002754:	40020070 	.word	0x40020070
24002758:	40020088 	.word	0x40020088
2400275c:	400200a0 	.word	0x400200a0
24002760:	400200b8 	.word	0x400200b8
24002764:	40020410 	.word	0x40020410
24002768:	40020428 	.word	0x40020428
2400276c:	40020440 	.word	0x40020440
24002770:	40020458 	.word	0x40020458
24002774:	40020470 	.word	0x40020470
24002778:	40020488 	.word	0x40020488
2400277c:	400204a0 	.word	0x400204a0
24002780:	400204b8 	.word	0x400204b8
      }
    }
    else /* BDMA channel */
    {
      /* Enable Common interrupts */
      MODIFY_REG(((BDMA_Channel_TypeDef   *)hdma->Instance)->CCR, (BDMA_CCR_TCIE | BDMA_CCR_HTIE | BDMA_CCR_TEIE), (BDMA_CCR_TCIE | BDMA_CCR_TEIE));
24002784:	68fb      	ldr	r3, [r7, #12]
24002786:	681b      	ldr	r3, [r3, #0]
24002788:	681b      	ldr	r3, [r3, #0]
2400278a:	f023 020e 	bic.w	r2, r3, #14
2400278e:	68fb      	ldr	r3, [r7, #12]
24002790:	681b      	ldr	r3, [r3, #0]
24002792:	f042 020a 	orr.w	r2, r2, #10
24002796:	601a      	str	r2, [r3, #0]

      if(hdma->XferHalfCpltCallback != NULL)
24002798:	68fb      	ldr	r3, [r7, #12]
2400279a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
2400279c:	2b00      	cmp	r3, #0
2400279e:	d007      	beq.n	240027b0 <HAL_DMA_Start_IT+0x260>
      {
        /*Enable Half Transfer IT if corresponding Callback is set */
        ((BDMA_Channel_TypeDef   *)hdma->Instance)->CCR  |= BDMA_CCR_HTIE;
240027a0:	68fb      	ldr	r3, [r7, #12]
240027a2:	681b      	ldr	r3, [r3, #0]
240027a4:	681a      	ldr	r2, [r3, #0]
240027a6:	68fb      	ldr	r3, [r7, #12]
240027a8:	681b      	ldr	r3, [r3, #0]
240027aa:	f042 0204 	orr.w	r2, r2, #4
240027ae:	601a      	str	r2, [r3, #0]
      }
    }

    if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
240027b0:	68fb      	ldr	r3, [r7, #12]
240027b2:	681b      	ldr	r3, [r3, #0]
240027b4:	4a83      	ldr	r2, [pc, #524]	; (240029c4 <HAL_DMA_Start_IT+0x474>)
240027b6:	4293      	cmp	r3, r2
240027b8:	d072      	beq.n	240028a0 <HAL_DMA_Start_IT+0x350>
240027ba:	68fb      	ldr	r3, [r7, #12]
240027bc:	681b      	ldr	r3, [r3, #0]
240027be:	4a82      	ldr	r2, [pc, #520]	; (240029c8 <HAL_DMA_Start_IT+0x478>)
240027c0:	4293      	cmp	r3, r2
240027c2:	d06d      	beq.n	240028a0 <HAL_DMA_Start_IT+0x350>
240027c4:	68fb      	ldr	r3, [r7, #12]
240027c6:	681b      	ldr	r3, [r3, #0]
240027c8:	4a80      	ldr	r2, [pc, #512]	; (240029cc <HAL_DMA_Start_IT+0x47c>)
240027ca:	4293      	cmp	r3, r2
240027cc:	d068      	beq.n	240028a0 <HAL_DMA_Start_IT+0x350>
240027ce:	68fb      	ldr	r3, [r7, #12]
240027d0:	681b      	ldr	r3, [r3, #0]
240027d2:	4a7f      	ldr	r2, [pc, #508]	; (240029d0 <HAL_DMA_Start_IT+0x480>)
240027d4:	4293      	cmp	r3, r2
240027d6:	d063      	beq.n	240028a0 <HAL_DMA_Start_IT+0x350>
240027d8:	68fb      	ldr	r3, [r7, #12]
240027da:	681b      	ldr	r3, [r3, #0]
240027dc:	4a7d      	ldr	r2, [pc, #500]	; (240029d4 <HAL_DMA_Start_IT+0x484>)
240027de:	4293      	cmp	r3, r2
240027e0:	d05e      	beq.n	240028a0 <HAL_DMA_Start_IT+0x350>
240027e2:	68fb      	ldr	r3, [r7, #12]
240027e4:	681b      	ldr	r3, [r3, #0]
240027e6:	4a7c      	ldr	r2, [pc, #496]	; (240029d8 <HAL_DMA_Start_IT+0x488>)
240027e8:	4293      	cmp	r3, r2
240027ea:	d059      	beq.n	240028a0 <HAL_DMA_Start_IT+0x350>
240027ec:	68fb      	ldr	r3, [r7, #12]
240027ee:	681b      	ldr	r3, [r3, #0]
240027f0:	4a7a      	ldr	r2, [pc, #488]	; (240029dc <HAL_DMA_Start_IT+0x48c>)
240027f2:	4293      	cmp	r3, r2
240027f4:	d054      	beq.n	240028a0 <HAL_DMA_Start_IT+0x350>
240027f6:	68fb      	ldr	r3, [r7, #12]
240027f8:	681b      	ldr	r3, [r3, #0]
240027fa:	4a79      	ldr	r2, [pc, #484]	; (240029e0 <HAL_DMA_Start_IT+0x490>)
240027fc:	4293      	cmp	r3, r2
240027fe:	d04f      	beq.n	240028a0 <HAL_DMA_Start_IT+0x350>
24002800:	68fb      	ldr	r3, [r7, #12]
24002802:	681b      	ldr	r3, [r3, #0]
24002804:	4a77      	ldr	r2, [pc, #476]	; (240029e4 <HAL_DMA_Start_IT+0x494>)
24002806:	4293      	cmp	r3, r2
24002808:	d04a      	beq.n	240028a0 <HAL_DMA_Start_IT+0x350>
2400280a:	68fb      	ldr	r3, [r7, #12]
2400280c:	681b      	ldr	r3, [r3, #0]
2400280e:	4a76      	ldr	r2, [pc, #472]	; (240029e8 <HAL_DMA_Start_IT+0x498>)
24002810:	4293      	cmp	r3, r2
24002812:	d045      	beq.n	240028a0 <HAL_DMA_Start_IT+0x350>
24002814:	68fb      	ldr	r3, [r7, #12]
24002816:	681b      	ldr	r3, [r3, #0]
24002818:	4a74      	ldr	r2, [pc, #464]	; (240029ec <HAL_DMA_Start_IT+0x49c>)
2400281a:	4293      	cmp	r3, r2
2400281c:	d040      	beq.n	240028a0 <HAL_DMA_Start_IT+0x350>
2400281e:	68fb      	ldr	r3, [r7, #12]
24002820:	681b      	ldr	r3, [r3, #0]
24002822:	4a73      	ldr	r2, [pc, #460]	; (240029f0 <HAL_DMA_Start_IT+0x4a0>)
24002824:	4293      	cmp	r3, r2
24002826:	d03b      	beq.n	240028a0 <HAL_DMA_Start_IT+0x350>
24002828:	68fb      	ldr	r3, [r7, #12]
2400282a:	681b      	ldr	r3, [r3, #0]
2400282c:	4a71      	ldr	r2, [pc, #452]	; (240029f4 <HAL_DMA_Start_IT+0x4a4>)
2400282e:	4293      	cmp	r3, r2
24002830:	d036      	beq.n	240028a0 <HAL_DMA_Start_IT+0x350>
24002832:	68fb      	ldr	r3, [r7, #12]
24002834:	681b      	ldr	r3, [r3, #0]
24002836:	4a70      	ldr	r2, [pc, #448]	; (240029f8 <HAL_DMA_Start_IT+0x4a8>)
24002838:	4293      	cmp	r3, r2
2400283a:	d031      	beq.n	240028a0 <HAL_DMA_Start_IT+0x350>
2400283c:	68fb      	ldr	r3, [r7, #12]
2400283e:	681b      	ldr	r3, [r3, #0]
24002840:	4a6e      	ldr	r2, [pc, #440]	; (240029fc <HAL_DMA_Start_IT+0x4ac>)
24002842:	4293      	cmp	r3, r2
24002844:	d02c      	beq.n	240028a0 <HAL_DMA_Start_IT+0x350>
24002846:	68fb      	ldr	r3, [r7, #12]
24002848:	681b      	ldr	r3, [r3, #0]
2400284a:	4a6d      	ldr	r2, [pc, #436]	; (24002a00 <HAL_DMA_Start_IT+0x4b0>)
2400284c:	4293      	cmp	r3, r2
2400284e:	d027      	beq.n	240028a0 <HAL_DMA_Start_IT+0x350>
24002850:	68fb      	ldr	r3, [r7, #12]
24002852:	681b      	ldr	r3, [r3, #0]
24002854:	4a6b      	ldr	r2, [pc, #428]	; (24002a04 <HAL_DMA_Start_IT+0x4b4>)
24002856:	4293      	cmp	r3, r2
24002858:	d022      	beq.n	240028a0 <HAL_DMA_Start_IT+0x350>
2400285a:	68fb      	ldr	r3, [r7, #12]
2400285c:	681b      	ldr	r3, [r3, #0]
2400285e:	4a6a      	ldr	r2, [pc, #424]	; (24002a08 <HAL_DMA_Start_IT+0x4b8>)
24002860:	4293      	cmp	r3, r2
24002862:	d01d      	beq.n	240028a0 <HAL_DMA_Start_IT+0x350>
24002864:	68fb      	ldr	r3, [r7, #12]
24002866:	681b      	ldr	r3, [r3, #0]
24002868:	4a68      	ldr	r2, [pc, #416]	; (24002a0c <HAL_DMA_Start_IT+0x4bc>)
2400286a:	4293      	cmp	r3, r2
2400286c:	d018      	beq.n	240028a0 <HAL_DMA_Start_IT+0x350>
2400286e:	68fb      	ldr	r3, [r7, #12]
24002870:	681b      	ldr	r3, [r3, #0]
24002872:	4a67      	ldr	r2, [pc, #412]	; (24002a10 <HAL_DMA_Start_IT+0x4c0>)
24002874:	4293      	cmp	r3, r2
24002876:	d013      	beq.n	240028a0 <HAL_DMA_Start_IT+0x350>
24002878:	68fb      	ldr	r3, [r7, #12]
2400287a:	681b      	ldr	r3, [r3, #0]
2400287c:	4a65      	ldr	r2, [pc, #404]	; (24002a14 <HAL_DMA_Start_IT+0x4c4>)
2400287e:	4293      	cmp	r3, r2
24002880:	d00e      	beq.n	240028a0 <HAL_DMA_Start_IT+0x350>
24002882:	68fb      	ldr	r3, [r7, #12]
24002884:	681b      	ldr	r3, [r3, #0]
24002886:	4a64      	ldr	r2, [pc, #400]	; (24002a18 <HAL_DMA_Start_IT+0x4c8>)
24002888:	4293      	cmp	r3, r2
2400288a:	d009      	beq.n	240028a0 <HAL_DMA_Start_IT+0x350>
2400288c:	68fb      	ldr	r3, [r7, #12]
2400288e:	681b      	ldr	r3, [r3, #0]
24002890:	4a62      	ldr	r2, [pc, #392]	; (24002a1c <HAL_DMA_Start_IT+0x4cc>)
24002892:	4293      	cmp	r3, r2
24002894:	d004      	beq.n	240028a0 <HAL_DMA_Start_IT+0x350>
24002896:	68fb      	ldr	r3, [r7, #12]
24002898:	681b      	ldr	r3, [r3, #0]
2400289a:	4a61      	ldr	r2, [pc, #388]	; (24002a20 <HAL_DMA_Start_IT+0x4d0>)
2400289c:	4293      	cmp	r3, r2
2400289e:	d101      	bne.n	240028a4 <HAL_DMA_Start_IT+0x354>
240028a0:	2301      	movs	r3, #1
240028a2:	e000      	b.n	240028a6 <HAL_DMA_Start_IT+0x356>
240028a4:	2300      	movs	r3, #0
240028a6:	2b00      	cmp	r3, #0
240028a8:	d01a      	beq.n	240028e0 <HAL_DMA_Start_IT+0x390>
    {
      /* Check if DMAMUX Synchronization is enabled */
      if((hdma->DMAmuxChannel->CCR & DMAMUX_CxCR_SE) != 0U)
240028aa:	68fb      	ldr	r3, [r7, #12]
240028ac:	6e1b      	ldr	r3, [r3, #96]	; 0x60
240028ae:	681b      	ldr	r3, [r3, #0]
240028b0:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
240028b4:	2b00      	cmp	r3, #0
240028b6:	d007      	beq.n	240028c8 <HAL_DMA_Start_IT+0x378>
      {
        /* Enable DMAMUX sync overrun IT*/
        hdma->DMAmuxChannel->CCR |= DMAMUX_CxCR_SOIE;
240028b8:	68fb      	ldr	r3, [r7, #12]
240028ba:	6e1b      	ldr	r3, [r3, #96]	; 0x60
240028bc:	681a      	ldr	r2, [r3, #0]
240028be:	68fb      	ldr	r3, [r7, #12]
240028c0:	6e1b      	ldr	r3, [r3, #96]	; 0x60
240028c2:	f442 7280 	orr.w	r2, r2, #256	; 0x100
240028c6:	601a      	str	r2, [r3, #0]
      }

      if(hdma->DMAmuxRequestGen != 0U)
240028c8:	68fb      	ldr	r3, [r7, #12]
240028ca:	6edb      	ldr	r3, [r3, #108]	; 0x6c
240028cc:	2b00      	cmp	r3, #0
240028ce:	d007      	beq.n	240028e0 <HAL_DMA_Start_IT+0x390>
      {
        /* if using DMAMUX request generator, enable the DMAMUX request generator overrun IT*/
        /* enable the request gen overrun IT */
        hdma->DMAmuxRequestGen->RGCR |= DMAMUX_RGxCR_OIE;
240028d0:	68fb      	ldr	r3, [r7, #12]
240028d2:	6edb      	ldr	r3, [r3, #108]	; 0x6c
240028d4:	681a      	ldr	r2, [r3, #0]
240028d6:	68fb      	ldr	r3, [r7, #12]
240028d8:	6edb      	ldr	r3, [r3, #108]	; 0x6c
240028da:	f442 7280 	orr.w	r2, r2, #256	; 0x100
240028de:	601a      	str	r2, [r3, #0]
      }
    }

    /* Enable the Peripheral */
    __HAL_DMA_ENABLE(hdma);
240028e0:	68fb      	ldr	r3, [r7, #12]
240028e2:	681b      	ldr	r3, [r3, #0]
240028e4:	4a37      	ldr	r2, [pc, #220]	; (240029c4 <HAL_DMA_Start_IT+0x474>)
240028e6:	4293      	cmp	r3, r2
240028e8:	d04a      	beq.n	24002980 <HAL_DMA_Start_IT+0x430>
240028ea:	68fb      	ldr	r3, [r7, #12]
240028ec:	681b      	ldr	r3, [r3, #0]
240028ee:	4a36      	ldr	r2, [pc, #216]	; (240029c8 <HAL_DMA_Start_IT+0x478>)
240028f0:	4293      	cmp	r3, r2
240028f2:	d045      	beq.n	24002980 <HAL_DMA_Start_IT+0x430>
240028f4:	68fb      	ldr	r3, [r7, #12]
240028f6:	681b      	ldr	r3, [r3, #0]
240028f8:	4a34      	ldr	r2, [pc, #208]	; (240029cc <HAL_DMA_Start_IT+0x47c>)
240028fa:	4293      	cmp	r3, r2
240028fc:	d040      	beq.n	24002980 <HAL_DMA_Start_IT+0x430>
240028fe:	68fb      	ldr	r3, [r7, #12]
24002900:	681b      	ldr	r3, [r3, #0]
24002902:	4a33      	ldr	r2, [pc, #204]	; (240029d0 <HAL_DMA_Start_IT+0x480>)
24002904:	4293      	cmp	r3, r2
24002906:	d03b      	beq.n	24002980 <HAL_DMA_Start_IT+0x430>
24002908:	68fb      	ldr	r3, [r7, #12]
2400290a:	681b      	ldr	r3, [r3, #0]
2400290c:	4a31      	ldr	r2, [pc, #196]	; (240029d4 <HAL_DMA_Start_IT+0x484>)
2400290e:	4293      	cmp	r3, r2
24002910:	d036      	beq.n	24002980 <HAL_DMA_Start_IT+0x430>
24002912:	68fb      	ldr	r3, [r7, #12]
24002914:	681b      	ldr	r3, [r3, #0]
24002916:	4a30      	ldr	r2, [pc, #192]	; (240029d8 <HAL_DMA_Start_IT+0x488>)
24002918:	4293      	cmp	r3, r2
2400291a:	d031      	beq.n	24002980 <HAL_DMA_Start_IT+0x430>
2400291c:	68fb      	ldr	r3, [r7, #12]
2400291e:	681b      	ldr	r3, [r3, #0]
24002920:	4a2e      	ldr	r2, [pc, #184]	; (240029dc <HAL_DMA_Start_IT+0x48c>)
24002922:	4293      	cmp	r3, r2
24002924:	d02c      	beq.n	24002980 <HAL_DMA_Start_IT+0x430>
24002926:	68fb      	ldr	r3, [r7, #12]
24002928:	681b      	ldr	r3, [r3, #0]
2400292a:	4a2d      	ldr	r2, [pc, #180]	; (240029e0 <HAL_DMA_Start_IT+0x490>)
2400292c:	4293      	cmp	r3, r2
2400292e:	d027      	beq.n	24002980 <HAL_DMA_Start_IT+0x430>
24002930:	68fb      	ldr	r3, [r7, #12]
24002932:	681b      	ldr	r3, [r3, #0]
24002934:	4a2b      	ldr	r2, [pc, #172]	; (240029e4 <HAL_DMA_Start_IT+0x494>)
24002936:	4293      	cmp	r3, r2
24002938:	d022      	beq.n	24002980 <HAL_DMA_Start_IT+0x430>
2400293a:	68fb      	ldr	r3, [r7, #12]
2400293c:	681b      	ldr	r3, [r3, #0]
2400293e:	4a2a      	ldr	r2, [pc, #168]	; (240029e8 <HAL_DMA_Start_IT+0x498>)
24002940:	4293      	cmp	r3, r2
24002942:	d01d      	beq.n	24002980 <HAL_DMA_Start_IT+0x430>
24002944:	68fb      	ldr	r3, [r7, #12]
24002946:	681b      	ldr	r3, [r3, #0]
24002948:	4a28      	ldr	r2, [pc, #160]	; (240029ec <HAL_DMA_Start_IT+0x49c>)
2400294a:	4293      	cmp	r3, r2
2400294c:	d018      	beq.n	24002980 <HAL_DMA_Start_IT+0x430>
2400294e:	68fb      	ldr	r3, [r7, #12]
24002950:	681b      	ldr	r3, [r3, #0]
24002952:	4a27      	ldr	r2, [pc, #156]	; (240029f0 <HAL_DMA_Start_IT+0x4a0>)
24002954:	4293      	cmp	r3, r2
24002956:	d013      	beq.n	24002980 <HAL_DMA_Start_IT+0x430>
24002958:	68fb      	ldr	r3, [r7, #12]
2400295a:	681b      	ldr	r3, [r3, #0]
2400295c:	4a25      	ldr	r2, [pc, #148]	; (240029f4 <HAL_DMA_Start_IT+0x4a4>)
2400295e:	4293      	cmp	r3, r2
24002960:	d00e      	beq.n	24002980 <HAL_DMA_Start_IT+0x430>
24002962:	68fb      	ldr	r3, [r7, #12]
24002964:	681b      	ldr	r3, [r3, #0]
24002966:	4a24      	ldr	r2, [pc, #144]	; (240029f8 <HAL_DMA_Start_IT+0x4a8>)
24002968:	4293      	cmp	r3, r2
2400296a:	d009      	beq.n	24002980 <HAL_DMA_Start_IT+0x430>
2400296c:	68fb      	ldr	r3, [r7, #12]
2400296e:	681b      	ldr	r3, [r3, #0]
24002970:	4a22      	ldr	r2, [pc, #136]	; (240029fc <HAL_DMA_Start_IT+0x4ac>)
24002972:	4293      	cmp	r3, r2
24002974:	d004      	beq.n	24002980 <HAL_DMA_Start_IT+0x430>
24002976:	68fb      	ldr	r3, [r7, #12]
24002978:	681b      	ldr	r3, [r3, #0]
2400297a:	4a21      	ldr	r2, [pc, #132]	; (24002a00 <HAL_DMA_Start_IT+0x4b0>)
2400297c:	4293      	cmp	r3, r2
2400297e:	d108      	bne.n	24002992 <HAL_DMA_Start_IT+0x442>
24002980:	68fb      	ldr	r3, [r7, #12]
24002982:	681b      	ldr	r3, [r3, #0]
24002984:	681a      	ldr	r2, [r3, #0]
24002986:	68fb      	ldr	r3, [r7, #12]
24002988:	681b      	ldr	r3, [r3, #0]
2400298a:	f042 0201 	orr.w	r2, r2, #1
2400298e:	601a      	str	r2, [r3, #0]
24002990:	e012      	b.n	240029b8 <HAL_DMA_Start_IT+0x468>
24002992:	68fb      	ldr	r3, [r7, #12]
24002994:	681b      	ldr	r3, [r3, #0]
24002996:	681a      	ldr	r2, [r3, #0]
24002998:	68fb      	ldr	r3, [r7, #12]
2400299a:	681b      	ldr	r3, [r3, #0]
2400299c:	f042 0201 	orr.w	r2, r2, #1
240029a0:	601a      	str	r2, [r3, #0]
240029a2:	e009      	b.n	240029b8 <HAL_DMA_Start_IT+0x468>
  }
  else
  {
    /* Process unlocked */
    __HAL_UNLOCK(hdma);
240029a4:	68fb      	ldr	r3, [r7, #12]
240029a6:	2200      	movs	r2, #0
240029a8:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

    /* Set the error code to busy */
    hdma->ErrorCode = HAL_DMA_ERROR_BUSY;
240029ac:	68fb      	ldr	r3, [r7, #12]
240029ae:	f44f 6200 	mov.w	r2, #2048	; 0x800
240029b2:	655a      	str	r2, [r3, #84]	; 0x54

    /* Return error status */
    status = HAL_ERROR;
240029b4:	2301      	movs	r3, #1
240029b6:	75fb      	strb	r3, [r7, #23]
  }

  return status;
240029b8:	7dfb      	ldrb	r3, [r7, #23]
}
240029ba:	4618      	mov	r0, r3
240029bc:	3718      	adds	r7, #24
240029be:	46bd      	mov	sp, r7
240029c0:	bd80      	pop	{r7, pc}
240029c2:	bf00      	nop
240029c4:	40020010 	.word	0x40020010
240029c8:	40020028 	.word	0x40020028
240029cc:	40020040 	.word	0x40020040
240029d0:	40020058 	.word	0x40020058
240029d4:	40020070 	.word	0x40020070
240029d8:	40020088 	.word	0x40020088
240029dc:	400200a0 	.word	0x400200a0
240029e0:	400200b8 	.word	0x400200b8
240029e4:	40020410 	.word	0x40020410
240029e8:	40020428 	.word	0x40020428
240029ec:	40020440 	.word	0x40020440
240029f0:	40020458 	.word	0x40020458
240029f4:	40020470 	.word	0x40020470
240029f8:	40020488 	.word	0x40020488
240029fc:	400204a0 	.word	0x400204a0
24002a00:	400204b8 	.word	0x400204b8
24002a04:	58025408 	.word	0x58025408
24002a08:	5802541c 	.word	0x5802541c
24002a0c:	58025430 	.word	0x58025430
24002a10:	58025444 	.word	0x58025444
24002a14:	58025458 	.word	0x58025458
24002a18:	5802546c 	.word	0x5802546c
24002a1c:	58025480 	.word	0x58025480
24002a20:	58025494 	.word	0x58025494

24002a24 <HAL_DMA_Abort>:
  *        and the Stream will be effectively disabled only after the transfer of
  *        this single data is finished.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Abort(DMA_HandleTypeDef *hdma)
{
24002a24:	b580      	push	{r7, lr}
24002a26:	b086      	sub	sp, #24
24002a28:	af00      	add	r7, sp, #0
24002a2a:	6078      	str	r0, [r7, #4]
  /* calculate DMA base and stream number */
  DMA_Base_Registers *regs_dma;
  BDMA_Base_Registers *regs_bdma;
  const __IO uint32_t *enableRegister;

  uint32_t tickstart = HAL_GetTick();
24002a2c:	f7fd ff12 	bl	24000854 <HAL_GetTick>
24002a30:	6138      	str	r0, [r7, #16]

 /* Check the DMA peripheral handle */
  if(hdma == NULL)
24002a32:	687b      	ldr	r3, [r7, #4]
24002a34:	2b00      	cmp	r3, #0
24002a36:	d101      	bne.n	24002a3c <HAL_DMA_Abort+0x18>
  {
    return HAL_ERROR;
24002a38:	2301      	movs	r3, #1
24002a3a:	e2dc      	b.n	24002ff6 <HAL_DMA_Abort+0x5d2>
  }

  /* Check the DMA peripheral state */
  if(hdma->State != HAL_DMA_STATE_BUSY)
24002a3c:	687b      	ldr	r3, [r7, #4]
24002a3e:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
24002a42:	b2db      	uxtb	r3, r3
24002a44:	2b02      	cmp	r3, #2
24002a46:	d008      	beq.n	24002a5a <HAL_DMA_Abort+0x36>
  {
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
24002a48:	687b      	ldr	r3, [r7, #4]
24002a4a:	2280      	movs	r2, #128	; 0x80
24002a4c:	655a      	str	r2, [r3, #84]	; 0x54

    /* Process Unlocked */
    __HAL_UNLOCK(hdma);
24002a4e:	687b      	ldr	r3, [r7, #4]
24002a50:	2200      	movs	r2, #0
24002a52:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

    return HAL_ERROR;
24002a56:	2301      	movs	r3, #1
24002a58:	e2cd      	b.n	24002ff6 <HAL_DMA_Abort+0x5d2>
  }
  else
  {
    /* Disable all the transfer interrupts */
    if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
24002a5a:	687b      	ldr	r3, [r7, #4]
24002a5c:	681b      	ldr	r3, [r3, #0]
24002a5e:	4a76      	ldr	r2, [pc, #472]	; (24002c38 <HAL_DMA_Abort+0x214>)
24002a60:	4293      	cmp	r3, r2
24002a62:	d04a      	beq.n	24002afa <HAL_DMA_Abort+0xd6>
24002a64:	687b      	ldr	r3, [r7, #4]
24002a66:	681b      	ldr	r3, [r3, #0]
24002a68:	4a74      	ldr	r2, [pc, #464]	; (24002c3c <HAL_DMA_Abort+0x218>)
24002a6a:	4293      	cmp	r3, r2
24002a6c:	d045      	beq.n	24002afa <HAL_DMA_Abort+0xd6>
24002a6e:	687b      	ldr	r3, [r7, #4]
24002a70:	681b      	ldr	r3, [r3, #0]
24002a72:	4a73      	ldr	r2, [pc, #460]	; (24002c40 <HAL_DMA_Abort+0x21c>)
24002a74:	4293      	cmp	r3, r2
24002a76:	d040      	beq.n	24002afa <HAL_DMA_Abort+0xd6>
24002a78:	687b      	ldr	r3, [r7, #4]
24002a7a:	681b      	ldr	r3, [r3, #0]
24002a7c:	4a71      	ldr	r2, [pc, #452]	; (24002c44 <HAL_DMA_Abort+0x220>)
24002a7e:	4293      	cmp	r3, r2
24002a80:	d03b      	beq.n	24002afa <HAL_DMA_Abort+0xd6>
24002a82:	687b      	ldr	r3, [r7, #4]
24002a84:	681b      	ldr	r3, [r3, #0]
24002a86:	4a70      	ldr	r2, [pc, #448]	; (24002c48 <HAL_DMA_Abort+0x224>)
24002a88:	4293      	cmp	r3, r2
24002a8a:	d036      	beq.n	24002afa <HAL_DMA_Abort+0xd6>
24002a8c:	687b      	ldr	r3, [r7, #4]
24002a8e:	681b      	ldr	r3, [r3, #0]
24002a90:	4a6e      	ldr	r2, [pc, #440]	; (24002c4c <HAL_DMA_Abort+0x228>)
24002a92:	4293      	cmp	r3, r2
24002a94:	d031      	beq.n	24002afa <HAL_DMA_Abort+0xd6>
24002a96:	687b      	ldr	r3, [r7, #4]
24002a98:	681b      	ldr	r3, [r3, #0]
24002a9a:	4a6d      	ldr	r2, [pc, #436]	; (24002c50 <HAL_DMA_Abort+0x22c>)
24002a9c:	4293      	cmp	r3, r2
24002a9e:	d02c      	beq.n	24002afa <HAL_DMA_Abort+0xd6>
24002aa0:	687b      	ldr	r3, [r7, #4]
24002aa2:	681b      	ldr	r3, [r3, #0]
24002aa4:	4a6b      	ldr	r2, [pc, #428]	; (24002c54 <HAL_DMA_Abort+0x230>)
24002aa6:	4293      	cmp	r3, r2
24002aa8:	d027      	beq.n	24002afa <HAL_DMA_Abort+0xd6>
24002aaa:	687b      	ldr	r3, [r7, #4]
24002aac:	681b      	ldr	r3, [r3, #0]
24002aae:	4a6a      	ldr	r2, [pc, #424]	; (24002c58 <HAL_DMA_Abort+0x234>)
24002ab0:	4293      	cmp	r3, r2
24002ab2:	d022      	beq.n	24002afa <HAL_DMA_Abort+0xd6>
24002ab4:	687b      	ldr	r3, [r7, #4]
24002ab6:	681b      	ldr	r3, [r3, #0]
24002ab8:	4a68      	ldr	r2, [pc, #416]	; (24002c5c <HAL_DMA_Abort+0x238>)
24002aba:	4293      	cmp	r3, r2
24002abc:	d01d      	beq.n	24002afa <HAL_DMA_Abort+0xd6>
24002abe:	687b      	ldr	r3, [r7, #4]
24002ac0:	681b      	ldr	r3, [r3, #0]
24002ac2:	4a67      	ldr	r2, [pc, #412]	; (24002c60 <HAL_DMA_Abort+0x23c>)
24002ac4:	4293      	cmp	r3, r2
24002ac6:	d018      	beq.n	24002afa <HAL_DMA_Abort+0xd6>
24002ac8:	687b      	ldr	r3, [r7, #4]
24002aca:	681b      	ldr	r3, [r3, #0]
24002acc:	4a65      	ldr	r2, [pc, #404]	; (24002c64 <HAL_DMA_Abort+0x240>)
24002ace:	4293      	cmp	r3, r2
24002ad0:	d013      	beq.n	24002afa <HAL_DMA_Abort+0xd6>
24002ad2:	687b      	ldr	r3, [r7, #4]
24002ad4:	681b      	ldr	r3, [r3, #0]
24002ad6:	4a64      	ldr	r2, [pc, #400]	; (24002c68 <HAL_DMA_Abort+0x244>)
24002ad8:	4293      	cmp	r3, r2
24002ada:	d00e      	beq.n	24002afa <HAL_DMA_Abort+0xd6>
24002adc:	687b      	ldr	r3, [r7, #4]
24002ade:	681b      	ldr	r3, [r3, #0]
24002ae0:	4a62      	ldr	r2, [pc, #392]	; (24002c6c <HAL_DMA_Abort+0x248>)
24002ae2:	4293      	cmp	r3, r2
24002ae4:	d009      	beq.n	24002afa <HAL_DMA_Abort+0xd6>
24002ae6:	687b      	ldr	r3, [r7, #4]
24002ae8:	681b      	ldr	r3, [r3, #0]
24002aea:	4a61      	ldr	r2, [pc, #388]	; (24002c70 <HAL_DMA_Abort+0x24c>)
24002aec:	4293      	cmp	r3, r2
24002aee:	d004      	beq.n	24002afa <HAL_DMA_Abort+0xd6>
24002af0:	687b      	ldr	r3, [r7, #4]
24002af2:	681b      	ldr	r3, [r3, #0]
24002af4:	4a5f      	ldr	r2, [pc, #380]	; (24002c74 <HAL_DMA_Abort+0x250>)
24002af6:	4293      	cmp	r3, r2
24002af8:	d101      	bne.n	24002afe <HAL_DMA_Abort+0xda>
24002afa:	2301      	movs	r3, #1
24002afc:	e000      	b.n	24002b00 <HAL_DMA_Abort+0xdc>
24002afe:	2300      	movs	r3, #0
24002b00:	2b00      	cmp	r3, #0
24002b02:	d013      	beq.n	24002b2c <HAL_DMA_Abort+0x108>
    {
       /* Disable DMA All Interrupts  */
      ((DMA_Stream_TypeDef   *)hdma->Instance)->CR  &= ~(DMA_IT_TC | DMA_IT_TE | DMA_IT_DME | DMA_IT_HT);
24002b04:	687b      	ldr	r3, [r7, #4]
24002b06:	681b      	ldr	r3, [r3, #0]
24002b08:	681a      	ldr	r2, [r3, #0]
24002b0a:	687b      	ldr	r3, [r7, #4]
24002b0c:	681b      	ldr	r3, [r3, #0]
24002b0e:	f022 021e 	bic.w	r2, r2, #30
24002b12:	601a      	str	r2, [r3, #0]
      ((DMA_Stream_TypeDef   *)hdma->Instance)->FCR &= ~(DMA_IT_FE);
24002b14:	687b      	ldr	r3, [r7, #4]
24002b16:	681b      	ldr	r3, [r3, #0]
24002b18:	695a      	ldr	r2, [r3, #20]
24002b1a:	687b      	ldr	r3, [r7, #4]
24002b1c:	681b      	ldr	r3, [r3, #0]
24002b1e:	f022 0280 	bic.w	r2, r2, #128	; 0x80
24002b22:	615a      	str	r2, [r3, #20]

      enableRegister = (__IO uint32_t *)(&(((DMA_Stream_TypeDef   *)hdma->Instance)->CR));
24002b24:	687b      	ldr	r3, [r7, #4]
24002b26:	681b      	ldr	r3, [r3, #0]
24002b28:	617b      	str	r3, [r7, #20]
24002b2a:	e00a      	b.n	24002b42 <HAL_DMA_Abort+0x11e>
    }
    else /* BDMA channel */
    {
      /* Disable DMA All Interrupts */
      ((BDMA_Channel_TypeDef   *)hdma->Instance)->CCR  &= ~(BDMA_CCR_TCIE | BDMA_CCR_HTIE | BDMA_CCR_TEIE);
24002b2c:	687b      	ldr	r3, [r7, #4]
24002b2e:	681b      	ldr	r3, [r3, #0]
24002b30:	681a      	ldr	r2, [r3, #0]
24002b32:	687b      	ldr	r3, [r7, #4]
24002b34:	681b      	ldr	r3, [r3, #0]
24002b36:	f022 020e 	bic.w	r2, r2, #14
24002b3a:	601a      	str	r2, [r3, #0]

      enableRegister = (__IO uint32_t *)(&(((BDMA_Channel_TypeDef   *)hdma->Instance)->CCR));
24002b3c:	687b      	ldr	r3, [r7, #4]
24002b3e:	681b      	ldr	r3, [r3, #0]
24002b40:	617b      	str	r3, [r7, #20]
    }

    if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
24002b42:	687b      	ldr	r3, [r7, #4]
24002b44:	681b      	ldr	r3, [r3, #0]
24002b46:	4a3c      	ldr	r2, [pc, #240]	; (24002c38 <HAL_DMA_Abort+0x214>)
24002b48:	4293      	cmp	r3, r2
24002b4a:	d072      	beq.n	24002c32 <HAL_DMA_Abort+0x20e>
24002b4c:	687b      	ldr	r3, [r7, #4]
24002b4e:	681b      	ldr	r3, [r3, #0]
24002b50:	4a3a      	ldr	r2, [pc, #232]	; (24002c3c <HAL_DMA_Abort+0x218>)
24002b52:	4293      	cmp	r3, r2
24002b54:	d06d      	beq.n	24002c32 <HAL_DMA_Abort+0x20e>
24002b56:	687b      	ldr	r3, [r7, #4]
24002b58:	681b      	ldr	r3, [r3, #0]
24002b5a:	4a39      	ldr	r2, [pc, #228]	; (24002c40 <HAL_DMA_Abort+0x21c>)
24002b5c:	4293      	cmp	r3, r2
24002b5e:	d068      	beq.n	24002c32 <HAL_DMA_Abort+0x20e>
24002b60:	687b      	ldr	r3, [r7, #4]
24002b62:	681b      	ldr	r3, [r3, #0]
24002b64:	4a37      	ldr	r2, [pc, #220]	; (24002c44 <HAL_DMA_Abort+0x220>)
24002b66:	4293      	cmp	r3, r2
24002b68:	d063      	beq.n	24002c32 <HAL_DMA_Abort+0x20e>
24002b6a:	687b      	ldr	r3, [r7, #4]
24002b6c:	681b      	ldr	r3, [r3, #0]
24002b6e:	4a36      	ldr	r2, [pc, #216]	; (24002c48 <HAL_DMA_Abort+0x224>)
24002b70:	4293      	cmp	r3, r2
24002b72:	d05e      	beq.n	24002c32 <HAL_DMA_Abort+0x20e>
24002b74:	687b      	ldr	r3, [r7, #4]
24002b76:	681b      	ldr	r3, [r3, #0]
24002b78:	4a34      	ldr	r2, [pc, #208]	; (24002c4c <HAL_DMA_Abort+0x228>)
24002b7a:	4293      	cmp	r3, r2
24002b7c:	d059      	beq.n	24002c32 <HAL_DMA_Abort+0x20e>
24002b7e:	687b      	ldr	r3, [r7, #4]
24002b80:	681b      	ldr	r3, [r3, #0]
24002b82:	4a33      	ldr	r2, [pc, #204]	; (24002c50 <HAL_DMA_Abort+0x22c>)
24002b84:	4293      	cmp	r3, r2
24002b86:	d054      	beq.n	24002c32 <HAL_DMA_Abort+0x20e>
24002b88:	687b      	ldr	r3, [r7, #4]
24002b8a:	681b      	ldr	r3, [r3, #0]
24002b8c:	4a31      	ldr	r2, [pc, #196]	; (24002c54 <HAL_DMA_Abort+0x230>)
24002b8e:	4293      	cmp	r3, r2
24002b90:	d04f      	beq.n	24002c32 <HAL_DMA_Abort+0x20e>
24002b92:	687b      	ldr	r3, [r7, #4]
24002b94:	681b      	ldr	r3, [r3, #0]
24002b96:	4a30      	ldr	r2, [pc, #192]	; (24002c58 <HAL_DMA_Abort+0x234>)
24002b98:	4293      	cmp	r3, r2
24002b9a:	d04a      	beq.n	24002c32 <HAL_DMA_Abort+0x20e>
24002b9c:	687b      	ldr	r3, [r7, #4]
24002b9e:	681b      	ldr	r3, [r3, #0]
24002ba0:	4a2e      	ldr	r2, [pc, #184]	; (24002c5c <HAL_DMA_Abort+0x238>)
24002ba2:	4293      	cmp	r3, r2
24002ba4:	d045      	beq.n	24002c32 <HAL_DMA_Abort+0x20e>
24002ba6:	687b      	ldr	r3, [r7, #4]
24002ba8:	681b      	ldr	r3, [r3, #0]
24002baa:	4a2d      	ldr	r2, [pc, #180]	; (24002c60 <HAL_DMA_Abort+0x23c>)
24002bac:	4293      	cmp	r3, r2
24002bae:	d040      	beq.n	24002c32 <HAL_DMA_Abort+0x20e>
24002bb0:	687b      	ldr	r3, [r7, #4]
24002bb2:	681b      	ldr	r3, [r3, #0]
24002bb4:	4a2b      	ldr	r2, [pc, #172]	; (24002c64 <HAL_DMA_Abort+0x240>)
24002bb6:	4293      	cmp	r3, r2
24002bb8:	d03b      	beq.n	24002c32 <HAL_DMA_Abort+0x20e>
24002bba:	687b      	ldr	r3, [r7, #4]
24002bbc:	681b      	ldr	r3, [r3, #0]
24002bbe:	4a2a      	ldr	r2, [pc, #168]	; (24002c68 <HAL_DMA_Abort+0x244>)
24002bc0:	4293      	cmp	r3, r2
24002bc2:	d036      	beq.n	24002c32 <HAL_DMA_Abort+0x20e>
24002bc4:	687b      	ldr	r3, [r7, #4]
24002bc6:	681b      	ldr	r3, [r3, #0]
24002bc8:	4a28      	ldr	r2, [pc, #160]	; (24002c6c <HAL_DMA_Abort+0x248>)
24002bca:	4293      	cmp	r3, r2
24002bcc:	d031      	beq.n	24002c32 <HAL_DMA_Abort+0x20e>
24002bce:	687b      	ldr	r3, [r7, #4]
24002bd0:	681b      	ldr	r3, [r3, #0]
24002bd2:	4a27      	ldr	r2, [pc, #156]	; (24002c70 <HAL_DMA_Abort+0x24c>)
24002bd4:	4293      	cmp	r3, r2
24002bd6:	d02c      	beq.n	24002c32 <HAL_DMA_Abort+0x20e>
24002bd8:	687b      	ldr	r3, [r7, #4]
24002bda:	681b      	ldr	r3, [r3, #0]
24002bdc:	4a25      	ldr	r2, [pc, #148]	; (24002c74 <HAL_DMA_Abort+0x250>)
24002bde:	4293      	cmp	r3, r2
24002be0:	d027      	beq.n	24002c32 <HAL_DMA_Abort+0x20e>
24002be2:	687b      	ldr	r3, [r7, #4]
24002be4:	681b      	ldr	r3, [r3, #0]
24002be6:	4a24      	ldr	r2, [pc, #144]	; (24002c78 <HAL_DMA_Abort+0x254>)
24002be8:	4293      	cmp	r3, r2
24002bea:	d022      	beq.n	24002c32 <HAL_DMA_Abort+0x20e>
24002bec:	687b      	ldr	r3, [r7, #4]
24002bee:	681b      	ldr	r3, [r3, #0]
24002bf0:	4a22      	ldr	r2, [pc, #136]	; (24002c7c <HAL_DMA_Abort+0x258>)
24002bf2:	4293      	cmp	r3, r2
24002bf4:	d01d      	beq.n	24002c32 <HAL_DMA_Abort+0x20e>
24002bf6:	687b      	ldr	r3, [r7, #4]
24002bf8:	681b      	ldr	r3, [r3, #0]
24002bfa:	4a21      	ldr	r2, [pc, #132]	; (24002c80 <HAL_DMA_Abort+0x25c>)
24002bfc:	4293      	cmp	r3, r2
24002bfe:	d018      	beq.n	24002c32 <HAL_DMA_Abort+0x20e>
24002c00:	687b      	ldr	r3, [r7, #4]
24002c02:	681b      	ldr	r3, [r3, #0]
24002c04:	4a1f      	ldr	r2, [pc, #124]	; (24002c84 <HAL_DMA_Abort+0x260>)
24002c06:	4293      	cmp	r3, r2
24002c08:	d013      	beq.n	24002c32 <HAL_DMA_Abort+0x20e>
24002c0a:	687b      	ldr	r3, [r7, #4]
24002c0c:	681b      	ldr	r3, [r3, #0]
24002c0e:	4a1e      	ldr	r2, [pc, #120]	; (24002c88 <HAL_DMA_Abort+0x264>)
24002c10:	4293      	cmp	r3, r2
24002c12:	d00e      	beq.n	24002c32 <HAL_DMA_Abort+0x20e>
24002c14:	687b      	ldr	r3, [r7, #4]
24002c16:	681b      	ldr	r3, [r3, #0]
24002c18:	4a1c      	ldr	r2, [pc, #112]	; (24002c8c <HAL_DMA_Abort+0x268>)
24002c1a:	4293      	cmp	r3, r2
24002c1c:	d009      	beq.n	24002c32 <HAL_DMA_Abort+0x20e>
24002c1e:	687b      	ldr	r3, [r7, #4]
24002c20:	681b      	ldr	r3, [r3, #0]
24002c22:	4a1b      	ldr	r2, [pc, #108]	; (24002c90 <HAL_DMA_Abort+0x26c>)
24002c24:	4293      	cmp	r3, r2
24002c26:	d004      	beq.n	24002c32 <HAL_DMA_Abort+0x20e>
24002c28:	687b      	ldr	r3, [r7, #4]
24002c2a:	681b      	ldr	r3, [r3, #0]
24002c2c:	4a19      	ldr	r2, [pc, #100]	; (24002c94 <HAL_DMA_Abort+0x270>)
24002c2e:	4293      	cmp	r3, r2
24002c30:	d132      	bne.n	24002c98 <HAL_DMA_Abort+0x274>
24002c32:	2301      	movs	r3, #1
24002c34:	e031      	b.n	24002c9a <HAL_DMA_Abort+0x276>
24002c36:	bf00      	nop
24002c38:	40020010 	.word	0x40020010
24002c3c:	40020028 	.word	0x40020028
24002c40:	40020040 	.word	0x40020040
24002c44:	40020058 	.word	0x40020058
24002c48:	40020070 	.word	0x40020070
24002c4c:	40020088 	.word	0x40020088
24002c50:	400200a0 	.word	0x400200a0
24002c54:	400200b8 	.word	0x400200b8
24002c58:	40020410 	.word	0x40020410
24002c5c:	40020428 	.word	0x40020428
24002c60:	40020440 	.word	0x40020440
24002c64:	40020458 	.word	0x40020458
24002c68:	40020470 	.word	0x40020470
24002c6c:	40020488 	.word	0x40020488
24002c70:	400204a0 	.word	0x400204a0
24002c74:	400204b8 	.word	0x400204b8
24002c78:	58025408 	.word	0x58025408
24002c7c:	5802541c 	.word	0x5802541c
24002c80:	58025430 	.word	0x58025430
24002c84:	58025444 	.word	0x58025444
24002c88:	58025458 	.word	0x58025458
24002c8c:	5802546c 	.word	0x5802546c
24002c90:	58025480 	.word	0x58025480
24002c94:	58025494 	.word	0x58025494
24002c98:	2300      	movs	r3, #0
24002c9a:	2b00      	cmp	r3, #0
24002c9c:	d007      	beq.n	24002cae <HAL_DMA_Abort+0x28a>
    {
      /* disable the DMAMUX sync overrun IT */
      hdma->DMAmuxChannel->CCR &= ~DMAMUX_CxCR_SOIE;
24002c9e:	687b      	ldr	r3, [r7, #4]
24002ca0:	6e1b      	ldr	r3, [r3, #96]	; 0x60
24002ca2:	681a      	ldr	r2, [r3, #0]
24002ca4:	687b      	ldr	r3, [r7, #4]
24002ca6:	6e1b      	ldr	r3, [r3, #96]	; 0x60
24002ca8:	f422 7280 	bic.w	r2, r2, #256	; 0x100
24002cac:	601a      	str	r2, [r3, #0]
    }

    /* Disable the stream */
    __HAL_DMA_DISABLE(hdma);
24002cae:	687b      	ldr	r3, [r7, #4]
24002cb0:	681b      	ldr	r3, [r3, #0]
24002cb2:	4a6d      	ldr	r2, [pc, #436]	; (24002e68 <HAL_DMA_Abort+0x444>)
24002cb4:	4293      	cmp	r3, r2
24002cb6:	d04a      	beq.n	24002d4e <HAL_DMA_Abort+0x32a>
24002cb8:	687b      	ldr	r3, [r7, #4]
24002cba:	681b      	ldr	r3, [r3, #0]
24002cbc:	4a6b      	ldr	r2, [pc, #428]	; (24002e6c <HAL_DMA_Abort+0x448>)
24002cbe:	4293      	cmp	r3, r2
24002cc0:	d045      	beq.n	24002d4e <HAL_DMA_Abort+0x32a>
24002cc2:	687b      	ldr	r3, [r7, #4]
24002cc4:	681b      	ldr	r3, [r3, #0]
24002cc6:	4a6a      	ldr	r2, [pc, #424]	; (24002e70 <HAL_DMA_Abort+0x44c>)
24002cc8:	4293      	cmp	r3, r2
24002cca:	d040      	beq.n	24002d4e <HAL_DMA_Abort+0x32a>
24002ccc:	687b      	ldr	r3, [r7, #4]
24002cce:	681b      	ldr	r3, [r3, #0]
24002cd0:	4a68      	ldr	r2, [pc, #416]	; (24002e74 <HAL_DMA_Abort+0x450>)
24002cd2:	4293      	cmp	r3, r2
24002cd4:	d03b      	beq.n	24002d4e <HAL_DMA_Abort+0x32a>
24002cd6:	687b      	ldr	r3, [r7, #4]
24002cd8:	681b      	ldr	r3, [r3, #0]
24002cda:	4a67      	ldr	r2, [pc, #412]	; (24002e78 <HAL_DMA_Abort+0x454>)
24002cdc:	4293      	cmp	r3, r2
24002cde:	d036      	beq.n	24002d4e <HAL_DMA_Abort+0x32a>
24002ce0:	687b      	ldr	r3, [r7, #4]
24002ce2:	681b      	ldr	r3, [r3, #0]
24002ce4:	4a65      	ldr	r2, [pc, #404]	; (24002e7c <HAL_DMA_Abort+0x458>)
24002ce6:	4293      	cmp	r3, r2
24002ce8:	d031      	beq.n	24002d4e <HAL_DMA_Abort+0x32a>
24002cea:	687b      	ldr	r3, [r7, #4]
24002cec:	681b      	ldr	r3, [r3, #0]
24002cee:	4a64      	ldr	r2, [pc, #400]	; (24002e80 <HAL_DMA_Abort+0x45c>)
24002cf0:	4293      	cmp	r3, r2
24002cf2:	d02c      	beq.n	24002d4e <HAL_DMA_Abort+0x32a>
24002cf4:	687b      	ldr	r3, [r7, #4]
24002cf6:	681b      	ldr	r3, [r3, #0]
24002cf8:	4a62      	ldr	r2, [pc, #392]	; (24002e84 <HAL_DMA_Abort+0x460>)
24002cfa:	4293      	cmp	r3, r2
24002cfc:	d027      	beq.n	24002d4e <HAL_DMA_Abort+0x32a>
24002cfe:	687b      	ldr	r3, [r7, #4]
24002d00:	681b      	ldr	r3, [r3, #0]
24002d02:	4a61      	ldr	r2, [pc, #388]	; (24002e88 <HAL_DMA_Abort+0x464>)
24002d04:	4293      	cmp	r3, r2
24002d06:	d022      	beq.n	24002d4e <HAL_DMA_Abort+0x32a>
24002d08:	687b      	ldr	r3, [r7, #4]
24002d0a:	681b      	ldr	r3, [r3, #0]
24002d0c:	4a5f      	ldr	r2, [pc, #380]	; (24002e8c <HAL_DMA_Abort+0x468>)
24002d0e:	4293      	cmp	r3, r2
24002d10:	d01d      	beq.n	24002d4e <HAL_DMA_Abort+0x32a>
24002d12:	687b      	ldr	r3, [r7, #4]
24002d14:	681b      	ldr	r3, [r3, #0]
24002d16:	4a5e      	ldr	r2, [pc, #376]	; (24002e90 <HAL_DMA_Abort+0x46c>)
24002d18:	4293      	cmp	r3, r2
24002d1a:	d018      	beq.n	24002d4e <HAL_DMA_Abort+0x32a>
24002d1c:	687b      	ldr	r3, [r7, #4]
24002d1e:	681b      	ldr	r3, [r3, #0]
24002d20:	4a5c      	ldr	r2, [pc, #368]	; (24002e94 <HAL_DMA_Abort+0x470>)
24002d22:	4293      	cmp	r3, r2
24002d24:	d013      	beq.n	24002d4e <HAL_DMA_Abort+0x32a>
24002d26:	687b      	ldr	r3, [r7, #4]
24002d28:	681b      	ldr	r3, [r3, #0]
24002d2a:	4a5b      	ldr	r2, [pc, #364]	; (24002e98 <HAL_DMA_Abort+0x474>)
24002d2c:	4293      	cmp	r3, r2
24002d2e:	d00e      	beq.n	24002d4e <HAL_DMA_Abort+0x32a>
24002d30:	687b      	ldr	r3, [r7, #4]
24002d32:	681b      	ldr	r3, [r3, #0]
24002d34:	4a59      	ldr	r2, [pc, #356]	; (24002e9c <HAL_DMA_Abort+0x478>)
24002d36:	4293      	cmp	r3, r2
24002d38:	d009      	beq.n	24002d4e <HAL_DMA_Abort+0x32a>
24002d3a:	687b      	ldr	r3, [r7, #4]
24002d3c:	681b      	ldr	r3, [r3, #0]
24002d3e:	4a58      	ldr	r2, [pc, #352]	; (24002ea0 <HAL_DMA_Abort+0x47c>)
24002d40:	4293      	cmp	r3, r2
24002d42:	d004      	beq.n	24002d4e <HAL_DMA_Abort+0x32a>
24002d44:	687b      	ldr	r3, [r7, #4]
24002d46:	681b      	ldr	r3, [r3, #0]
24002d48:	4a56      	ldr	r2, [pc, #344]	; (24002ea4 <HAL_DMA_Abort+0x480>)
24002d4a:	4293      	cmp	r3, r2
24002d4c:	d108      	bne.n	24002d60 <HAL_DMA_Abort+0x33c>
24002d4e:	687b      	ldr	r3, [r7, #4]
24002d50:	681b      	ldr	r3, [r3, #0]
24002d52:	681a      	ldr	r2, [r3, #0]
24002d54:	687b      	ldr	r3, [r7, #4]
24002d56:	681b      	ldr	r3, [r3, #0]
24002d58:	f022 0201 	bic.w	r2, r2, #1
24002d5c:	601a      	str	r2, [r3, #0]
24002d5e:	e007      	b.n	24002d70 <HAL_DMA_Abort+0x34c>
24002d60:	687b      	ldr	r3, [r7, #4]
24002d62:	681b      	ldr	r3, [r3, #0]
24002d64:	681a      	ldr	r2, [r3, #0]
24002d66:	687b      	ldr	r3, [r7, #4]
24002d68:	681b      	ldr	r3, [r3, #0]
24002d6a:	f022 0201 	bic.w	r2, r2, #1
24002d6e:	601a      	str	r2, [r3, #0]

    /* Check if the DMA Stream is effectively disabled */
    while(((*enableRegister) & DMA_SxCR_EN) != 0U)
24002d70:	e013      	b.n	24002d9a <HAL_DMA_Abort+0x376>
    {
      /* Check for the Timeout */
      if((HAL_GetTick() - tickstart ) > HAL_TIMEOUT_DMA_ABORT)
24002d72:	f7fd fd6f 	bl	24000854 <HAL_GetTick>
24002d76:	4602      	mov	r2, r0
24002d78:	693b      	ldr	r3, [r7, #16]
24002d7a:	1ad3      	subs	r3, r2, r3
24002d7c:	2b05      	cmp	r3, #5
24002d7e:	d90c      	bls.n	24002d9a <HAL_DMA_Abort+0x376>
      {
        /* Update error code */
        hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
24002d80:	687b      	ldr	r3, [r7, #4]
24002d82:	2220      	movs	r2, #32
24002d84:	655a      	str	r2, [r3, #84]	; 0x54

        /* Process Unlocked */
        __HAL_UNLOCK(hdma);
24002d86:	687b      	ldr	r3, [r7, #4]
24002d88:	2200      	movs	r2, #0
24002d8a:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

        /* Change the DMA state */
        hdma->State = HAL_DMA_STATE_ERROR;
24002d8e:	687b      	ldr	r3, [r7, #4]
24002d90:	2203      	movs	r2, #3
24002d92:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

        return HAL_ERROR;
24002d96:	2301      	movs	r3, #1
24002d98:	e12d      	b.n	24002ff6 <HAL_DMA_Abort+0x5d2>
    while(((*enableRegister) & DMA_SxCR_EN) != 0U)
24002d9a:	697b      	ldr	r3, [r7, #20]
24002d9c:	681b      	ldr	r3, [r3, #0]
24002d9e:	f003 0301 	and.w	r3, r3, #1
24002da2:	2b00      	cmp	r3, #0
24002da4:	d1e5      	bne.n	24002d72 <HAL_DMA_Abort+0x34e>
      }
    }

    /* Clear all interrupt flags at correct offset within the register */
    if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
24002da6:	687b      	ldr	r3, [r7, #4]
24002da8:	681b      	ldr	r3, [r3, #0]
24002daa:	4a2f      	ldr	r2, [pc, #188]	; (24002e68 <HAL_DMA_Abort+0x444>)
24002dac:	4293      	cmp	r3, r2
24002dae:	d04a      	beq.n	24002e46 <HAL_DMA_Abort+0x422>
24002db0:	687b      	ldr	r3, [r7, #4]
24002db2:	681b      	ldr	r3, [r3, #0]
24002db4:	4a2d      	ldr	r2, [pc, #180]	; (24002e6c <HAL_DMA_Abort+0x448>)
24002db6:	4293      	cmp	r3, r2
24002db8:	d045      	beq.n	24002e46 <HAL_DMA_Abort+0x422>
24002dba:	687b      	ldr	r3, [r7, #4]
24002dbc:	681b      	ldr	r3, [r3, #0]
24002dbe:	4a2c      	ldr	r2, [pc, #176]	; (24002e70 <HAL_DMA_Abort+0x44c>)
24002dc0:	4293      	cmp	r3, r2
24002dc2:	d040      	beq.n	24002e46 <HAL_DMA_Abort+0x422>
24002dc4:	687b      	ldr	r3, [r7, #4]
24002dc6:	681b      	ldr	r3, [r3, #0]
24002dc8:	4a2a      	ldr	r2, [pc, #168]	; (24002e74 <HAL_DMA_Abort+0x450>)
24002dca:	4293      	cmp	r3, r2
24002dcc:	d03b      	beq.n	24002e46 <HAL_DMA_Abort+0x422>
24002dce:	687b      	ldr	r3, [r7, #4]
24002dd0:	681b      	ldr	r3, [r3, #0]
24002dd2:	4a29      	ldr	r2, [pc, #164]	; (24002e78 <HAL_DMA_Abort+0x454>)
24002dd4:	4293      	cmp	r3, r2
24002dd6:	d036      	beq.n	24002e46 <HAL_DMA_Abort+0x422>
24002dd8:	687b      	ldr	r3, [r7, #4]
24002dda:	681b      	ldr	r3, [r3, #0]
24002ddc:	4a27      	ldr	r2, [pc, #156]	; (24002e7c <HAL_DMA_Abort+0x458>)
24002dde:	4293      	cmp	r3, r2
24002de0:	d031      	beq.n	24002e46 <HAL_DMA_Abort+0x422>
24002de2:	687b      	ldr	r3, [r7, #4]
24002de4:	681b      	ldr	r3, [r3, #0]
24002de6:	4a26      	ldr	r2, [pc, #152]	; (24002e80 <HAL_DMA_Abort+0x45c>)
24002de8:	4293      	cmp	r3, r2
24002dea:	d02c      	beq.n	24002e46 <HAL_DMA_Abort+0x422>
24002dec:	687b      	ldr	r3, [r7, #4]
24002dee:	681b      	ldr	r3, [r3, #0]
24002df0:	4a24      	ldr	r2, [pc, #144]	; (24002e84 <HAL_DMA_Abort+0x460>)
24002df2:	4293      	cmp	r3, r2
24002df4:	d027      	beq.n	24002e46 <HAL_DMA_Abort+0x422>
24002df6:	687b      	ldr	r3, [r7, #4]
24002df8:	681b      	ldr	r3, [r3, #0]
24002dfa:	4a23      	ldr	r2, [pc, #140]	; (24002e88 <HAL_DMA_Abort+0x464>)
24002dfc:	4293      	cmp	r3, r2
24002dfe:	d022      	beq.n	24002e46 <HAL_DMA_Abort+0x422>
24002e00:	687b      	ldr	r3, [r7, #4]
24002e02:	681b      	ldr	r3, [r3, #0]
24002e04:	4a21      	ldr	r2, [pc, #132]	; (24002e8c <HAL_DMA_Abort+0x468>)
24002e06:	4293      	cmp	r3, r2
24002e08:	d01d      	beq.n	24002e46 <HAL_DMA_Abort+0x422>
24002e0a:	687b      	ldr	r3, [r7, #4]
24002e0c:	681b      	ldr	r3, [r3, #0]
24002e0e:	4a20      	ldr	r2, [pc, #128]	; (24002e90 <HAL_DMA_Abort+0x46c>)
24002e10:	4293      	cmp	r3, r2
24002e12:	d018      	beq.n	24002e46 <HAL_DMA_Abort+0x422>
24002e14:	687b      	ldr	r3, [r7, #4]
24002e16:	681b      	ldr	r3, [r3, #0]
24002e18:	4a1e      	ldr	r2, [pc, #120]	; (24002e94 <HAL_DMA_Abort+0x470>)
24002e1a:	4293      	cmp	r3, r2
24002e1c:	d013      	beq.n	24002e46 <HAL_DMA_Abort+0x422>
24002e1e:	687b      	ldr	r3, [r7, #4]
24002e20:	681b      	ldr	r3, [r3, #0]
24002e22:	4a1d      	ldr	r2, [pc, #116]	; (24002e98 <HAL_DMA_Abort+0x474>)
24002e24:	4293      	cmp	r3, r2
24002e26:	d00e      	beq.n	24002e46 <HAL_DMA_Abort+0x422>
24002e28:	687b      	ldr	r3, [r7, #4]
24002e2a:	681b      	ldr	r3, [r3, #0]
24002e2c:	4a1b      	ldr	r2, [pc, #108]	; (24002e9c <HAL_DMA_Abort+0x478>)
24002e2e:	4293      	cmp	r3, r2
24002e30:	d009      	beq.n	24002e46 <HAL_DMA_Abort+0x422>
24002e32:	687b      	ldr	r3, [r7, #4]
24002e34:	681b      	ldr	r3, [r3, #0]
24002e36:	4a1a      	ldr	r2, [pc, #104]	; (24002ea0 <HAL_DMA_Abort+0x47c>)
24002e38:	4293      	cmp	r3, r2
24002e3a:	d004      	beq.n	24002e46 <HAL_DMA_Abort+0x422>
24002e3c:	687b      	ldr	r3, [r7, #4]
24002e3e:	681b      	ldr	r3, [r3, #0]
24002e40:	4a18      	ldr	r2, [pc, #96]	; (24002ea4 <HAL_DMA_Abort+0x480>)
24002e42:	4293      	cmp	r3, r2
24002e44:	d101      	bne.n	24002e4a <HAL_DMA_Abort+0x426>
24002e46:	2301      	movs	r3, #1
24002e48:	e000      	b.n	24002e4c <HAL_DMA_Abort+0x428>
24002e4a:	2300      	movs	r3, #0
24002e4c:	2b00      	cmp	r3, #0
24002e4e:	d02b      	beq.n	24002ea8 <HAL_DMA_Abort+0x484>
    {
      regs_dma = (DMA_Base_Registers *)hdma->StreamBaseAddress;
24002e50:	687b      	ldr	r3, [r7, #4]
24002e52:	6d9b      	ldr	r3, [r3, #88]	; 0x58
24002e54:	60bb      	str	r3, [r7, #8]
      regs_dma->IFCR = 0x3FUL << (hdma->StreamIndex & 0x1FU);
24002e56:	687b      	ldr	r3, [r7, #4]
24002e58:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
24002e5a:	f003 031f 	and.w	r3, r3, #31
24002e5e:	223f      	movs	r2, #63	; 0x3f
24002e60:	409a      	lsls	r2, r3
24002e62:	68bb      	ldr	r3, [r7, #8]
24002e64:	609a      	str	r2, [r3, #8]
24002e66:	e02a      	b.n	24002ebe <HAL_DMA_Abort+0x49a>
24002e68:	40020010 	.word	0x40020010
24002e6c:	40020028 	.word	0x40020028
24002e70:	40020040 	.word	0x40020040
24002e74:	40020058 	.word	0x40020058
24002e78:	40020070 	.word	0x40020070
24002e7c:	40020088 	.word	0x40020088
24002e80:	400200a0 	.word	0x400200a0
24002e84:	400200b8 	.word	0x400200b8
24002e88:	40020410 	.word	0x40020410
24002e8c:	40020428 	.word	0x40020428
24002e90:	40020440 	.word	0x40020440
24002e94:	40020458 	.word	0x40020458
24002e98:	40020470 	.word	0x40020470
24002e9c:	40020488 	.word	0x40020488
24002ea0:	400204a0 	.word	0x400204a0
24002ea4:	400204b8 	.word	0x400204b8
    }
    else /* BDMA channel */
    {
      regs_bdma = (BDMA_Base_Registers *)hdma->StreamBaseAddress;
24002ea8:	687b      	ldr	r3, [r7, #4]
24002eaa:	6d9b      	ldr	r3, [r3, #88]	; 0x58
24002eac:	60fb      	str	r3, [r7, #12]
      regs_bdma->IFCR = ((BDMA_IFCR_CGIF0) << (hdma->StreamIndex & 0x1FU));
24002eae:	687b      	ldr	r3, [r7, #4]
24002eb0:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
24002eb2:	f003 031f 	and.w	r3, r3, #31
24002eb6:	2201      	movs	r2, #1
24002eb8:	409a      	lsls	r2, r3
24002eba:	68fb      	ldr	r3, [r7, #12]
24002ebc:	605a      	str	r2, [r3, #4]
    }

    if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
24002ebe:	687b      	ldr	r3, [r7, #4]
24002ec0:	681b      	ldr	r3, [r3, #0]
24002ec2:	4a4f      	ldr	r2, [pc, #316]	; (24003000 <HAL_DMA_Abort+0x5dc>)
24002ec4:	4293      	cmp	r3, r2
24002ec6:	d072      	beq.n	24002fae <HAL_DMA_Abort+0x58a>
24002ec8:	687b      	ldr	r3, [r7, #4]
24002eca:	681b      	ldr	r3, [r3, #0]
24002ecc:	4a4d      	ldr	r2, [pc, #308]	; (24003004 <HAL_DMA_Abort+0x5e0>)
24002ece:	4293      	cmp	r3, r2
24002ed0:	d06d      	beq.n	24002fae <HAL_DMA_Abort+0x58a>
24002ed2:	687b      	ldr	r3, [r7, #4]
24002ed4:	681b      	ldr	r3, [r3, #0]
24002ed6:	4a4c      	ldr	r2, [pc, #304]	; (24003008 <HAL_DMA_Abort+0x5e4>)
24002ed8:	4293      	cmp	r3, r2
24002eda:	d068      	beq.n	24002fae <HAL_DMA_Abort+0x58a>
24002edc:	687b      	ldr	r3, [r7, #4]
24002ede:	681b      	ldr	r3, [r3, #0]
24002ee0:	4a4a      	ldr	r2, [pc, #296]	; (2400300c <HAL_DMA_Abort+0x5e8>)
24002ee2:	4293      	cmp	r3, r2
24002ee4:	d063      	beq.n	24002fae <HAL_DMA_Abort+0x58a>
24002ee6:	687b      	ldr	r3, [r7, #4]
24002ee8:	681b      	ldr	r3, [r3, #0]
24002eea:	4a49      	ldr	r2, [pc, #292]	; (24003010 <HAL_DMA_Abort+0x5ec>)
24002eec:	4293      	cmp	r3, r2
24002eee:	d05e      	beq.n	24002fae <HAL_DMA_Abort+0x58a>
24002ef0:	687b      	ldr	r3, [r7, #4]
24002ef2:	681b      	ldr	r3, [r3, #0]
24002ef4:	4a47      	ldr	r2, [pc, #284]	; (24003014 <HAL_DMA_Abort+0x5f0>)
24002ef6:	4293      	cmp	r3, r2
24002ef8:	d059      	beq.n	24002fae <HAL_DMA_Abort+0x58a>
24002efa:	687b      	ldr	r3, [r7, #4]
24002efc:	681b      	ldr	r3, [r3, #0]
24002efe:	4a46      	ldr	r2, [pc, #280]	; (24003018 <HAL_DMA_Abort+0x5f4>)
24002f00:	4293      	cmp	r3, r2
24002f02:	d054      	beq.n	24002fae <HAL_DMA_Abort+0x58a>
24002f04:	687b      	ldr	r3, [r7, #4]
24002f06:	681b      	ldr	r3, [r3, #0]
24002f08:	4a44      	ldr	r2, [pc, #272]	; (2400301c <HAL_DMA_Abort+0x5f8>)
24002f0a:	4293      	cmp	r3, r2
24002f0c:	d04f      	beq.n	24002fae <HAL_DMA_Abort+0x58a>
24002f0e:	687b      	ldr	r3, [r7, #4]
24002f10:	681b      	ldr	r3, [r3, #0]
24002f12:	4a43      	ldr	r2, [pc, #268]	; (24003020 <HAL_DMA_Abort+0x5fc>)
24002f14:	4293      	cmp	r3, r2
24002f16:	d04a      	beq.n	24002fae <HAL_DMA_Abort+0x58a>
24002f18:	687b      	ldr	r3, [r7, #4]
24002f1a:	681b      	ldr	r3, [r3, #0]
24002f1c:	4a41      	ldr	r2, [pc, #260]	; (24003024 <HAL_DMA_Abort+0x600>)
24002f1e:	4293      	cmp	r3, r2
24002f20:	d045      	beq.n	24002fae <HAL_DMA_Abort+0x58a>
24002f22:	687b      	ldr	r3, [r7, #4]
24002f24:	681b      	ldr	r3, [r3, #0]
24002f26:	4a40      	ldr	r2, [pc, #256]	; (24003028 <HAL_DMA_Abort+0x604>)
24002f28:	4293      	cmp	r3, r2
24002f2a:	d040      	beq.n	24002fae <HAL_DMA_Abort+0x58a>
24002f2c:	687b      	ldr	r3, [r7, #4]
24002f2e:	681b      	ldr	r3, [r3, #0]
24002f30:	4a3e      	ldr	r2, [pc, #248]	; (2400302c <HAL_DMA_Abort+0x608>)
24002f32:	4293      	cmp	r3, r2
24002f34:	d03b      	beq.n	24002fae <HAL_DMA_Abort+0x58a>
24002f36:	687b      	ldr	r3, [r7, #4]
24002f38:	681b      	ldr	r3, [r3, #0]
24002f3a:	4a3d      	ldr	r2, [pc, #244]	; (24003030 <HAL_DMA_Abort+0x60c>)
24002f3c:	4293      	cmp	r3, r2
24002f3e:	d036      	beq.n	24002fae <HAL_DMA_Abort+0x58a>
24002f40:	687b      	ldr	r3, [r7, #4]
24002f42:	681b      	ldr	r3, [r3, #0]
24002f44:	4a3b      	ldr	r2, [pc, #236]	; (24003034 <HAL_DMA_Abort+0x610>)
24002f46:	4293      	cmp	r3, r2
24002f48:	d031      	beq.n	24002fae <HAL_DMA_Abort+0x58a>
24002f4a:	687b      	ldr	r3, [r7, #4]
24002f4c:	681b      	ldr	r3, [r3, #0]
24002f4e:	4a3a      	ldr	r2, [pc, #232]	; (24003038 <HAL_DMA_Abort+0x614>)
24002f50:	4293      	cmp	r3, r2
24002f52:	d02c      	beq.n	24002fae <HAL_DMA_Abort+0x58a>
24002f54:	687b      	ldr	r3, [r7, #4]
24002f56:	681b      	ldr	r3, [r3, #0]
24002f58:	4a38      	ldr	r2, [pc, #224]	; (2400303c <HAL_DMA_Abort+0x618>)
24002f5a:	4293      	cmp	r3, r2
24002f5c:	d027      	beq.n	24002fae <HAL_DMA_Abort+0x58a>
24002f5e:	687b      	ldr	r3, [r7, #4]
24002f60:	681b      	ldr	r3, [r3, #0]
24002f62:	4a37      	ldr	r2, [pc, #220]	; (24003040 <HAL_DMA_Abort+0x61c>)
24002f64:	4293      	cmp	r3, r2
24002f66:	d022      	beq.n	24002fae <HAL_DMA_Abort+0x58a>
24002f68:	687b      	ldr	r3, [r7, #4]
24002f6a:	681b      	ldr	r3, [r3, #0]
24002f6c:	4a35      	ldr	r2, [pc, #212]	; (24003044 <HAL_DMA_Abort+0x620>)
24002f6e:	4293      	cmp	r3, r2
24002f70:	d01d      	beq.n	24002fae <HAL_DMA_Abort+0x58a>
24002f72:	687b      	ldr	r3, [r7, #4]
24002f74:	681b      	ldr	r3, [r3, #0]
24002f76:	4a34      	ldr	r2, [pc, #208]	; (24003048 <HAL_DMA_Abort+0x624>)
24002f78:	4293      	cmp	r3, r2
24002f7a:	d018      	beq.n	24002fae <HAL_DMA_Abort+0x58a>
24002f7c:	687b      	ldr	r3, [r7, #4]
24002f7e:	681b      	ldr	r3, [r3, #0]
24002f80:	4a32      	ldr	r2, [pc, #200]	; (2400304c <HAL_DMA_Abort+0x628>)
24002f82:	4293      	cmp	r3, r2
24002f84:	d013      	beq.n	24002fae <HAL_DMA_Abort+0x58a>
24002f86:	687b      	ldr	r3, [r7, #4]
24002f88:	681b      	ldr	r3, [r3, #0]
24002f8a:	4a31      	ldr	r2, [pc, #196]	; (24003050 <HAL_DMA_Abort+0x62c>)
24002f8c:	4293      	cmp	r3, r2
24002f8e:	d00e      	beq.n	24002fae <HAL_DMA_Abort+0x58a>
24002f90:	687b      	ldr	r3, [r7, #4]
24002f92:	681b      	ldr	r3, [r3, #0]
24002f94:	4a2f      	ldr	r2, [pc, #188]	; (24003054 <HAL_DMA_Abort+0x630>)
24002f96:	4293      	cmp	r3, r2
24002f98:	d009      	beq.n	24002fae <HAL_DMA_Abort+0x58a>
24002f9a:	687b      	ldr	r3, [r7, #4]
24002f9c:	681b      	ldr	r3, [r3, #0]
24002f9e:	4a2e      	ldr	r2, [pc, #184]	; (24003058 <HAL_DMA_Abort+0x634>)
24002fa0:	4293      	cmp	r3, r2
24002fa2:	d004      	beq.n	24002fae <HAL_DMA_Abort+0x58a>
24002fa4:	687b      	ldr	r3, [r7, #4]
24002fa6:	681b      	ldr	r3, [r3, #0]
24002fa8:	4a2c      	ldr	r2, [pc, #176]	; (2400305c <HAL_DMA_Abort+0x638>)
24002faa:	4293      	cmp	r3, r2
24002fac:	d101      	bne.n	24002fb2 <HAL_DMA_Abort+0x58e>
24002fae:	2301      	movs	r3, #1
24002fb0:	e000      	b.n	24002fb4 <HAL_DMA_Abort+0x590>
24002fb2:	2300      	movs	r3, #0
24002fb4:	2b00      	cmp	r3, #0
24002fb6:	d015      	beq.n	24002fe4 <HAL_DMA_Abort+0x5c0>
    {
      /* Clear the DMAMUX synchro overrun flag */
      hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
24002fb8:	687b      	ldr	r3, [r7, #4]
24002fba:	6e5b      	ldr	r3, [r3, #100]	; 0x64
24002fbc:	687a      	ldr	r2, [r7, #4]
24002fbe:	6e92      	ldr	r2, [r2, #104]	; 0x68
24002fc0:	605a      	str	r2, [r3, #4]

      if(hdma->DMAmuxRequestGen != 0U)
24002fc2:	687b      	ldr	r3, [r7, #4]
24002fc4:	6edb      	ldr	r3, [r3, #108]	; 0x6c
24002fc6:	2b00      	cmp	r3, #0
24002fc8:	d00c      	beq.n	24002fe4 <HAL_DMA_Abort+0x5c0>
      {
        /* if using DMAMUX request generator, disable the DMAMUX request generator overrun IT */
        /* disable the request gen overrun IT */
        hdma->DMAmuxRequestGen->RGCR &= ~DMAMUX_RGxCR_OIE;
24002fca:	687b      	ldr	r3, [r7, #4]
24002fcc:	6edb      	ldr	r3, [r3, #108]	; 0x6c
24002fce:	681a      	ldr	r2, [r3, #0]
24002fd0:	687b      	ldr	r3, [r7, #4]
24002fd2:	6edb      	ldr	r3, [r3, #108]	; 0x6c
24002fd4:	f422 7280 	bic.w	r2, r2, #256	; 0x100
24002fd8:	601a      	str	r2, [r3, #0]

        /* Clear the DMAMUX request generator overrun flag */
        hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
24002fda:	687b      	ldr	r3, [r7, #4]
24002fdc:	6f1b      	ldr	r3, [r3, #112]	; 0x70
24002fde:	687a      	ldr	r2, [r7, #4]
24002fe0:	6f52      	ldr	r2, [r2, #116]	; 0x74
24002fe2:	605a      	str	r2, [r3, #4]
      }
    }

    /* Process Unlocked */
    __HAL_UNLOCK(hdma);
24002fe4:	687b      	ldr	r3, [r7, #4]
24002fe6:	2200      	movs	r2, #0
24002fe8:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

    /* Change the DMA state */
    hdma->State = HAL_DMA_STATE_READY;
24002fec:	687b      	ldr	r3, [r7, #4]
24002fee:	2201      	movs	r2, #1
24002ff0:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
  }

  return HAL_OK;
24002ff4:	2300      	movs	r3, #0
}
24002ff6:	4618      	mov	r0, r3
24002ff8:	3718      	adds	r7, #24
24002ffa:	46bd      	mov	sp, r7
24002ffc:	bd80      	pop	{r7, pc}
24002ffe:	bf00      	nop
24003000:	40020010 	.word	0x40020010
24003004:	40020028 	.word	0x40020028
24003008:	40020040 	.word	0x40020040
2400300c:	40020058 	.word	0x40020058
24003010:	40020070 	.word	0x40020070
24003014:	40020088 	.word	0x40020088
24003018:	400200a0 	.word	0x400200a0
2400301c:	400200b8 	.word	0x400200b8
24003020:	40020410 	.word	0x40020410
24003024:	40020428 	.word	0x40020428
24003028:	40020440 	.word	0x40020440
2400302c:	40020458 	.word	0x40020458
24003030:	40020470 	.word	0x40020470
24003034:	40020488 	.word	0x40020488
24003038:	400204a0 	.word	0x400204a0
2400303c:	400204b8 	.word	0x400204b8
24003040:	58025408 	.word	0x58025408
24003044:	5802541c 	.word	0x5802541c
24003048:	58025430 	.word	0x58025430
2400304c:	58025444 	.word	0x58025444
24003050:	58025458 	.word	0x58025458
24003054:	5802546c 	.word	0x5802546c
24003058:	58025480 	.word	0x58025480
2400305c:	58025494 	.word	0x58025494

24003060 <HAL_DMA_Abort_IT>:
  * @param  hdma  : pointer to a DMA_HandleTypeDef structure that contains
  *                 the configuration information for the specified DMA Stream.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Abort_IT(DMA_HandleTypeDef *hdma)
{
24003060:	b580      	push	{r7, lr}
24003062:	b084      	sub	sp, #16
24003064:	af00      	add	r7, sp, #0
24003066:	6078      	str	r0, [r7, #4]
  BDMA_Base_Registers *regs_bdma;

  /* Check the DMA peripheral handle */
  if(hdma == NULL)
24003068:	687b      	ldr	r3, [r7, #4]
2400306a:	2b00      	cmp	r3, #0
2400306c:	d101      	bne.n	24003072 <HAL_DMA_Abort_IT+0x12>
  {
    return HAL_ERROR;
2400306e:	2301      	movs	r3, #1
24003070:	e205      	b.n	2400347e <HAL_DMA_Abort_IT+0x41e>
  }

  if(hdma->State != HAL_DMA_STATE_BUSY)
24003072:	687b      	ldr	r3, [r7, #4]
24003074:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
24003078:	b2db      	uxtb	r3, r3
2400307a:	2b02      	cmp	r3, #2
2400307c:	d004      	beq.n	24003088 <HAL_DMA_Abort_IT+0x28>
  {
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
2400307e:	687b      	ldr	r3, [r7, #4]
24003080:	2280      	movs	r2, #128	; 0x80
24003082:	655a      	str	r2, [r3, #84]	; 0x54
    return HAL_ERROR;
24003084:	2301      	movs	r3, #1
24003086:	e1fa      	b.n	2400347e <HAL_DMA_Abort_IT+0x41e>
  }
  else
  {
    if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
24003088:	687b      	ldr	r3, [r7, #4]
2400308a:	681b      	ldr	r3, [r3, #0]
2400308c:	4a8c      	ldr	r2, [pc, #560]	; (240032c0 <HAL_DMA_Abort_IT+0x260>)
2400308e:	4293      	cmp	r3, r2
24003090:	d04a      	beq.n	24003128 <HAL_DMA_Abort_IT+0xc8>
24003092:	687b      	ldr	r3, [r7, #4]
24003094:	681b      	ldr	r3, [r3, #0]
24003096:	4a8b      	ldr	r2, [pc, #556]	; (240032c4 <HAL_DMA_Abort_IT+0x264>)
24003098:	4293      	cmp	r3, r2
2400309a:	d045      	beq.n	24003128 <HAL_DMA_Abort_IT+0xc8>
2400309c:	687b      	ldr	r3, [r7, #4]
2400309e:	681b      	ldr	r3, [r3, #0]
240030a0:	4a89      	ldr	r2, [pc, #548]	; (240032c8 <HAL_DMA_Abort_IT+0x268>)
240030a2:	4293      	cmp	r3, r2
240030a4:	d040      	beq.n	24003128 <HAL_DMA_Abort_IT+0xc8>
240030a6:	687b      	ldr	r3, [r7, #4]
240030a8:	681b      	ldr	r3, [r3, #0]
240030aa:	4a88      	ldr	r2, [pc, #544]	; (240032cc <HAL_DMA_Abort_IT+0x26c>)
240030ac:	4293      	cmp	r3, r2
240030ae:	d03b      	beq.n	24003128 <HAL_DMA_Abort_IT+0xc8>
240030b0:	687b      	ldr	r3, [r7, #4]
240030b2:	681b      	ldr	r3, [r3, #0]
240030b4:	4a86      	ldr	r2, [pc, #536]	; (240032d0 <HAL_DMA_Abort_IT+0x270>)
240030b6:	4293      	cmp	r3, r2
240030b8:	d036      	beq.n	24003128 <HAL_DMA_Abort_IT+0xc8>
240030ba:	687b      	ldr	r3, [r7, #4]
240030bc:	681b      	ldr	r3, [r3, #0]
240030be:	4a85      	ldr	r2, [pc, #532]	; (240032d4 <HAL_DMA_Abort_IT+0x274>)
240030c0:	4293      	cmp	r3, r2
240030c2:	d031      	beq.n	24003128 <HAL_DMA_Abort_IT+0xc8>
240030c4:	687b      	ldr	r3, [r7, #4]
240030c6:	681b      	ldr	r3, [r3, #0]
240030c8:	4a83      	ldr	r2, [pc, #524]	; (240032d8 <HAL_DMA_Abort_IT+0x278>)
240030ca:	4293      	cmp	r3, r2
240030cc:	d02c      	beq.n	24003128 <HAL_DMA_Abort_IT+0xc8>
240030ce:	687b      	ldr	r3, [r7, #4]
240030d0:	681b      	ldr	r3, [r3, #0]
240030d2:	4a82      	ldr	r2, [pc, #520]	; (240032dc <HAL_DMA_Abort_IT+0x27c>)
240030d4:	4293      	cmp	r3, r2
240030d6:	d027      	beq.n	24003128 <HAL_DMA_Abort_IT+0xc8>
240030d8:	687b      	ldr	r3, [r7, #4]
240030da:	681b      	ldr	r3, [r3, #0]
240030dc:	4a80      	ldr	r2, [pc, #512]	; (240032e0 <HAL_DMA_Abort_IT+0x280>)
240030de:	4293      	cmp	r3, r2
240030e0:	d022      	beq.n	24003128 <HAL_DMA_Abort_IT+0xc8>
240030e2:	687b      	ldr	r3, [r7, #4]
240030e4:	681b      	ldr	r3, [r3, #0]
240030e6:	4a7f      	ldr	r2, [pc, #508]	; (240032e4 <HAL_DMA_Abort_IT+0x284>)
240030e8:	4293      	cmp	r3, r2
240030ea:	d01d      	beq.n	24003128 <HAL_DMA_Abort_IT+0xc8>
240030ec:	687b      	ldr	r3, [r7, #4]
240030ee:	681b      	ldr	r3, [r3, #0]
240030f0:	4a7d      	ldr	r2, [pc, #500]	; (240032e8 <HAL_DMA_Abort_IT+0x288>)
240030f2:	4293      	cmp	r3, r2
240030f4:	d018      	beq.n	24003128 <HAL_DMA_Abort_IT+0xc8>
240030f6:	687b      	ldr	r3, [r7, #4]
240030f8:	681b      	ldr	r3, [r3, #0]
240030fa:	4a7c      	ldr	r2, [pc, #496]	; (240032ec <HAL_DMA_Abort_IT+0x28c>)
240030fc:	4293      	cmp	r3, r2
240030fe:	d013      	beq.n	24003128 <HAL_DMA_Abort_IT+0xc8>
24003100:	687b      	ldr	r3, [r7, #4]
24003102:	681b      	ldr	r3, [r3, #0]
24003104:	4a7a      	ldr	r2, [pc, #488]	; (240032f0 <HAL_DMA_Abort_IT+0x290>)
24003106:	4293      	cmp	r3, r2
24003108:	d00e      	beq.n	24003128 <HAL_DMA_Abort_IT+0xc8>
2400310a:	687b      	ldr	r3, [r7, #4]
2400310c:	681b      	ldr	r3, [r3, #0]
2400310e:	4a79      	ldr	r2, [pc, #484]	; (240032f4 <HAL_DMA_Abort_IT+0x294>)
24003110:	4293      	cmp	r3, r2
24003112:	d009      	beq.n	24003128 <HAL_DMA_Abort_IT+0xc8>
24003114:	687b      	ldr	r3, [r7, #4]
24003116:	681b      	ldr	r3, [r3, #0]
24003118:	4a77      	ldr	r2, [pc, #476]	; (240032f8 <HAL_DMA_Abort_IT+0x298>)
2400311a:	4293      	cmp	r3, r2
2400311c:	d004      	beq.n	24003128 <HAL_DMA_Abort_IT+0xc8>
2400311e:	687b      	ldr	r3, [r7, #4]
24003120:	681b      	ldr	r3, [r3, #0]
24003122:	4a76      	ldr	r2, [pc, #472]	; (240032fc <HAL_DMA_Abort_IT+0x29c>)
24003124:	4293      	cmp	r3, r2
24003126:	d101      	bne.n	2400312c <HAL_DMA_Abort_IT+0xcc>
24003128:	2301      	movs	r3, #1
2400312a:	e000      	b.n	2400312e <HAL_DMA_Abort_IT+0xce>
2400312c:	2300      	movs	r3, #0
2400312e:	2b00      	cmp	r3, #0
24003130:	d065      	beq.n	240031fe <HAL_DMA_Abort_IT+0x19e>
    {
      /* Set Abort State  */
      hdma->State = HAL_DMA_STATE_ABORT;
24003132:	687b      	ldr	r3, [r7, #4]
24003134:	2204      	movs	r2, #4
24003136:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

      /* Disable the stream */
      __HAL_DMA_DISABLE(hdma);
2400313a:	687b      	ldr	r3, [r7, #4]
2400313c:	681b      	ldr	r3, [r3, #0]
2400313e:	4a60      	ldr	r2, [pc, #384]	; (240032c0 <HAL_DMA_Abort_IT+0x260>)
24003140:	4293      	cmp	r3, r2
24003142:	d04a      	beq.n	240031da <HAL_DMA_Abort_IT+0x17a>
24003144:	687b      	ldr	r3, [r7, #4]
24003146:	681b      	ldr	r3, [r3, #0]
24003148:	4a5e      	ldr	r2, [pc, #376]	; (240032c4 <HAL_DMA_Abort_IT+0x264>)
2400314a:	4293      	cmp	r3, r2
2400314c:	d045      	beq.n	240031da <HAL_DMA_Abort_IT+0x17a>
2400314e:	687b      	ldr	r3, [r7, #4]
24003150:	681b      	ldr	r3, [r3, #0]
24003152:	4a5d      	ldr	r2, [pc, #372]	; (240032c8 <HAL_DMA_Abort_IT+0x268>)
24003154:	4293      	cmp	r3, r2
24003156:	d040      	beq.n	240031da <HAL_DMA_Abort_IT+0x17a>
24003158:	687b      	ldr	r3, [r7, #4]
2400315a:	681b      	ldr	r3, [r3, #0]
2400315c:	4a5b      	ldr	r2, [pc, #364]	; (240032cc <HAL_DMA_Abort_IT+0x26c>)
2400315e:	4293      	cmp	r3, r2
24003160:	d03b      	beq.n	240031da <HAL_DMA_Abort_IT+0x17a>
24003162:	687b      	ldr	r3, [r7, #4]
24003164:	681b      	ldr	r3, [r3, #0]
24003166:	4a5a      	ldr	r2, [pc, #360]	; (240032d0 <HAL_DMA_Abort_IT+0x270>)
24003168:	4293      	cmp	r3, r2
2400316a:	d036      	beq.n	240031da <HAL_DMA_Abort_IT+0x17a>
2400316c:	687b      	ldr	r3, [r7, #4]
2400316e:	681b      	ldr	r3, [r3, #0]
24003170:	4a58      	ldr	r2, [pc, #352]	; (240032d4 <HAL_DMA_Abort_IT+0x274>)
24003172:	4293      	cmp	r3, r2
24003174:	d031      	beq.n	240031da <HAL_DMA_Abort_IT+0x17a>
24003176:	687b      	ldr	r3, [r7, #4]
24003178:	681b      	ldr	r3, [r3, #0]
2400317a:	4a57      	ldr	r2, [pc, #348]	; (240032d8 <HAL_DMA_Abort_IT+0x278>)
2400317c:	4293      	cmp	r3, r2
2400317e:	d02c      	beq.n	240031da <HAL_DMA_Abort_IT+0x17a>
24003180:	687b      	ldr	r3, [r7, #4]
24003182:	681b      	ldr	r3, [r3, #0]
24003184:	4a55      	ldr	r2, [pc, #340]	; (240032dc <HAL_DMA_Abort_IT+0x27c>)
24003186:	4293      	cmp	r3, r2
24003188:	d027      	beq.n	240031da <HAL_DMA_Abort_IT+0x17a>
2400318a:	687b      	ldr	r3, [r7, #4]
2400318c:	681b      	ldr	r3, [r3, #0]
2400318e:	4a54      	ldr	r2, [pc, #336]	; (240032e0 <HAL_DMA_Abort_IT+0x280>)
24003190:	4293      	cmp	r3, r2
24003192:	d022      	beq.n	240031da <HAL_DMA_Abort_IT+0x17a>
24003194:	687b      	ldr	r3, [r7, #4]
24003196:	681b      	ldr	r3, [r3, #0]
24003198:	4a52      	ldr	r2, [pc, #328]	; (240032e4 <HAL_DMA_Abort_IT+0x284>)
2400319a:	4293      	cmp	r3, r2
2400319c:	d01d      	beq.n	240031da <HAL_DMA_Abort_IT+0x17a>
2400319e:	687b      	ldr	r3, [r7, #4]
240031a0:	681b      	ldr	r3, [r3, #0]
240031a2:	4a51      	ldr	r2, [pc, #324]	; (240032e8 <HAL_DMA_Abort_IT+0x288>)
240031a4:	4293      	cmp	r3, r2
240031a6:	d018      	beq.n	240031da <HAL_DMA_Abort_IT+0x17a>
240031a8:	687b      	ldr	r3, [r7, #4]
240031aa:	681b      	ldr	r3, [r3, #0]
240031ac:	4a4f      	ldr	r2, [pc, #316]	; (240032ec <HAL_DMA_Abort_IT+0x28c>)
240031ae:	4293      	cmp	r3, r2
240031b0:	d013      	beq.n	240031da <HAL_DMA_Abort_IT+0x17a>
240031b2:	687b      	ldr	r3, [r7, #4]
240031b4:	681b      	ldr	r3, [r3, #0]
240031b6:	4a4e      	ldr	r2, [pc, #312]	; (240032f0 <HAL_DMA_Abort_IT+0x290>)
240031b8:	4293      	cmp	r3, r2
240031ba:	d00e      	beq.n	240031da <HAL_DMA_Abort_IT+0x17a>
240031bc:	687b      	ldr	r3, [r7, #4]
240031be:	681b      	ldr	r3, [r3, #0]
240031c0:	4a4c      	ldr	r2, [pc, #304]	; (240032f4 <HAL_DMA_Abort_IT+0x294>)
240031c2:	4293      	cmp	r3, r2
240031c4:	d009      	beq.n	240031da <HAL_DMA_Abort_IT+0x17a>
240031c6:	687b      	ldr	r3, [r7, #4]
240031c8:	681b      	ldr	r3, [r3, #0]
240031ca:	4a4b      	ldr	r2, [pc, #300]	; (240032f8 <HAL_DMA_Abort_IT+0x298>)
240031cc:	4293      	cmp	r3, r2
240031ce:	d004      	beq.n	240031da <HAL_DMA_Abort_IT+0x17a>
240031d0:	687b      	ldr	r3, [r7, #4]
240031d2:	681b      	ldr	r3, [r3, #0]
240031d4:	4a49      	ldr	r2, [pc, #292]	; (240032fc <HAL_DMA_Abort_IT+0x29c>)
240031d6:	4293      	cmp	r3, r2
240031d8:	d108      	bne.n	240031ec <HAL_DMA_Abort_IT+0x18c>
240031da:	687b      	ldr	r3, [r7, #4]
240031dc:	681b      	ldr	r3, [r3, #0]
240031de:	681a      	ldr	r2, [r3, #0]
240031e0:	687b      	ldr	r3, [r7, #4]
240031e2:	681b      	ldr	r3, [r3, #0]
240031e4:	f022 0201 	bic.w	r2, r2, #1
240031e8:	601a      	str	r2, [r3, #0]
240031ea:	e147      	b.n	2400347c <HAL_DMA_Abort_IT+0x41c>
240031ec:	687b      	ldr	r3, [r7, #4]
240031ee:	681b      	ldr	r3, [r3, #0]
240031f0:	681a      	ldr	r2, [r3, #0]
240031f2:	687b      	ldr	r3, [r7, #4]
240031f4:	681b      	ldr	r3, [r3, #0]
240031f6:	f022 0201 	bic.w	r2, r2, #1
240031fa:	601a      	str	r2, [r3, #0]
240031fc:	e13e      	b.n	2400347c <HAL_DMA_Abort_IT+0x41c>
    }
    else /* BDMA channel */
    {
      /* Disable DMA All Interrupts  */
      ((BDMA_Channel_TypeDef   *)hdma->Instance)->CCR  &= ~(BDMA_CCR_TCIE | BDMA_CCR_HTIE | BDMA_CCR_TEIE);
240031fe:	687b      	ldr	r3, [r7, #4]
24003200:	681b      	ldr	r3, [r3, #0]
24003202:	681a      	ldr	r2, [r3, #0]
24003204:	687b      	ldr	r3, [r7, #4]
24003206:	681b      	ldr	r3, [r3, #0]
24003208:	f022 020e 	bic.w	r2, r2, #14
2400320c:	601a      	str	r2, [r3, #0]

      /* Disable the channel */
      __HAL_DMA_DISABLE(hdma);
2400320e:	687b      	ldr	r3, [r7, #4]
24003210:	681b      	ldr	r3, [r3, #0]
24003212:	4a2b      	ldr	r2, [pc, #172]	; (240032c0 <HAL_DMA_Abort_IT+0x260>)
24003214:	4293      	cmp	r3, r2
24003216:	d04a      	beq.n	240032ae <HAL_DMA_Abort_IT+0x24e>
24003218:	687b      	ldr	r3, [r7, #4]
2400321a:	681b      	ldr	r3, [r3, #0]
2400321c:	4a29      	ldr	r2, [pc, #164]	; (240032c4 <HAL_DMA_Abort_IT+0x264>)
2400321e:	4293      	cmp	r3, r2
24003220:	d045      	beq.n	240032ae <HAL_DMA_Abort_IT+0x24e>
24003222:	687b      	ldr	r3, [r7, #4]
24003224:	681b      	ldr	r3, [r3, #0]
24003226:	4a28      	ldr	r2, [pc, #160]	; (240032c8 <HAL_DMA_Abort_IT+0x268>)
24003228:	4293      	cmp	r3, r2
2400322a:	d040      	beq.n	240032ae <HAL_DMA_Abort_IT+0x24e>
2400322c:	687b      	ldr	r3, [r7, #4]
2400322e:	681b      	ldr	r3, [r3, #0]
24003230:	4a26      	ldr	r2, [pc, #152]	; (240032cc <HAL_DMA_Abort_IT+0x26c>)
24003232:	4293      	cmp	r3, r2
24003234:	d03b      	beq.n	240032ae <HAL_DMA_Abort_IT+0x24e>
24003236:	687b      	ldr	r3, [r7, #4]
24003238:	681b      	ldr	r3, [r3, #0]
2400323a:	4a25      	ldr	r2, [pc, #148]	; (240032d0 <HAL_DMA_Abort_IT+0x270>)
2400323c:	4293      	cmp	r3, r2
2400323e:	d036      	beq.n	240032ae <HAL_DMA_Abort_IT+0x24e>
24003240:	687b      	ldr	r3, [r7, #4]
24003242:	681b      	ldr	r3, [r3, #0]
24003244:	4a23      	ldr	r2, [pc, #140]	; (240032d4 <HAL_DMA_Abort_IT+0x274>)
24003246:	4293      	cmp	r3, r2
24003248:	d031      	beq.n	240032ae <HAL_DMA_Abort_IT+0x24e>
2400324a:	687b      	ldr	r3, [r7, #4]
2400324c:	681b      	ldr	r3, [r3, #0]
2400324e:	4a22      	ldr	r2, [pc, #136]	; (240032d8 <HAL_DMA_Abort_IT+0x278>)
24003250:	4293      	cmp	r3, r2
24003252:	d02c      	beq.n	240032ae <HAL_DMA_Abort_IT+0x24e>
24003254:	687b      	ldr	r3, [r7, #4]
24003256:	681b      	ldr	r3, [r3, #0]
24003258:	4a20      	ldr	r2, [pc, #128]	; (240032dc <HAL_DMA_Abort_IT+0x27c>)
2400325a:	4293      	cmp	r3, r2
2400325c:	d027      	beq.n	240032ae <HAL_DMA_Abort_IT+0x24e>
2400325e:	687b      	ldr	r3, [r7, #4]
24003260:	681b      	ldr	r3, [r3, #0]
24003262:	4a1f      	ldr	r2, [pc, #124]	; (240032e0 <HAL_DMA_Abort_IT+0x280>)
24003264:	4293      	cmp	r3, r2
24003266:	d022      	beq.n	240032ae <HAL_DMA_Abort_IT+0x24e>
24003268:	687b      	ldr	r3, [r7, #4]
2400326a:	681b      	ldr	r3, [r3, #0]
2400326c:	4a1d      	ldr	r2, [pc, #116]	; (240032e4 <HAL_DMA_Abort_IT+0x284>)
2400326e:	4293      	cmp	r3, r2
24003270:	d01d      	beq.n	240032ae <HAL_DMA_Abort_IT+0x24e>
24003272:	687b      	ldr	r3, [r7, #4]
24003274:	681b      	ldr	r3, [r3, #0]
24003276:	4a1c      	ldr	r2, [pc, #112]	; (240032e8 <HAL_DMA_Abort_IT+0x288>)
24003278:	4293      	cmp	r3, r2
2400327a:	d018      	beq.n	240032ae <HAL_DMA_Abort_IT+0x24e>
2400327c:	687b      	ldr	r3, [r7, #4]
2400327e:	681b      	ldr	r3, [r3, #0]
24003280:	4a1a      	ldr	r2, [pc, #104]	; (240032ec <HAL_DMA_Abort_IT+0x28c>)
24003282:	4293      	cmp	r3, r2
24003284:	d013      	beq.n	240032ae <HAL_DMA_Abort_IT+0x24e>
24003286:	687b      	ldr	r3, [r7, #4]
24003288:	681b      	ldr	r3, [r3, #0]
2400328a:	4a19      	ldr	r2, [pc, #100]	; (240032f0 <HAL_DMA_Abort_IT+0x290>)
2400328c:	4293      	cmp	r3, r2
2400328e:	d00e      	beq.n	240032ae <HAL_DMA_Abort_IT+0x24e>
24003290:	687b      	ldr	r3, [r7, #4]
24003292:	681b      	ldr	r3, [r3, #0]
24003294:	4a17      	ldr	r2, [pc, #92]	; (240032f4 <HAL_DMA_Abort_IT+0x294>)
24003296:	4293      	cmp	r3, r2
24003298:	d009      	beq.n	240032ae <HAL_DMA_Abort_IT+0x24e>
2400329a:	687b      	ldr	r3, [r7, #4]
2400329c:	681b      	ldr	r3, [r3, #0]
2400329e:	4a16      	ldr	r2, [pc, #88]	; (240032f8 <HAL_DMA_Abort_IT+0x298>)
240032a0:	4293      	cmp	r3, r2
240032a2:	d004      	beq.n	240032ae <HAL_DMA_Abort_IT+0x24e>
240032a4:	687b      	ldr	r3, [r7, #4]
240032a6:	681b      	ldr	r3, [r3, #0]
240032a8:	4a14      	ldr	r2, [pc, #80]	; (240032fc <HAL_DMA_Abort_IT+0x29c>)
240032aa:	4293      	cmp	r3, r2
240032ac:	d128      	bne.n	24003300 <HAL_DMA_Abort_IT+0x2a0>
240032ae:	687b      	ldr	r3, [r7, #4]
240032b0:	681b      	ldr	r3, [r3, #0]
240032b2:	681a      	ldr	r2, [r3, #0]
240032b4:	687b      	ldr	r3, [r7, #4]
240032b6:	681b      	ldr	r3, [r3, #0]
240032b8:	f022 0201 	bic.w	r2, r2, #1
240032bc:	601a      	str	r2, [r3, #0]
240032be:	e027      	b.n	24003310 <HAL_DMA_Abort_IT+0x2b0>
240032c0:	40020010 	.word	0x40020010
240032c4:	40020028 	.word	0x40020028
240032c8:	40020040 	.word	0x40020040
240032cc:	40020058 	.word	0x40020058
240032d0:	40020070 	.word	0x40020070
240032d4:	40020088 	.word	0x40020088
240032d8:	400200a0 	.word	0x400200a0
240032dc:	400200b8 	.word	0x400200b8
240032e0:	40020410 	.word	0x40020410
240032e4:	40020428 	.word	0x40020428
240032e8:	40020440 	.word	0x40020440
240032ec:	40020458 	.word	0x40020458
240032f0:	40020470 	.word	0x40020470
240032f4:	40020488 	.word	0x40020488
240032f8:	400204a0 	.word	0x400204a0
240032fc:	400204b8 	.word	0x400204b8
24003300:	687b      	ldr	r3, [r7, #4]
24003302:	681b      	ldr	r3, [r3, #0]
24003304:	681a      	ldr	r2, [r3, #0]
24003306:	687b      	ldr	r3, [r7, #4]
24003308:	681b      	ldr	r3, [r3, #0]
2400330a:	f022 0201 	bic.w	r2, r2, #1
2400330e:	601a      	str	r2, [r3, #0]

      if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
24003310:	687b      	ldr	r3, [r7, #4]
24003312:	681b      	ldr	r3, [r3, #0]
24003314:	4a5c      	ldr	r2, [pc, #368]	; (24003488 <HAL_DMA_Abort_IT+0x428>)
24003316:	4293      	cmp	r3, r2
24003318:	d072      	beq.n	24003400 <HAL_DMA_Abort_IT+0x3a0>
2400331a:	687b      	ldr	r3, [r7, #4]
2400331c:	681b      	ldr	r3, [r3, #0]
2400331e:	4a5b      	ldr	r2, [pc, #364]	; (2400348c <HAL_DMA_Abort_IT+0x42c>)
24003320:	4293      	cmp	r3, r2
24003322:	d06d      	beq.n	24003400 <HAL_DMA_Abort_IT+0x3a0>
24003324:	687b      	ldr	r3, [r7, #4]
24003326:	681b      	ldr	r3, [r3, #0]
24003328:	4a59      	ldr	r2, [pc, #356]	; (24003490 <HAL_DMA_Abort_IT+0x430>)
2400332a:	4293      	cmp	r3, r2
2400332c:	d068      	beq.n	24003400 <HAL_DMA_Abort_IT+0x3a0>
2400332e:	687b      	ldr	r3, [r7, #4]
24003330:	681b      	ldr	r3, [r3, #0]
24003332:	4a58      	ldr	r2, [pc, #352]	; (24003494 <HAL_DMA_Abort_IT+0x434>)
24003334:	4293      	cmp	r3, r2
24003336:	d063      	beq.n	24003400 <HAL_DMA_Abort_IT+0x3a0>
24003338:	687b      	ldr	r3, [r7, #4]
2400333a:	681b      	ldr	r3, [r3, #0]
2400333c:	4a56      	ldr	r2, [pc, #344]	; (24003498 <HAL_DMA_Abort_IT+0x438>)
2400333e:	4293      	cmp	r3, r2
24003340:	d05e      	beq.n	24003400 <HAL_DMA_Abort_IT+0x3a0>
24003342:	687b      	ldr	r3, [r7, #4]
24003344:	681b      	ldr	r3, [r3, #0]
24003346:	4a55      	ldr	r2, [pc, #340]	; (2400349c <HAL_DMA_Abort_IT+0x43c>)
24003348:	4293      	cmp	r3, r2
2400334a:	d059      	beq.n	24003400 <HAL_DMA_Abort_IT+0x3a0>
2400334c:	687b      	ldr	r3, [r7, #4]
2400334e:	681b      	ldr	r3, [r3, #0]
24003350:	4a53      	ldr	r2, [pc, #332]	; (240034a0 <HAL_DMA_Abort_IT+0x440>)
24003352:	4293      	cmp	r3, r2
24003354:	d054      	beq.n	24003400 <HAL_DMA_Abort_IT+0x3a0>
24003356:	687b      	ldr	r3, [r7, #4]
24003358:	681b      	ldr	r3, [r3, #0]
2400335a:	4a52      	ldr	r2, [pc, #328]	; (240034a4 <HAL_DMA_Abort_IT+0x444>)
2400335c:	4293      	cmp	r3, r2
2400335e:	d04f      	beq.n	24003400 <HAL_DMA_Abort_IT+0x3a0>
24003360:	687b      	ldr	r3, [r7, #4]
24003362:	681b      	ldr	r3, [r3, #0]
24003364:	4a50      	ldr	r2, [pc, #320]	; (240034a8 <HAL_DMA_Abort_IT+0x448>)
24003366:	4293      	cmp	r3, r2
24003368:	d04a      	beq.n	24003400 <HAL_DMA_Abort_IT+0x3a0>
2400336a:	687b      	ldr	r3, [r7, #4]
2400336c:	681b      	ldr	r3, [r3, #0]
2400336e:	4a4f      	ldr	r2, [pc, #316]	; (240034ac <HAL_DMA_Abort_IT+0x44c>)
24003370:	4293      	cmp	r3, r2
24003372:	d045      	beq.n	24003400 <HAL_DMA_Abort_IT+0x3a0>
24003374:	687b      	ldr	r3, [r7, #4]
24003376:	681b      	ldr	r3, [r3, #0]
24003378:	4a4d      	ldr	r2, [pc, #308]	; (240034b0 <HAL_DMA_Abort_IT+0x450>)
2400337a:	4293      	cmp	r3, r2
2400337c:	d040      	beq.n	24003400 <HAL_DMA_Abort_IT+0x3a0>
2400337e:	687b      	ldr	r3, [r7, #4]
24003380:	681b      	ldr	r3, [r3, #0]
24003382:	4a4c      	ldr	r2, [pc, #304]	; (240034b4 <HAL_DMA_Abort_IT+0x454>)
24003384:	4293      	cmp	r3, r2
24003386:	d03b      	beq.n	24003400 <HAL_DMA_Abort_IT+0x3a0>
24003388:	687b      	ldr	r3, [r7, #4]
2400338a:	681b      	ldr	r3, [r3, #0]
2400338c:	4a4a      	ldr	r2, [pc, #296]	; (240034b8 <HAL_DMA_Abort_IT+0x458>)
2400338e:	4293      	cmp	r3, r2
24003390:	d036      	beq.n	24003400 <HAL_DMA_Abort_IT+0x3a0>
24003392:	687b      	ldr	r3, [r7, #4]
24003394:	681b      	ldr	r3, [r3, #0]
24003396:	4a49      	ldr	r2, [pc, #292]	; (240034bc <HAL_DMA_Abort_IT+0x45c>)
24003398:	4293      	cmp	r3, r2
2400339a:	d031      	beq.n	24003400 <HAL_DMA_Abort_IT+0x3a0>
2400339c:	687b      	ldr	r3, [r7, #4]
2400339e:	681b      	ldr	r3, [r3, #0]
240033a0:	4a47      	ldr	r2, [pc, #284]	; (240034c0 <HAL_DMA_Abort_IT+0x460>)
240033a2:	4293      	cmp	r3, r2
240033a4:	d02c      	beq.n	24003400 <HAL_DMA_Abort_IT+0x3a0>
240033a6:	687b      	ldr	r3, [r7, #4]
240033a8:	681b      	ldr	r3, [r3, #0]
240033aa:	4a46      	ldr	r2, [pc, #280]	; (240034c4 <HAL_DMA_Abort_IT+0x464>)
240033ac:	4293      	cmp	r3, r2
240033ae:	d027      	beq.n	24003400 <HAL_DMA_Abort_IT+0x3a0>
240033b0:	687b      	ldr	r3, [r7, #4]
240033b2:	681b      	ldr	r3, [r3, #0]
240033b4:	4a44      	ldr	r2, [pc, #272]	; (240034c8 <HAL_DMA_Abort_IT+0x468>)
240033b6:	4293      	cmp	r3, r2
240033b8:	d022      	beq.n	24003400 <HAL_DMA_Abort_IT+0x3a0>
240033ba:	687b      	ldr	r3, [r7, #4]
240033bc:	681b      	ldr	r3, [r3, #0]
240033be:	4a43      	ldr	r2, [pc, #268]	; (240034cc <HAL_DMA_Abort_IT+0x46c>)
240033c0:	4293      	cmp	r3, r2
240033c2:	d01d      	beq.n	24003400 <HAL_DMA_Abort_IT+0x3a0>
240033c4:	687b      	ldr	r3, [r7, #4]
240033c6:	681b      	ldr	r3, [r3, #0]
240033c8:	4a41      	ldr	r2, [pc, #260]	; (240034d0 <HAL_DMA_Abort_IT+0x470>)
240033ca:	4293      	cmp	r3, r2
240033cc:	d018      	beq.n	24003400 <HAL_DMA_Abort_IT+0x3a0>
240033ce:	687b      	ldr	r3, [r7, #4]
240033d0:	681b      	ldr	r3, [r3, #0]
240033d2:	4a40      	ldr	r2, [pc, #256]	; (240034d4 <HAL_DMA_Abort_IT+0x474>)
240033d4:	4293      	cmp	r3, r2
240033d6:	d013      	beq.n	24003400 <HAL_DMA_Abort_IT+0x3a0>
240033d8:	687b      	ldr	r3, [r7, #4]
240033da:	681b      	ldr	r3, [r3, #0]
240033dc:	4a3e      	ldr	r2, [pc, #248]	; (240034d8 <HAL_DMA_Abort_IT+0x478>)
240033de:	4293      	cmp	r3, r2
240033e0:	d00e      	beq.n	24003400 <HAL_DMA_Abort_IT+0x3a0>
240033e2:	687b      	ldr	r3, [r7, #4]
240033e4:	681b      	ldr	r3, [r3, #0]
240033e6:	4a3d      	ldr	r2, [pc, #244]	; (240034dc <HAL_DMA_Abort_IT+0x47c>)
240033e8:	4293      	cmp	r3, r2
240033ea:	d009      	beq.n	24003400 <HAL_DMA_Abort_IT+0x3a0>
240033ec:	687b      	ldr	r3, [r7, #4]
240033ee:	681b      	ldr	r3, [r3, #0]
240033f0:	4a3b      	ldr	r2, [pc, #236]	; (240034e0 <HAL_DMA_Abort_IT+0x480>)
240033f2:	4293      	cmp	r3, r2
240033f4:	d004      	beq.n	24003400 <HAL_DMA_Abort_IT+0x3a0>
240033f6:	687b      	ldr	r3, [r7, #4]
240033f8:	681b      	ldr	r3, [r3, #0]
240033fa:	4a3a      	ldr	r2, [pc, #232]	; (240034e4 <HAL_DMA_Abort_IT+0x484>)
240033fc:	4293      	cmp	r3, r2
240033fe:	d101      	bne.n	24003404 <HAL_DMA_Abort_IT+0x3a4>
24003400:	2301      	movs	r3, #1
24003402:	e000      	b.n	24003406 <HAL_DMA_Abort_IT+0x3a6>
24003404:	2300      	movs	r3, #0
24003406:	2b00      	cmp	r3, #0
24003408:	d028      	beq.n	2400345c <HAL_DMA_Abort_IT+0x3fc>
      {
        /* disable the DMAMUX sync overrun IT */
        hdma->DMAmuxChannel->CCR &= ~DMAMUX_CxCR_SOIE;
2400340a:	687b      	ldr	r3, [r7, #4]
2400340c:	6e1b      	ldr	r3, [r3, #96]	; 0x60
2400340e:	681a      	ldr	r2, [r3, #0]
24003410:	687b      	ldr	r3, [r7, #4]
24003412:	6e1b      	ldr	r3, [r3, #96]	; 0x60
24003414:	f422 7280 	bic.w	r2, r2, #256	; 0x100
24003418:	601a      	str	r2, [r3, #0]

        /* Clear all flags */
        regs_bdma = (BDMA_Base_Registers *)hdma->StreamBaseAddress;
2400341a:	687b      	ldr	r3, [r7, #4]
2400341c:	6d9b      	ldr	r3, [r3, #88]	; 0x58
2400341e:	60fb      	str	r3, [r7, #12]
        regs_bdma->IFCR = ((BDMA_IFCR_CGIF0) << (hdma->StreamIndex & 0x1FU));
24003420:	687b      	ldr	r3, [r7, #4]
24003422:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
24003424:	f003 031f 	and.w	r3, r3, #31
24003428:	2201      	movs	r2, #1
2400342a:	409a      	lsls	r2, r3
2400342c:	68fb      	ldr	r3, [r7, #12]
2400342e:	605a      	str	r2, [r3, #4]

        /* Clear the DMAMUX synchro overrun flag */
        hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
24003430:	687b      	ldr	r3, [r7, #4]
24003432:	6e5b      	ldr	r3, [r3, #100]	; 0x64
24003434:	687a      	ldr	r2, [r7, #4]
24003436:	6e92      	ldr	r2, [r2, #104]	; 0x68
24003438:	605a      	str	r2, [r3, #4]

        if(hdma->DMAmuxRequestGen != 0U)
2400343a:	687b      	ldr	r3, [r7, #4]
2400343c:	6edb      	ldr	r3, [r3, #108]	; 0x6c
2400343e:	2b00      	cmp	r3, #0
24003440:	d00c      	beq.n	2400345c <HAL_DMA_Abort_IT+0x3fc>
        {
          /* if using DMAMUX request generator, disable the DMAMUX request generator overrun IT*/
          /* disable the request gen overrun IT */
          hdma->DMAmuxRequestGen->RGCR &= ~DMAMUX_RGxCR_OIE;
24003442:	687b      	ldr	r3, [r7, #4]
24003444:	6edb      	ldr	r3, [r3, #108]	; 0x6c
24003446:	681a      	ldr	r2, [r3, #0]
24003448:	687b      	ldr	r3, [r7, #4]
2400344a:	6edb      	ldr	r3, [r3, #108]	; 0x6c
2400344c:	f422 7280 	bic.w	r2, r2, #256	; 0x100
24003450:	601a      	str	r2, [r3, #0]

          /* Clear the DMAMUX request generator overrun flag */
          hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
24003452:	687b      	ldr	r3, [r7, #4]
24003454:	6f1b      	ldr	r3, [r3, #112]	; 0x70
24003456:	687a      	ldr	r2, [r7, #4]
24003458:	6f52      	ldr	r2, [r2, #116]	; 0x74
2400345a:	605a      	str	r2, [r3, #4]
        }
      }

      /* Process Unlocked */
      __HAL_UNLOCK(hdma);
2400345c:	687b      	ldr	r3, [r7, #4]
2400345e:	2200      	movs	r2, #0
24003460:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

      /* Change the DMA state */
      hdma->State = HAL_DMA_STATE_READY;
24003464:	687b      	ldr	r3, [r7, #4]
24003466:	2201      	movs	r2, #1
24003468:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

      /* Call User Abort callback */
      if(hdma->XferAbortCallback != NULL)
2400346c:	687b      	ldr	r3, [r7, #4]
2400346e:	6d1b      	ldr	r3, [r3, #80]	; 0x50
24003470:	2b00      	cmp	r3, #0
24003472:	d003      	beq.n	2400347c <HAL_DMA_Abort_IT+0x41c>
      {
        hdma->XferAbortCallback(hdma);
24003474:	687b      	ldr	r3, [r7, #4]
24003476:	6d1b      	ldr	r3, [r3, #80]	; 0x50
24003478:	6878      	ldr	r0, [r7, #4]
2400347a:	4798      	blx	r3
      }
    }
  }

  return HAL_OK;
2400347c:	2300      	movs	r3, #0
}
2400347e:	4618      	mov	r0, r3
24003480:	3710      	adds	r7, #16
24003482:	46bd      	mov	sp, r7
24003484:	bd80      	pop	{r7, pc}
24003486:	bf00      	nop
24003488:	40020010 	.word	0x40020010
2400348c:	40020028 	.word	0x40020028
24003490:	40020040 	.word	0x40020040
24003494:	40020058 	.word	0x40020058
24003498:	40020070 	.word	0x40020070
2400349c:	40020088 	.word	0x40020088
240034a0:	400200a0 	.word	0x400200a0
240034a4:	400200b8 	.word	0x400200b8
240034a8:	40020410 	.word	0x40020410
240034ac:	40020428 	.word	0x40020428
240034b0:	40020440 	.word	0x40020440
240034b4:	40020458 	.word	0x40020458
240034b8:	40020470 	.word	0x40020470
240034bc:	40020488 	.word	0x40020488
240034c0:	400204a0 	.word	0x400204a0
240034c4:	400204b8 	.word	0x400204b8
240034c8:	58025408 	.word	0x58025408
240034cc:	5802541c 	.word	0x5802541c
240034d0:	58025430 	.word	0x58025430
240034d4:	58025444 	.word	0x58025444
240034d8:	58025458 	.word	0x58025458
240034dc:	5802546c 	.word	0x5802546c
240034e0:	58025480 	.word	0x58025480
240034e4:	58025494 	.word	0x58025494

240034e8 <HAL_DMA_PollForTransfer>:
  * @note   The HAL_DMA_PollForTransfer API cannot be used in circular and double buffering mode (automatic circular mode).
  * @param  Timeout:       Timeout duration.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_PollForTransfer(DMA_HandleTypeDef *hdma, HAL_DMA_LevelCompleteTypeDef CompleteLevel, uint32_t Timeout)
{
240034e8:	b580      	push	{r7, lr}
240034ea:	b08a      	sub	sp, #40	; 0x28
240034ec:	af00      	add	r7, sp, #0
240034ee:	60f8      	str	r0, [r7, #12]
240034f0:	460b      	mov	r3, r1
240034f2:	607a      	str	r2, [r7, #4]
240034f4:	72fb      	strb	r3, [r7, #11]
  HAL_StatusTypeDef status = HAL_OK;
240034f6:	2300      	movs	r3, #0
240034f8:	76fb      	strb	r3, [r7, #27]
  uint32_t cpltlevel_mask;
  uint32_t tickstart = HAL_GetTick();
240034fa:	f7fd f9ab 	bl	24000854 <HAL_GetTick>
240034fe:	6178      	str	r0, [r7, #20]
  __IO uint32_t *isr_reg;
  /* IT clear flag register */
  __IO uint32_t *ifcr_reg;

  /* Check the DMA peripheral handle */
  if(hdma == NULL)
24003500:	68fb      	ldr	r3, [r7, #12]
24003502:	2b00      	cmp	r3, #0
24003504:	d101      	bne.n	2400350a <HAL_DMA_PollForTransfer+0x22>
  {
    return HAL_ERROR;
24003506:	2301      	movs	r3, #1
24003508:	e373      	b.n	24003bf2 <HAL_DMA_PollForTransfer+0x70a>
  }

  if(HAL_DMA_STATE_BUSY != hdma->State)
2400350a:	68fb      	ldr	r3, [r7, #12]
2400350c:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
24003510:	b2db      	uxtb	r3, r3
24003512:	2b02      	cmp	r3, #2
24003514:	d008      	beq.n	24003528 <HAL_DMA_PollForTransfer+0x40>
  {
    /* No transfer ongoing */
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
24003516:	68fb      	ldr	r3, [r7, #12]
24003518:	2280      	movs	r2, #128	; 0x80
2400351a:	655a      	str	r2, [r3, #84]	; 0x54
    __HAL_UNLOCK(hdma);
2400351c:	68fb      	ldr	r3, [r7, #12]
2400351e:	2200      	movs	r2, #0
24003520:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

    return HAL_ERROR;
24003524:	2301      	movs	r3, #1
24003526:	e364      	b.n	24003bf2 <HAL_DMA_PollForTransfer+0x70a>
  }

  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
24003528:	68fb      	ldr	r3, [r7, #12]
2400352a:	681b      	ldr	r3, [r3, #0]
2400352c:	4a7b      	ldr	r2, [pc, #492]	; (2400371c <HAL_DMA_PollForTransfer+0x234>)
2400352e:	4293      	cmp	r3, r2
24003530:	d04a      	beq.n	240035c8 <HAL_DMA_PollForTransfer+0xe0>
24003532:	68fb      	ldr	r3, [r7, #12]
24003534:	681b      	ldr	r3, [r3, #0]
24003536:	4a7a      	ldr	r2, [pc, #488]	; (24003720 <HAL_DMA_PollForTransfer+0x238>)
24003538:	4293      	cmp	r3, r2
2400353a:	d045      	beq.n	240035c8 <HAL_DMA_PollForTransfer+0xe0>
2400353c:	68fb      	ldr	r3, [r7, #12]
2400353e:	681b      	ldr	r3, [r3, #0]
24003540:	4a78      	ldr	r2, [pc, #480]	; (24003724 <HAL_DMA_PollForTransfer+0x23c>)
24003542:	4293      	cmp	r3, r2
24003544:	d040      	beq.n	240035c8 <HAL_DMA_PollForTransfer+0xe0>
24003546:	68fb      	ldr	r3, [r7, #12]
24003548:	681b      	ldr	r3, [r3, #0]
2400354a:	4a77      	ldr	r2, [pc, #476]	; (24003728 <HAL_DMA_PollForTransfer+0x240>)
2400354c:	4293      	cmp	r3, r2
2400354e:	d03b      	beq.n	240035c8 <HAL_DMA_PollForTransfer+0xe0>
24003550:	68fb      	ldr	r3, [r7, #12]
24003552:	681b      	ldr	r3, [r3, #0]
24003554:	4a75      	ldr	r2, [pc, #468]	; (2400372c <HAL_DMA_PollForTransfer+0x244>)
24003556:	4293      	cmp	r3, r2
24003558:	d036      	beq.n	240035c8 <HAL_DMA_PollForTransfer+0xe0>
2400355a:	68fb      	ldr	r3, [r7, #12]
2400355c:	681b      	ldr	r3, [r3, #0]
2400355e:	4a74      	ldr	r2, [pc, #464]	; (24003730 <HAL_DMA_PollForTransfer+0x248>)
24003560:	4293      	cmp	r3, r2
24003562:	d031      	beq.n	240035c8 <HAL_DMA_PollForTransfer+0xe0>
24003564:	68fb      	ldr	r3, [r7, #12]
24003566:	681b      	ldr	r3, [r3, #0]
24003568:	4a72      	ldr	r2, [pc, #456]	; (24003734 <HAL_DMA_PollForTransfer+0x24c>)
2400356a:	4293      	cmp	r3, r2
2400356c:	d02c      	beq.n	240035c8 <HAL_DMA_PollForTransfer+0xe0>
2400356e:	68fb      	ldr	r3, [r7, #12]
24003570:	681b      	ldr	r3, [r3, #0]
24003572:	4a71      	ldr	r2, [pc, #452]	; (24003738 <HAL_DMA_PollForTransfer+0x250>)
24003574:	4293      	cmp	r3, r2
24003576:	d027      	beq.n	240035c8 <HAL_DMA_PollForTransfer+0xe0>
24003578:	68fb      	ldr	r3, [r7, #12]
2400357a:	681b      	ldr	r3, [r3, #0]
2400357c:	4a6f      	ldr	r2, [pc, #444]	; (2400373c <HAL_DMA_PollForTransfer+0x254>)
2400357e:	4293      	cmp	r3, r2
24003580:	d022      	beq.n	240035c8 <HAL_DMA_PollForTransfer+0xe0>
24003582:	68fb      	ldr	r3, [r7, #12]
24003584:	681b      	ldr	r3, [r3, #0]
24003586:	4a6e      	ldr	r2, [pc, #440]	; (24003740 <HAL_DMA_PollForTransfer+0x258>)
24003588:	4293      	cmp	r3, r2
2400358a:	d01d      	beq.n	240035c8 <HAL_DMA_PollForTransfer+0xe0>
2400358c:	68fb      	ldr	r3, [r7, #12]
2400358e:	681b      	ldr	r3, [r3, #0]
24003590:	4a6c      	ldr	r2, [pc, #432]	; (24003744 <HAL_DMA_PollForTransfer+0x25c>)
24003592:	4293      	cmp	r3, r2
24003594:	d018      	beq.n	240035c8 <HAL_DMA_PollForTransfer+0xe0>
24003596:	68fb      	ldr	r3, [r7, #12]
24003598:	681b      	ldr	r3, [r3, #0]
2400359a:	4a6b      	ldr	r2, [pc, #428]	; (24003748 <HAL_DMA_PollForTransfer+0x260>)
2400359c:	4293      	cmp	r3, r2
2400359e:	d013      	beq.n	240035c8 <HAL_DMA_PollForTransfer+0xe0>
240035a0:	68fb      	ldr	r3, [r7, #12]
240035a2:	681b      	ldr	r3, [r3, #0]
240035a4:	4a69      	ldr	r2, [pc, #420]	; (2400374c <HAL_DMA_PollForTransfer+0x264>)
240035a6:	4293      	cmp	r3, r2
240035a8:	d00e      	beq.n	240035c8 <HAL_DMA_PollForTransfer+0xe0>
240035aa:	68fb      	ldr	r3, [r7, #12]
240035ac:	681b      	ldr	r3, [r3, #0]
240035ae:	4a68      	ldr	r2, [pc, #416]	; (24003750 <HAL_DMA_PollForTransfer+0x268>)
240035b0:	4293      	cmp	r3, r2
240035b2:	d009      	beq.n	240035c8 <HAL_DMA_PollForTransfer+0xe0>
240035b4:	68fb      	ldr	r3, [r7, #12]
240035b6:	681b      	ldr	r3, [r3, #0]
240035b8:	4a66      	ldr	r2, [pc, #408]	; (24003754 <HAL_DMA_PollForTransfer+0x26c>)
240035ba:	4293      	cmp	r3, r2
240035bc:	d004      	beq.n	240035c8 <HAL_DMA_PollForTransfer+0xe0>
240035be:	68fb      	ldr	r3, [r7, #12]
240035c0:	681b      	ldr	r3, [r3, #0]
240035c2:	4a65      	ldr	r2, [pc, #404]	; (24003758 <HAL_DMA_PollForTransfer+0x270>)
240035c4:	4293      	cmp	r3, r2
240035c6:	d101      	bne.n	240035cc <HAL_DMA_PollForTransfer+0xe4>
240035c8:	2301      	movs	r3, #1
240035ca:	e000      	b.n	240035ce <HAL_DMA_PollForTransfer+0xe6>
240035cc:	2300      	movs	r3, #0
240035ce:	2b00      	cmp	r3, #0
240035d0:	d028      	beq.n	24003624 <HAL_DMA_PollForTransfer+0x13c>
  {
    /* Polling mode not supported in circular mode and double buffering mode */
    if ((((DMA_Stream_TypeDef   *)hdma->Instance)->CR & DMA_SxCR_CIRC) != 0U)
240035d2:	68fb      	ldr	r3, [r7, #12]
240035d4:	681b      	ldr	r3, [r3, #0]
240035d6:	681b      	ldr	r3, [r3, #0]
240035d8:	f403 7380 	and.w	r3, r3, #256	; 0x100
240035dc:	2b00      	cmp	r3, #0
240035de:	d005      	beq.n	240035ec <HAL_DMA_PollForTransfer+0x104>
    {
      hdma->ErrorCode = HAL_DMA_ERROR_NOT_SUPPORTED;
240035e0:	68fb      	ldr	r3, [r7, #12]
240035e2:	f44f 7280 	mov.w	r2, #256	; 0x100
240035e6:	655a      	str	r2, [r3, #84]	; 0x54
      return HAL_ERROR;
240035e8:	2301      	movs	r3, #1
240035ea:	e302      	b.n	24003bf2 <HAL_DMA_PollForTransfer+0x70a>
    }

    /* Get the level transfer complete flag */
    if(CompleteLevel == HAL_DMA_FULL_TRANSFER)
240035ec:	7afb      	ldrb	r3, [r7, #11]
240035ee:	2b00      	cmp	r3, #0
240035f0:	d108      	bne.n	24003604 <HAL_DMA_PollForTransfer+0x11c>
    {
      /* Transfer Complete flag */
      cpltlevel_mask = DMA_FLAG_TCIF0_4 << (hdma->StreamIndex & 0x1FU);
240035f2:	68fb      	ldr	r3, [r7, #12]
240035f4:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
240035f6:	f003 031f 	and.w	r3, r3, #31
240035fa:	2220      	movs	r2, #32
240035fc:	fa02 f303 	lsl.w	r3, r2, r3
24003600:	627b      	str	r3, [r7, #36]	; 0x24
24003602:	e007      	b.n	24003614 <HAL_DMA_PollForTransfer+0x12c>
    }
    else
    {
      /* Half Transfer Complete flag */
      cpltlevel_mask = DMA_FLAG_HTIF0_4 << (hdma->StreamIndex & 0x1FU);
24003604:	68fb      	ldr	r3, [r7, #12]
24003606:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
24003608:	f003 031f 	and.w	r3, r3, #31
2400360c:	2210      	movs	r2, #16
2400360e:	fa02 f303 	lsl.w	r3, r2, r3
24003612:	627b      	str	r3, [r7, #36]	; 0x24
    }

    isr_reg  = &(((DMA_Base_Registers *)hdma->StreamBaseAddress)->ISR);
24003614:	68fb      	ldr	r3, [r7, #12]
24003616:	6d9b      	ldr	r3, [r3, #88]	; 0x58
24003618:	623b      	str	r3, [r7, #32]
    ifcr_reg = &(((DMA_Base_Registers *)hdma->StreamBaseAddress)->IFCR);
2400361a:	68fb      	ldr	r3, [r7, #12]
2400361c:	6d9b      	ldr	r3, [r3, #88]	; 0x58
2400361e:	3308      	adds	r3, #8
24003620:	61fb      	str	r3, [r7, #28]
24003622:	e1d5      	b.n	240039d0 <HAL_DMA_PollForTransfer+0x4e8>
  }
  else /* BDMA channel */
  {
    /* Polling mode not supported in circular mode */
    if ((((BDMA_Channel_TypeDef   *)hdma->Instance)->CCR & BDMA_CCR_CIRC) != 0U)
24003624:	68fb      	ldr	r3, [r7, #12]
24003626:	681b      	ldr	r3, [r3, #0]
24003628:	681b      	ldr	r3, [r3, #0]
2400362a:	f003 0320 	and.w	r3, r3, #32
2400362e:	2b00      	cmp	r3, #0
24003630:	d005      	beq.n	2400363e <HAL_DMA_PollForTransfer+0x156>
    {
      hdma->ErrorCode = HAL_DMA_ERROR_NOT_SUPPORTED;
24003632:	68fb      	ldr	r3, [r7, #12]
24003634:	f44f 7280 	mov.w	r2, #256	; 0x100
24003638:	655a      	str	r2, [r3, #84]	; 0x54
      return HAL_ERROR;
2400363a:	2301      	movs	r3, #1
2400363c:	e2d9      	b.n	24003bf2 <HAL_DMA_PollForTransfer+0x70a>
    }

    /* Get the level transfer complete flag */
    if(CompleteLevel == HAL_DMA_FULL_TRANSFER)
2400363e:	7afb      	ldrb	r3, [r7, #11]
24003640:	2b00      	cmp	r3, #0
24003642:	d108      	bne.n	24003656 <HAL_DMA_PollForTransfer+0x16e>
    {
      /* Transfer Complete flag */
      cpltlevel_mask = BDMA_FLAG_TC0 << (hdma->StreamIndex & 0x1FU);
24003644:	68fb      	ldr	r3, [r7, #12]
24003646:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
24003648:	f003 031f 	and.w	r3, r3, #31
2400364c:	2202      	movs	r2, #2
2400364e:	fa02 f303 	lsl.w	r3, r2, r3
24003652:	627b      	str	r3, [r7, #36]	; 0x24
24003654:	e007      	b.n	24003666 <HAL_DMA_PollForTransfer+0x17e>
    }
    else
    {
      /* Half Transfer Complete flag */
      cpltlevel_mask = BDMA_FLAG_HT0 << (hdma->StreamIndex & 0x1FU);
24003656:	68fb      	ldr	r3, [r7, #12]
24003658:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
2400365a:	f003 031f 	and.w	r3, r3, #31
2400365e:	2204      	movs	r2, #4
24003660:	fa02 f303 	lsl.w	r3, r2, r3
24003664:	627b      	str	r3, [r7, #36]	; 0x24
    }

    isr_reg  = &(((BDMA_Base_Registers *)hdma->StreamBaseAddress)->ISR);
24003666:	68fb      	ldr	r3, [r7, #12]
24003668:	6d9b      	ldr	r3, [r3, #88]	; 0x58
2400366a:	623b      	str	r3, [r7, #32]
    ifcr_reg = &(((BDMA_Base_Registers *)hdma->StreamBaseAddress)->IFCR);
2400366c:	68fb      	ldr	r3, [r7, #12]
2400366e:	6d9b      	ldr	r3, [r3, #88]	; 0x58
24003670:	3304      	adds	r3, #4
24003672:	61fb      	str	r3, [r7, #28]
  }

  while(((*isr_reg) & cpltlevel_mask) == 0U)
24003674:	e1ac      	b.n	240039d0 <HAL_DMA_PollForTransfer+0x4e8>
  {
    if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
24003676:	68fb      	ldr	r3, [r7, #12]
24003678:	681b      	ldr	r3, [r3, #0]
2400367a:	4a28      	ldr	r2, [pc, #160]	; (2400371c <HAL_DMA_PollForTransfer+0x234>)
2400367c:	4293      	cmp	r3, r2
2400367e:	d04a      	beq.n	24003716 <HAL_DMA_PollForTransfer+0x22e>
24003680:	68fb      	ldr	r3, [r7, #12]
24003682:	681b      	ldr	r3, [r3, #0]
24003684:	4a26      	ldr	r2, [pc, #152]	; (24003720 <HAL_DMA_PollForTransfer+0x238>)
24003686:	4293      	cmp	r3, r2
24003688:	d045      	beq.n	24003716 <HAL_DMA_PollForTransfer+0x22e>
2400368a:	68fb      	ldr	r3, [r7, #12]
2400368c:	681b      	ldr	r3, [r3, #0]
2400368e:	4a25      	ldr	r2, [pc, #148]	; (24003724 <HAL_DMA_PollForTransfer+0x23c>)
24003690:	4293      	cmp	r3, r2
24003692:	d040      	beq.n	24003716 <HAL_DMA_PollForTransfer+0x22e>
24003694:	68fb      	ldr	r3, [r7, #12]
24003696:	681b      	ldr	r3, [r3, #0]
24003698:	4a23      	ldr	r2, [pc, #140]	; (24003728 <HAL_DMA_PollForTransfer+0x240>)
2400369a:	4293      	cmp	r3, r2
2400369c:	d03b      	beq.n	24003716 <HAL_DMA_PollForTransfer+0x22e>
2400369e:	68fb      	ldr	r3, [r7, #12]
240036a0:	681b      	ldr	r3, [r3, #0]
240036a2:	4a22      	ldr	r2, [pc, #136]	; (2400372c <HAL_DMA_PollForTransfer+0x244>)
240036a4:	4293      	cmp	r3, r2
240036a6:	d036      	beq.n	24003716 <HAL_DMA_PollForTransfer+0x22e>
240036a8:	68fb      	ldr	r3, [r7, #12]
240036aa:	681b      	ldr	r3, [r3, #0]
240036ac:	4a20      	ldr	r2, [pc, #128]	; (24003730 <HAL_DMA_PollForTransfer+0x248>)
240036ae:	4293      	cmp	r3, r2
240036b0:	d031      	beq.n	24003716 <HAL_DMA_PollForTransfer+0x22e>
240036b2:	68fb      	ldr	r3, [r7, #12]
240036b4:	681b      	ldr	r3, [r3, #0]
240036b6:	4a1f      	ldr	r2, [pc, #124]	; (24003734 <HAL_DMA_PollForTransfer+0x24c>)
240036b8:	4293      	cmp	r3, r2
240036ba:	d02c      	beq.n	24003716 <HAL_DMA_PollForTransfer+0x22e>
240036bc:	68fb      	ldr	r3, [r7, #12]
240036be:	681b      	ldr	r3, [r3, #0]
240036c0:	4a1d      	ldr	r2, [pc, #116]	; (24003738 <HAL_DMA_PollForTransfer+0x250>)
240036c2:	4293      	cmp	r3, r2
240036c4:	d027      	beq.n	24003716 <HAL_DMA_PollForTransfer+0x22e>
240036c6:	68fb      	ldr	r3, [r7, #12]
240036c8:	681b      	ldr	r3, [r3, #0]
240036ca:	4a1c      	ldr	r2, [pc, #112]	; (2400373c <HAL_DMA_PollForTransfer+0x254>)
240036cc:	4293      	cmp	r3, r2
240036ce:	d022      	beq.n	24003716 <HAL_DMA_PollForTransfer+0x22e>
240036d0:	68fb      	ldr	r3, [r7, #12]
240036d2:	681b      	ldr	r3, [r3, #0]
240036d4:	4a1a      	ldr	r2, [pc, #104]	; (24003740 <HAL_DMA_PollForTransfer+0x258>)
240036d6:	4293      	cmp	r3, r2
240036d8:	d01d      	beq.n	24003716 <HAL_DMA_PollForTransfer+0x22e>
240036da:	68fb      	ldr	r3, [r7, #12]
240036dc:	681b      	ldr	r3, [r3, #0]
240036de:	4a19      	ldr	r2, [pc, #100]	; (24003744 <HAL_DMA_PollForTransfer+0x25c>)
240036e0:	4293      	cmp	r3, r2
240036e2:	d018      	beq.n	24003716 <HAL_DMA_PollForTransfer+0x22e>
240036e4:	68fb      	ldr	r3, [r7, #12]
240036e6:	681b      	ldr	r3, [r3, #0]
240036e8:	4a17      	ldr	r2, [pc, #92]	; (24003748 <HAL_DMA_PollForTransfer+0x260>)
240036ea:	4293      	cmp	r3, r2
240036ec:	d013      	beq.n	24003716 <HAL_DMA_PollForTransfer+0x22e>
240036ee:	68fb      	ldr	r3, [r7, #12]
240036f0:	681b      	ldr	r3, [r3, #0]
240036f2:	4a16      	ldr	r2, [pc, #88]	; (2400374c <HAL_DMA_PollForTransfer+0x264>)
240036f4:	4293      	cmp	r3, r2
240036f6:	d00e      	beq.n	24003716 <HAL_DMA_PollForTransfer+0x22e>
240036f8:	68fb      	ldr	r3, [r7, #12]
240036fa:	681b      	ldr	r3, [r3, #0]
240036fc:	4a14      	ldr	r2, [pc, #80]	; (24003750 <HAL_DMA_PollForTransfer+0x268>)
240036fe:	4293      	cmp	r3, r2
24003700:	d009      	beq.n	24003716 <HAL_DMA_PollForTransfer+0x22e>
24003702:	68fb      	ldr	r3, [r7, #12]
24003704:	681b      	ldr	r3, [r3, #0]
24003706:	4a13      	ldr	r2, [pc, #76]	; (24003754 <HAL_DMA_PollForTransfer+0x26c>)
24003708:	4293      	cmp	r3, r2
2400370a:	d004      	beq.n	24003716 <HAL_DMA_PollForTransfer+0x22e>
2400370c:	68fb      	ldr	r3, [r7, #12]
2400370e:	681b      	ldr	r3, [r3, #0]
24003710:	4a11      	ldr	r2, [pc, #68]	; (24003758 <HAL_DMA_PollForTransfer+0x270>)
24003712:	4293      	cmp	r3, r2
24003714:	d122      	bne.n	2400375c <HAL_DMA_PollForTransfer+0x274>
24003716:	2301      	movs	r3, #1
24003718:	e021      	b.n	2400375e <HAL_DMA_PollForTransfer+0x276>
2400371a:	bf00      	nop
2400371c:	40020010 	.word	0x40020010
24003720:	40020028 	.word	0x40020028
24003724:	40020040 	.word	0x40020040
24003728:	40020058 	.word	0x40020058
2400372c:	40020070 	.word	0x40020070
24003730:	40020088 	.word	0x40020088
24003734:	400200a0 	.word	0x400200a0
24003738:	400200b8 	.word	0x400200b8
2400373c:	40020410 	.word	0x40020410
24003740:	40020428 	.word	0x40020428
24003744:	40020440 	.word	0x40020440
24003748:	40020458 	.word	0x40020458
2400374c:	40020470 	.word	0x40020470
24003750:	40020488 	.word	0x40020488
24003754:	400204a0 	.word	0x400204a0
24003758:	400204b8 	.word	0x400204b8
2400375c:	2300      	movs	r3, #0
2400375e:	2b00      	cmp	r3, #0
24003760:	d057      	beq.n	24003812 <HAL_DMA_PollForTransfer+0x32a>
    {
      if(((*isr_reg) & (DMA_FLAG_FEIF0_4 << (hdma->StreamIndex & 0x1FU))) != 0U)
24003762:	6a3b      	ldr	r3, [r7, #32]
24003764:	681a      	ldr	r2, [r3, #0]
24003766:	68fb      	ldr	r3, [r7, #12]
24003768:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
2400376a:	f003 031f 	and.w	r3, r3, #31
2400376e:	fa22 f303 	lsr.w	r3, r2, r3
24003772:	f003 0301 	and.w	r3, r3, #1
24003776:	2b00      	cmp	r3, #0
24003778:	d00d      	beq.n	24003796 <HAL_DMA_PollForTransfer+0x2ae>
      {
        /* Update error code */
        hdma->ErrorCode |= HAL_DMA_ERROR_FE;
2400377a:	68fb      	ldr	r3, [r7, #12]
2400377c:	6d5b      	ldr	r3, [r3, #84]	; 0x54
2400377e:	f043 0202 	orr.w	r2, r3, #2
24003782:	68fb      	ldr	r3, [r7, #12]
24003784:	655a      	str	r2, [r3, #84]	; 0x54

        /* Clear the FIFO error flag */
        (*ifcr_reg) = DMA_FLAG_FEIF0_4 << (hdma->StreamIndex & 0x1FU);
24003786:	68fb      	ldr	r3, [r7, #12]
24003788:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
2400378a:	f003 031f 	and.w	r3, r3, #31
2400378e:	2201      	movs	r2, #1
24003790:	409a      	lsls	r2, r3
24003792:	69fb      	ldr	r3, [r7, #28]
24003794:	601a      	str	r2, [r3, #0]
      }

      if(((*isr_reg) & (DMA_FLAG_DMEIF0_4 << (hdma->StreamIndex & 0x1FU))) != 0U)
24003796:	6a3b      	ldr	r3, [r7, #32]
24003798:	681a      	ldr	r2, [r3, #0]
2400379a:	68fb      	ldr	r3, [r7, #12]
2400379c:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
2400379e:	f003 031f 	and.w	r3, r3, #31
240037a2:	2104      	movs	r1, #4
240037a4:	fa01 f303 	lsl.w	r3, r1, r3
240037a8:	4013      	ands	r3, r2
240037aa:	2b00      	cmp	r3, #0
240037ac:	d00d      	beq.n	240037ca <HAL_DMA_PollForTransfer+0x2e2>
      {
        /* Update error code */
        hdma->ErrorCode |= HAL_DMA_ERROR_DME;
240037ae:	68fb      	ldr	r3, [r7, #12]
240037b0:	6d5b      	ldr	r3, [r3, #84]	; 0x54
240037b2:	f043 0204 	orr.w	r2, r3, #4
240037b6:	68fb      	ldr	r3, [r7, #12]
240037b8:	655a      	str	r2, [r3, #84]	; 0x54

        /* Clear the Direct Mode error flag */
        (*ifcr_reg) = DMA_FLAG_DMEIF0_4 << (hdma->StreamIndex & 0x1FU);
240037ba:	68fb      	ldr	r3, [r7, #12]
240037bc:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
240037be:	f003 031f 	and.w	r3, r3, #31
240037c2:	2204      	movs	r2, #4
240037c4:	409a      	lsls	r2, r3
240037c6:	69fb      	ldr	r3, [r7, #28]
240037c8:	601a      	str	r2, [r3, #0]
      }

      if(((*isr_reg) & (DMA_FLAG_TEIF0_4 << (hdma->StreamIndex & 0x1FU))) != 0U)
240037ca:	6a3b      	ldr	r3, [r7, #32]
240037cc:	681a      	ldr	r2, [r3, #0]
240037ce:	68fb      	ldr	r3, [r7, #12]
240037d0:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
240037d2:	f003 031f 	and.w	r3, r3, #31
240037d6:	2108      	movs	r1, #8
240037d8:	fa01 f303 	lsl.w	r3, r1, r3
240037dc:	4013      	ands	r3, r2
240037de:	2b00      	cmp	r3, #0
240037e0:	d038      	beq.n	24003854 <HAL_DMA_PollForTransfer+0x36c>
      {
        /* Update error code */
        hdma->ErrorCode |= HAL_DMA_ERROR_TE;
240037e2:	68fb      	ldr	r3, [r7, #12]
240037e4:	6d5b      	ldr	r3, [r3, #84]	; 0x54
240037e6:	f043 0201 	orr.w	r2, r3, #1
240037ea:	68fb      	ldr	r3, [r7, #12]
240037ec:	655a      	str	r2, [r3, #84]	; 0x54

        /* Clear the transfer error flag */
        (*ifcr_reg) = DMA_FLAG_TEIF0_4 << (hdma->StreamIndex & 0x1FU);
240037ee:	68fb      	ldr	r3, [r7, #12]
240037f0:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
240037f2:	f003 031f 	and.w	r3, r3, #31
240037f6:	2208      	movs	r2, #8
240037f8:	409a      	lsls	r2, r3
240037fa:	69fb      	ldr	r3, [r7, #28]
240037fc:	601a      	str	r2, [r3, #0]

        /* Change the DMA state */
        hdma->State = HAL_DMA_STATE_READY;
240037fe:	68fb      	ldr	r3, [r7, #12]
24003800:	2201      	movs	r2, #1
24003802:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

        /* Process Unlocked */
        __HAL_UNLOCK(hdma);
24003806:	68fb      	ldr	r3, [r7, #12]
24003808:	2200      	movs	r2, #0
2400380a:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

        return HAL_ERROR;
2400380e:	2301      	movs	r3, #1
24003810:	e1ef      	b.n	24003bf2 <HAL_DMA_PollForTransfer+0x70a>
      }
    }
    else /* BDMA channel */
    {
      if(((*isr_reg) & (BDMA_FLAG_TE0 << (hdma->StreamIndex & 0x1FU))) != 0U)
24003812:	6a3b      	ldr	r3, [r7, #32]
24003814:	681a      	ldr	r2, [r3, #0]
24003816:	68fb      	ldr	r3, [r7, #12]
24003818:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
2400381a:	f003 031f 	and.w	r3, r3, #31
2400381e:	2108      	movs	r1, #8
24003820:	fa01 f303 	lsl.w	r3, r1, r3
24003824:	4013      	ands	r3, r2
24003826:	2b00      	cmp	r3, #0
24003828:	d014      	beq.n	24003854 <HAL_DMA_PollForTransfer+0x36c>
      {
        /* When a DMA transfer error occurs */
        /* A hardware clear of its EN bits is performed */
        /* Clear all flags */
        (*isr_reg) = ((BDMA_ISR_GIF0) << (hdma->StreamIndex & 0x1FU));
2400382a:	68fb      	ldr	r3, [r7, #12]
2400382c:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
2400382e:	f003 031f 	and.w	r3, r3, #31
24003832:	2201      	movs	r2, #1
24003834:	409a      	lsls	r2, r3
24003836:	6a3b      	ldr	r3, [r7, #32]
24003838:	601a      	str	r2, [r3, #0]

        /* Update error code */
        hdma->ErrorCode = HAL_DMA_ERROR_TE;
2400383a:	68fb      	ldr	r3, [r7, #12]
2400383c:	2201      	movs	r2, #1
2400383e:	655a      	str	r2, [r3, #84]	; 0x54

        /* Change the DMA state */
        hdma->State = HAL_DMA_STATE_READY;
24003840:	68fb      	ldr	r3, [r7, #12]
24003842:	2201      	movs	r2, #1
24003844:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

        /* Process Unlocked */
        __HAL_UNLOCK(hdma);
24003848:	68fb      	ldr	r3, [r7, #12]
2400384a:	2200      	movs	r2, #0
2400384c:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

        return HAL_ERROR;
24003850:	2301      	movs	r3, #1
24003852:	e1ce      	b.n	24003bf2 <HAL_DMA_PollForTransfer+0x70a>
      }
    }

    /* Check for the Timeout (Not applicable in circular mode)*/
    if(Timeout != HAL_MAX_DELAY)
24003854:	687b      	ldr	r3, [r7, #4]
24003856:	f1b3 3fff 	cmp.w	r3, #4294967295
2400385a:	d012      	beq.n	24003882 <HAL_DMA_PollForTransfer+0x39a>
    {
      if(((HAL_GetTick() - tickstart ) > Timeout)||(Timeout == 0U))
2400385c:	f7fc fffa 	bl	24000854 <HAL_GetTick>
24003860:	4602      	mov	r2, r0
24003862:	697b      	ldr	r3, [r7, #20]
24003864:	1ad3      	subs	r3, r2, r3
24003866:	687a      	ldr	r2, [r7, #4]
24003868:	429a      	cmp	r2, r3
2400386a:	d302      	bcc.n	24003872 <HAL_DMA_PollForTransfer+0x38a>
2400386c:	687b      	ldr	r3, [r7, #4]
2400386e:	2b00      	cmp	r3, #0
24003870:	d107      	bne.n	24003882 <HAL_DMA_PollForTransfer+0x39a>
      {
        /* Update error code */
        hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
24003872:	68fb      	ldr	r3, [r7, #12]
24003874:	2220      	movs	r2, #32
24003876:	655a      	str	r2, [r3, #84]	; 0x54

        /* if timeout then abort the current transfer */
        /* No need to check return value: as in this case we will return HAL_ERROR with HAL_DMA_ERROR_TIMEOUT error code  */
        (void) HAL_DMA_Abort(hdma);
24003878:	68f8      	ldr	r0, [r7, #12]
2400387a:	f7ff f8d3 	bl	24002a24 <HAL_DMA_Abort>
              - Clear the transfer error flags
              - Unlock
              - Set the State
          */

        return HAL_ERROR;
2400387e:	2301      	movs	r3, #1
24003880:	e1b7      	b.n	24003bf2 <HAL_DMA_PollForTransfer+0x70a>
      }
    }

    if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
24003882:	68fb      	ldr	r3, [r7, #12]
24003884:	681b      	ldr	r3, [r3, #0]
24003886:	4a8f      	ldr	r2, [pc, #572]	; (24003ac4 <HAL_DMA_PollForTransfer+0x5dc>)
24003888:	4293      	cmp	r3, r2
2400388a:	d072      	beq.n	24003972 <HAL_DMA_PollForTransfer+0x48a>
2400388c:	68fb      	ldr	r3, [r7, #12]
2400388e:	681b      	ldr	r3, [r3, #0]
24003890:	4a8d      	ldr	r2, [pc, #564]	; (24003ac8 <HAL_DMA_PollForTransfer+0x5e0>)
24003892:	4293      	cmp	r3, r2
24003894:	d06d      	beq.n	24003972 <HAL_DMA_PollForTransfer+0x48a>
24003896:	68fb      	ldr	r3, [r7, #12]
24003898:	681b      	ldr	r3, [r3, #0]
2400389a:	4a8c      	ldr	r2, [pc, #560]	; (24003acc <HAL_DMA_PollForTransfer+0x5e4>)
2400389c:	4293      	cmp	r3, r2
2400389e:	d068      	beq.n	24003972 <HAL_DMA_PollForTransfer+0x48a>
240038a0:	68fb      	ldr	r3, [r7, #12]
240038a2:	681b      	ldr	r3, [r3, #0]
240038a4:	4a8a      	ldr	r2, [pc, #552]	; (24003ad0 <HAL_DMA_PollForTransfer+0x5e8>)
240038a6:	4293      	cmp	r3, r2
240038a8:	d063      	beq.n	24003972 <HAL_DMA_PollForTransfer+0x48a>
240038aa:	68fb      	ldr	r3, [r7, #12]
240038ac:	681b      	ldr	r3, [r3, #0]
240038ae:	4a89      	ldr	r2, [pc, #548]	; (24003ad4 <HAL_DMA_PollForTransfer+0x5ec>)
240038b0:	4293      	cmp	r3, r2
240038b2:	d05e      	beq.n	24003972 <HAL_DMA_PollForTransfer+0x48a>
240038b4:	68fb      	ldr	r3, [r7, #12]
240038b6:	681b      	ldr	r3, [r3, #0]
240038b8:	4a87      	ldr	r2, [pc, #540]	; (24003ad8 <HAL_DMA_PollForTransfer+0x5f0>)
240038ba:	4293      	cmp	r3, r2
240038bc:	d059      	beq.n	24003972 <HAL_DMA_PollForTransfer+0x48a>
240038be:	68fb      	ldr	r3, [r7, #12]
240038c0:	681b      	ldr	r3, [r3, #0]
240038c2:	4a86      	ldr	r2, [pc, #536]	; (24003adc <HAL_DMA_PollForTransfer+0x5f4>)
240038c4:	4293      	cmp	r3, r2
240038c6:	d054      	beq.n	24003972 <HAL_DMA_PollForTransfer+0x48a>
240038c8:	68fb      	ldr	r3, [r7, #12]
240038ca:	681b      	ldr	r3, [r3, #0]
240038cc:	4a84      	ldr	r2, [pc, #528]	; (24003ae0 <HAL_DMA_PollForTransfer+0x5f8>)
240038ce:	4293      	cmp	r3, r2
240038d0:	d04f      	beq.n	24003972 <HAL_DMA_PollForTransfer+0x48a>
240038d2:	68fb      	ldr	r3, [r7, #12]
240038d4:	681b      	ldr	r3, [r3, #0]
240038d6:	4a83      	ldr	r2, [pc, #524]	; (24003ae4 <HAL_DMA_PollForTransfer+0x5fc>)
240038d8:	4293      	cmp	r3, r2
240038da:	d04a      	beq.n	24003972 <HAL_DMA_PollForTransfer+0x48a>
240038dc:	68fb      	ldr	r3, [r7, #12]
240038de:	681b      	ldr	r3, [r3, #0]
240038e0:	4a81      	ldr	r2, [pc, #516]	; (24003ae8 <HAL_DMA_PollForTransfer+0x600>)
240038e2:	4293      	cmp	r3, r2
240038e4:	d045      	beq.n	24003972 <HAL_DMA_PollForTransfer+0x48a>
240038e6:	68fb      	ldr	r3, [r7, #12]
240038e8:	681b      	ldr	r3, [r3, #0]
240038ea:	4a80      	ldr	r2, [pc, #512]	; (24003aec <HAL_DMA_PollForTransfer+0x604>)
240038ec:	4293      	cmp	r3, r2
240038ee:	d040      	beq.n	24003972 <HAL_DMA_PollForTransfer+0x48a>
240038f0:	68fb      	ldr	r3, [r7, #12]
240038f2:	681b      	ldr	r3, [r3, #0]
240038f4:	4a7e      	ldr	r2, [pc, #504]	; (24003af0 <HAL_DMA_PollForTransfer+0x608>)
240038f6:	4293      	cmp	r3, r2
240038f8:	d03b      	beq.n	24003972 <HAL_DMA_PollForTransfer+0x48a>
240038fa:	68fb      	ldr	r3, [r7, #12]
240038fc:	681b      	ldr	r3, [r3, #0]
240038fe:	4a7d      	ldr	r2, [pc, #500]	; (24003af4 <HAL_DMA_PollForTransfer+0x60c>)
24003900:	4293      	cmp	r3, r2
24003902:	d036      	beq.n	24003972 <HAL_DMA_PollForTransfer+0x48a>
24003904:	68fb      	ldr	r3, [r7, #12]
24003906:	681b      	ldr	r3, [r3, #0]
24003908:	4a7b      	ldr	r2, [pc, #492]	; (24003af8 <HAL_DMA_PollForTransfer+0x610>)
2400390a:	4293      	cmp	r3, r2
2400390c:	d031      	beq.n	24003972 <HAL_DMA_PollForTransfer+0x48a>
2400390e:	68fb      	ldr	r3, [r7, #12]
24003910:	681b      	ldr	r3, [r3, #0]
24003912:	4a7a      	ldr	r2, [pc, #488]	; (24003afc <HAL_DMA_PollForTransfer+0x614>)
24003914:	4293      	cmp	r3, r2
24003916:	d02c      	beq.n	24003972 <HAL_DMA_PollForTransfer+0x48a>
24003918:	68fb      	ldr	r3, [r7, #12]
2400391a:	681b      	ldr	r3, [r3, #0]
2400391c:	4a78      	ldr	r2, [pc, #480]	; (24003b00 <HAL_DMA_PollForTransfer+0x618>)
2400391e:	4293      	cmp	r3, r2
24003920:	d027      	beq.n	24003972 <HAL_DMA_PollForTransfer+0x48a>
24003922:	68fb      	ldr	r3, [r7, #12]
24003924:	681b      	ldr	r3, [r3, #0]
24003926:	4a77      	ldr	r2, [pc, #476]	; (24003b04 <HAL_DMA_PollForTransfer+0x61c>)
24003928:	4293      	cmp	r3, r2
2400392a:	d022      	beq.n	24003972 <HAL_DMA_PollForTransfer+0x48a>
2400392c:	68fb      	ldr	r3, [r7, #12]
2400392e:	681b      	ldr	r3, [r3, #0]
24003930:	4a75      	ldr	r2, [pc, #468]	; (24003b08 <HAL_DMA_PollForTransfer+0x620>)
24003932:	4293      	cmp	r3, r2
24003934:	d01d      	beq.n	24003972 <HAL_DMA_PollForTransfer+0x48a>
24003936:	68fb      	ldr	r3, [r7, #12]
24003938:	681b      	ldr	r3, [r3, #0]
2400393a:	4a74      	ldr	r2, [pc, #464]	; (24003b0c <HAL_DMA_PollForTransfer+0x624>)
2400393c:	4293      	cmp	r3, r2
2400393e:	d018      	beq.n	24003972 <HAL_DMA_PollForTransfer+0x48a>
24003940:	68fb      	ldr	r3, [r7, #12]
24003942:	681b      	ldr	r3, [r3, #0]
24003944:	4a72      	ldr	r2, [pc, #456]	; (24003b10 <HAL_DMA_PollForTransfer+0x628>)
24003946:	4293      	cmp	r3, r2
24003948:	d013      	beq.n	24003972 <HAL_DMA_PollForTransfer+0x48a>
2400394a:	68fb      	ldr	r3, [r7, #12]
2400394c:	681b      	ldr	r3, [r3, #0]
2400394e:	4a71      	ldr	r2, [pc, #452]	; (24003b14 <HAL_DMA_PollForTransfer+0x62c>)
24003950:	4293      	cmp	r3, r2
24003952:	d00e      	beq.n	24003972 <HAL_DMA_PollForTransfer+0x48a>
24003954:	68fb      	ldr	r3, [r7, #12]
24003956:	681b      	ldr	r3, [r3, #0]
24003958:	4a6f      	ldr	r2, [pc, #444]	; (24003b18 <HAL_DMA_PollForTransfer+0x630>)
2400395a:	4293      	cmp	r3, r2
2400395c:	d009      	beq.n	24003972 <HAL_DMA_PollForTransfer+0x48a>
2400395e:	68fb      	ldr	r3, [r7, #12]
24003960:	681b      	ldr	r3, [r3, #0]
24003962:	4a6e      	ldr	r2, [pc, #440]	; (24003b1c <HAL_DMA_PollForTransfer+0x634>)
24003964:	4293      	cmp	r3, r2
24003966:	d004      	beq.n	24003972 <HAL_DMA_PollForTransfer+0x48a>
24003968:	68fb      	ldr	r3, [r7, #12]
2400396a:	681b      	ldr	r3, [r3, #0]
2400396c:	4a6c      	ldr	r2, [pc, #432]	; (24003b20 <HAL_DMA_PollForTransfer+0x638>)
2400396e:	4293      	cmp	r3, r2
24003970:	d101      	bne.n	24003976 <HAL_DMA_PollForTransfer+0x48e>
24003972:	2301      	movs	r3, #1
24003974:	e000      	b.n	24003978 <HAL_DMA_PollForTransfer+0x490>
24003976:	2300      	movs	r3, #0
24003978:	2b00      	cmp	r3, #0
2400397a:	d029      	beq.n	240039d0 <HAL_DMA_PollForTransfer+0x4e8>
    {
      /* Check for DMAMUX Request generator (if used) overrun status */
      if(hdma->DMAmuxRequestGen != 0U)
2400397c:	68fb      	ldr	r3, [r7, #12]
2400397e:	6edb      	ldr	r3, [r3, #108]	; 0x6c
24003980:	2b00      	cmp	r3, #0
24003982:	d012      	beq.n	240039aa <HAL_DMA_PollForTransfer+0x4c2>
      {
        /* if using DMAMUX request generator Check for DMAMUX request generator overrun */
        if((hdma->DMAmuxRequestGenStatus->RGSR & hdma->DMAmuxRequestGenStatusMask) != 0U)
24003984:	68fb      	ldr	r3, [r7, #12]
24003986:	6f1b      	ldr	r3, [r3, #112]	; 0x70
24003988:	681a      	ldr	r2, [r3, #0]
2400398a:	68fb      	ldr	r3, [r7, #12]
2400398c:	6f5b      	ldr	r3, [r3, #116]	; 0x74
2400398e:	4013      	ands	r3, r2
24003990:	2b00      	cmp	r3, #0
24003992:	d00a      	beq.n	240039aa <HAL_DMA_PollForTransfer+0x4c2>
        {
          /* Clear the DMAMUX request generator overrun flag */
          hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
24003994:	68fb      	ldr	r3, [r7, #12]
24003996:	6f1b      	ldr	r3, [r3, #112]	; 0x70
24003998:	68fa      	ldr	r2, [r7, #12]
2400399a:	6f52      	ldr	r2, [r2, #116]	; 0x74
2400399c:	605a      	str	r2, [r3, #4]

          /* Update error code */
          hdma->ErrorCode |= HAL_DMA_ERROR_REQGEN;
2400399e:	68fb      	ldr	r3, [r7, #12]
240039a0:	6d5b      	ldr	r3, [r3, #84]	; 0x54
240039a2:	f443 6280 	orr.w	r2, r3, #1024	; 0x400
240039a6:	68fb      	ldr	r3, [r7, #12]
240039a8:	655a      	str	r2, [r3, #84]	; 0x54
        }
      }

      /* Check for DMAMUX Synchronization overrun */
      if((hdma->DMAmuxChannelStatus->CSR & hdma->DMAmuxChannelStatusMask) != 0U)
240039aa:	68fb      	ldr	r3, [r7, #12]
240039ac:	6e5b      	ldr	r3, [r3, #100]	; 0x64
240039ae:	681a      	ldr	r2, [r3, #0]
240039b0:	68fb      	ldr	r3, [r7, #12]
240039b2:	6e9b      	ldr	r3, [r3, #104]	; 0x68
240039b4:	4013      	ands	r3, r2
240039b6:	2b00      	cmp	r3, #0
240039b8:	d00a      	beq.n	240039d0 <HAL_DMA_PollForTransfer+0x4e8>
      {
        /* Clear the DMAMUX synchro overrun flag */
        hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
240039ba:	68fb      	ldr	r3, [r7, #12]
240039bc:	6e5b      	ldr	r3, [r3, #100]	; 0x64
240039be:	68fa      	ldr	r2, [r7, #12]
240039c0:	6e92      	ldr	r2, [r2, #104]	; 0x68
240039c2:	605a      	str	r2, [r3, #4]

        /* Update error code */
        hdma->ErrorCode |= HAL_DMA_ERROR_SYNC;
240039c4:	68fb      	ldr	r3, [r7, #12]
240039c6:	6d5b      	ldr	r3, [r3, #84]	; 0x54
240039c8:	f443 7200 	orr.w	r2, r3, #512	; 0x200
240039cc:	68fb      	ldr	r3, [r7, #12]
240039ce:	655a      	str	r2, [r3, #84]	; 0x54
  while(((*isr_reg) & cpltlevel_mask) == 0U)
240039d0:	6a3b      	ldr	r3, [r7, #32]
240039d2:	681a      	ldr	r2, [r3, #0]
240039d4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
240039d6:	4013      	ands	r3, r2
240039d8:	2b00      	cmp	r3, #0
240039da:	f43f ae4c 	beq.w	24003676 <HAL_DMA_PollForTransfer+0x18e>
    }
  }


  /* Get the level transfer complete flag */
  if(CompleteLevel == HAL_DMA_FULL_TRANSFER)
240039de:	7afb      	ldrb	r3, [r7, #11]
240039e0:	2b00      	cmp	r3, #0
240039e2:	f040 809f 	bne.w	24003b24 <HAL_DMA_PollForTransfer+0x63c>
  {
    /* Clear the half transfer and transfer complete flags */
    if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
240039e6:	68fb      	ldr	r3, [r7, #12]
240039e8:	681b      	ldr	r3, [r3, #0]
240039ea:	4a36      	ldr	r2, [pc, #216]	; (24003ac4 <HAL_DMA_PollForTransfer+0x5dc>)
240039ec:	4293      	cmp	r3, r2
240039ee:	d04a      	beq.n	24003a86 <HAL_DMA_PollForTransfer+0x59e>
240039f0:	68fb      	ldr	r3, [r7, #12]
240039f2:	681b      	ldr	r3, [r3, #0]
240039f4:	4a34      	ldr	r2, [pc, #208]	; (24003ac8 <HAL_DMA_PollForTransfer+0x5e0>)
240039f6:	4293      	cmp	r3, r2
240039f8:	d045      	beq.n	24003a86 <HAL_DMA_PollForTransfer+0x59e>
240039fa:	68fb      	ldr	r3, [r7, #12]
240039fc:	681b      	ldr	r3, [r3, #0]
240039fe:	4a33      	ldr	r2, [pc, #204]	; (24003acc <HAL_DMA_PollForTransfer+0x5e4>)
24003a00:	4293      	cmp	r3, r2
24003a02:	d040      	beq.n	24003a86 <HAL_DMA_PollForTransfer+0x59e>
24003a04:	68fb      	ldr	r3, [r7, #12]
24003a06:	681b      	ldr	r3, [r3, #0]
24003a08:	4a31      	ldr	r2, [pc, #196]	; (24003ad0 <HAL_DMA_PollForTransfer+0x5e8>)
24003a0a:	4293      	cmp	r3, r2
24003a0c:	d03b      	beq.n	24003a86 <HAL_DMA_PollForTransfer+0x59e>
24003a0e:	68fb      	ldr	r3, [r7, #12]
24003a10:	681b      	ldr	r3, [r3, #0]
24003a12:	4a30      	ldr	r2, [pc, #192]	; (24003ad4 <HAL_DMA_PollForTransfer+0x5ec>)
24003a14:	4293      	cmp	r3, r2
24003a16:	d036      	beq.n	24003a86 <HAL_DMA_PollForTransfer+0x59e>
24003a18:	68fb      	ldr	r3, [r7, #12]
24003a1a:	681b      	ldr	r3, [r3, #0]
24003a1c:	4a2e      	ldr	r2, [pc, #184]	; (24003ad8 <HAL_DMA_PollForTransfer+0x5f0>)
24003a1e:	4293      	cmp	r3, r2
24003a20:	d031      	beq.n	24003a86 <HAL_DMA_PollForTransfer+0x59e>
24003a22:	68fb      	ldr	r3, [r7, #12]
24003a24:	681b      	ldr	r3, [r3, #0]
24003a26:	4a2d      	ldr	r2, [pc, #180]	; (24003adc <HAL_DMA_PollForTransfer+0x5f4>)
24003a28:	4293      	cmp	r3, r2
24003a2a:	d02c      	beq.n	24003a86 <HAL_DMA_PollForTransfer+0x59e>
24003a2c:	68fb      	ldr	r3, [r7, #12]
24003a2e:	681b      	ldr	r3, [r3, #0]
24003a30:	4a2b      	ldr	r2, [pc, #172]	; (24003ae0 <HAL_DMA_PollForTransfer+0x5f8>)
24003a32:	4293      	cmp	r3, r2
24003a34:	d027      	beq.n	24003a86 <HAL_DMA_PollForTransfer+0x59e>
24003a36:	68fb      	ldr	r3, [r7, #12]
24003a38:	681b      	ldr	r3, [r3, #0]
24003a3a:	4a2a      	ldr	r2, [pc, #168]	; (24003ae4 <HAL_DMA_PollForTransfer+0x5fc>)
24003a3c:	4293      	cmp	r3, r2
24003a3e:	d022      	beq.n	24003a86 <HAL_DMA_PollForTransfer+0x59e>
24003a40:	68fb      	ldr	r3, [r7, #12]
24003a42:	681b      	ldr	r3, [r3, #0]
24003a44:	4a28      	ldr	r2, [pc, #160]	; (24003ae8 <HAL_DMA_PollForTransfer+0x600>)
24003a46:	4293      	cmp	r3, r2
24003a48:	d01d      	beq.n	24003a86 <HAL_DMA_PollForTransfer+0x59e>
24003a4a:	68fb      	ldr	r3, [r7, #12]
24003a4c:	681b      	ldr	r3, [r3, #0]
24003a4e:	4a27      	ldr	r2, [pc, #156]	; (24003aec <HAL_DMA_PollForTransfer+0x604>)
24003a50:	4293      	cmp	r3, r2
24003a52:	d018      	beq.n	24003a86 <HAL_DMA_PollForTransfer+0x59e>
24003a54:	68fb      	ldr	r3, [r7, #12]
24003a56:	681b      	ldr	r3, [r3, #0]
24003a58:	4a25      	ldr	r2, [pc, #148]	; (24003af0 <HAL_DMA_PollForTransfer+0x608>)
24003a5a:	4293      	cmp	r3, r2
24003a5c:	d013      	beq.n	24003a86 <HAL_DMA_PollForTransfer+0x59e>
24003a5e:	68fb      	ldr	r3, [r7, #12]
24003a60:	681b      	ldr	r3, [r3, #0]
24003a62:	4a24      	ldr	r2, [pc, #144]	; (24003af4 <HAL_DMA_PollForTransfer+0x60c>)
24003a64:	4293      	cmp	r3, r2
24003a66:	d00e      	beq.n	24003a86 <HAL_DMA_PollForTransfer+0x59e>
24003a68:	68fb      	ldr	r3, [r7, #12]
24003a6a:	681b      	ldr	r3, [r3, #0]
24003a6c:	4a22      	ldr	r2, [pc, #136]	; (24003af8 <HAL_DMA_PollForTransfer+0x610>)
24003a6e:	4293      	cmp	r3, r2
24003a70:	d009      	beq.n	24003a86 <HAL_DMA_PollForTransfer+0x59e>
24003a72:	68fb      	ldr	r3, [r7, #12]
24003a74:	681b      	ldr	r3, [r3, #0]
24003a76:	4a21      	ldr	r2, [pc, #132]	; (24003afc <HAL_DMA_PollForTransfer+0x614>)
24003a78:	4293      	cmp	r3, r2
24003a7a:	d004      	beq.n	24003a86 <HAL_DMA_PollForTransfer+0x59e>
24003a7c:	68fb      	ldr	r3, [r7, #12]
24003a7e:	681b      	ldr	r3, [r3, #0]
24003a80:	4a1f      	ldr	r2, [pc, #124]	; (24003b00 <HAL_DMA_PollForTransfer+0x618>)
24003a82:	4293      	cmp	r3, r2
24003a84:	d101      	bne.n	24003a8a <HAL_DMA_PollForTransfer+0x5a2>
24003a86:	2301      	movs	r3, #1
24003a88:	e000      	b.n	24003a8c <HAL_DMA_PollForTransfer+0x5a4>
24003a8a:	2300      	movs	r3, #0
24003a8c:	2b00      	cmp	r3, #0
24003a8e:	d008      	beq.n	24003aa2 <HAL_DMA_PollForTransfer+0x5ba>
    {
      (*ifcr_reg) = (DMA_FLAG_HTIF0_4 | DMA_FLAG_TCIF0_4) << (hdma->StreamIndex & 0x1FU);
24003a90:	68fb      	ldr	r3, [r7, #12]
24003a92:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
24003a94:	f003 031f 	and.w	r3, r3, #31
24003a98:	2230      	movs	r2, #48	; 0x30
24003a9a:	409a      	lsls	r2, r3
24003a9c:	69fb      	ldr	r3, [r7, #28]
24003a9e:	601a      	str	r2, [r3, #0]
24003aa0:	e007      	b.n	24003ab2 <HAL_DMA_PollForTransfer+0x5ca>
    }
    else /* BDMA channel */
    {
      (*ifcr_reg) = (BDMA_FLAG_TC0 << (hdma->StreamIndex & 0x1FU));
24003aa2:	68fb      	ldr	r3, [r7, #12]
24003aa4:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
24003aa6:	f003 031f 	and.w	r3, r3, #31
24003aaa:	2202      	movs	r2, #2
24003aac:	409a      	lsls	r2, r3
24003aae:	69fb      	ldr	r3, [r7, #28]
24003ab0:	601a      	str	r2, [r3, #0]
    }

    /* Process Unlocked */
    __HAL_UNLOCK(hdma);
24003ab2:	68fb      	ldr	r3, [r7, #12]
24003ab4:	2200      	movs	r2, #0
24003ab6:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

    hdma->State = HAL_DMA_STATE_READY;
24003aba:	68fb      	ldr	r3, [r7, #12]
24003abc:	2201      	movs	r2, #1
24003abe:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
24003ac2:	e095      	b.n	24003bf0 <HAL_DMA_PollForTransfer+0x708>
24003ac4:	40020010 	.word	0x40020010
24003ac8:	40020028 	.word	0x40020028
24003acc:	40020040 	.word	0x40020040
24003ad0:	40020058 	.word	0x40020058
24003ad4:	40020070 	.word	0x40020070
24003ad8:	40020088 	.word	0x40020088
24003adc:	400200a0 	.word	0x400200a0
24003ae0:	400200b8 	.word	0x400200b8
24003ae4:	40020410 	.word	0x40020410
24003ae8:	40020428 	.word	0x40020428
24003aec:	40020440 	.word	0x40020440
24003af0:	40020458 	.word	0x40020458
24003af4:	40020470 	.word	0x40020470
24003af8:	40020488 	.word	0x40020488
24003afc:	400204a0 	.word	0x400204a0
24003b00:	400204b8 	.word	0x400204b8
24003b04:	58025408 	.word	0x58025408
24003b08:	5802541c 	.word	0x5802541c
24003b0c:	58025430 	.word	0x58025430
24003b10:	58025444 	.word	0x58025444
24003b14:	58025458 	.word	0x58025458
24003b18:	5802546c 	.word	0x5802546c
24003b1c:	58025480 	.word	0x58025480
24003b20:	58025494 	.word	0x58025494
  }
  else /*CompleteLevel = HAL_DMA_HALF_TRANSFER*/
  {
    /* Clear the half transfer and transfer complete flags */
    if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
24003b24:	68fb      	ldr	r3, [r7, #12]
24003b26:	681b      	ldr	r3, [r3, #0]
24003b28:	4a34      	ldr	r2, [pc, #208]	; (24003bfc <HAL_DMA_PollForTransfer+0x714>)
24003b2a:	4293      	cmp	r3, r2
24003b2c:	d04a      	beq.n	24003bc4 <HAL_DMA_PollForTransfer+0x6dc>
24003b2e:	68fb      	ldr	r3, [r7, #12]
24003b30:	681b      	ldr	r3, [r3, #0]
24003b32:	4a33      	ldr	r2, [pc, #204]	; (24003c00 <HAL_DMA_PollForTransfer+0x718>)
24003b34:	4293      	cmp	r3, r2
24003b36:	d045      	beq.n	24003bc4 <HAL_DMA_PollForTransfer+0x6dc>
24003b38:	68fb      	ldr	r3, [r7, #12]
24003b3a:	681b      	ldr	r3, [r3, #0]
24003b3c:	4a31      	ldr	r2, [pc, #196]	; (24003c04 <HAL_DMA_PollForTransfer+0x71c>)
24003b3e:	4293      	cmp	r3, r2
24003b40:	d040      	beq.n	24003bc4 <HAL_DMA_PollForTransfer+0x6dc>
24003b42:	68fb      	ldr	r3, [r7, #12]
24003b44:	681b      	ldr	r3, [r3, #0]
24003b46:	4a30      	ldr	r2, [pc, #192]	; (24003c08 <HAL_DMA_PollForTransfer+0x720>)
24003b48:	4293      	cmp	r3, r2
24003b4a:	d03b      	beq.n	24003bc4 <HAL_DMA_PollForTransfer+0x6dc>
24003b4c:	68fb      	ldr	r3, [r7, #12]
24003b4e:	681b      	ldr	r3, [r3, #0]
24003b50:	4a2e      	ldr	r2, [pc, #184]	; (24003c0c <HAL_DMA_PollForTransfer+0x724>)
24003b52:	4293      	cmp	r3, r2
24003b54:	d036      	beq.n	24003bc4 <HAL_DMA_PollForTransfer+0x6dc>
24003b56:	68fb      	ldr	r3, [r7, #12]
24003b58:	681b      	ldr	r3, [r3, #0]
24003b5a:	4a2d      	ldr	r2, [pc, #180]	; (24003c10 <HAL_DMA_PollForTransfer+0x728>)
24003b5c:	4293      	cmp	r3, r2
24003b5e:	d031      	beq.n	24003bc4 <HAL_DMA_PollForTransfer+0x6dc>
24003b60:	68fb      	ldr	r3, [r7, #12]
24003b62:	681b      	ldr	r3, [r3, #0]
24003b64:	4a2b      	ldr	r2, [pc, #172]	; (24003c14 <HAL_DMA_PollForTransfer+0x72c>)
24003b66:	4293      	cmp	r3, r2
24003b68:	d02c      	beq.n	24003bc4 <HAL_DMA_PollForTransfer+0x6dc>
24003b6a:	68fb      	ldr	r3, [r7, #12]
24003b6c:	681b      	ldr	r3, [r3, #0]
24003b6e:	4a2a      	ldr	r2, [pc, #168]	; (24003c18 <HAL_DMA_PollForTransfer+0x730>)
24003b70:	4293      	cmp	r3, r2
24003b72:	d027      	beq.n	24003bc4 <HAL_DMA_PollForTransfer+0x6dc>
24003b74:	68fb      	ldr	r3, [r7, #12]
24003b76:	681b      	ldr	r3, [r3, #0]
24003b78:	4a28      	ldr	r2, [pc, #160]	; (24003c1c <HAL_DMA_PollForTransfer+0x734>)
24003b7a:	4293      	cmp	r3, r2
24003b7c:	d022      	beq.n	24003bc4 <HAL_DMA_PollForTransfer+0x6dc>
24003b7e:	68fb      	ldr	r3, [r7, #12]
24003b80:	681b      	ldr	r3, [r3, #0]
24003b82:	4a27      	ldr	r2, [pc, #156]	; (24003c20 <HAL_DMA_PollForTransfer+0x738>)
24003b84:	4293      	cmp	r3, r2
24003b86:	d01d      	beq.n	24003bc4 <HAL_DMA_PollForTransfer+0x6dc>
24003b88:	68fb      	ldr	r3, [r7, #12]
24003b8a:	681b      	ldr	r3, [r3, #0]
24003b8c:	4a25      	ldr	r2, [pc, #148]	; (24003c24 <HAL_DMA_PollForTransfer+0x73c>)
24003b8e:	4293      	cmp	r3, r2
24003b90:	d018      	beq.n	24003bc4 <HAL_DMA_PollForTransfer+0x6dc>
24003b92:	68fb      	ldr	r3, [r7, #12]
24003b94:	681b      	ldr	r3, [r3, #0]
24003b96:	4a24      	ldr	r2, [pc, #144]	; (24003c28 <HAL_DMA_PollForTransfer+0x740>)
24003b98:	4293      	cmp	r3, r2
24003b9a:	d013      	beq.n	24003bc4 <HAL_DMA_PollForTransfer+0x6dc>
24003b9c:	68fb      	ldr	r3, [r7, #12]
24003b9e:	681b      	ldr	r3, [r3, #0]
24003ba0:	4a22      	ldr	r2, [pc, #136]	; (24003c2c <HAL_DMA_PollForTransfer+0x744>)
24003ba2:	4293      	cmp	r3, r2
24003ba4:	d00e      	beq.n	24003bc4 <HAL_DMA_PollForTransfer+0x6dc>
24003ba6:	68fb      	ldr	r3, [r7, #12]
24003ba8:	681b      	ldr	r3, [r3, #0]
24003baa:	4a21      	ldr	r2, [pc, #132]	; (24003c30 <HAL_DMA_PollForTransfer+0x748>)
24003bac:	4293      	cmp	r3, r2
24003bae:	d009      	beq.n	24003bc4 <HAL_DMA_PollForTransfer+0x6dc>
24003bb0:	68fb      	ldr	r3, [r7, #12]
24003bb2:	681b      	ldr	r3, [r3, #0]
24003bb4:	4a1f      	ldr	r2, [pc, #124]	; (24003c34 <HAL_DMA_PollForTransfer+0x74c>)
24003bb6:	4293      	cmp	r3, r2
24003bb8:	d004      	beq.n	24003bc4 <HAL_DMA_PollForTransfer+0x6dc>
24003bba:	68fb      	ldr	r3, [r7, #12]
24003bbc:	681b      	ldr	r3, [r3, #0]
24003bbe:	4a1e      	ldr	r2, [pc, #120]	; (24003c38 <HAL_DMA_PollForTransfer+0x750>)
24003bc0:	4293      	cmp	r3, r2
24003bc2:	d101      	bne.n	24003bc8 <HAL_DMA_PollForTransfer+0x6e0>
24003bc4:	2301      	movs	r3, #1
24003bc6:	e000      	b.n	24003bca <HAL_DMA_PollForTransfer+0x6e2>
24003bc8:	2300      	movs	r3, #0
24003bca:	2b00      	cmp	r3, #0
24003bcc:	d008      	beq.n	24003be0 <HAL_DMA_PollForTransfer+0x6f8>
    {
      (*ifcr_reg) = (DMA_FLAG_HTIF0_4) << (hdma->StreamIndex & 0x1FU);
24003bce:	68fb      	ldr	r3, [r7, #12]
24003bd0:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
24003bd2:	f003 031f 	and.w	r3, r3, #31
24003bd6:	2210      	movs	r2, #16
24003bd8:	409a      	lsls	r2, r3
24003bda:	69fb      	ldr	r3, [r7, #28]
24003bdc:	601a      	str	r2, [r3, #0]
24003bde:	e007      	b.n	24003bf0 <HAL_DMA_PollForTransfer+0x708>
    }
    else /* BDMA channel */
    {
      (*ifcr_reg) = (BDMA_FLAG_HT0 << (hdma->StreamIndex & 0x1FU));
24003be0:	68fb      	ldr	r3, [r7, #12]
24003be2:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
24003be4:	f003 031f 	and.w	r3, r3, #31
24003be8:	2204      	movs	r2, #4
24003bea:	409a      	lsls	r2, r3
24003bec:	69fb      	ldr	r3, [r7, #28]
24003bee:	601a      	str	r2, [r3, #0]
    }
  }

  return status;
24003bf0:	7efb      	ldrb	r3, [r7, #27]
}
24003bf2:	4618      	mov	r0, r3
24003bf4:	3728      	adds	r7, #40	; 0x28
24003bf6:	46bd      	mov	sp, r7
24003bf8:	bd80      	pop	{r7, pc}
24003bfa:	bf00      	nop
24003bfc:	40020010 	.word	0x40020010
24003c00:	40020028 	.word	0x40020028
24003c04:	40020040 	.word	0x40020040
24003c08:	40020058 	.word	0x40020058
24003c0c:	40020070 	.word	0x40020070
24003c10:	40020088 	.word	0x40020088
24003c14:	400200a0 	.word	0x400200a0
24003c18:	400200b8 	.word	0x400200b8
24003c1c:	40020410 	.word	0x40020410
24003c20:	40020428 	.word	0x40020428
24003c24:	40020440 	.word	0x40020440
24003c28:	40020458 	.word	0x40020458
24003c2c:	40020470 	.word	0x40020470
24003c30:	40020488 	.word	0x40020488
24003c34:	400204a0 	.word	0x400204a0
24003c38:	400204b8 	.word	0x400204b8

24003c3c <HAL_DMA_IRQHandler>:
  * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Stream.
  * @retval None
  */
void HAL_DMA_IRQHandler(DMA_HandleTypeDef *hdma)
{
24003c3c:	b580      	push	{r7, lr}
24003c3e:	b08a      	sub	sp, #40	; 0x28
24003c40:	af00      	add	r7, sp, #0
24003c42:	6078      	str	r0, [r7, #4]
  uint32_t tmpisr_dma, tmpisr_bdma;
  uint32_t ccr_reg;
  __IO uint32_t count = 0U;
24003c44:	2300      	movs	r3, #0
24003c46:	60fb      	str	r3, [r7, #12]
  uint32_t timeout = SystemCoreClock / 9600U;
24003c48:	4b67      	ldr	r3, [pc, #412]	; (24003de8 <HAL_DMA_IRQHandler+0x1ac>)
24003c4a:	681b      	ldr	r3, [r3, #0]
24003c4c:	4a67      	ldr	r2, [pc, #412]	; (24003dec <HAL_DMA_IRQHandler+0x1b0>)
24003c4e:	fba2 2303 	umull	r2, r3, r2, r3
24003c52:	0a9b      	lsrs	r3, r3, #10
24003c54:	627b      	str	r3, [r7, #36]	; 0x24

  /* calculate DMA base and stream number */
  DMA_Base_Registers  *regs_dma  = (DMA_Base_Registers *)hdma->StreamBaseAddress;
24003c56:	687b      	ldr	r3, [r7, #4]
24003c58:	6d9b      	ldr	r3, [r3, #88]	; 0x58
24003c5a:	623b      	str	r3, [r7, #32]
  BDMA_Base_Registers *regs_bdma = (BDMA_Base_Registers *)hdma->StreamBaseAddress;
24003c5c:	687b      	ldr	r3, [r7, #4]
24003c5e:	6d9b      	ldr	r3, [r3, #88]	; 0x58
24003c60:	61fb      	str	r3, [r7, #28]

  tmpisr_dma  = regs_dma->ISR;
24003c62:	6a3b      	ldr	r3, [r7, #32]
24003c64:	681b      	ldr	r3, [r3, #0]
24003c66:	61bb      	str	r3, [r7, #24]
  tmpisr_bdma = regs_bdma->ISR;
24003c68:	69fb      	ldr	r3, [r7, #28]
24003c6a:	681b      	ldr	r3, [r3, #0]
24003c6c:	617b      	str	r3, [r7, #20]

  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U)  /* DMA1 or DMA2 instance */
24003c6e:	687b      	ldr	r3, [r7, #4]
24003c70:	681b      	ldr	r3, [r3, #0]
24003c72:	4a5f      	ldr	r2, [pc, #380]	; (24003df0 <HAL_DMA_IRQHandler+0x1b4>)
24003c74:	4293      	cmp	r3, r2
24003c76:	d04a      	beq.n	24003d0e <HAL_DMA_IRQHandler+0xd2>
24003c78:	687b      	ldr	r3, [r7, #4]
24003c7a:	681b      	ldr	r3, [r3, #0]
24003c7c:	4a5d      	ldr	r2, [pc, #372]	; (24003df4 <HAL_DMA_IRQHandler+0x1b8>)
24003c7e:	4293      	cmp	r3, r2
24003c80:	d045      	beq.n	24003d0e <HAL_DMA_IRQHandler+0xd2>
24003c82:	687b      	ldr	r3, [r7, #4]
24003c84:	681b      	ldr	r3, [r3, #0]
24003c86:	4a5c      	ldr	r2, [pc, #368]	; (24003df8 <HAL_DMA_IRQHandler+0x1bc>)
24003c88:	4293      	cmp	r3, r2
24003c8a:	d040      	beq.n	24003d0e <HAL_DMA_IRQHandler+0xd2>
24003c8c:	687b      	ldr	r3, [r7, #4]
24003c8e:	681b      	ldr	r3, [r3, #0]
24003c90:	4a5a      	ldr	r2, [pc, #360]	; (24003dfc <HAL_DMA_IRQHandler+0x1c0>)
24003c92:	4293      	cmp	r3, r2
24003c94:	d03b      	beq.n	24003d0e <HAL_DMA_IRQHandler+0xd2>
24003c96:	687b      	ldr	r3, [r7, #4]
24003c98:	681b      	ldr	r3, [r3, #0]
24003c9a:	4a59      	ldr	r2, [pc, #356]	; (24003e00 <HAL_DMA_IRQHandler+0x1c4>)
24003c9c:	4293      	cmp	r3, r2
24003c9e:	d036      	beq.n	24003d0e <HAL_DMA_IRQHandler+0xd2>
24003ca0:	687b      	ldr	r3, [r7, #4]
24003ca2:	681b      	ldr	r3, [r3, #0]
24003ca4:	4a57      	ldr	r2, [pc, #348]	; (24003e04 <HAL_DMA_IRQHandler+0x1c8>)
24003ca6:	4293      	cmp	r3, r2
24003ca8:	d031      	beq.n	24003d0e <HAL_DMA_IRQHandler+0xd2>
24003caa:	687b      	ldr	r3, [r7, #4]
24003cac:	681b      	ldr	r3, [r3, #0]
24003cae:	4a56      	ldr	r2, [pc, #344]	; (24003e08 <HAL_DMA_IRQHandler+0x1cc>)
24003cb0:	4293      	cmp	r3, r2
24003cb2:	d02c      	beq.n	24003d0e <HAL_DMA_IRQHandler+0xd2>
24003cb4:	687b      	ldr	r3, [r7, #4]
24003cb6:	681b      	ldr	r3, [r3, #0]
24003cb8:	4a54      	ldr	r2, [pc, #336]	; (24003e0c <HAL_DMA_IRQHandler+0x1d0>)
24003cba:	4293      	cmp	r3, r2
24003cbc:	d027      	beq.n	24003d0e <HAL_DMA_IRQHandler+0xd2>
24003cbe:	687b      	ldr	r3, [r7, #4]
24003cc0:	681b      	ldr	r3, [r3, #0]
24003cc2:	4a53      	ldr	r2, [pc, #332]	; (24003e10 <HAL_DMA_IRQHandler+0x1d4>)
24003cc4:	4293      	cmp	r3, r2
24003cc6:	d022      	beq.n	24003d0e <HAL_DMA_IRQHandler+0xd2>
24003cc8:	687b      	ldr	r3, [r7, #4]
24003cca:	681b      	ldr	r3, [r3, #0]
24003ccc:	4a51      	ldr	r2, [pc, #324]	; (24003e14 <HAL_DMA_IRQHandler+0x1d8>)
24003cce:	4293      	cmp	r3, r2
24003cd0:	d01d      	beq.n	24003d0e <HAL_DMA_IRQHandler+0xd2>
24003cd2:	687b      	ldr	r3, [r7, #4]
24003cd4:	681b      	ldr	r3, [r3, #0]
24003cd6:	4a50      	ldr	r2, [pc, #320]	; (24003e18 <HAL_DMA_IRQHandler+0x1dc>)
24003cd8:	4293      	cmp	r3, r2
24003cda:	d018      	beq.n	24003d0e <HAL_DMA_IRQHandler+0xd2>
24003cdc:	687b      	ldr	r3, [r7, #4]
24003cde:	681b      	ldr	r3, [r3, #0]
24003ce0:	4a4e      	ldr	r2, [pc, #312]	; (24003e1c <HAL_DMA_IRQHandler+0x1e0>)
24003ce2:	4293      	cmp	r3, r2
24003ce4:	d013      	beq.n	24003d0e <HAL_DMA_IRQHandler+0xd2>
24003ce6:	687b      	ldr	r3, [r7, #4]
24003ce8:	681b      	ldr	r3, [r3, #0]
24003cea:	4a4d      	ldr	r2, [pc, #308]	; (24003e20 <HAL_DMA_IRQHandler+0x1e4>)
24003cec:	4293      	cmp	r3, r2
24003cee:	d00e      	beq.n	24003d0e <HAL_DMA_IRQHandler+0xd2>
24003cf0:	687b      	ldr	r3, [r7, #4]
24003cf2:	681b      	ldr	r3, [r3, #0]
24003cf4:	4a4b      	ldr	r2, [pc, #300]	; (24003e24 <HAL_DMA_IRQHandler+0x1e8>)
24003cf6:	4293      	cmp	r3, r2
24003cf8:	d009      	beq.n	24003d0e <HAL_DMA_IRQHandler+0xd2>
24003cfa:	687b      	ldr	r3, [r7, #4]
24003cfc:	681b      	ldr	r3, [r3, #0]
24003cfe:	4a4a      	ldr	r2, [pc, #296]	; (24003e28 <HAL_DMA_IRQHandler+0x1ec>)
24003d00:	4293      	cmp	r3, r2
24003d02:	d004      	beq.n	24003d0e <HAL_DMA_IRQHandler+0xd2>
24003d04:	687b      	ldr	r3, [r7, #4]
24003d06:	681b      	ldr	r3, [r3, #0]
24003d08:	4a48      	ldr	r2, [pc, #288]	; (24003e2c <HAL_DMA_IRQHandler+0x1f0>)
24003d0a:	4293      	cmp	r3, r2
24003d0c:	d101      	bne.n	24003d12 <HAL_DMA_IRQHandler+0xd6>
24003d0e:	2301      	movs	r3, #1
24003d10:	e000      	b.n	24003d14 <HAL_DMA_IRQHandler+0xd8>
24003d12:	2300      	movs	r3, #0
24003d14:	2b00      	cmp	r3, #0
24003d16:	f000 842b 	beq.w	24004570 <HAL_DMA_IRQHandler+0x934>
  {
    /* Transfer Error Interrupt management ***************************************/
    if ((tmpisr_dma & (DMA_FLAG_TEIF0_4 << (hdma->StreamIndex & 0x1FU))) != 0U)
24003d1a:	687b      	ldr	r3, [r7, #4]
24003d1c:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
24003d1e:	f003 031f 	and.w	r3, r3, #31
24003d22:	2208      	movs	r2, #8
24003d24:	409a      	lsls	r2, r3
24003d26:	69bb      	ldr	r3, [r7, #24]
24003d28:	4013      	ands	r3, r2
24003d2a:	2b00      	cmp	r3, #0
24003d2c:	f000 80a2 	beq.w	24003e74 <HAL_DMA_IRQHandler+0x238>
    {
      if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TE) != 0U)
24003d30:	687b      	ldr	r3, [r7, #4]
24003d32:	681b      	ldr	r3, [r3, #0]
24003d34:	4a2e      	ldr	r2, [pc, #184]	; (24003df0 <HAL_DMA_IRQHandler+0x1b4>)
24003d36:	4293      	cmp	r3, r2
24003d38:	d04a      	beq.n	24003dd0 <HAL_DMA_IRQHandler+0x194>
24003d3a:	687b      	ldr	r3, [r7, #4]
24003d3c:	681b      	ldr	r3, [r3, #0]
24003d3e:	4a2d      	ldr	r2, [pc, #180]	; (24003df4 <HAL_DMA_IRQHandler+0x1b8>)
24003d40:	4293      	cmp	r3, r2
24003d42:	d045      	beq.n	24003dd0 <HAL_DMA_IRQHandler+0x194>
24003d44:	687b      	ldr	r3, [r7, #4]
24003d46:	681b      	ldr	r3, [r3, #0]
24003d48:	4a2b      	ldr	r2, [pc, #172]	; (24003df8 <HAL_DMA_IRQHandler+0x1bc>)
24003d4a:	4293      	cmp	r3, r2
24003d4c:	d040      	beq.n	24003dd0 <HAL_DMA_IRQHandler+0x194>
24003d4e:	687b      	ldr	r3, [r7, #4]
24003d50:	681b      	ldr	r3, [r3, #0]
24003d52:	4a2a      	ldr	r2, [pc, #168]	; (24003dfc <HAL_DMA_IRQHandler+0x1c0>)
24003d54:	4293      	cmp	r3, r2
24003d56:	d03b      	beq.n	24003dd0 <HAL_DMA_IRQHandler+0x194>
24003d58:	687b      	ldr	r3, [r7, #4]
24003d5a:	681b      	ldr	r3, [r3, #0]
24003d5c:	4a28      	ldr	r2, [pc, #160]	; (24003e00 <HAL_DMA_IRQHandler+0x1c4>)
24003d5e:	4293      	cmp	r3, r2
24003d60:	d036      	beq.n	24003dd0 <HAL_DMA_IRQHandler+0x194>
24003d62:	687b      	ldr	r3, [r7, #4]
24003d64:	681b      	ldr	r3, [r3, #0]
24003d66:	4a27      	ldr	r2, [pc, #156]	; (24003e04 <HAL_DMA_IRQHandler+0x1c8>)
24003d68:	4293      	cmp	r3, r2
24003d6a:	d031      	beq.n	24003dd0 <HAL_DMA_IRQHandler+0x194>
24003d6c:	687b      	ldr	r3, [r7, #4]
24003d6e:	681b      	ldr	r3, [r3, #0]
24003d70:	4a25      	ldr	r2, [pc, #148]	; (24003e08 <HAL_DMA_IRQHandler+0x1cc>)
24003d72:	4293      	cmp	r3, r2
24003d74:	d02c      	beq.n	24003dd0 <HAL_DMA_IRQHandler+0x194>
24003d76:	687b      	ldr	r3, [r7, #4]
24003d78:	681b      	ldr	r3, [r3, #0]
24003d7a:	4a24      	ldr	r2, [pc, #144]	; (24003e0c <HAL_DMA_IRQHandler+0x1d0>)
24003d7c:	4293      	cmp	r3, r2
24003d7e:	d027      	beq.n	24003dd0 <HAL_DMA_IRQHandler+0x194>
24003d80:	687b      	ldr	r3, [r7, #4]
24003d82:	681b      	ldr	r3, [r3, #0]
24003d84:	4a22      	ldr	r2, [pc, #136]	; (24003e10 <HAL_DMA_IRQHandler+0x1d4>)
24003d86:	4293      	cmp	r3, r2
24003d88:	d022      	beq.n	24003dd0 <HAL_DMA_IRQHandler+0x194>
24003d8a:	687b      	ldr	r3, [r7, #4]
24003d8c:	681b      	ldr	r3, [r3, #0]
24003d8e:	4a21      	ldr	r2, [pc, #132]	; (24003e14 <HAL_DMA_IRQHandler+0x1d8>)
24003d90:	4293      	cmp	r3, r2
24003d92:	d01d      	beq.n	24003dd0 <HAL_DMA_IRQHandler+0x194>
24003d94:	687b      	ldr	r3, [r7, #4]
24003d96:	681b      	ldr	r3, [r3, #0]
24003d98:	4a1f      	ldr	r2, [pc, #124]	; (24003e18 <HAL_DMA_IRQHandler+0x1dc>)
24003d9a:	4293      	cmp	r3, r2
24003d9c:	d018      	beq.n	24003dd0 <HAL_DMA_IRQHandler+0x194>
24003d9e:	687b      	ldr	r3, [r7, #4]
24003da0:	681b      	ldr	r3, [r3, #0]
24003da2:	4a1e      	ldr	r2, [pc, #120]	; (24003e1c <HAL_DMA_IRQHandler+0x1e0>)
24003da4:	4293      	cmp	r3, r2
24003da6:	d013      	beq.n	24003dd0 <HAL_DMA_IRQHandler+0x194>
24003da8:	687b      	ldr	r3, [r7, #4]
24003daa:	681b      	ldr	r3, [r3, #0]
24003dac:	4a1c      	ldr	r2, [pc, #112]	; (24003e20 <HAL_DMA_IRQHandler+0x1e4>)
24003dae:	4293      	cmp	r3, r2
24003db0:	d00e      	beq.n	24003dd0 <HAL_DMA_IRQHandler+0x194>
24003db2:	687b      	ldr	r3, [r7, #4]
24003db4:	681b      	ldr	r3, [r3, #0]
24003db6:	4a1b      	ldr	r2, [pc, #108]	; (24003e24 <HAL_DMA_IRQHandler+0x1e8>)
24003db8:	4293      	cmp	r3, r2
24003dba:	d009      	beq.n	24003dd0 <HAL_DMA_IRQHandler+0x194>
24003dbc:	687b      	ldr	r3, [r7, #4]
24003dbe:	681b      	ldr	r3, [r3, #0]
24003dc0:	4a19      	ldr	r2, [pc, #100]	; (24003e28 <HAL_DMA_IRQHandler+0x1ec>)
24003dc2:	4293      	cmp	r3, r2
24003dc4:	d004      	beq.n	24003dd0 <HAL_DMA_IRQHandler+0x194>
24003dc6:	687b      	ldr	r3, [r7, #4]
24003dc8:	681b      	ldr	r3, [r3, #0]
24003dca:	4a18      	ldr	r2, [pc, #96]	; (24003e2c <HAL_DMA_IRQHandler+0x1f0>)
24003dcc:	4293      	cmp	r3, r2
24003dce:	d12f      	bne.n	24003e30 <HAL_DMA_IRQHandler+0x1f4>
24003dd0:	687b      	ldr	r3, [r7, #4]
24003dd2:	681b      	ldr	r3, [r3, #0]
24003dd4:	681b      	ldr	r3, [r3, #0]
24003dd6:	f003 0304 	and.w	r3, r3, #4
24003dda:	2b00      	cmp	r3, #0
24003ddc:	bf14      	ite	ne
24003dde:	2301      	movne	r3, #1
24003de0:	2300      	moveq	r3, #0
24003de2:	b2db      	uxtb	r3, r3
24003de4:	e02e      	b.n	24003e44 <HAL_DMA_IRQHandler+0x208>
24003de6:	bf00      	nop
24003de8:	240004b8 	.word	0x240004b8
24003dec:	1b4e81b5 	.word	0x1b4e81b5
24003df0:	40020010 	.word	0x40020010
24003df4:	40020028 	.word	0x40020028
24003df8:	40020040 	.word	0x40020040
24003dfc:	40020058 	.word	0x40020058
24003e00:	40020070 	.word	0x40020070
24003e04:	40020088 	.word	0x40020088
24003e08:	400200a0 	.word	0x400200a0
24003e0c:	400200b8 	.word	0x400200b8
24003e10:	40020410 	.word	0x40020410
24003e14:	40020428 	.word	0x40020428
24003e18:	40020440 	.word	0x40020440
24003e1c:	40020458 	.word	0x40020458
24003e20:	40020470 	.word	0x40020470
24003e24:	40020488 	.word	0x40020488
24003e28:	400204a0 	.word	0x400204a0
24003e2c:	400204b8 	.word	0x400204b8
24003e30:	687b      	ldr	r3, [r7, #4]
24003e32:	681b      	ldr	r3, [r3, #0]
24003e34:	681b      	ldr	r3, [r3, #0]
24003e36:	f003 0308 	and.w	r3, r3, #8
24003e3a:	2b00      	cmp	r3, #0
24003e3c:	bf14      	ite	ne
24003e3e:	2301      	movne	r3, #1
24003e40:	2300      	moveq	r3, #0
24003e42:	b2db      	uxtb	r3, r3
24003e44:	2b00      	cmp	r3, #0
24003e46:	d015      	beq.n	24003e74 <HAL_DMA_IRQHandler+0x238>
      {
        /* Disable the transfer error interrupt */
        ((DMA_Stream_TypeDef   *)hdma->Instance)->CR  &= ~(DMA_IT_TE);
24003e48:	687b      	ldr	r3, [r7, #4]
24003e4a:	681b      	ldr	r3, [r3, #0]
24003e4c:	681a      	ldr	r2, [r3, #0]
24003e4e:	687b      	ldr	r3, [r7, #4]
24003e50:	681b      	ldr	r3, [r3, #0]
24003e52:	f022 0204 	bic.w	r2, r2, #4
24003e56:	601a      	str	r2, [r3, #0]

        /* Clear the transfer error flag */
        regs_dma->IFCR = DMA_FLAG_TEIF0_4 << (hdma->StreamIndex & 0x1FU);
24003e58:	687b      	ldr	r3, [r7, #4]
24003e5a:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
24003e5c:	f003 031f 	and.w	r3, r3, #31
24003e60:	2208      	movs	r2, #8
24003e62:	409a      	lsls	r2, r3
24003e64:	6a3b      	ldr	r3, [r7, #32]
24003e66:	609a      	str	r2, [r3, #8]

        /* Update error code */
        hdma->ErrorCode |= HAL_DMA_ERROR_TE;
24003e68:	687b      	ldr	r3, [r7, #4]
24003e6a:	6d5b      	ldr	r3, [r3, #84]	; 0x54
24003e6c:	f043 0201 	orr.w	r2, r3, #1
24003e70:	687b      	ldr	r3, [r7, #4]
24003e72:	655a      	str	r2, [r3, #84]	; 0x54
      }
    }
    /* FIFO Error Interrupt management ******************************************/
    if ((tmpisr_dma & (DMA_FLAG_FEIF0_4 << (hdma->StreamIndex & 0x1FU))) != 0U)
24003e74:	687b      	ldr	r3, [r7, #4]
24003e76:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
24003e78:	f003 031f 	and.w	r3, r3, #31
24003e7c:	69ba      	ldr	r2, [r7, #24]
24003e7e:	fa22 f303 	lsr.w	r3, r2, r3
24003e82:	f003 0301 	and.w	r3, r3, #1
24003e86:	2b00      	cmp	r3, #0
24003e88:	d06e      	beq.n	24003f68 <HAL_DMA_IRQHandler+0x32c>
    {
      if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_FE) != 0U)
24003e8a:	687b      	ldr	r3, [r7, #4]
24003e8c:	681b      	ldr	r3, [r3, #0]
24003e8e:	4a69      	ldr	r2, [pc, #420]	; (24004034 <HAL_DMA_IRQHandler+0x3f8>)
24003e90:	4293      	cmp	r3, r2
24003e92:	d04a      	beq.n	24003f2a <HAL_DMA_IRQHandler+0x2ee>
24003e94:	687b      	ldr	r3, [r7, #4]
24003e96:	681b      	ldr	r3, [r3, #0]
24003e98:	4a67      	ldr	r2, [pc, #412]	; (24004038 <HAL_DMA_IRQHandler+0x3fc>)
24003e9a:	4293      	cmp	r3, r2
24003e9c:	d045      	beq.n	24003f2a <HAL_DMA_IRQHandler+0x2ee>
24003e9e:	687b      	ldr	r3, [r7, #4]
24003ea0:	681b      	ldr	r3, [r3, #0]
24003ea2:	4a66      	ldr	r2, [pc, #408]	; (2400403c <HAL_DMA_IRQHandler+0x400>)
24003ea4:	4293      	cmp	r3, r2
24003ea6:	d040      	beq.n	24003f2a <HAL_DMA_IRQHandler+0x2ee>
24003ea8:	687b      	ldr	r3, [r7, #4]
24003eaa:	681b      	ldr	r3, [r3, #0]
24003eac:	4a64      	ldr	r2, [pc, #400]	; (24004040 <HAL_DMA_IRQHandler+0x404>)
24003eae:	4293      	cmp	r3, r2
24003eb0:	d03b      	beq.n	24003f2a <HAL_DMA_IRQHandler+0x2ee>
24003eb2:	687b      	ldr	r3, [r7, #4]
24003eb4:	681b      	ldr	r3, [r3, #0]
24003eb6:	4a63      	ldr	r2, [pc, #396]	; (24004044 <HAL_DMA_IRQHandler+0x408>)
24003eb8:	4293      	cmp	r3, r2
24003eba:	d036      	beq.n	24003f2a <HAL_DMA_IRQHandler+0x2ee>
24003ebc:	687b      	ldr	r3, [r7, #4]
24003ebe:	681b      	ldr	r3, [r3, #0]
24003ec0:	4a61      	ldr	r2, [pc, #388]	; (24004048 <HAL_DMA_IRQHandler+0x40c>)
24003ec2:	4293      	cmp	r3, r2
24003ec4:	d031      	beq.n	24003f2a <HAL_DMA_IRQHandler+0x2ee>
24003ec6:	687b      	ldr	r3, [r7, #4]
24003ec8:	681b      	ldr	r3, [r3, #0]
24003eca:	4a60      	ldr	r2, [pc, #384]	; (2400404c <HAL_DMA_IRQHandler+0x410>)
24003ecc:	4293      	cmp	r3, r2
24003ece:	d02c      	beq.n	24003f2a <HAL_DMA_IRQHandler+0x2ee>
24003ed0:	687b      	ldr	r3, [r7, #4]
24003ed2:	681b      	ldr	r3, [r3, #0]
24003ed4:	4a5e      	ldr	r2, [pc, #376]	; (24004050 <HAL_DMA_IRQHandler+0x414>)
24003ed6:	4293      	cmp	r3, r2
24003ed8:	d027      	beq.n	24003f2a <HAL_DMA_IRQHandler+0x2ee>
24003eda:	687b      	ldr	r3, [r7, #4]
24003edc:	681b      	ldr	r3, [r3, #0]
24003ede:	4a5d      	ldr	r2, [pc, #372]	; (24004054 <HAL_DMA_IRQHandler+0x418>)
24003ee0:	4293      	cmp	r3, r2
24003ee2:	d022      	beq.n	24003f2a <HAL_DMA_IRQHandler+0x2ee>
24003ee4:	687b      	ldr	r3, [r7, #4]
24003ee6:	681b      	ldr	r3, [r3, #0]
24003ee8:	4a5b      	ldr	r2, [pc, #364]	; (24004058 <HAL_DMA_IRQHandler+0x41c>)
24003eea:	4293      	cmp	r3, r2
24003eec:	d01d      	beq.n	24003f2a <HAL_DMA_IRQHandler+0x2ee>
24003eee:	687b      	ldr	r3, [r7, #4]
24003ef0:	681b      	ldr	r3, [r3, #0]
24003ef2:	4a5a      	ldr	r2, [pc, #360]	; (2400405c <HAL_DMA_IRQHandler+0x420>)
24003ef4:	4293      	cmp	r3, r2
24003ef6:	d018      	beq.n	24003f2a <HAL_DMA_IRQHandler+0x2ee>
24003ef8:	687b      	ldr	r3, [r7, #4]
24003efa:	681b      	ldr	r3, [r3, #0]
24003efc:	4a58      	ldr	r2, [pc, #352]	; (24004060 <HAL_DMA_IRQHandler+0x424>)
24003efe:	4293      	cmp	r3, r2
24003f00:	d013      	beq.n	24003f2a <HAL_DMA_IRQHandler+0x2ee>
24003f02:	687b      	ldr	r3, [r7, #4]
24003f04:	681b      	ldr	r3, [r3, #0]
24003f06:	4a57      	ldr	r2, [pc, #348]	; (24004064 <HAL_DMA_IRQHandler+0x428>)
24003f08:	4293      	cmp	r3, r2
24003f0a:	d00e      	beq.n	24003f2a <HAL_DMA_IRQHandler+0x2ee>
24003f0c:	687b      	ldr	r3, [r7, #4]
24003f0e:	681b      	ldr	r3, [r3, #0]
24003f10:	4a55      	ldr	r2, [pc, #340]	; (24004068 <HAL_DMA_IRQHandler+0x42c>)
24003f12:	4293      	cmp	r3, r2
24003f14:	d009      	beq.n	24003f2a <HAL_DMA_IRQHandler+0x2ee>
24003f16:	687b      	ldr	r3, [r7, #4]
24003f18:	681b      	ldr	r3, [r3, #0]
24003f1a:	4a54      	ldr	r2, [pc, #336]	; (2400406c <HAL_DMA_IRQHandler+0x430>)
24003f1c:	4293      	cmp	r3, r2
24003f1e:	d004      	beq.n	24003f2a <HAL_DMA_IRQHandler+0x2ee>
24003f20:	687b      	ldr	r3, [r7, #4]
24003f22:	681b      	ldr	r3, [r3, #0]
24003f24:	4a52      	ldr	r2, [pc, #328]	; (24004070 <HAL_DMA_IRQHandler+0x434>)
24003f26:	4293      	cmp	r3, r2
24003f28:	d10a      	bne.n	24003f40 <HAL_DMA_IRQHandler+0x304>
24003f2a:	687b      	ldr	r3, [r7, #4]
24003f2c:	681b      	ldr	r3, [r3, #0]
24003f2e:	695b      	ldr	r3, [r3, #20]
24003f30:	f003 0380 	and.w	r3, r3, #128	; 0x80
24003f34:	2b00      	cmp	r3, #0
24003f36:	bf14      	ite	ne
24003f38:	2301      	movne	r3, #1
24003f3a:	2300      	moveq	r3, #0
24003f3c:	b2db      	uxtb	r3, r3
24003f3e:	e003      	b.n	24003f48 <HAL_DMA_IRQHandler+0x30c>
24003f40:	687b      	ldr	r3, [r7, #4]
24003f42:	681b      	ldr	r3, [r3, #0]
24003f44:	681b      	ldr	r3, [r3, #0]
24003f46:	2300      	movs	r3, #0
24003f48:	2b00      	cmp	r3, #0
24003f4a:	d00d      	beq.n	24003f68 <HAL_DMA_IRQHandler+0x32c>
      {
        /* Clear the FIFO error flag */
        regs_dma->IFCR = DMA_FLAG_FEIF0_4 << (hdma->StreamIndex & 0x1FU);
24003f4c:	687b      	ldr	r3, [r7, #4]
24003f4e:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
24003f50:	f003 031f 	and.w	r3, r3, #31
24003f54:	2201      	movs	r2, #1
24003f56:	409a      	lsls	r2, r3
24003f58:	6a3b      	ldr	r3, [r7, #32]
24003f5a:	609a      	str	r2, [r3, #8]

        /* Update error code */
        hdma->ErrorCode |= HAL_DMA_ERROR_FE;
24003f5c:	687b      	ldr	r3, [r7, #4]
24003f5e:	6d5b      	ldr	r3, [r3, #84]	; 0x54
24003f60:	f043 0202 	orr.w	r2, r3, #2
24003f64:	687b      	ldr	r3, [r7, #4]
24003f66:	655a      	str	r2, [r3, #84]	; 0x54
      }
    }
    /* Direct Mode Error Interrupt management ***********************************/
    if ((tmpisr_dma & (DMA_FLAG_DMEIF0_4 << (hdma->StreamIndex & 0x1FU))) != 0U)
24003f68:	687b      	ldr	r3, [r7, #4]
24003f6a:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
24003f6c:	f003 031f 	and.w	r3, r3, #31
24003f70:	2204      	movs	r2, #4
24003f72:	409a      	lsls	r2, r3
24003f74:	69bb      	ldr	r3, [r7, #24]
24003f76:	4013      	ands	r3, r2
24003f78:	2b00      	cmp	r3, #0
24003f7a:	f000 808f 	beq.w	2400409c <HAL_DMA_IRQHandler+0x460>
    {
      if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_DME) != 0U)
24003f7e:	687b      	ldr	r3, [r7, #4]
24003f80:	681b      	ldr	r3, [r3, #0]
24003f82:	4a2c      	ldr	r2, [pc, #176]	; (24004034 <HAL_DMA_IRQHandler+0x3f8>)
24003f84:	4293      	cmp	r3, r2
24003f86:	d04a      	beq.n	2400401e <HAL_DMA_IRQHandler+0x3e2>
24003f88:	687b      	ldr	r3, [r7, #4]
24003f8a:	681b      	ldr	r3, [r3, #0]
24003f8c:	4a2a      	ldr	r2, [pc, #168]	; (24004038 <HAL_DMA_IRQHandler+0x3fc>)
24003f8e:	4293      	cmp	r3, r2
24003f90:	d045      	beq.n	2400401e <HAL_DMA_IRQHandler+0x3e2>
24003f92:	687b      	ldr	r3, [r7, #4]
24003f94:	681b      	ldr	r3, [r3, #0]
24003f96:	4a29      	ldr	r2, [pc, #164]	; (2400403c <HAL_DMA_IRQHandler+0x400>)
24003f98:	4293      	cmp	r3, r2
24003f9a:	d040      	beq.n	2400401e <HAL_DMA_IRQHandler+0x3e2>
24003f9c:	687b      	ldr	r3, [r7, #4]
24003f9e:	681b      	ldr	r3, [r3, #0]
24003fa0:	4a27      	ldr	r2, [pc, #156]	; (24004040 <HAL_DMA_IRQHandler+0x404>)
24003fa2:	4293      	cmp	r3, r2
24003fa4:	d03b      	beq.n	2400401e <HAL_DMA_IRQHandler+0x3e2>
24003fa6:	687b      	ldr	r3, [r7, #4]
24003fa8:	681b      	ldr	r3, [r3, #0]
24003faa:	4a26      	ldr	r2, [pc, #152]	; (24004044 <HAL_DMA_IRQHandler+0x408>)
24003fac:	4293      	cmp	r3, r2
24003fae:	d036      	beq.n	2400401e <HAL_DMA_IRQHandler+0x3e2>
24003fb0:	687b      	ldr	r3, [r7, #4]
24003fb2:	681b      	ldr	r3, [r3, #0]
24003fb4:	4a24      	ldr	r2, [pc, #144]	; (24004048 <HAL_DMA_IRQHandler+0x40c>)
24003fb6:	4293      	cmp	r3, r2
24003fb8:	d031      	beq.n	2400401e <HAL_DMA_IRQHandler+0x3e2>
24003fba:	687b      	ldr	r3, [r7, #4]
24003fbc:	681b      	ldr	r3, [r3, #0]
24003fbe:	4a23      	ldr	r2, [pc, #140]	; (2400404c <HAL_DMA_IRQHandler+0x410>)
24003fc0:	4293      	cmp	r3, r2
24003fc2:	d02c      	beq.n	2400401e <HAL_DMA_IRQHandler+0x3e2>
24003fc4:	687b      	ldr	r3, [r7, #4]
24003fc6:	681b      	ldr	r3, [r3, #0]
24003fc8:	4a21      	ldr	r2, [pc, #132]	; (24004050 <HAL_DMA_IRQHandler+0x414>)
24003fca:	4293      	cmp	r3, r2
24003fcc:	d027      	beq.n	2400401e <HAL_DMA_IRQHandler+0x3e2>
24003fce:	687b      	ldr	r3, [r7, #4]
24003fd0:	681b      	ldr	r3, [r3, #0]
24003fd2:	4a20      	ldr	r2, [pc, #128]	; (24004054 <HAL_DMA_IRQHandler+0x418>)
24003fd4:	4293      	cmp	r3, r2
24003fd6:	d022      	beq.n	2400401e <HAL_DMA_IRQHandler+0x3e2>
24003fd8:	687b      	ldr	r3, [r7, #4]
24003fda:	681b      	ldr	r3, [r3, #0]
24003fdc:	4a1e      	ldr	r2, [pc, #120]	; (24004058 <HAL_DMA_IRQHandler+0x41c>)
24003fde:	4293      	cmp	r3, r2
24003fe0:	d01d      	beq.n	2400401e <HAL_DMA_IRQHandler+0x3e2>
24003fe2:	687b      	ldr	r3, [r7, #4]
24003fe4:	681b      	ldr	r3, [r3, #0]
24003fe6:	4a1d      	ldr	r2, [pc, #116]	; (2400405c <HAL_DMA_IRQHandler+0x420>)
24003fe8:	4293      	cmp	r3, r2
24003fea:	d018      	beq.n	2400401e <HAL_DMA_IRQHandler+0x3e2>
24003fec:	687b      	ldr	r3, [r7, #4]
24003fee:	681b      	ldr	r3, [r3, #0]
24003ff0:	4a1b      	ldr	r2, [pc, #108]	; (24004060 <HAL_DMA_IRQHandler+0x424>)
24003ff2:	4293      	cmp	r3, r2
24003ff4:	d013      	beq.n	2400401e <HAL_DMA_IRQHandler+0x3e2>
24003ff6:	687b      	ldr	r3, [r7, #4]
24003ff8:	681b      	ldr	r3, [r3, #0]
24003ffa:	4a1a      	ldr	r2, [pc, #104]	; (24004064 <HAL_DMA_IRQHandler+0x428>)
24003ffc:	4293      	cmp	r3, r2
24003ffe:	d00e      	beq.n	2400401e <HAL_DMA_IRQHandler+0x3e2>
24004000:	687b      	ldr	r3, [r7, #4]
24004002:	681b      	ldr	r3, [r3, #0]
24004004:	4a18      	ldr	r2, [pc, #96]	; (24004068 <HAL_DMA_IRQHandler+0x42c>)
24004006:	4293      	cmp	r3, r2
24004008:	d009      	beq.n	2400401e <HAL_DMA_IRQHandler+0x3e2>
2400400a:	687b      	ldr	r3, [r7, #4]
2400400c:	681b      	ldr	r3, [r3, #0]
2400400e:	4a17      	ldr	r2, [pc, #92]	; (2400406c <HAL_DMA_IRQHandler+0x430>)
24004010:	4293      	cmp	r3, r2
24004012:	d004      	beq.n	2400401e <HAL_DMA_IRQHandler+0x3e2>
24004014:	687b      	ldr	r3, [r7, #4]
24004016:	681b      	ldr	r3, [r3, #0]
24004018:	4a15      	ldr	r2, [pc, #84]	; (24004070 <HAL_DMA_IRQHandler+0x434>)
2400401a:	4293      	cmp	r3, r2
2400401c:	d12a      	bne.n	24004074 <HAL_DMA_IRQHandler+0x438>
2400401e:	687b      	ldr	r3, [r7, #4]
24004020:	681b      	ldr	r3, [r3, #0]
24004022:	681b      	ldr	r3, [r3, #0]
24004024:	f003 0302 	and.w	r3, r3, #2
24004028:	2b00      	cmp	r3, #0
2400402a:	bf14      	ite	ne
2400402c:	2301      	movne	r3, #1
2400402e:	2300      	moveq	r3, #0
24004030:	b2db      	uxtb	r3, r3
24004032:	e023      	b.n	2400407c <HAL_DMA_IRQHandler+0x440>
24004034:	40020010 	.word	0x40020010
24004038:	40020028 	.word	0x40020028
2400403c:	40020040 	.word	0x40020040
24004040:	40020058 	.word	0x40020058
24004044:	40020070 	.word	0x40020070
24004048:	40020088 	.word	0x40020088
2400404c:	400200a0 	.word	0x400200a0
24004050:	400200b8 	.word	0x400200b8
24004054:	40020410 	.word	0x40020410
24004058:	40020428 	.word	0x40020428
2400405c:	40020440 	.word	0x40020440
24004060:	40020458 	.word	0x40020458
24004064:	40020470 	.word	0x40020470
24004068:	40020488 	.word	0x40020488
2400406c:	400204a0 	.word	0x400204a0
24004070:	400204b8 	.word	0x400204b8
24004074:	687b      	ldr	r3, [r7, #4]
24004076:	681b      	ldr	r3, [r3, #0]
24004078:	681b      	ldr	r3, [r3, #0]
2400407a:	2300      	movs	r3, #0
2400407c:	2b00      	cmp	r3, #0
2400407e:	d00d      	beq.n	2400409c <HAL_DMA_IRQHandler+0x460>
      {
        /* Clear the direct mode error flag */
        regs_dma->IFCR = DMA_FLAG_DMEIF0_4 << (hdma->StreamIndex & 0x1FU);
24004080:	687b      	ldr	r3, [r7, #4]
24004082:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
24004084:	f003 031f 	and.w	r3, r3, #31
24004088:	2204      	movs	r2, #4
2400408a:	409a      	lsls	r2, r3
2400408c:	6a3b      	ldr	r3, [r7, #32]
2400408e:	609a      	str	r2, [r3, #8]

        /* Update error code */
        hdma->ErrorCode |= HAL_DMA_ERROR_DME;
24004090:	687b      	ldr	r3, [r7, #4]
24004092:	6d5b      	ldr	r3, [r3, #84]	; 0x54
24004094:	f043 0204 	orr.w	r2, r3, #4
24004098:	687b      	ldr	r3, [r7, #4]
2400409a:	655a      	str	r2, [r3, #84]	; 0x54
      }
    }
    /* Half Transfer Complete Interrupt management ******************************/
    if ((tmpisr_dma & (DMA_FLAG_HTIF0_4 << (hdma->StreamIndex & 0x1FU))) != 0U)
2400409c:	687b      	ldr	r3, [r7, #4]
2400409e:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
240040a0:	f003 031f 	and.w	r3, r3, #31
240040a4:	2210      	movs	r2, #16
240040a6:	409a      	lsls	r2, r3
240040a8:	69bb      	ldr	r3, [r7, #24]
240040aa:	4013      	ands	r3, r2
240040ac:	2b00      	cmp	r3, #0
240040ae:	f000 80a6 	beq.w	240041fe <HAL_DMA_IRQHandler+0x5c2>
    {
      if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_HT) != 0U)
240040b2:	687b      	ldr	r3, [r7, #4]
240040b4:	681b      	ldr	r3, [r3, #0]
240040b6:	4a85      	ldr	r2, [pc, #532]	; (240042cc <HAL_DMA_IRQHandler+0x690>)
240040b8:	4293      	cmp	r3, r2
240040ba:	d04a      	beq.n	24004152 <HAL_DMA_IRQHandler+0x516>
240040bc:	687b      	ldr	r3, [r7, #4]
240040be:	681b      	ldr	r3, [r3, #0]
240040c0:	4a83      	ldr	r2, [pc, #524]	; (240042d0 <HAL_DMA_IRQHandler+0x694>)
240040c2:	4293      	cmp	r3, r2
240040c4:	d045      	beq.n	24004152 <HAL_DMA_IRQHandler+0x516>
240040c6:	687b      	ldr	r3, [r7, #4]
240040c8:	681b      	ldr	r3, [r3, #0]
240040ca:	4a82      	ldr	r2, [pc, #520]	; (240042d4 <HAL_DMA_IRQHandler+0x698>)
240040cc:	4293      	cmp	r3, r2
240040ce:	d040      	beq.n	24004152 <HAL_DMA_IRQHandler+0x516>
240040d0:	687b      	ldr	r3, [r7, #4]
240040d2:	681b      	ldr	r3, [r3, #0]
240040d4:	4a80      	ldr	r2, [pc, #512]	; (240042d8 <HAL_DMA_IRQHandler+0x69c>)
240040d6:	4293      	cmp	r3, r2
240040d8:	d03b      	beq.n	24004152 <HAL_DMA_IRQHandler+0x516>
240040da:	687b      	ldr	r3, [r7, #4]
240040dc:	681b      	ldr	r3, [r3, #0]
240040de:	4a7f      	ldr	r2, [pc, #508]	; (240042dc <HAL_DMA_IRQHandler+0x6a0>)
240040e0:	4293      	cmp	r3, r2
240040e2:	d036      	beq.n	24004152 <HAL_DMA_IRQHandler+0x516>
240040e4:	687b      	ldr	r3, [r7, #4]
240040e6:	681b      	ldr	r3, [r3, #0]
240040e8:	4a7d      	ldr	r2, [pc, #500]	; (240042e0 <HAL_DMA_IRQHandler+0x6a4>)
240040ea:	4293      	cmp	r3, r2
240040ec:	d031      	beq.n	24004152 <HAL_DMA_IRQHandler+0x516>
240040ee:	687b      	ldr	r3, [r7, #4]
240040f0:	681b      	ldr	r3, [r3, #0]
240040f2:	4a7c      	ldr	r2, [pc, #496]	; (240042e4 <HAL_DMA_IRQHandler+0x6a8>)
240040f4:	4293      	cmp	r3, r2
240040f6:	d02c      	beq.n	24004152 <HAL_DMA_IRQHandler+0x516>
240040f8:	687b      	ldr	r3, [r7, #4]
240040fa:	681b      	ldr	r3, [r3, #0]
240040fc:	4a7a      	ldr	r2, [pc, #488]	; (240042e8 <HAL_DMA_IRQHandler+0x6ac>)
240040fe:	4293      	cmp	r3, r2
24004100:	d027      	beq.n	24004152 <HAL_DMA_IRQHandler+0x516>
24004102:	687b      	ldr	r3, [r7, #4]
24004104:	681b      	ldr	r3, [r3, #0]
24004106:	4a79      	ldr	r2, [pc, #484]	; (240042ec <HAL_DMA_IRQHandler+0x6b0>)
24004108:	4293      	cmp	r3, r2
2400410a:	d022      	beq.n	24004152 <HAL_DMA_IRQHandler+0x516>
2400410c:	687b      	ldr	r3, [r7, #4]
2400410e:	681b      	ldr	r3, [r3, #0]
24004110:	4a77      	ldr	r2, [pc, #476]	; (240042f0 <HAL_DMA_IRQHandler+0x6b4>)
24004112:	4293      	cmp	r3, r2
24004114:	d01d      	beq.n	24004152 <HAL_DMA_IRQHandler+0x516>
24004116:	687b      	ldr	r3, [r7, #4]
24004118:	681b      	ldr	r3, [r3, #0]
2400411a:	4a76      	ldr	r2, [pc, #472]	; (240042f4 <HAL_DMA_IRQHandler+0x6b8>)
2400411c:	4293      	cmp	r3, r2
2400411e:	d018      	beq.n	24004152 <HAL_DMA_IRQHandler+0x516>
24004120:	687b      	ldr	r3, [r7, #4]
24004122:	681b      	ldr	r3, [r3, #0]
24004124:	4a74      	ldr	r2, [pc, #464]	; (240042f8 <HAL_DMA_IRQHandler+0x6bc>)
24004126:	4293      	cmp	r3, r2
24004128:	d013      	beq.n	24004152 <HAL_DMA_IRQHandler+0x516>
2400412a:	687b      	ldr	r3, [r7, #4]
2400412c:	681b      	ldr	r3, [r3, #0]
2400412e:	4a73      	ldr	r2, [pc, #460]	; (240042fc <HAL_DMA_IRQHandler+0x6c0>)
24004130:	4293      	cmp	r3, r2
24004132:	d00e      	beq.n	24004152 <HAL_DMA_IRQHandler+0x516>
24004134:	687b      	ldr	r3, [r7, #4]
24004136:	681b      	ldr	r3, [r3, #0]
24004138:	4a71      	ldr	r2, [pc, #452]	; (24004300 <HAL_DMA_IRQHandler+0x6c4>)
2400413a:	4293      	cmp	r3, r2
2400413c:	d009      	beq.n	24004152 <HAL_DMA_IRQHandler+0x516>
2400413e:	687b      	ldr	r3, [r7, #4]
24004140:	681b      	ldr	r3, [r3, #0]
24004142:	4a70      	ldr	r2, [pc, #448]	; (24004304 <HAL_DMA_IRQHandler+0x6c8>)
24004144:	4293      	cmp	r3, r2
24004146:	d004      	beq.n	24004152 <HAL_DMA_IRQHandler+0x516>
24004148:	687b      	ldr	r3, [r7, #4]
2400414a:	681b      	ldr	r3, [r3, #0]
2400414c:	4a6e      	ldr	r2, [pc, #440]	; (24004308 <HAL_DMA_IRQHandler+0x6cc>)
2400414e:	4293      	cmp	r3, r2
24004150:	d10a      	bne.n	24004168 <HAL_DMA_IRQHandler+0x52c>
24004152:	687b      	ldr	r3, [r7, #4]
24004154:	681b      	ldr	r3, [r3, #0]
24004156:	681b      	ldr	r3, [r3, #0]
24004158:	f003 0308 	and.w	r3, r3, #8
2400415c:	2b00      	cmp	r3, #0
2400415e:	bf14      	ite	ne
24004160:	2301      	movne	r3, #1
24004162:	2300      	moveq	r3, #0
24004164:	b2db      	uxtb	r3, r3
24004166:	e009      	b.n	2400417c <HAL_DMA_IRQHandler+0x540>
24004168:	687b      	ldr	r3, [r7, #4]
2400416a:	681b      	ldr	r3, [r3, #0]
2400416c:	681b      	ldr	r3, [r3, #0]
2400416e:	f003 0304 	and.w	r3, r3, #4
24004172:	2b00      	cmp	r3, #0
24004174:	bf14      	ite	ne
24004176:	2301      	movne	r3, #1
24004178:	2300      	moveq	r3, #0
2400417a:	b2db      	uxtb	r3, r3
2400417c:	2b00      	cmp	r3, #0
2400417e:	d03e      	beq.n	240041fe <HAL_DMA_IRQHandler+0x5c2>
      {
        /* Clear the half transfer complete flag */
        regs_dma->IFCR = DMA_FLAG_HTIF0_4 << (hdma->StreamIndex & 0x1FU);
24004180:	687b      	ldr	r3, [r7, #4]
24004182:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
24004184:	f003 031f 	and.w	r3, r3, #31
24004188:	2210      	movs	r2, #16
2400418a:	409a      	lsls	r2, r3
2400418c:	6a3b      	ldr	r3, [r7, #32]
2400418e:	609a      	str	r2, [r3, #8]

        /* Multi_Buffering mode enabled */
        if(((((DMA_Stream_TypeDef   *)hdma->Instance)->CR) & (uint32_t)(DMA_SxCR_DBM)) != 0U)
24004190:	687b      	ldr	r3, [r7, #4]
24004192:	681b      	ldr	r3, [r3, #0]
24004194:	681b      	ldr	r3, [r3, #0]
24004196:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
2400419a:	2b00      	cmp	r3, #0
2400419c:	d018      	beq.n	240041d0 <HAL_DMA_IRQHandler+0x594>
        {
          /* Current memory buffer used is Memory 0 */
          if((((DMA_Stream_TypeDef   *)hdma->Instance)->CR & DMA_SxCR_CT) == 0U)
2400419e:	687b      	ldr	r3, [r7, #4]
240041a0:	681b      	ldr	r3, [r3, #0]
240041a2:	681b      	ldr	r3, [r3, #0]
240041a4:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
240041a8:	2b00      	cmp	r3, #0
240041aa:	d108      	bne.n	240041be <HAL_DMA_IRQHandler+0x582>
          {
            if(hdma->XferHalfCpltCallback != NULL)
240041ac:	687b      	ldr	r3, [r7, #4]
240041ae:	6c1b      	ldr	r3, [r3, #64]	; 0x40
240041b0:	2b00      	cmp	r3, #0
240041b2:	d024      	beq.n	240041fe <HAL_DMA_IRQHandler+0x5c2>
            {
              /* Half transfer callback */
              hdma->XferHalfCpltCallback(hdma);
240041b4:	687b      	ldr	r3, [r7, #4]
240041b6:	6c1b      	ldr	r3, [r3, #64]	; 0x40
240041b8:	6878      	ldr	r0, [r7, #4]
240041ba:	4798      	blx	r3
240041bc:	e01f      	b.n	240041fe <HAL_DMA_IRQHandler+0x5c2>
            }
          }
          /* Current memory buffer used is Memory 1 */
          else
          {
            if(hdma->XferM1HalfCpltCallback != NULL)
240041be:	687b      	ldr	r3, [r7, #4]
240041c0:	6c9b      	ldr	r3, [r3, #72]	; 0x48
240041c2:	2b00      	cmp	r3, #0
240041c4:	d01b      	beq.n	240041fe <HAL_DMA_IRQHandler+0x5c2>
            {
              /* Half transfer callback */
              hdma->XferM1HalfCpltCallback(hdma);
240041c6:	687b      	ldr	r3, [r7, #4]
240041c8:	6c9b      	ldr	r3, [r3, #72]	; 0x48
240041ca:	6878      	ldr	r0, [r7, #4]
240041cc:	4798      	blx	r3
240041ce:	e016      	b.n	240041fe <HAL_DMA_IRQHandler+0x5c2>
          }
        }
        else
        {
          /* Disable the half transfer interrupt if the DMA mode is not CIRCULAR */
          if((((DMA_Stream_TypeDef   *)hdma->Instance)->CR & DMA_SxCR_CIRC) == 0U)
240041d0:	687b      	ldr	r3, [r7, #4]
240041d2:	681b      	ldr	r3, [r3, #0]
240041d4:	681b      	ldr	r3, [r3, #0]
240041d6:	f403 7380 	and.w	r3, r3, #256	; 0x100
240041da:	2b00      	cmp	r3, #0
240041dc:	d107      	bne.n	240041ee <HAL_DMA_IRQHandler+0x5b2>
          {
            /* Disable the half transfer interrupt */
            ((DMA_Stream_TypeDef   *)hdma->Instance)->CR  &= ~(DMA_IT_HT);
240041de:	687b      	ldr	r3, [r7, #4]
240041e0:	681b      	ldr	r3, [r3, #0]
240041e2:	681a      	ldr	r2, [r3, #0]
240041e4:	687b      	ldr	r3, [r7, #4]
240041e6:	681b      	ldr	r3, [r3, #0]
240041e8:	f022 0208 	bic.w	r2, r2, #8
240041ec:	601a      	str	r2, [r3, #0]
          }

          if(hdma->XferHalfCpltCallback != NULL)
240041ee:	687b      	ldr	r3, [r7, #4]
240041f0:	6c1b      	ldr	r3, [r3, #64]	; 0x40
240041f2:	2b00      	cmp	r3, #0
240041f4:	d003      	beq.n	240041fe <HAL_DMA_IRQHandler+0x5c2>
          {
            /* Half transfer callback */
            hdma->XferHalfCpltCallback(hdma);
240041f6:	687b      	ldr	r3, [r7, #4]
240041f8:	6c1b      	ldr	r3, [r3, #64]	; 0x40
240041fa:	6878      	ldr	r0, [r7, #4]
240041fc:	4798      	blx	r3
          }
        }
      }
    }
    /* Transfer Complete Interrupt management ***********************************/
    if ((tmpisr_dma & (DMA_FLAG_TCIF0_4 << (hdma->StreamIndex & 0x1FU))) != 0U)
240041fe:	687b      	ldr	r3, [r7, #4]
24004200:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
24004202:	f003 031f 	and.w	r3, r3, #31
24004206:	2220      	movs	r2, #32
24004208:	409a      	lsls	r2, r3
2400420a:	69bb      	ldr	r3, [r7, #24]
2400420c:	4013      	ands	r3, r2
2400420e:	2b00      	cmp	r3, #0
24004210:	f000 8110 	beq.w	24004434 <HAL_DMA_IRQHandler+0x7f8>
    {
      if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TC) != 0U)
24004214:	687b      	ldr	r3, [r7, #4]
24004216:	681b      	ldr	r3, [r3, #0]
24004218:	4a2c      	ldr	r2, [pc, #176]	; (240042cc <HAL_DMA_IRQHandler+0x690>)
2400421a:	4293      	cmp	r3, r2
2400421c:	d04a      	beq.n	240042b4 <HAL_DMA_IRQHandler+0x678>
2400421e:	687b      	ldr	r3, [r7, #4]
24004220:	681b      	ldr	r3, [r3, #0]
24004222:	4a2b      	ldr	r2, [pc, #172]	; (240042d0 <HAL_DMA_IRQHandler+0x694>)
24004224:	4293      	cmp	r3, r2
24004226:	d045      	beq.n	240042b4 <HAL_DMA_IRQHandler+0x678>
24004228:	687b      	ldr	r3, [r7, #4]
2400422a:	681b      	ldr	r3, [r3, #0]
2400422c:	4a29      	ldr	r2, [pc, #164]	; (240042d4 <HAL_DMA_IRQHandler+0x698>)
2400422e:	4293      	cmp	r3, r2
24004230:	d040      	beq.n	240042b4 <HAL_DMA_IRQHandler+0x678>
24004232:	687b      	ldr	r3, [r7, #4]
24004234:	681b      	ldr	r3, [r3, #0]
24004236:	4a28      	ldr	r2, [pc, #160]	; (240042d8 <HAL_DMA_IRQHandler+0x69c>)
24004238:	4293      	cmp	r3, r2
2400423a:	d03b      	beq.n	240042b4 <HAL_DMA_IRQHandler+0x678>
2400423c:	687b      	ldr	r3, [r7, #4]
2400423e:	681b      	ldr	r3, [r3, #0]
24004240:	4a26      	ldr	r2, [pc, #152]	; (240042dc <HAL_DMA_IRQHandler+0x6a0>)
24004242:	4293      	cmp	r3, r2
24004244:	d036      	beq.n	240042b4 <HAL_DMA_IRQHandler+0x678>
24004246:	687b      	ldr	r3, [r7, #4]
24004248:	681b      	ldr	r3, [r3, #0]
2400424a:	4a25      	ldr	r2, [pc, #148]	; (240042e0 <HAL_DMA_IRQHandler+0x6a4>)
2400424c:	4293      	cmp	r3, r2
2400424e:	d031      	beq.n	240042b4 <HAL_DMA_IRQHandler+0x678>
24004250:	687b      	ldr	r3, [r7, #4]
24004252:	681b      	ldr	r3, [r3, #0]
24004254:	4a23      	ldr	r2, [pc, #140]	; (240042e4 <HAL_DMA_IRQHandler+0x6a8>)
24004256:	4293      	cmp	r3, r2
24004258:	d02c      	beq.n	240042b4 <HAL_DMA_IRQHandler+0x678>
2400425a:	687b      	ldr	r3, [r7, #4]
2400425c:	681b      	ldr	r3, [r3, #0]
2400425e:	4a22      	ldr	r2, [pc, #136]	; (240042e8 <HAL_DMA_IRQHandler+0x6ac>)
24004260:	4293      	cmp	r3, r2
24004262:	d027      	beq.n	240042b4 <HAL_DMA_IRQHandler+0x678>
24004264:	687b      	ldr	r3, [r7, #4]
24004266:	681b      	ldr	r3, [r3, #0]
24004268:	4a20      	ldr	r2, [pc, #128]	; (240042ec <HAL_DMA_IRQHandler+0x6b0>)
2400426a:	4293      	cmp	r3, r2
2400426c:	d022      	beq.n	240042b4 <HAL_DMA_IRQHandler+0x678>
2400426e:	687b      	ldr	r3, [r7, #4]
24004270:	681b      	ldr	r3, [r3, #0]
24004272:	4a1f      	ldr	r2, [pc, #124]	; (240042f0 <HAL_DMA_IRQHandler+0x6b4>)
24004274:	4293      	cmp	r3, r2
24004276:	d01d      	beq.n	240042b4 <HAL_DMA_IRQHandler+0x678>
24004278:	687b      	ldr	r3, [r7, #4]
2400427a:	681b      	ldr	r3, [r3, #0]
2400427c:	4a1d      	ldr	r2, [pc, #116]	; (240042f4 <HAL_DMA_IRQHandler+0x6b8>)
2400427e:	4293      	cmp	r3, r2
24004280:	d018      	beq.n	240042b4 <HAL_DMA_IRQHandler+0x678>
24004282:	687b      	ldr	r3, [r7, #4]
24004284:	681b      	ldr	r3, [r3, #0]
24004286:	4a1c      	ldr	r2, [pc, #112]	; (240042f8 <HAL_DMA_IRQHandler+0x6bc>)
24004288:	4293      	cmp	r3, r2
2400428a:	d013      	beq.n	240042b4 <HAL_DMA_IRQHandler+0x678>
2400428c:	687b      	ldr	r3, [r7, #4]
2400428e:	681b      	ldr	r3, [r3, #0]
24004290:	4a1a      	ldr	r2, [pc, #104]	; (240042fc <HAL_DMA_IRQHandler+0x6c0>)
24004292:	4293      	cmp	r3, r2
24004294:	d00e      	beq.n	240042b4 <HAL_DMA_IRQHandler+0x678>
24004296:	687b      	ldr	r3, [r7, #4]
24004298:	681b      	ldr	r3, [r3, #0]
2400429a:	4a19      	ldr	r2, [pc, #100]	; (24004300 <HAL_DMA_IRQHandler+0x6c4>)
2400429c:	4293      	cmp	r3, r2
2400429e:	d009      	beq.n	240042b4 <HAL_DMA_IRQHandler+0x678>
240042a0:	687b      	ldr	r3, [r7, #4]
240042a2:	681b      	ldr	r3, [r3, #0]
240042a4:	4a17      	ldr	r2, [pc, #92]	; (24004304 <HAL_DMA_IRQHandler+0x6c8>)
240042a6:	4293      	cmp	r3, r2
240042a8:	d004      	beq.n	240042b4 <HAL_DMA_IRQHandler+0x678>
240042aa:	687b      	ldr	r3, [r7, #4]
240042ac:	681b      	ldr	r3, [r3, #0]
240042ae:	4a16      	ldr	r2, [pc, #88]	; (24004308 <HAL_DMA_IRQHandler+0x6cc>)
240042b0:	4293      	cmp	r3, r2
240042b2:	d12b      	bne.n	2400430c <HAL_DMA_IRQHandler+0x6d0>
240042b4:	687b      	ldr	r3, [r7, #4]
240042b6:	681b      	ldr	r3, [r3, #0]
240042b8:	681b      	ldr	r3, [r3, #0]
240042ba:	f003 0310 	and.w	r3, r3, #16
240042be:	2b00      	cmp	r3, #0
240042c0:	bf14      	ite	ne
240042c2:	2301      	movne	r3, #1
240042c4:	2300      	moveq	r3, #0
240042c6:	b2db      	uxtb	r3, r3
240042c8:	e02a      	b.n	24004320 <HAL_DMA_IRQHandler+0x6e4>
240042ca:	bf00      	nop
240042cc:	40020010 	.word	0x40020010
240042d0:	40020028 	.word	0x40020028
240042d4:	40020040 	.word	0x40020040
240042d8:	40020058 	.word	0x40020058
240042dc:	40020070 	.word	0x40020070
240042e0:	40020088 	.word	0x40020088
240042e4:	400200a0 	.word	0x400200a0
240042e8:	400200b8 	.word	0x400200b8
240042ec:	40020410 	.word	0x40020410
240042f0:	40020428 	.word	0x40020428
240042f4:	40020440 	.word	0x40020440
240042f8:	40020458 	.word	0x40020458
240042fc:	40020470 	.word	0x40020470
24004300:	40020488 	.word	0x40020488
24004304:	400204a0 	.word	0x400204a0
24004308:	400204b8 	.word	0x400204b8
2400430c:	687b      	ldr	r3, [r7, #4]
2400430e:	681b      	ldr	r3, [r3, #0]
24004310:	681b      	ldr	r3, [r3, #0]
24004312:	f003 0302 	and.w	r3, r3, #2
24004316:	2b00      	cmp	r3, #0
24004318:	bf14      	ite	ne
2400431a:	2301      	movne	r3, #1
2400431c:	2300      	moveq	r3, #0
2400431e:	b2db      	uxtb	r3, r3
24004320:	2b00      	cmp	r3, #0
24004322:	f000 8087 	beq.w	24004434 <HAL_DMA_IRQHandler+0x7f8>
      {
        /* Clear the transfer complete flag */
        regs_dma->IFCR = DMA_FLAG_TCIF0_4 << (hdma->StreamIndex & 0x1FU);
24004326:	687b      	ldr	r3, [r7, #4]
24004328:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
2400432a:	f003 031f 	and.w	r3, r3, #31
2400432e:	2220      	movs	r2, #32
24004330:	409a      	lsls	r2, r3
24004332:	6a3b      	ldr	r3, [r7, #32]
24004334:	609a      	str	r2, [r3, #8]

        if(HAL_DMA_STATE_ABORT == hdma->State)
24004336:	687b      	ldr	r3, [r7, #4]
24004338:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
2400433c:	b2db      	uxtb	r3, r3
2400433e:	2b04      	cmp	r3, #4
24004340:	d139      	bne.n	240043b6 <HAL_DMA_IRQHandler+0x77a>
        {
          /* Disable all the transfer interrupts */
          ((DMA_Stream_TypeDef   *)hdma->Instance)->CR  &= ~(DMA_IT_TC | DMA_IT_TE | DMA_IT_DME);
24004342:	687b      	ldr	r3, [r7, #4]
24004344:	681b      	ldr	r3, [r3, #0]
24004346:	681a      	ldr	r2, [r3, #0]
24004348:	687b      	ldr	r3, [r7, #4]
2400434a:	681b      	ldr	r3, [r3, #0]
2400434c:	f022 0216 	bic.w	r2, r2, #22
24004350:	601a      	str	r2, [r3, #0]
          ((DMA_Stream_TypeDef   *)hdma->Instance)->FCR &= ~(DMA_IT_FE);
24004352:	687b      	ldr	r3, [r7, #4]
24004354:	681b      	ldr	r3, [r3, #0]
24004356:	695a      	ldr	r2, [r3, #20]
24004358:	687b      	ldr	r3, [r7, #4]
2400435a:	681b      	ldr	r3, [r3, #0]
2400435c:	f022 0280 	bic.w	r2, r2, #128	; 0x80
24004360:	615a      	str	r2, [r3, #20]

          if((hdma->XferHalfCpltCallback != NULL) || (hdma->XferM1HalfCpltCallback != NULL))
24004362:	687b      	ldr	r3, [r7, #4]
24004364:	6c1b      	ldr	r3, [r3, #64]	; 0x40
24004366:	2b00      	cmp	r3, #0
24004368:	d103      	bne.n	24004372 <HAL_DMA_IRQHandler+0x736>
2400436a:	687b      	ldr	r3, [r7, #4]
2400436c:	6c9b      	ldr	r3, [r3, #72]	; 0x48
2400436e:	2b00      	cmp	r3, #0
24004370:	d007      	beq.n	24004382 <HAL_DMA_IRQHandler+0x746>
          {
            ((DMA_Stream_TypeDef   *)hdma->Instance)->CR  &= ~(DMA_IT_HT);
24004372:	687b      	ldr	r3, [r7, #4]
24004374:	681b      	ldr	r3, [r3, #0]
24004376:	681a      	ldr	r2, [r3, #0]
24004378:	687b      	ldr	r3, [r7, #4]
2400437a:	681b      	ldr	r3, [r3, #0]
2400437c:	f022 0208 	bic.w	r2, r2, #8
24004380:	601a      	str	r2, [r3, #0]
          }

          /* Clear all interrupt flags at correct offset within the register */
          regs_dma->IFCR = 0x3FUL << (hdma->StreamIndex & 0x1FU);
24004382:	687b      	ldr	r3, [r7, #4]
24004384:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
24004386:	f003 031f 	and.w	r3, r3, #31
2400438a:	223f      	movs	r2, #63	; 0x3f
2400438c:	409a      	lsls	r2, r3
2400438e:	6a3b      	ldr	r3, [r7, #32]
24004390:	609a      	str	r2, [r3, #8]

          /* Process Unlocked */
          __HAL_UNLOCK(hdma);
24004392:	687b      	ldr	r3, [r7, #4]
24004394:	2200      	movs	r2, #0
24004396:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

          /* Change the DMA state */
          hdma->State = HAL_DMA_STATE_READY;
2400439a:	687b      	ldr	r3, [r7, #4]
2400439c:	2201      	movs	r2, #1
2400439e:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

          if(hdma->XferAbortCallback != NULL)
240043a2:	687b      	ldr	r3, [r7, #4]
240043a4:	6d1b      	ldr	r3, [r3, #80]	; 0x50
240043a6:	2b00      	cmp	r3, #0
240043a8:	f000 834a 	beq.w	24004a40 <HAL_DMA_IRQHandler+0xe04>
          {
            hdma->XferAbortCallback(hdma);
240043ac:	687b      	ldr	r3, [r7, #4]
240043ae:	6d1b      	ldr	r3, [r3, #80]	; 0x50
240043b0:	6878      	ldr	r0, [r7, #4]
240043b2:	4798      	blx	r3
          }
          return;
240043b4:	e344      	b.n	24004a40 <HAL_DMA_IRQHandler+0xe04>
        }

        if(((((DMA_Stream_TypeDef   *)hdma->Instance)->CR) & (uint32_t)(DMA_SxCR_DBM)) != 0U)
240043b6:	687b      	ldr	r3, [r7, #4]
240043b8:	681b      	ldr	r3, [r3, #0]
240043ba:	681b      	ldr	r3, [r3, #0]
240043bc:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
240043c0:	2b00      	cmp	r3, #0
240043c2:	d018      	beq.n	240043f6 <HAL_DMA_IRQHandler+0x7ba>
        {
          /* Current memory buffer used is Memory 0 */
          if((((DMA_Stream_TypeDef   *)hdma->Instance)->CR & DMA_SxCR_CT) == 0U)
240043c4:	687b      	ldr	r3, [r7, #4]
240043c6:	681b      	ldr	r3, [r3, #0]
240043c8:	681b      	ldr	r3, [r3, #0]
240043ca:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
240043ce:	2b00      	cmp	r3, #0
240043d0:	d108      	bne.n	240043e4 <HAL_DMA_IRQHandler+0x7a8>
          {
            if(hdma->XferM1CpltCallback != NULL)
240043d2:	687b      	ldr	r3, [r7, #4]
240043d4:	6c5b      	ldr	r3, [r3, #68]	; 0x44
240043d6:	2b00      	cmp	r3, #0
240043d8:	d02c      	beq.n	24004434 <HAL_DMA_IRQHandler+0x7f8>
            {
              /* Transfer complete Callback for memory1 */
              hdma->XferM1CpltCallback(hdma);
240043da:	687b      	ldr	r3, [r7, #4]
240043dc:	6c5b      	ldr	r3, [r3, #68]	; 0x44
240043de:	6878      	ldr	r0, [r7, #4]
240043e0:	4798      	blx	r3
240043e2:	e027      	b.n	24004434 <HAL_DMA_IRQHandler+0x7f8>
            }
          }
          /* Current memory buffer used is Memory 1 */
          else
          {
            if(hdma->XferCpltCallback != NULL)
240043e4:	687b      	ldr	r3, [r7, #4]
240043e6:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
240043e8:	2b00      	cmp	r3, #0
240043ea:	d023      	beq.n	24004434 <HAL_DMA_IRQHandler+0x7f8>
            {
              /* Transfer complete Callback for memory0 */
              hdma->XferCpltCallback(hdma);
240043ec:	687b      	ldr	r3, [r7, #4]
240043ee:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
240043f0:	6878      	ldr	r0, [r7, #4]
240043f2:	4798      	blx	r3
240043f4:	e01e      	b.n	24004434 <HAL_DMA_IRQHandler+0x7f8>
          }
        }
        /* Disable the transfer complete interrupt if the DMA mode is not CIRCULAR */
        else
        {
          if((((DMA_Stream_TypeDef   *)hdma->Instance)->CR & DMA_SxCR_CIRC) == 0U)
240043f6:	687b      	ldr	r3, [r7, #4]
240043f8:	681b      	ldr	r3, [r3, #0]
240043fa:	681b      	ldr	r3, [r3, #0]
240043fc:	f403 7380 	and.w	r3, r3, #256	; 0x100
24004400:	2b00      	cmp	r3, #0
24004402:	d10f      	bne.n	24004424 <HAL_DMA_IRQHandler+0x7e8>
          {
            /* Disable the transfer complete interrupt */
            ((DMA_Stream_TypeDef   *)hdma->Instance)->CR  &= ~(DMA_IT_TC);
24004404:	687b      	ldr	r3, [r7, #4]
24004406:	681b      	ldr	r3, [r3, #0]
24004408:	681a      	ldr	r2, [r3, #0]
2400440a:	687b      	ldr	r3, [r7, #4]
2400440c:	681b      	ldr	r3, [r3, #0]
2400440e:	f022 0210 	bic.w	r2, r2, #16
24004412:	601a      	str	r2, [r3, #0]

            /* Process Unlocked */
            __HAL_UNLOCK(hdma);
24004414:	687b      	ldr	r3, [r7, #4]
24004416:	2200      	movs	r2, #0
24004418:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

            /* Change the DMA state */
            hdma->State = HAL_DMA_STATE_READY;
2400441c:	687b      	ldr	r3, [r7, #4]
2400441e:	2201      	movs	r2, #1
24004420:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
          }

          if(hdma->XferCpltCallback != NULL)
24004424:	687b      	ldr	r3, [r7, #4]
24004426:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
24004428:	2b00      	cmp	r3, #0
2400442a:	d003      	beq.n	24004434 <HAL_DMA_IRQHandler+0x7f8>
          {
            /* Transfer complete callback */
            hdma->XferCpltCallback(hdma);
2400442c:	687b      	ldr	r3, [r7, #4]
2400442e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
24004430:	6878      	ldr	r0, [r7, #4]
24004432:	4798      	blx	r3
        }
      }
    }

    /* manage error case */
    if(hdma->ErrorCode != HAL_DMA_ERROR_NONE)
24004434:	687b      	ldr	r3, [r7, #4]
24004436:	6d5b      	ldr	r3, [r3, #84]	; 0x54
24004438:	2b00      	cmp	r3, #0
2400443a:	f000 8306 	beq.w	24004a4a <HAL_DMA_IRQHandler+0xe0e>
    {
      if((hdma->ErrorCode & HAL_DMA_ERROR_TE) != 0U)
2400443e:	687b      	ldr	r3, [r7, #4]
24004440:	6d5b      	ldr	r3, [r3, #84]	; 0x54
24004442:	f003 0301 	and.w	r3, r3, #1
24004446:	2b00      	cmp	r3, #0
24004448:	f000 8088 	beq.w	2400455c <HAL_DMA_IRQHandler+0x920>
      {
        hdma->State = HAL_DMA_STATE_ABORT;
2400444c:	687b      	ldr	r3, [r7, #4]
2400444e:	2204      	movs	r2, #4
24004450:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

        /* Disable the stream */
        __HAL_DMA_DISABLE(hdma);
24004454:	687b      	ldr	r3, [r7, #4]
24004456:	681b      	ldr	r3, [r3, #0]
24004458:	4a7a      	ldr	r2, [pc, #488]	; (24004644 <HAL_DMA_IRQHandler+0xa08>)
2400445a:	4293      	cmp	r3, r2
2400445c:	d04a      	beq.n	240044f4 <HAL_DMA_IRQHandler+0x8b8>
2400445e:	687b      	ldr	r3, [r7, #4]
24004460:	681b      	ldr	r3, [r3, #0]
24004462:	4a79      	ldr	r2, [pc, #484]	; (24004648 <HAL_DMA_IRQHandler+0xa0c>)
24004464:	4293      	cmp	r3, r2
24004466:	d045      	beq.n	240044f4 <HAL_DMA_IRQHandler+0x8b8>
24004468:	687b      	ldr	r3, [r7, #4]
2400446a:	681b      	ldr	r3, [r3, #0]
2400446c:	4a77      	ldr	r2, [pc, #476]	; (2400464c <HAL_DMA_IRQHandler+0xa10>)
2400446e:	4293      	cmp	r3, r2
24004470:	d040      	beq.n	240044f4 <HAL_DMA_IRQHandler+0x8b8>
24004472:	687b      	ldr	r3, [r7, #4]
24004474:	681b      	ldr	r3, [r3, #0]
24004476:	4a76      	ldr	r2, [pc, #472]	; (24004650 <HAL_DMA_IRQHandler+0xa14>)
24004478:	4293      	cmp	r3, r2
2400447a:	d03b      	beq.n	240044f4 <HAL_DMA_IRQHandler+0x8b8>
2400447c:	687b      	ldr	r3, [r7, #4]
2400447e:	681b      	ldr	r3, [r3, #0]
24004480:	4a74      	ldr	r2, [pc, #464]	; (24004654 <HAL_DMA_IRQHandler+0xa18>)
24004482:	4293      	cmp	r3, r2
24004484:	d036      	beq.n	240044f4 <HAL_DMA_IRQHandler+0x8b8>
24004486:	687b      	ldr	r3, [r7, #4]
24004488:	681b      	ldr	r3, [r3, #0]
2400448a:	4a73      	ldr	r2, [pc, #460]	; (24004658 <HAL_DMA_IRQHandler+0xa1c>)
2400448c:	4293      	cmp	r3, r2
2400448e:	d031      	beq.n	240044f4 <HAL_DMA_IRQHandler+0x8b8>
24004490:	687b      	ldr	r3, [r7, #4]
24004492:	681b      	ldr	r3, [r3, #0]
24004494:	4a71      	ldr	r2, [pc, #452]	; (2400465c <HAL_DMA_IRQHandler+0xa20>)
24004496:	4293      	cmp	r3, r2
24004498:	d02c      	beq.n	240044f4 <HAL_DMA_IRQHandler+0x8b8>
2400449a:	687b      	ldr	r3, [r7, #4]
2400449c:	681b      	ldr	r3, [r3, #0]
2400449e:	4a70      	ldr	r2, [pc, #448]	; (24004660 <HAL_DMA_IRQHandler+0xa24>)
240044a0:	4293      	cmp	r3, r2
240044a2:	d027      	beq.n	240044f4 <HAL_DMA_IRQHandler+0x8b8>
240044a4:	687b      	ldr	r3, [r7, #4]
240044a6:	681b      	ldr	r3, [r3, #0]
240044a8:	4a6e      	ldr	r2, [pc, #440]	; (24004664 <HAL_DMA_IRQHandler+0xa28>)
240044aa:	4293      	cmp	r3, r2
240044ac:	d022      	beq.n	240044f4 <HAL_DMA_IRQHandler+0x8b8>
240044ae:	687b      	ldr	r3, [r7, #4]
240044b0:	681b      	ldr	r3, [r3, #0]
240044b2:	4a6d      	ldr	r2, [pc, #436]	; (24004668 <HAL_DMA_IRQHandler+0xa2c>)
240044b4:	4293      	cmp	r3, r2
240044b6:	d01d      	beq.n	240044f4 <HAL_DMA_IRQHandler+0x8b8>
240044b8:	687b      	ldr	r3, [r7, #4]
240044ba:	681b      	ldr	r3, [r3, #0]
240044bc:	4a6b      	ldr	r2, [pc, #428]	; (2400466c <HAL_DMA_IRQHandler+0xa30>)
240044be:	4293      	cmp	r3, r2
240044c0:	d018      	beq.n	240044f4 <HAL_DMA_IRQHandler+0x8b8>
240044c2:	687b      	ldr	r3, [r7, #4]
240044c4:	681b      	ldr	r3, [r3, #0]
240044c6:	4a6a      	ldr	r2, [pc, #424]	; (24004670 <HAL_DMA_IRQHandler+0xa34>)
240044c8:	4293      	cmp	r3, r2
240044ca:	d013      	beq.n	240044f4 <HAL_DMA_IRQHandler+0x8b8>
240044cc:	687b      	ldr	r3, [r7, #4]
240044ce:	681b      	ldr	r3, [r3, #0]
240044d0:	4a68      	ldr	r2, [pc, #416]	; (24004674 <HAL_DMA_IRQHandler+0xa38>)
240044d2:	4293      	cmp	r3, r2
240044d4:	d00e      	beq.n	240044f4 <HAL_DMA_IRQHandler+0x8b8>
240044d6:	687b      	ldr	r3, [r7, #4]
240044d8:	681b      	ldr	r3, [r3, #0]
240044da:	4a67      	ldr	r2, [pc, #412]	; (24004678 <HAL_DMA_IRQHandler+0xa3c>)
240044dc:	4293      	cmp	r3, r2
240044de:	d009      	beq.n	240044f4 <HAL_DMA_IRQHandler+0x8b8>
240044e0:	687b      	ldr	r3, [r7, #4]
240044e2:	681b      	ldr	r3, [r3, #0]
240044e4:	4a65      	ldr	r2, [pc, #404]	; (2400467c <HAL_DMA_IRQHandler+0xa40>)
240044e6:	4293      	cmp	r3, r2
240044e8:	d004      	beq.n	240044f4 <HAL_DMA_IRQHandler+0x8b8>
240044ea:	687b      	ldr	r3, [r7, #4]
240044ec:	681b      	ldr	r3, [r3, #0]
240044ee:	4a64      	ldr	r2, [pc, #400]	; (24004680 <HAL_DMA_IRQHandler+0xa44>)
240044f0:	4293      	cmp	r3, r2
240044f2:	d108      	bne.n	24004506 <HAL_DMA_IRQHandler+0x8ca>
240044f4:	687b      	ldr	r3, [r7, #4]
240044f6:	681b      	ldr	r3, [r3, #0]
240044f8:	681a      	ldr	r2, [r3, #0]
240044fa:	687b      	ldr	r3, [r7, #4]
240044fc:	681b      	ldr	r3, [r3, #0]
240044fe:	f022 0201 	bic.w	r2, r2, #1
24004502:	601a      	str	r2, [r3, #0]
24004504:	e007      	b.n	24004516 <HAL_DMA_IRQHandler+0x8da>
24004506:	687b      	ldr	r3, [r7, #4]
24004508:	681b      	ldr	r3, [r3, #0]
2400450a:	681a      	ldr	r2, [r3, #0]
2400450c:	687b      	ldr	r3, [r7, #4]
2400450e:	681b      	ldr	r3, [r3, #0]
24004510:	f022 0201 	bic.w	r2, r2, #1
24004514:	601a      	str	r2, [r3, #0]

        do
        {
          if (++count > timeout)
24004516:	68fb      	ldr	r3, [r7, #12]
24004518:	3301      	adds	r3, #1
2400451a:	60fb      	str	r3, [r7, #12]
2400451c:	6a7a      	ldr	r2, [r7, #36]	; 0x24
2400451e:	429a      	cmp	r2, r3
24004520:	d307      	bcc.n	24004532 <HAL_DMA_IRQHandler+0x8f6>
          {
            break;
          }
        }
        while((((DMA_Stream_TypeDef   *)hdma->Instance)->CR & DMA_SxCR_EN) != 0U);
24004522:	687b      	ldr	r3, [r7, #4]
24004524:	681b      	ldr	r3, [r3, #0]
24004526:	681b      	ldr	r3, [r3, #0]
24004528:	f003 0301 	and.w	r3, r3, #1
2400452c:	2b00      	cmp	r3, #0
2400452e:	d1f2      	bne.n	24004516 <HAL_DMA_IRQHandler+0x8da>
24004530:	e000      	b.n	24004534 <HAL_DMA_IRQHandler+0x8f8>
            break;
24004532:	bf00      	nop

        /* Process Unlocked */
        __HAL_UNLOCK(hdma);
24004534:	687b      	ldr	r3, [r7, #4]
24004536:	2200      	movs	r2, #0
24004538:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

        if((((DMA_Stream_TypeDef   *)hdma->Instance)->CR & DMA_SxCR_EN) != 0U)
2400453c:	687b      	ldr	r3, [r7, #4]
2400453e:	681b      	ldr	r3, [r3, #0]
24004540:	681b      	ldr	r3, [r3, #0]
24004542:	f003 0301 	and.w	r3, r3, #1
24004546:	2b00      	cmp	r3, #0
24004548:	d004      	beq.n	24004554 <HAL_DMA_IRQHandler+0x918>
        {
          /* Change the DMA state to error if DMA disable fails */
          hdma->State = HAL_DMA_STATE_ERROR;
2400454a:	687b      	ldr	r3, [r7, #4]
2400454c:	2203      	movs	r2, #3
2400454e:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
24004552:	e003      	b.n	2400455c <HAL_DMA_IRQHandler+0x920>
        }
        else
        {
          /* Change the DMA state to Ready if DMA disable success */
          hdma->State = HAL_DMA_STATE_READY;
24004554:	687b      	ldr	r3, [r7, #4]
24004556:	2201      	movs	r2, #1
24004558:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
        }
      }

      if(hdma->XferErrorCallback != NULL)
2400455c:	687b      	ldr	r3, [r7, #4]
2400455e:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
24004560:	2b00      	cmp	r3, #0
24004562:	f000 8272 	beq.w	24004a4a <HAL_DMA_IRQHandler+0xe0e>
      {
        /* Transfer error callback */
        hdma->XferErrorCallback(hdma);
24004566:	687b      	ldr	r3, [r7, #4]
24004568:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
2400456a:	6878      	ldr	r0, [r7, #4]
2400456c:	4798      	blx	r3
2400456e:	e26c      	b.n	24004a4a <HAL_DMA_IRQHandler+0xe0e>
      }
    }
  }
  else if(IS_BDMA_CHANNEL_INSTANCE(hdma->Instance) != 0U)  /* BDMA instance(s) */
24004570:	687b      	ldr	r3, [r7, #4]
24004572:	681b      	ldr	r3, [r3, #0]
24004574:	4a43      	ldr	r2, [pc, #268]	; (24004684 <HAL_DMA_IRQHandler+0xa48>)
24004576:	4293      	cmp	r3, r2
24004578:	d022      	beq.n	240045c0 <HAL_DMA_IRQHandler+0x984>
2400457a:	687b      	ldr	r3, [r7, #4]
2400457c:	681b      	ldr	r3, [r3, #0]
2400457e:	4a42      	ldr	r2, [pc, #264]	; (24004688 <HAL_DMA_IRQHandler+0xa4c>)
24004580:	4293      	cmp	r3, r2
24004582:	d01d      	beq.n	240045c0 <HAL_DMA_IRQHandler+0x984>
24004584:	687b      	ldr	r3, [r7, #4]
24004586:	681b      	ldr	r3, [r3, #0]
24004588:	4a40      	ldr	r2, [pc, #256]	; (2400468c <HAL_DMA_IRQHandler+0xa50>)
2400458a:	4293      	cmp	r3, r2
2400458c:	d018      	beq.n	240045c0 <HAL_DMA_IRQHandler+0x984>
2400458e:	687b      	ldr	r3, [r7, #4]
24004590:	681b      	ldr	r3, [r3, #0]
24004592:	4a3f      	ldr	r2, [pc, #252]	; (24004690 <HAL_DMA_IRQHandler+0xa54>)
24004594:	4293      	cmp	r3, r2
24004596:	d013      	beq.n	240045c0 <HAL_DMA_IRQHandler+0x984>
24004598:	687b      	ldr	r3, [r7, #4]
2400459a:	681b      	ldr	r3, [r3, #0]
2400459c:	4a3d      	ldr	r2, [pc, #244]	; (24004694 <HAL_DMA_IRQHandler+0xa58>)
2400459e:	4293      	cmp	r3, r2
240045a0:	d00e      	beq.n	240045c0 <HAL_DMA_IRQHandler+0x984>
240045a2:	687b      	ldr	r3, [r7, #4]
240045a4:	681b      	ldr	r3, [r3, #0]
240045a6:	4a3c      	ldr	r2, [pc, #240]	; (24004698 <HAL_DMA_IRQHandler+0xa5c>)
240045a8:	4293      	cmp	r3, r2
240045aa:	d009      	beq.n	240045c0 <HAL_DMA_IRQHandler+0x984>
240045ac:	687b      	ldr	r3, [r7, #4]
240045ae:	681b      	ldr	r3, [r3, #0]
240045b0:	4a3a      	ldr	r2, [pc, #232]	; (2400469c <HAL_DMA_IRQHandler+0xa60>)
240045b2:	4293      	cmp	r3, r2
240045b4:	d004      	beq.n	240045c0 <HAL_DMA_IRQHandler+0x984>
240045b6:	687b      	ldr	r3, [r7, #4]
240045b8:	681b      	ldr	r3, [r3, #0]
240045ba:	4a39      	ldr	r2, [pc, #228]	; (240046a0 <HAL_DMA_IRQHandler+0xa64>)
240045bc:	4293      	cmp	r3, r2
240045be:	d101      	bne.n	240045c4 <HAL_DMA_IRQHandler+0x988>
240045c0:	2301      	movs	r3, #1
240045c2:	e000      	b.n	240045c6 <HAL_DMA_IRQHandler+0x98a>
240045c4:	2300      	movs	r3, #0
240045c6:	2b00      	cmp	r3, #0
240045c8:	f000 823f 	beq.w	24004a4a <HAL_DMA_IRQHandler+0xe0e>
  {
    ccr_reg = (((BDMA_Channel_TypeDef   *)hdma->Instance)->CCR);
240045cc:	687b      	ldr	r3, [r7, #4]
240045ce:	681b      	ldr	r3, [r3, #0]
240045d0:	681b      	ldr	r3, [r3, #0]
240045d2:	613b      	str	r3, [r7, #16]

    /* Half Transfer Complete Interrupt management ******************************/
    if (((tmpisr_bdma & (BDMA_FLAG_HT0 << (hdma->StreamIndex & 0x1FU))) != 0U) && ((ccr_reg & BDMA_CCR_HTIE) != 0U))
240045d4:	687b      	ldr	r3, [r7, #4]
240045d6:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
240045d8:	f003 031f 	and.w	r3, r3, #31
240045dc:	2204      	movs	r2, #4
240045de:	409a      	lsls	r2, r3
240045e0:	697b      	ldr	r3, [r7, #20]
240045e2:	4013      	ands	r3, r2
240045e4:	2b00      	cmp	r3, #0
240045e6:	f000 80cd 	beq.w	24004784 <HAL_DMA_IRQHandler+0xb48>
240045ea:	693b      	ldr	r3, [r7, #16]
240045ec:	f003 0304 	and.w	r3, r3, #4
240045f0:	2b00      	cmp	r3, #0
240045f2:	f000 80c7 	beq.w	24004784 <HAL_DMA_IRQHandler+0xb48>
    {
      /* Clear the half transfer complete flag */
      regs_bdma->IFCR = (BDMA_ISR_HTIF0 << (hdma->StreamIndex & 0x1FU));
240045f6:	687b      	ldr	r3, [r7, #4]
240045f8:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
240045fa:	f003 031f 	and.w	r3, r3, #31
240045fe:	2204      	movs	r2, #4
24004600:	409a      	lsls	r2, r3
24004602:	69fb      	ldr	r3, [r7, #28]
24004604:	605a      	str	r2, [r3, #4]

      /* Disable the transfer complete interrupt if the DMA mode is Double Buffering */
      if((ccr_reg & BDMA_CCR_DBM) != 0U)
24004606:	693b      	ldr	r3, [r7, #16]
24004608:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
2400460c:	2b00      	cmp	r3, #0
2400460e:	d049      	beq.n	240046a4 <HAL_DMA_IRQHandler+0xa68>
      {
        /* Current memory buffer used is Memory 0 */
        if((ccr_reg & BDMA_CCR_CT) == 0U)
24004610:	693b      	ldr	r3, [r7, #16]
24004612:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
24004616:	2b00      	cmp	r3, #0
24004618:	d109      	bne.n	2400462e <HAL_DMA_IRQHandler+0x9f2>
        {
          if(hdma->XferM1HalfCpltCallback != NULL)
2400461a:	687b      	ldr	r3, [r7, #4]
2400461c:	6c9b      	ldr	r3, [r3, #72]	; 0x48
2400461e:	2b00      	cmp	r3, #0
24004620:	f000 8210 	beq.w	24004a44 <HAL_DMA_IRQHandler+0xe08>
          {
            /* Half transfer Callback for Memory 1 */
            hdma->XferM1HalfCpltCallback(hdma);
24004624:	687b      	ldr	r3, [r7, #4]
24004626:	6c9b      	ldr	r3, [r3, #72]	; 0x48
24004628:	6878      	ldr	r0, [r7, #4]
2400462a:	4798      	blx	r3
      if((ccr_reg & BDMA_CCR_DBM) != 0U)
2400462c:	e20a      	b.n	24004a44 <HAL_DMA_IRQHandler+0xe08>
          }
        }
        /* Current memory buffer used is Memory 1 */
        else
        {
          if(hdma->XferHalfCpltCallback != NULL)
2400462e:	687b      	ldr	r3, [r7, #4]
24004630:	6c1b      	ldr	r3, [r3, #64]	; 0x40
24004632:	2b00      	cmp	r3, #0
24004634:	f000 8206 	beq.w	24004a44 <HAL_DMA_IRQHandler+0xe08>
          {
            /* Half transfer Callback for Memory 0 */
            hdma->XferHalfCpltCallback(hdma);
24004638:	687b      	ldr	r3, [r7, #4]
2400463a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
2400463c:	6878      	ldr	r0, [r7, #4]
2400463e:	4798      	blx	r3
      if((ccr_reg & BDMA_CCR_DBM) != 0U)
24004640:	e200      	b.n	24004a44 <HAL_DMA_IRQHandler+0xe08>
24004642:	bf00      	nop
24004644:	40020010 	.word	0x40020010
24004648:	40020028 	.word	0x40020028
2400464c:	40020040 	.word	0x40020040
24004650:	40020058 	.word	0x40020058
24004654:	40020070 	.word	0x40020070
24004658:	40020088 	.word	0x40020088
2400465c:	400200a0 	.word	0x400200a0
24004660:	400200b8 	.word	0x400200b8
24004664:	40020410 	.word	0x40020410
24004668:	40020428 	.word	0x40020428
2400466c:	40020440 	.word	0x40020440
24004670:	40020458 	.word	0x40020458
24004674:	40020470 	.word	0x40020470
24004678:	40020488 	.word	0x40020488
2400467c:	400204a0 	.word	0x400204a0
24004680:	400204b8 	.word	0x400204b8
24004684:	58025408 	.word	0x58025408
24004688:	5802541c 	.word	0x5802541c
2400468c:	58025430 	.word	0x58025430
24004690:	58025444 	.word	0x58025444
24004694:	58025458 	.word	0x58025458
24004698:	5802546c 	.word	0x5802546c
2400469c:	58025480 	.word	0x58025480
240046a0:	58025494 	.word	0x58025494
          }
        }
      }
      else
      {
        if((ccr_reg & BDMA_CCR_CIRC) == 0U)
240046a4:	693b      	ldr	r3, [r7, #16]
240046a6:	f003 0320 	and.w	r3, r3, #32
240046aa:	2b00      	cmp	r3, #0
240046ac:	d160      	bne.n	24004770 <HAL_DMA_IRQHandler+0xb34>
        {
          /* Disable the half transfer interrupt */
          __HAL_DMA_DISABLE_IT(hdma, DMA_IT_HT);
240046ae:	687b      	ldr	r3, [r7, #4]
240046b0:	681b      	ldr	r3, [r3, #0]
240046b2:	4a8c      	ldr	r2, [pc, #560]	; (240048e4 <HAL_DMA_IRQHandler+0xca8>)
240046b4:	4293      	cmp	r3, r2
240046b6:	d04a      	beq.n	2400474e <HAL_DMA_IRQHandler+0xb12>
240046b8:	687b      	ldr	r3, [r7, #4]
240046ba:	681b      	ldr	r3, [r3, #0]
240046bc:	4a8a      	ldr	r2, [pc, #552]	; (240048e8 <HAL_DMA_IRQHandler+0xcac>)
240046be:	4293      	cmp	r3, r2
240046c0:	d045      	beq.n	2400474e <HAL_DMA_IRQHandler+0xb12>
240046c2:	687b      	ldr	r3, [r7, #4]
240046c4:	681b      	ldr	r3, [r3, #0]
240046c6:	4a89      	ldr	r2, [pc, #548]	; (240048ec <HAL_DMA_IRQHandler+0xcb0>)
240046c8:	4293      	cmp	r3, r2
240046ca:	d040      	beq.n	2400474e <HAL_DMA_IRQHandler+0xb12>
240046cc:	687b      	ldr	r3, [r7, #4]
240046ce:	681b      	ldr	r3, [r3, #0]
240046d0:	4a87      	ldr	r2, [pc, #540]	; (240048f0 <HAL_DMA_IRQHandler+0xcb4>)
240046d2:	4293      	cmp	r3, r2
240046d4:	d03b      	beq.n	2400474e <HAL_DMA_IRQHandler+0xb12>
240046d6:	687b      	ldr	r3, [r7, #4]
240046d8:	681b      	ldr	r3, [r3, #0]
240046da:	4a86      	ldr	r2, [pc, #536]	; (240048f4 <HAL_DMA_IRQHandler+0xcb8>)
240046dc:	4293      	cmp	r3, r2
240046de:	d036      	beq.n	2400474e <HAL_DMA_IRQHandler+0xb12>
240046e0:	687b      	ldr	r3, [r7, #4]
240046e2:	681b      	ldr	r3, [r3, #0]
240046e4:	4a84      	ldr	r2, [pc, #528]	; (240048f8 <HAL_DMA_IRQHandler+0xcbc>)
240046e6:	4293      	cmp	r3, r2
240046e8:	d031      	beq.n	2400474e <HAL_DMA_IRQHandler+0xb12>
240046ea:	687b      	ldr	r3, [r7, #4]
240046ec:	681b      	ldr	r3, [r3, #0]
240046ee:	4a83      	ldr	r2, [pc, #524]	; (240048fc <HAL_DMA_IRQHandler+0xcc0>)
240046f0:	4293      	cmp	r3, r2
240046f2:	d02c      	beq.n	2400474e <HAL_DMA_IRQHandler+0xb12>
240046f4:	687b      	ldr	r3, [r7, #4]
240046f6:	681b      	ldr	r3, [r3, #0]
240046f8:	4a81      	ldr	r2, [pc, #516]	; (24004900 <HAL_DMA_IRQHandler+0xcc4>)
240046fa:	4293      	cmp	r3, r2
240046fc:	d027      	beq.n	2400474e <HAL_DMA_IRQHandler+0xb12>
240046fe:	687b      	ldr	r3, [r7, #4]
24004700:	681b      	ldr	r3, [r3, #0]
24004702:	4a80      	ldr	r2, [pc, #512]	; (24004904 <HAL_DMA_IRQHandler+0xcc8>)
24004704:	4293      	cmp	r3, r2
24004706:	d022      	beq.n	2400474e <HAL_DMA_IRQHandler+0xb12>
24004708:	687b      	ldr	r3, [r7, #4]
2400470a:	681b      	ldr	r3, [r3, #0]
2400470c:	4a7e      	ldr	r2, [pc, #504]	; (24004908 <HAL_DMA_IRQHandler+0xccc>)
2400470e:	4293      	cmp	r3, r2
24004710:	d01d      	beq.n	2400474e <HAL_DMA_IRQHandler+0xb12>
24004712:	687b      	ldr	r3, [r7, #4]
24004714:	681b      	ldr	r3, [r3, #0]
24004716:	4a7d      	ldr	r2, [pc, #500]	; (2400490c <HAL_DMA_IRQHandler+0xcd0>)
24004718:	4293      	cmp	r3, r2
2400471a:	d018      	beq.n	2400474e <HAL_DMA_IRQHandler+0xb12>
2400471c:	687b      	ldr	r3, [r7, #4]
2400471e:	681b      	ldr	r3, [r3, #0]
24004720:	4a7b      	ldr	r2, [pc, #492]	; (24004910 <HAL_DMA_IRQHandler+0xcd4>)
24004722:	4293      	cmp	r3, r2
24004724:	d013      	beq.n	2400474e <HAL_DMA_IRQHandler+0xb12>
24004726:	687b      	ldr	r3, [r7, #4]
24004728:	681b      	ldr	r3, [r3, #0]
2400472a:	4a7a      	ldr	r2, [pc, #488]	; (24004914 <HAL_DMA_IRQHandler+0xcd8>)
2400472c:	4293      	cmp	r3, r2
2400472e:	d00e      	beq.n	2400474e <HAL_DMA_IRQHandler+0xb12>
24004730:	687b      	ldr	r3, [r7, #4]
24004732:	681b      	ldr	r3, [r3, #0]
24004734:	4a78      	ldr	r2, [pc, #480]	; (24004918 <HAL_DMA_IRQHandler+0xcdc>)
24004736:	4293      	cmp	r3, r2
24004738:	d009      	beq.n	2400474e <HAL_DMA_IRQHandler+0xb12>
2400473a:	687b      	ldr	r3, [r7, #4]
2400473c:	681b      	ldr	r3, [r3, #0]
2400473e:	4a77      	ldr	r2, [pc, #476]	; (2400491c <HAL_DMA_IRQHandler+0xce0>)
24004740:	4293      	cmp	r3, r2
24004742:	d004      	beq.n	2400474e <HAL_DMA_IRQHandler+0xb12>
24004744:	687b      	ldr	r3, [r7, #4]
24004746:	681b      	ldr	r3, [r3, #0]
24004748:	4a75      	ldr	r2, [pc, #468]	; (24004920 <HAL_DMA_IRQHandler+0xce4>)
2400474a:	4293      	cmp	r3, r2
2400474c:	d108      	bne.n	24004760 <HAL_DMA_IRQHandler+0xb24>
2400474e:	687b      	ldr	r3, [r7, #4]
24004750:	681b      	ldr	r3, [r3, #0]
24004752:	681a      	ldr	r2, [r3, #0]
24004754:	687b      	ldr	r3, [r7, #4]
24004756:	681b      	ldr	r3, [r3, #0]
24004758:	f022 0208 	bic.w	r2, r2, #8
2400475c:	601a      	str	r2, [r3, #0]
2400475e:	e007      	b.n	24004770 <HAL_DMA_IRQHandler+0xb34>
24004760:	687b      	ldr	r3, [r7, #4]
24004762:	681b      	ldr	r3, [r3, #0]
24004764:	681a      	ldr	r2, [r3, #0]
24004766:	687b      	ldr	r3, [r7, #4]
24004768:	681b      	ldr	r3, [r3, #0]
2400476a:	f022 0204 	bic.w	r2, r2, #4
2400476e:	601a      	str	r2, [r3, #0]
        }

        /* DMA peripheral state is not updated in Half Transfer */
        /* but in Transfer Complete case */

       if(hdma->XferHalfCpltCallback != NULL)
24004770:	687b      	ldr	r3, [r7, #4]
24004772:	6c1b      	ldr	r3, [r3, #64]	; 0x40
24004774:	2b00      	cmp	r3, #0
24004776:	f000 8165 	beq.w	24004a44 <HAL_DMA_IRQHandler+0xe08>
        {
          /* Half transfer callback */
          hdma->XferHalfCpltCallback(hdma);
2400477a:	687b      	ldr	r3, [r7, #4]
2400477c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
2400477e:	6878      	ldr	r0, [r7, #4]
24004780:	4798      	blx	r3
      if((ccr_reg & BDMA_CCR_DBM) != 0U)
24004782:	e15f      	b.n	24004a44 <HAL_DMA_IRQHandler+0xe08>
        }
      }
    }

    /* Transfer Complete Interrupt management ***********************************/
    else if (((tmpisr_bdma & (BDMA_FLAG_TC0 << (hdma->StreamIndex & 0x1FU))) != 0U) && ((ccr_reg & BDMA_CCR_TCIE) != 0U))
24004784:	687b      	ldr	r3, [r7, #4]
24004786:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
24004788:	f003 031f 	and.w	r3, r3, #31
2400478c:	2202      	movs	r2, #2
2400478e:	409a      	lsls	r2, r3
24004790:	697b      	ldr	r3, [r7, #20]
24004792:	4013      	ands	r3, r2
24004794:	2b00      	cmp	r3, #0
24004796:	f000 80c5 	beq.w	24004924 <HAL_DMA_IRQHandler+0xce8>
2400479a:	693b      	ldr	r3, [r7, #16]
2400479c:	f003 0302 	and.w	r3, r3, #2
240047a0:	2b00      	cmp	r3, #0
240047a2:	f000 80bf 	beq.w	24004924 <HAL_DMA_IRQHandler+0xce8>
    {
      /* Clear the transfer complete flag */
      regs_bdma->IFCR = (BDMA_ISR_TCIF0) << (hdma->StreamIndex & 0x1FU);
240047a6:	687b      	ldr	r3, [r7, #4]
240047a8:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
240047aa:	f003 031f 	and.w	r3, r3, #31
240047ae:	2202      	movs	r2, #2
240047b0:	409a      	lsls	r2, r3
240047b2:	69fb      	ldr	r3, [r7, #28]
240047b4:	605a      	str	r2, [r3, #4]

      /* Disable the transfer complete interrupt if the DMA mode is Double Buffering */
      if((ccr_reg & BDMA_CCR_DBM) != 0U)
240047b6:	693b      	ldr	r3, [r7, #16]
240047b8:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
240047bc:	2b00      	cmp	r3, #0
240047be:	d018      	beq.n	240047f2 <HAL_DMA_IRQHandler+0xbb6>
      {
        /* Current memory buffer used is Memory 0 */
        if((ccr_reg & BDMA_CCR_CT) == 0U)
240047c0:	693b      	ldr	r3, [r7, #16]
240047c2:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
240047c6:	2b00      	cmp	r3, #0
240047c8:	d109      	bne.n	240047de <HAL_DMA_IRQHandler+0xba2>
        {
          if(hdma->XferM1CpltCallback != NULL)
240047ca:	687b      	ldr	r3, [r7, #4]
240047cc:	6c5b      	ldr	r3, [r3, #68]	; 0x44
240047ce:	2b00      	cmp	r3, #0
240047d0:	f000 813a 	beq.w	24004a48 <HAL_DMA_IRQHandler+0xe0c>
          {
            /* Transfer complete Callback for Memory 1 */
            hdma->XferM1CpltCallback(hdma);
240047d4:	687b      	ldr	r3, [r7, #4]
240047d6:	6c5b      	ldr	r3, [r3, #68]	; 0x44
240047d8:	6878      	ldr	r0, [r7, #4]
240047da:	4798      	blx	r3
      if((ccr_reg & BDMA_CCR_DBM) != 0U)
240047dc:	e134      	b.n	24004a48 <HAL_DMA_IRQHandler+0xe0c>
          }
        }
        /* Current memory buffer used is Memory 1 */
        else
        {
          if(hdma->XferCpltCallback != NULL)
240047de:	687b      	ldr	r3, [r7, #4]
240047e0:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
240047e2:	2b00      	cmp	r3, #0
240047e4:	f000 8130 	beq.w	24004a48 <HAL_DMA_IRQHandler+0xe0c>
          {
            /* Transfer complete Callback for Memory 0 */
            hdma->XferCpltCallback(hdma);
240047e8:	687b      	ldr	r3, [r7, #4]
240047ea:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
240047ec:	6878      	ldr	r0, [r7, #4]
240047ee:	4798      	blx	r3
      if((ccr_reg & BDMA_CCR_DBM) != 0U)
240047f0:	e12a      	b.n	24004a48 <HAL_DMA_IRQHandler+0xe0c>
          }
        }
      }
      else
      {
        if((ccr_reg & BDMA_CCR_CIRC) == 0U)
240047f2:	693b      	ldr	r3, [r7, #16]
240047f4:	f003 0320 	and.w	r3, r3, #32
240047f8:	2b00      	cmp	r3, #0
240047fa:	d168      	bne.n	240048ce <HAL_DMA_IRQHandler+0xc92>
        {
          /* Disable the transfer complete and error interrupt, if the DMA mode is not CIRCULAR */
          __HAL_DMA_DISABLE_IT(hdma, DMA_IT_TE | DMA_IT_TC);
240047fc:	687b      	ldr	r3, [r7, #4]
240047fe:	681b      	ldr	r3, [r3, #0]
24004800:	4a38      	ldr	r2, [pc, #224]	; (240048e4 <HAL_DMA_IRQHandler+0xca8>)
24004802:	4293      	cmp	r3, r2
24004804:	d04a      	beq.n	2400489c <HAL_DMA_IRQHandler+0xc60>
24004806:	687b      	ldr	r3, [r7, #4]
24004808:	681b      	ldr	r3, [r3, #0]
2400480a:	4a37      	ldr	r2, [pc, #220]	; (240048e8 <HAL_DMA_IRQHandler+0xcac>)
2400480c:	4293      	cmp	r3, r2
2400480e:	d045      	beq.n	2400489c <HAL_DMA_IRQHandler+0xc60>
24004810:	687b      	ldr	r3, [r7, #4]
24004812:	681b      	ldr	r3, [r3, #0]
24004814:	4a35      	ldr	r2, [pc, #212]	; (240048ec <HAL_DMA_IRQHandler+0xcb0>)
24004816:	4293      	cmp	r3, r2
24004818:	d040      	beq.n	2400489c <HAL_DMA_IRQHandler+0xc60>
2400481a:	687b      	ldr	r3, [r7, #4]
2400481c:	681b      	ldr	r3, [r3, #0]
2400481e:	4a34      	ldr	r2, [pc, #208]	; (240048f0 <HAL_DMA_IRQHandler+0xcb4>)
24004820:	4293      	cmp	r3, r2
24004822:	d03b      	beq.n	2400489c <HAL_DMA_IRQHandler+0xc60>
24004824:	687b      	ldr	r3, [r7, #4]
24004826:	681b      	ldr	r3, [r3, #0]
24004828:	4a32      	ldr	r2, [pc, #200]	; (240048f4 <HAL_DMA_IRQHandler+0xcb8>)
2400482a:	4293      	cmp	r3, r2
2400482c:	d036      	beq.n	2400489c <HAL_DMA_IRQHandler+0xc60>
2400482e:	687b      	ldr	r3, [r7, #4]
24004830:	681b      	ldr	r3, [r3, #0]
24004832:	4a31      	ldr	r2, [pc, #196]	; (240048f8 <HAL_DMA_IRQHandler+0xcbc>)
24004834:	4293      	cmp	r3, r2
24004836:	d031      	beq.n	2400489c <HAL_DMA_IRQHandler+0xc60>
24004838:	687b      	ldr	r3, [r7, #4]
2400483a:	681b      	ldr	r3, [r3, #0]
2400483c:	4a2f      	ldr	r2, [pc, #188]	; (240048fc <HAL_DMA_IRQHandler+0xcc0>)
2400483e:	4293      	cmp	r3, r2
24004840:	d02c      	beq.n	2400489c <HAL_DMA_IRQHandler+0xc60>
24004842:	687b      	ldr	r3, [r7, #4]
24004844:	681b      	ldr	r3, [r3, #0]
24004846:	4a2e      	ldr	r2, [pc, #184]	; (24004900 <HAL_DMA_IRQHandler+0xcc4>)
24004848:	4293      	cmp	r3, r2
2400484a:	d027      	beq.n	2400489c <HAL_DMA_IRQHandler+0xc60>
2400484c:	687b      	ldr	r3, [r7, #4]
2400484e:	681b      	ldr	r3, [r3, #0]
24004850:	4a2c      	ldr	r2, [pc, #176]	; (24004904 <HAL_DMA_IRQHandler+0xcc8>)
24004852:	4293      	cmp	r3, r2
24004854:	d022      	beq.n	2400489c <HAL_DMA_IRQHandler+0xc60>
24004856:	687b      	ldr	r3, [r7, #4]
24004858:	681b      	ldr	r3, [r3, #0]
2400485a:	4a2b      	ldr	r2, [pc, #172]	; (24004908 <HAL_DMA_IRQHandler+0xccc>)
2400485c:	4293      	cmp	r3, r2
2400485e:	d01d      	beq.n	2400489c <HAL_DMA_IRQHandler+0xc60>
24004860:	687b      	ldr	r3, [r7, #4]
24004862:	681b      	ldr	r3, [r3, #0]
24004864:	4a29      	ldr	r2, [pc, #164]	; (2400490c <HAL_DMA_IRQHandler+0xcd0>)
24004866:	4293      	cmp	r3, r2
24004868:	d018      	beq.n	2400489c <HAL_DMA_IRQHandler+0xc60>
2400486a:	687b      	ldr	r3, [r7, #4]
2400486c:	681b      	ldr	r3, [r3, #0]
2400486e:	4a28      	ldr	r2, [pc, #160]	; (24004910 <HAL_DMA_IRQHandler+0xcd4>)
24004870:	4293      	cmp	r3, r2
24004872:	d013      	beq.n	2400489c <HAL_DMA_IRQHandler+0xc60>
24004874:	687b      	ldr	r3, [r7, #4]
24004876:	681b      	ldr	r3, [r3, #0]
24004878:	4a26      	ldr	r2, [pc, #152]	; (24004914 <HAL_DMA_IRQHandler+0xcd8>)
2400487a:	4293      	cmp	r3, r2
2400487c:	d00e      	beq.n	2400489c <HAL_DMA_IRQHandler+0xc60>
2400487e:	687b      	ldr	r3, [r7, #4]
24004880:	681b      	ldr	r3, [r3, #0]
24004882:	4a25      	ldr	r2, [pc, #148]	; (24004918 <HAL_DMA_IRQHandler+0xcdc>)
24004884:	4293      	cmp	r3, r2
24004886:	d009      	beq.n	2400489c <HAL_DMA_IRQHandler+0xc60>
24004888:	687b      	ldr	r3, [r7, #4]
2400488a:	681b      	ldr	r3, [r3, #0]
2400488c:	4a23      	ldr	r2, [pc, #140]	; (2400491c <HAL_DMA_IRQHandler+0xce0>)
2400488e:	4293      	cmp	r3, r2
24004890:	d004      	beq.n	2400489c <HAL_DMA_IRQHandler+0xc60>
24004892:	687b      	ldr	r3, [r7, #4]
24004894:	681b      	ldr	r3, [r3, #0]
24004896:	4a22      	ldr	r2, [pc, #136]	; (24004920 <HAL_DMA_IRQHandler+0xce4>)
24004898:	4293      	cmp	r3, r2
2400489a:	d108      	bne.n	240048ae <HAL_DMA_IRQHandler+0xc72>
2400489c:	687b      	ldr	r3, [r7, #4]
2400489e:	681b      	ldr	r3, [r3, #0]
240048a0:	681a      	ldr	r2, [r3, #0]
240048a2:	687b      	ldr	r3, [r7, #4]
240048a4:	681b      	ldr	r3, [r3, #0]
240048a6:	f022 0214 	bic.w	r2, r2, #20
240048aa:	601a      	str	r2, [r3, #0]
240048ac:	e007      	b.n	240048be <HAL_DMA_IRQHandler+0xc82>
240048ae:	687b      	ldr	r3, [r7, #4]
240048b0:	681b      	ldr	r3, [r3, #0]
240048b2:	681a      	ldr	r2, [r3, #0]
240048b4:	687b      	ldr	r3, [r7, #4]
240048b6:	681b      	ldr	r3, [r3, #0]
240048b8:	f022 020a 	bic.w	r2, r2, #10
240048bc:	601a      	str	r2, [r3, #0]

          /* Process Unlocked */
          __HAL_UNLOCK(hdma);
240048be:	687b      	ldr	r3, [r7, #4]
240048c0:	2200      	movs	r2, #0
240048c2:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

          /* Change the DMA state */
          hdma->State = HAL_DMA_STATE_READY;
240048c6:	687b      	ldr	r3, [r7, #4]
240048c8:	2201      	movs	r2, #1
240048ca:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
        }

        if(hdma->XferCpltCallback != NULL)
240048ce:	687b      	ldr	r3, [r7, #4]
240048d0:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
240048d2:	2b00      	cmp	r3, #0
240048d4:	f000 80b8 	beq.w	24004a48 <HAL_DMA_IRQHandler+0xe0c>
        {
          /* Transfer complete callback */
          hdma->XferCpltCallback(hdma);
240048d8:	687b      	ldr	r3, [r7, #4]
240048da:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
240048dc:	6878      	ldr	r0, [r7, #4]
240048de:	4798      	blx	r3
      if((ccr_reg & BDMA_CCR_DBM) != 0U)
240048e0:	e0b2      	b.n	24004a48 <HAL_DMA_IRQHandler+0xe0c>
240048e2:	bf00      	nop
240048e4:	40020010 	.word	0x40020010
240048e8:	40020028 	.word	0x40020028
240048ec:	40020040 	.word	0x40020040
240048f0:	40020058 	.word	0x40020058
240048f4:	40020070 	.word	0x40020070
240048f8:	40020088 	.word	0x40020088
240048fc:	400200a0 	.word	0x400200a0
24004900:	400200b8 	.word	0x400200b8
24004904:	40020410 	.word	0x40020410
24004908:	40020428 	.word	0x40020428
2400490c:	40020440 	.word	0x40020440
24004910:	40020458 	.word	0x40020458
24004914:	40020470 	.word	0x40020470
24004918:	40020488 	.word	0x40020488
2400491c:	400204a0 	.word	0x400204a0
24004920:	400204b8 	.word	0x400204b8
        }
      }
    }
    /* Transfer Error Interrupt management **************************************/
    else if (((tmpisr_bdma & (BDMA_FLAG_TE0 << (hdma->StreamIndex & 0x1FU))) != 0U) && ((ccr_reg & BDMA_CCR_TEIE) != 0U))
24004924:	687b      	ldr	r3, [r7, #4]
24004926:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
24004928:	f003 031f 	and.w	r3, r3, #31
2400492c:	2208      	movs	r2, #8
2400492e:	409a      	lsls	r2, r3
24004930:	697b      	ldr	r3, [r7, #20]
24004932:	4013      	ands	r3, r2
24004934:	2b00      	cmp	r3, #0
24004936:	f000 8088 	beq.w	24004a4a <HAL_DMA_IRQHandler+0xe0e>
2400493a:	693b      	ldr	r3, [r7, #16]
2400493c:	f003 0308 	and.w	r3, r3, #8
24004940:	2b00      	cmp	r3, #0
24004942:	f000 8082 	beq.w	24004a4a <HAL_DMA_IRQHandler+0xe0e>
    {
      /* When a DMA transfer error occurs */
      /* A hardware clear of its EN bits is performed */
      /* Disable ALL DMA IT */
      __HAL_DMA_DISABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
24004946:	687b      	ldr	r3, [r7, #4]
24004948:	681b      	ldr	r3, [r3, #0]
2400494a:	4a41      	ldr	r2, [pc, #260]	; (24004a50 <HAL_DMA_IRQHandler+0xe14>)
2400494c:	4293      	cmp	r3, r2
2400494e:	d04a      	beq.n	240049e6 <HAL_DMA_IRQHandler+0xdaa>
24004950:	687b      	ldr	r3, [r7, #4]
24004952:	681b      	ldr	r3, [r3, #0]
24004954:	4a3f      	ldr	r2, [pc, #252]	; (24004a54 <HAL_DMA_IRQHandler+0xe18>)
24004956:	4293      	cmp	r3, r2
24004958:	d045      	beq.n	240049e6 <HAL_DMA_IRQHandler+0xdaa>
2400495a:	687b      	ldr	r3, [r7, #4]
2400495c:	681b      	ldr	r3, [r3, #0]
2400495e:	4a3e      	ldr	r2, [pc, #248]	; (24004a58 <HAL_DMA_IRQHandler+0xe1c>)
24004960:	4293      	cmp	r3, r2
24004962:	d040      	beq.n	240049e6 <HAL_DMA_IRQHandler+0xdaa>
24004964:	687b      	ldr	r3, [r7, #4]
24004966:	681b      	ldr	r3, [r3, #0]
24004968:	4a3c      	ldr	r2, [pc, #240]	; (24004a5c <HAL_DMA_IRQHandler+0xe20>)
2400496a:	4293      	cmp	r3, r2
2400496c:	d03b      	beq.n	240049e6 <HAL_DMA_IRQHandler+0xdaa>
2400496e:	687b      	ldr	r3, [r7, #4]
24004970:	681b      	ldr	r3, [r3, #0]
24004972:	4a3b      	ldr	r2, [pc, #236]	; (24004a60 <HAL_DMA_IRQHandler+0xe24>)
24004974:	4293      	cmp	r3, r2
24004976:	d036      	beq.n	240049e6 <HAL_DMA_IRQHandler+0xdaa>
24004978:	687b      	ldr	r3, [r7, #4]
2400497a:	681b      	ldr	r3, [r3, #0]
2400497c:	4a39      	ldr	r2, [pc, #228]	; (24004a64 <HAL_DMA_IRQHandler+0xe28>)
2400497e:	4293      	cmp	r3, r2
24004980:	d031      	beq.n	240049e6 <HAL_DMA_IRQHandler+0xdaa>
24004982:	687b      	ldr	r3, [r7, #4]
24004984:	681b      	ldr	r3, [r3, #0]
24004986:	4a38      	ldr	r2, [pc, #224]	; (24004a68 <HAL_DMA_IRQHandler+0xe2c>)
24004988:	4293      	cmp	r3, r2
2400498a:	d02c      	beq.n	240049e6 <HAL_DMA_IRQHandler+0xdaa>
2400498c:	687b      	ldr	r3, [r7, #4]
2400498e:	681b      	ldr	r3, [r3, #0]
24004990:	4a36      	ldr	r2, [pc, #216]	; (24004a6c <HAL_DMA_IRQHandler+0xe30>)
24004992:	4293      	cmp	r3, r2
24004994:	d027      	beq.n	240049e6 <HAL_DMA_IRQHandler+0xdaa>
24004996:	687b      	ldr	r3, [r7, #4]
24004998:	681b      	ldr	r3, [r3, #0]
2400499a:	4a35      	ldr	r2, [pc, #212]	; (24004a70 <HAL_DMA_IRQHandler+0xe34>)
2400499c:	4293      	cmp	r3, r2
2400499e:	d022      	beq.n	240049e6 <HAL_DMA_IRQHandler+0xdaa>
240049a0:	687b      	ldr	r3, [r7, #4]
240049a2:	681b      	ldr	r3, [r3, #0]
240049a4:	4a33      	ldr	r2, [pc, #204]	; (24004a74 <HAL_DMA_IRQHandler+0xe38>)
240049a6:	4293      	cmp	r3, r2
240049a8:	d01d      	beq.n	240049e6 <HAL_DMA_IRQHandler+0xdaa>
240049aa:	687b      	ldr	r3, [r7, #4]
240049ac:	681b      	ldr	r3, [r3, #0]
240049ae:	4a32      	ldr	r2, [pc, #200]	; (24004a78 <HAL_DMA_IRQHandler+0xe3c>)
240049b0:	4293      	cmp	r3, r2
240049b2:	d018      	beq.n	240049e6 <HAL_DMA_IRQHandler+0xdaa>
240049b4:	687b      	ldr	r3, [r7, #4]
240049b6:	681b      	ldr	r3, [r3, #0]
240049b8:	4a30      	ldr	r2, [pc, #192]	; (24004a7c <HAL_DMA_IRQHandler+0xe40>)
240049ba:	4293      	cmp	r3, r2
240049bc:	d013      	beq.n	240049e6 <HAL_DMA_IRQHandler+0xdaa>
240049be:	687b      	ldr	r3, [r7, #4]
240049c0:	681b      	ldr	r3, [r3, #0]
240049c2:	4a2f      	ldr	r2, [pc, #188]	; (24004a80 <HAL_DMA_IRQHandler+0xe44>)
240049c4:	4293      	cmp	r3, r2
240049c6:	d00e      	beq.n	240049e6 <HAL_DMA_IRQHandler+0xdaa>
240049c8:	687b      	ldr	r3, [r7, #4]
240049ca:	681b      	ldr	r3, [r3, #0]
240049cc:	4a2d      	ldr	r2, [pc, #180]	; (24004a84 <HAL_DMA_IRQHandler+0xe48>)
240049ce:	4293      	cmp	r3, r2
240049d0:	d009      	beq.n	240049e6 <HAL_DMA_IRQHandler+0xdaa>
240049d2:	687b      	ldr	r3, [r7, #4]
240049d4:	681b      	ldr	r3, [r3, #0]
240049d6:	4a2c      	ldr	r2, [pc, #176]	; (24004a88 <HAL_DMA_IRQHandler+0xe4c>)
240049d8:	4293      	cmp	r3, r2
240049da:	d004      	beq.n	240049e6 <HAL_DMA_IRQHandler+0xdaa>
240049dc:	687b      	ldr	r3, [r7, #4]
240049de:	681b      	ldr	r3, [r3, #0]
240049e0:	4a2a      	ldr	r2, [pc, #168]	; (24004a8c <HAL_DMA_IRQHandler+0xe50>)
240049e2:	4293      	cmp	r3, r2
240049e4:	d108      	bne.n	240049f8 <HAL_DMA_IRQHandler+0xdbc>
240049e6:	687b      	ldr	r3, [r7, #4]
240049e8:	681b      	ldr	r3, [r3, #0]
240049ea:	681a      	ldr	r2, [r3, #0]
240049ec:	687b      	ldr	r3, [r7, #4]
240049ee:	681b      	ldr	r3, [r3, #0]
240049f0:	f022 021c 	bic.w	r2, r2, #28
240049f4:	601a      	str	r2, [r3, #0]
240049f6:	e007      	b.n	24004a08 <HAL_DMA_IRQHandler+0xdcc>
240049f8:	687b      	ldr	r3, [r7, #4]
240049fa:	681b      	ldr	r3, [r3, #0]
240049fc:	681a      	ldr	r2, [r3, #0]
240049fe:	687b      	ldr	r3, [r7, #4]
24004a00:	681b      	ldr	r3, [r3, #0]
24004a02:	f022 020e 	bic.w	r2, r2, #14
24004a06:	601a      	str	r2, [r3, #0]

      /* Clear all flags */
      regs_bdma->IFCR = (BDMA_ISR_GIF0) << (hdma->StreamIndex & 0x1FU);
24004a08:	687b      	ldr	r3, [r7, #4]
24004a0a:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
24004a0c:	f003 031f 	and.w	r3, r3, #31
24004a10:	2201      	movs	r2, #1
24004a12:	409a      	lsls	r2, r3
24004a14:	69fb      	ldr	r3, [r7, #28]
24004a16:	605a      	str	r2, [r3, #4]

      /* Update error code */
      hdma->ErrorCode = HAL_DMA_ERROR_TE;
24004a18:	687b      	ldr	r3, [r7, #4]
24004a1a:	2201      	movs	r2, #1
24004a1c:	655a      	str	r2, [r3, #84]	; 0x54

      /* Process Unlocked */
      __HAL_UNLOCK(hdma);
24004a1e:	687b      	ldr	r3, [r7, #4]
24004a20:	2200      	movs	r2, #0
24004a22:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

      /* Change the DMA state */
      hdma->State = HAL_DMA_STATE_READY;
24004a26:	687b      	ldr	r3, [r7, #4]
24004a28:	2201      	movs	r2, #1
24004a2a:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

      if (hdma->XferErrorCallback != NULL)
24004a2e:	687b      	ldr	r3, [r7, #4]
24004a30:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
24004a32:	2b00      	cmp	r3, #0
24004a34:	d009      	beq.n	24004a4a <HAL_DMA_IRQHandler+0xe0e>
      {
        /* Transfer error callback */
        hdma->XferErrorCallback(hdma);
24004a36:	687b      	ldr	r3, [r7, #4]
24004a38:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
24004a3a:	6878      	ldr	r0, [r7, #4]
24004a3c:	4798      	blx	r3
24004a3e:	e004      	b.n	24004a4a <HAL_DMA_IRQHandler+0xe0e>
          return;
24004a40:	bf00      	nop
24004a42:	e002      	b.n	24004a4a <HAL_DMA_IRQHandler+0xe0e>
      if((ccr_reg & BDMA_CCR_DBM) != 0U)
24004a44:	bf00      	nop
24004a46:	e000      	b.n	24004a4a <HAL_DMA_IRQHandler+0xe0e>
      if((ccr_reg & BDMA_CCR_DBM) != 0U)
24004a48:	bf00      	nop
  }
  else
  {
    /* Nothing To Do */
  }
}
24004a4a:	3728      	adds	r7, #40	; 0x28
24004a4c:	46bd      	mov	sp, r7
24004a4e:	bd80      	pop	{r7, pc}
24004a50:	40020010 	.word	0x40020010
24004a54:	40020028 	.word	0x40020028
24004a58:	40020040 	.word	0x40020040
24004a5c:	40020058 	.word	0x40020058
24004a60:	40020070 	.word	0x40020070
24004a64:	40020088 	.word	0x40020088
24004a68:	400200a0 	.word	0x400200a0
24004a6c:	400200b8 	.word	0x400200b8
24004a70:	40020410 	.word	0x40020410
24004a74:	40020428 	.word	0x40020428
24004a78:	40020440 	.word	0x40020440
24004a7c:	40020458 	.word	0x40020458
24004a80:	40020470 	.word	0x40020470
24004a84:	40020488 	.word	0x40020488
24004a88:	400204a0 	.word	0x400204a0
24004a8c:	400204b8 	.word	0x400204b8

24004a90 <HAL_DMA_RegisterCallback>:
  * @param  pCallback:            pointer to private callback function which has pointer to
  *                               a DMA_HandleTypeDef structure as parameter.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_RegisterCallback(DMA_HandleTypeDef *hdma, HAL_DMA_CallbackIDTypeDef CallbackID, void (* pCallback)(DMA_HandleTypeDef *_hdma))
{
24004a90:	b480      	push	{r7}
24004a92:	b087      	sub	sp, #28
24004a94:	af00      	add	r7, sp, #0
24004a96:	60f8      	str	r0, [r7, #12]
24004a98:	460b      	mov	r3, r1
24004a9a:	607a      	str	r2, [r7, #4]
24004a9c:	72fb      	strb	r3, [r7, #11]

  HAL_StatusTypeDef status = HAL_OK;
24004a9e:	2300      	movs	r3, #0
24004aa0:	75fb      	strb	r3, [r7, #23]

  /* Check the DMA peripheral handle */
  if(hdma == NULL)
24004aa2:	68fb      	ldr	r3, [r7, #12]
24004aa4:	2b00      	cmp	r3, #0
24004aa6:	d101      	bne.n	24004aac <HAL_DMA_RegisterCallback+0x1c>
  {
    return HAL_ERROR;
24004aa8:	2301      	movs	r3, #1
24004aaa:	e044      	b.n	24004b36 <HAL_DMA_RegisterCallback+0xa6>
  }

  /* Process locked */
  __HAL_LOCK(hdma);
24004aac:	68fb      	ldr	r3, [r7, #12]
24004aae:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
24004ab2:	2b01      	cmp	r3, #1
24004ab4:	d101      	bne.n	24004aba <HAL_DMA_RegisterCallback+0x2a>
24004ab6:	2302      	movs	r3, #2
24004ab8:	e03d      	b.n	24004b36 <HAL_DMA_RegisterCallback+0xa6>
24004aba:	68fb      	ldr	r3, [r7, #12]
24004abc:	2201      	movs	r2, #1
24004abe:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

  if(HAL_DMA_STATE_READY == hdma->State)
24004ac2:	68fb      	ldr	r3, [r7, #12]
24004ac4:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
24004ac8:	b2db      	uxtb	r3, r3
24004aca:	2b01      	cmp	r3, #1
24004acc:	d12a      	bne.n	24004b24 <HAL_DMA_RegisterCallback+0x94>
  {
    switch (CallbackID)
24004ace:	7afb      	ldrb	r3, [r7, #11]
24004ad0:	2b05      	cmp	r3, #5
24004ad2:	d82a      	bhi.n	24004b2a <HAL_DMA_RegisterCallback+0x9a>
24004ad4:	a201      	add	r2, pc, #4	; (adr r2, 24004adc <HAL_DMA_RegisterCallback+0x4c>)
24004ad6:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
24004ada:	bf00      	nop
24004adc:	24004af5 	.word	0x24004af5
24004ae0:	24004afd 	.word	0x24004afd
24004ae4:	24004b05 	.word	0x24004b05
24004ae8:	24004b0d 	.word	0x24004b0d
24004aec:	24004b15 	.word	0x24004b15
24004af0:	24004b1d 	.word	0x24004b1d
    {
    case  HAL_DMA_XFER_CPLT_CB_ID:
      hdma->XferCpltCallback = pCallback;
24004af4:	68fb      	ldr	r3, [r7, #12]
24004af6:	687a      	ldr	r2, [r7, #4]
24004af8:	63da      	str	r2, [r3, #60]	; 0x3c
      break;
24004afa:	e017      	b.n	24004b2c <HAL_DMA_RegisterCallback+0x9c>

    case  HAL_DMA_XFER_HALFCPLT_CB_ID:
      hdma->XferHalfCpltCallback = pCallback;
24004afc:	68fb      	ldr	r3, [r7, #12]
24004afe:	687a      	ldr	r2, [r7, #4]
24004b00:	641a      	str	r2, [r3, #64]	; 0x40
      break;
24004b02:	e013      	b.n	24004b2c <HAL_DMA_RegisterCallback+0x9c>

    case  HAL_DMA_XFER_M1CPLT_CB_ID:
      hdma->XferM1CpltCallback = pCallback;
24004b04:	68fb      	ldr	r3, [r7, #12]
24004b06:	687a      	ldr	r2, [r7, #4]
24004b08:	645a      	str	r2, [r3, #68]	; 0x44
      break;
24004b0a:	e00f      	b.n	24004b2c <HAL_DMA_RegisterCallback+0x9c>

    case  HAL_DMA_XFER_M1HALFCPLT_CB_ID:
      hdma->XferM1HalfCpltCallback = pCallback;
24004b0c:	68fb      	ldr	r3, [r7, #12]
24004b0e:	687a      	ldr	r2, [r7, #4]
24004b10:	649a      	str	r2, [r3, #72]	; 0x48
      break;
24004b12:	e00b      	b.n	24004b2c <HAL_DMA_RegisterCallback+0x9c>

    case  HAL_DMA_XFER_ERROR_CB_ID:
      hdma->XferErrorCallback = pCallback;
24004b14:	68fb      	ldr	r3, [r7, #12]
24004b16:	687a      	ldr	r2, [r7, #4]
24004b18:	64da      	str	r2, [r3, #76]	; 0x4c
      break;
24004b1a:	e007      	b.n	24004b2c <HAL_DMA_RegisterCallback+0x9c>

    case  HAL_DMA_XFER_ABORT_CB_ID:
      hdma->XferAbortCallback = pCallback;
24004b1c:	68fb      	ldr	r3, [r7, #12]
24004b1e:	687a      	ldr	r2, [r7, #4]
24004b20:	651a      	str	r2, [r3, #80]	; 0x50
      break;
24004b22:	e003      	b.n	24004b2c <HAL_DMA_RegisterCallback+0x9c>
    }
  }
  else
  {
    /* Return error status */
    status =  HAL_ERROR;
24004b24:	2301      	movs	r3, #1
24004b26:	75fb      	strb	r3, [r7, #23]
24004b28:	e000      	b.n	24004b2c <HAL_DMA_RegisterCallback+0x9c>
      break;
24004b2a:	bf00      	nop
  }

  /* Release Lock */
  __HAL_UNLOCK(hdma);
24004b2c:	68fb      	ldr	r3, [r7, #12]
24004b2e:	2200      	movs	r2, #0
24004b30:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

  return status;
24004b34:	7dfb      	ldrb	r3, [r7, #23]
}
24004b36:	4618      	mov	r0, r3
24004b38:	371c      	adds	r7, #28
24004b3a:	46bd      	mov	sp, r7
24004b3c:	f85d 7b04 	ldr.w	r7, [sp], #4
24004b40:	4770      	bx	lr
24004b42:	bf00      	nop

24004b44 <HAL_DMA_UnRegisterCallback>:
  * @param  CallbackID:           User Callback identifier
  *                               a HAL_DMA_CallbackIDTypeDef ENUM as parameter.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_UnRegisterCallback(DMA_HandleTypeDef *hdma, HAL_DMA_CallbackIDTypeDef CallbackID)
{
24004b44:	b480      	push	{r7}
24004b46:	b085      	sub	sp, #20
24004b48:	af00      	add	r7, sp, #0
24004b4a:	6078      	str	r0, [r7, #4]
24004b4c:	460b      	mov	r3, r1
24004b4e:	70fb      	strb	r3, [r7, #3]
  HAL_StatusTypeDef status = HAL_OK;
24004b50:	2300      	movs	r3, #0
24004b52:	73fb      	strb	r3, [r7, #15]

  /* Check the DMA peripheral handle */
  if(hdma == NULL)
24004b54:	687b      	ldr	r3, [r7, #4]
24004b56:	2b00      	cmp	r3, #0
24004b58:	d101      	bne.n	24004b5e <HAL_DMA_UnRegisterCallback+0x1a>
  {
    return HAL_ERROR;
24004b5a:	2301      	movs	r3, #1
24004b5c:	e05a      	b.n	24004c14 <HAL_DMA_UnRegisterCallback+0xd0>
  }

  /* Process locked */
  __HAL_LOCK(hdma);
24004b5e:	687b      	ldr	r3, [r7, #4]
24004b60:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
24004b64:	2b01      	cmp	r3, #1
24004b66:	d101      	bne.n	24004b6c <HAL_DMA_UnRegisterCallback+0x28>
24004b68:	2302      	movs	r3, #2
24004b6a:	e053      	b.n	24004c14 <HAL_DMA_UnRegisterCallback+0xd0>
24004b6c:	687b      	ldr	r3, [r7, #4]
24004b6e:	2201      	movs	r2, #1
24004b70:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

  if(HAL_DMA_STATE_READY == hdma->State)
24004b74:	687b      	ldr	r3, [r7, #4]
24004b76:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
24004b7a:	b2db      	uxtb	r3, r3
24004b7c:	2b01      	cmp	r3, #1
24004b7e:	d142      	bne.n	24004c06 <HAL_DMA_UnRegisterCallback+0xc2>
  {
    switch (CallbackID)
24004b80:	78fb      	ldrb	r3, [r7, #3]
24004b82:	2b06      	cmp	r3, #6
24004b84:	d83b      	bhi.n	24004bfe <HAL_DMA_UnRegisterCallback+0xba>
24004b86:	a201      	add	r2, pc, #4	; (adr r2, 24004b8c <HAL_DMA_UnRegisterCallback+0x48>)
24004b88:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
24004b8c:	24004ba9 	.word	0x24004ba9
24004b90:	24004bb1 	.word	0x24004bb1
24004b94:	24004bb9 	.word	0x24004bb9
24004b98:	24004bc1 	.word	0x24004bc1
24004b9c:	24004bc9 	.word	0x24004bc9
24004ba0:	24004bd1 	.word	0x24004bd1
24004ba4:	24004bd9 	.word	0x24004bd9
    {
    case  HAL_DMA_XFER_CPLT_CB_ID:
      hdma->XferCpltCallback = NULL;
24004ba8:	687b      	ldr	r3, [r7, #4]
24004baa:	2200      	movs	r2, #0
24004bac:	63da      	str	r2, [r3, #60]	; 0x3c
      break;
24004bae:	e02c      	b.n	24004c0a <HAL_DMA_UnRegisterCallback+0xc6>

    case  HAL_DMA_XFER_HALFCPLT_CB_ID:
      hdma->XferHalfCpltCallback = NULL;
24004bb0:	687b      	ldr	r3, [r7, #4]
24004bb2:	2200      	movs	r2, #0
24004bb4:	641a      	str	r2, [r3, #64]	; 0x40
      break;
24004bb6:	e028      	b.n	24004c0a <HAL_DMA_UnRegisterCallback+0xc6>

    case  HAL_DMA_XFER_M1CPLT_CB_ID:
      hdma->XferM1CpltCallback = NULL;
24004bb8:	687b      	ldr	r3, [r7, #4]
24004bba:	2200      	movs	r2, #0
24004bbc:	645a      	str	r2, [r3, #68]	; 0x44
      break;
24004bbe:	e024      	b.n	24004c0a <HAL_DMA_UnRegisterCallback+0xc6>

    case  HAL_DMA_XFER_M1HALFCPLT_CB_ID:
      hdma->XferM1HalfCpltCallback = NULL;
24004bc0:	687b      	ldr	r3, [r7, #4]
24004bc2:	2200      	movs	r2, #0
24004bc4:	649a      	str	r2, [r3, #72]	; 0x48
      break;
24004bc6:	e020      	b.n	24004c0a <HAL_DMA_UnRegisterCallback+0xc6>

    case  HAL_DMA_XFER_ERROR_CB_ID:
      hdma->XferErrorCallback = NULL;
24004bc8:	687b      	ldr	r3, [r7, #4]
24004bca:	2200      	movs	r2, #0
24004bcc:	64da      	str	r2, [r3, #76]	; 0x4c
      break;
24004bce:	e01c      	b.n	24004c0a <HAL_DMA_UnRegisterCallback+0xc6>

    case  HAL_DMA_XFER_ABORT_CB_ID:
      hdma->XferAbortCallback = NULL;
24004bd0:	687b      	ldr	r3, [r7, #4]
24004bd2:	2200      	movs	r2, #0
24004bd4:	651a      	str	r2, [r3, #80]	; 0x50
      break;
24004bd6:	e018      	b.n	24004c0a <HAL_DMA_UnRegisterCallback+0xc6>

    case   HAL_DMA_XFER_ALL_CB_ID:
      hdma->XferCpltCallback = NULL;
24004bd8:	687b      	ldr	r3, [r7, #4]
24004bda:	2200      	movs	r2, #0
24004bdc:	63da      	str	r2, [r3, #60]	; 0x3c
      hdma->XferHalfCpltCallback = NULL;
24004bde:	687b      	ldr	r3, [r7, #4]
24004be0:	2200      	movs	r2, #0
24004be2:	641a      	str	r2, [r3, #64]	; 0x40
      hdma->XferM1CpltCallback = NULL;
24004be4:	687b      	ldr	r3, [r7, #4]
24004be6:	2200      	movs	r2, #0
24004be8:	645a      	str	r2, [r3, #68]	; 0x44
      hdma->XferM1HalfCpltCallback = NULL;
24004bea:	687b      	ldr	r3, [r7, #4]
24004bec:	2200      	movs	r2, #0
24004bee:	649a      	str	r2, [r3, #72]	; 0x48
      hdma->XferErrorCallback = NULL;
24004bf0:	687b      	ldr	r3, [r7, #4]
24004bf2:	2200      	movs	r2, #0
24004bf4:	64da      	str	r2, [r3, #76]	; 0x4c
      hdma->XferAbortCallback = NULL;
24004bf6:	687b      	ldr	r3, [r7, #4]
24004bf8:	2200      	movs	r2, #0
24004bfa:	651a      	str	r2, [r3, #80]	; 0x50
      break;
24004bfc:	e005      	b.n	24004c0a <HAL_DMA_UnRegisterCallback+0xc6>

    default:
      status = HAL_ERROR;
24004bfe:	2301      	movs	r3, #1
24004c00:	73fb      	strb	r3, [r7, #15]
      break;
24004c02:	bf00      	nop
24004c04:	e001      	b.n	24004c0a <HAL_DMA_UnRegisterCallback+0xc6>
    }
  }
  else
  {
    status = HAL_ERROR;
24004c06:	2301      	movs	r3, #1
24004c08:	73fb      	strb	r3, [r7, #15]
  }

  /* Release Lock */
  __HAL_UNLOCK(hdma);
24004c0a:	687b      	ldr	r3, [r7, #4]
24004c0c:	2200      	movs	r2, #0
24004c0e:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

  return status;
24004c12:	7bfb      	ldrb	r3, [r7, #15]
}
24004c14:	4618      	mov	r0, r3
24004c16:	3714      	adds	r7, #20
24004c18:	46bd      	mov	sp, r7
24004c1a:	f85d 7b04 	ldr.w	r7, [sp], #4
24004c1e:	4770      	bx	lr

24004c20 <HAL_DMA_GetState>:
  * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Stream.
  * @retval HAL state
  */
HAL_DMA_StateTypeDef HAL_DMA_GetState(DMA_HandleTypeDef *hdma)
{
24004c20:	b480      	push	{r7}
24004c22:	b083      	sub	sp, #12
24004c24:	af00      	add	r7, sp, #0
24004c26:	6078      	str	r0, [r7, #4]
  return hdma->State;
24004c28:	687b      	ldr	r3, [r7, #4]
24004c2a:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
24004c2e:	b2db      	uxtb	r3, r3
}
24004c30:	4618      	mov	r0, r3
24004c32:	370c      	adds	r7, #12
24004c34:	46bd      	mov	sp, r7
24004c36:	f85d 7b04 	ldr.w	r7, [sp], #4
24004c3a:	4770      	bx	lr

24004c3c <HAL_DMA_GetError>:
  * @param  hdma : pointer to a DMA_HandleTypeDef structure that contains
  *              the configuration information for the specified DMA Stream.
  * @retval DMA Error Code
  */
uint32_t HAL_DMA_GetError(DMA_HandleTypeDef *hdma)
{
24004c3c:	b480      	push	{r7}
24004c3e:	b083      	sub	sp, #12
24004c40:	af00      	add	r7, sp, #0
24004c42:	6078      	str	r0, [r7, #4]
  return hdma->ErrorCode;
24004c44:	687b      	ldr	r3, [r7, #4]
24004c46:	6d5b      	ldr	r3, [r3, #84]	; 0x54
}
24004c48:	4618      	mov	r0, r3
24004c4a:	370c      	adds	r7, #12
24004c4c:	46bd      	mov	sp, r7
24004c4e:	f85d 7b04 	ldr.w	r7, [sp], #4
24004c52:	4770      	bx	lr

24004c54 <DMA_SetConfig>:
  * @param  DstAddress: The destination memory Buffer address
  * @param  DataLength: The length of data to be transferred from source to destination
  * @retval None
  */
static void DMA_SetConfig(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
{
24004c54:	b480      	push	{r7}
24004c56:	b087      	sub	sp, #28
24004c58:	af00      	add	r7, sp, #0
24004c5a:	60f8      	str	r0, [r7, #12]
24004c5c:	60b9      	str	r1, [r7, #8]
24004c5e:	607a      	str	r2, [r7, #4]
24004c60:	603b      	str	r3, [r7, #0]
  /* calculate DMA base and stream number */
  DMA_Base_Registers  *regs_dma  = (DMA_Base_Registers *)hdma->StreamBaseAddress;
24004c62:	68fb      	ldr	r3, [r7, #12]
24004c64:	6d9b      	ldr	r3, [r3, #88]	; 0x58
24004c66:	617b      	str	r3, [r7, #20]
  BDMA_Base_Registers *regs_bdma = (BDMA_Base_Registers *)hdma->StreamBaseAddress;
24004c68:	68fb      	ldr	r3, [r7, #12]
24004c6a:	6d9b      	ldr	r3, [r3, #88]	; 0x58
24004c6c:	613b      	str	r3, [r7, #16]

  if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
24004c6e:	68fb      	ldr	r3, [r7, #12]
24004c70:	681b      	ldr	r3, [r3, #0]
24004c72:	4a84      	ldr	r2, [pc, #528]	; (24004e84 <DMA_SetConfig+0x230>)
24004c74:	4293      	cmp	r3, r2
24004c76:	d072      	beq.n	24004d5e <DMA_SetConfig+0x10a>
24004c78:	68fb      	ldr	r3, [r7, #12]
24004c7a:	681b      	ldr	r3, [r3, #0]
24004c7c:	4a82      	ldr	r2, [pc, #520]	; (24004e88 <DMA_SetConfig+0x234>)
24004c7e:	4293      	cmp	r3, r2
24004c80:	d06d      	beq.n	24004d5e <DMA_SetConfig+0x10a>
24004c82:	68fb      	ldr	r3, [r7, #12]
24004c84:	681b      	ldr	r3, [r3, #0]
24004c86:	4a81      	ldr	r2, [pc, #516]	; (24004e8c <DMA_SetConfig+0x238>)
24004c88:	4293      	cmp	r3, r2
24004c8a:	d068      	beq.n	24004d5e <DMA_SetConfig+0x10a>
24004c8c:	68fb      	ldr	r3, [r7, #12]
24004c8e:	681b      	ldr	r3, [r3, #0]
24004c90:	4a7f      	ldr	r2, [pc, #508]	; (24004e90 <DMA_SetConfig+0x23c>)
24004c92:	4293      	cmp	r3, r2
24004c94:	d063      	beq.n	24004d5e <DMA_SetConfig+0x10a>
24004c96:	68fb      	ldr	r3, [r7, #12]
24004c98:	681b      	ldr	r3, [r3, #0]
24004c9a:	4a7e      	ldr	r2, [pc, #504]	; (24004e94 <DMA_SetConfig+0x240>)
24004c9c:	4293      	cmp	r3, r2
24004c9e:	d05e      	beq.n	24004d5e <DMA_SetConfig+0x10a>
24004ca0:	68fb      	ldr	r3, [r7, #12]
24004ca2:	681b      	ldr	r3, [r3, #0]
24004ca4:	4a7c      	ldr	r2, [pc, #496]	; (24004e98 <DMA_SetConfig+0x244>)
24004ca6:	4293      	cmp	r3, r2
24004ca8:	d059      	beq.n	24004d5e <DMA_SetConfig+0x10a>
24004caa:	68fb      	ldr	r3, [r7, #12]
24004cac:	681b      	ldr	r3, [r3, #0]
24004cae:	4a7b      	ldr	r2, [pc, #492]	; (24004e9c <DMA_SetConfig+0x248>)
24004cb0:	4293      	cmp	r3, r2
24004cb2:	d054      	beq.n	24004d5e <DMA_SetConfig+0x10a>
24004cb4:	68fb      	ldr	r3, [r7, #12]
24004cb6:	681b      	ldr	r3, [r3, #0]
24004cb8:	4a79      	ldr	r2, [pc, #484]	; (24004ea0 <DMA_SetConfig+0x24c>)
24004cba:	4293      	cmp	r3, r2
24004cbc:	d04f      	beq.n	24004d5e <DMA_SetConfig+0x10a>
24004cbe:	68fb      	ldr	r3, [r7, #12]
24004cc0:	681b      	ldr	r3, [r3, #0]
24004cc2:	4a78      	ldr	r2, [pc, #480]	; (24004ea4 <DMA_SetConfig+0x250>)
24004cc4:	4293      	cmp	r3, r2
24004cc6:	d04a      	beq.n	24004d5e <DMA_SetConfig+0x10a>
24004cc8:	68fb      	ldr	r3, [r7, #12]
24004cca:	681b      	ldr	r3, [r3, #0]
24004ccc:	4a76      	ldr	r2, [pc, #472]	; (24004ea8 <DMA_SetConfig+0x254>)
24004cce:	4293      	cmp	r3, r2
24004cd0:	d045      	beq.n	24004d5e <DMA_SetConfig+0x10a>
24004cd2:	68fb      	ldr	r3, [r7, #12]
24004cd4:	681b      	ldr	r3, [r3, #0]
24004cd6:	4a75      	ldr	r2, [pc, #468]	; (24004eac <DMA_SetConfig+0x258>)
24004cd8:	4293      	cmp	r3, r2
24004cda:	d040      	beq.n	24004d5e <DMA_SetConfig+0x10a>
24004cdc:	68fb      	ldr	r3, [r7, #12]
24004cde:	681b      	ldr	r3, [r3, #0]
24004ce0:	4a73      	ldr	r2, [pc, #460]	; (24004eb0 <DMA_SetConfig+0x25c>)
24004ce2:	4293      	cmp	r3, r2
24004ce4:	d03b      	beq.n	24004d5e <DMA_SetConfig+0x10a>
24004ce6:	68fb      	ldr	r3, [r7, #12]
24004ce8:	681b      	ldr	r3, [r3, #0]
24004cea:	4a72      	ldr	r2, [pc, #456]	; (24004eb4 <DMA_SetConfig+0x260>)
24004cec:	4293      	cmp	r3, r2
24004cee:	d036      	beq.n	24004d5e <DMA_SetConfig+0x10a>
24004cf0:	68fb      	ldr	r3, [r7, #12]
24004cf2:	681b      	ldr	r3, [r3, #0]
24004cf4:	4a70      	ldr	r2, [pc, #448]	; (24004eb8 <DMA_SetConfig+0x264>)
24004cf6:	4293      	cmp	r3, r2
24004cf8:	d031      	beq.n	24004d5e <DMA_SetConfig+0x10a>
24004cfa:	68fb      	ldr	r3, [r7, #12]
24004cfc:	681b      	ldr	r3, [r3, #0]
24004cfe:	4a6f      	ldr	r2, [pc, #444]	; (24004ebc <DMA_SetConfig+0x268>)
24004d00:	4293      	cmp	r3, r2
24004d02:	d02c      	beq.n	24004d5e <DMA_SetConfig+0x10a>
24004d04:	68fb      	ldr	r3, [r7, #12]
24004d06:	681b      	ldr	r3, [r3, #0]
24004d08:	4a6d      	ldr	r2, [pc, #436]	; (24004ec0 <DMA_SetConfig+0x26c>)
24004d0a:	4293      	cmp	r3, r2
24004d0c:	d027      	beq.n	24004d5e <DMA_SetConfig+0x10a>
24004d0e:	68fb      	ldr	r3, [r7, #12]
24004d10:	681b      	ldr	r3, [r3, #0]
24004d12:	4a6c      	ldr	r2, [pc, #432]	; (24004ec4 <DMA_SetConfig+0x270>)
24004d14:	4293      	cmp	r3, r2
24004d16:	d022      	beq.n	24004d5e <DMA_SetConfig+0x10a>
24004d18:	68fb      	ldr	r3, [r7, #12]
24004d1a:	681b      	ldr	r3, [r3, #0]
24004d1c:	4a6a      	ldr	r2, [pc, #424]	; (24004ec8 <DMA_SetConfig+0x274>)
24004d1e:	4293      	cmp	r3, r2
24004d20:	d01d      	beq.n	24004d5e <DMA_SetConfig+0x10a>
24004d22:	68fb      	ldr	r3, [r7, #12]
24004d24:	681b      	ldr	r3, [r3, #0]
24004d26:	4a69      	ldr	r2, [pc, #420]	; (24004ecc <DMA_SetConfig+0x278>)
24004d28:	4293      	cmp	r3, r2
24004d2a:	d018      	beq.n	24004d5e <DMA_SetConfig+0x10a>
24004d2c:	68fb      	ldr	r3, [r7, #12]
24004d2e:	681b      	ldr	r3, [r3, #0]
24004d30:	4a67      	ldr	r2, [pc, #412]	; (24004ed0 <DMA_SetConfig+0x27c>)
24004d32:	4293      	cmp	r3, r2
24004d34:	d013      	beq.n	24004d5e <DMA_SetConfig+0x10a>
24004d36:	68fb      	ldr	r3, [r7, #12]
24004d38:	681b      	ldr	r3, [r3, #0]
24004d3a:	4a66      	ldr	r2, [pc, #408]	; (24004ed4 <DMA_SetConfig+0x280>)
24004d3c:	4293      	cmp	r3, r2
24004d3e:	d00e      	beq.n	24004d5e <DMA_SetConfig+0x10a>
24004d40:	68fb      	ldr	r3, [r7, #12]
24004d42:	681b      	ldr	r3, [r3, #0]
24004d44:	4a64      	ldr	r2, [pc, #400]	; (24004ed8 <DMA_SetConfig+0x284>)
24004d46:	4293      	cmp	r3, r2
24004d48:	d009      	beq.n	24004d5e <DMA_SetConfig+0x10a>
24004d4a:	68fb      	ldr	r3, [r7, #12]
24004d4c:	681b      	ldr	r3, [r3, #0]
24004d4e:	4a63      	ldr	r2, [pc, #396]	; (24004edc <DMA_SetConfig+0x288>)
24004d50:	4293      	cmp	r3, r2
24004d52:	d004      	beq.n	24004d5e <DMA_SetConfig+0x10a>
24004d54:	68fb      	ldr	r3, [r7, #12]
24004d56:	681b      	ldr	r3, [r3, #0]
24004d58:	4a61      	ldr	r2, [pc, #388]	; (24004ee0 <DMA_SetConfig+0x28c>)
24004d5a:	4293      	cmp	r3, r2
24004d5c:	d101      	bne.n	24004d62 <DMA_SetConfig+0x10e>
24004d5e:	2301      	movs	r3, #1
24004d60:	e000      	b.n	24004d64 <DMA_SetConfig+0x110>
24004d62:	2300      	movs	r3, #0
24004d64:	2b00      	cmp	r3, #0
24004d66:	d00d      	beq.n	24004d84 <DMA_SetConfig+0x130>
  {
    /* Clear the DMAMUX synchro overrun flag */
    hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
24004d68:	68fb      	ldr	r3, [r7, #12]
24004d6a:	6e5b      	ldr	r3, [r3, #100]	; 0x64
24004d6c:	68fa      	ldr	r2, [r7, #12]
24004d6e:	6e92      	ldr	r2, [r2, #104]	; 0x68
24004d70:	605a      	str	r2, [r3, #4]

    if(hdma->DMAmuxRequestGen != 0U)
24004d72:	68fb      	ldr	r3, [r7, #12]
24004d74:	6edb      	ldr	r3, [r3, #108]	; 0x6c
24004d76:	2b00      	cmp	r3, #0
24004d78:	d004      	beq.n	24004d84 <DMA_SetConfig+0x130>
    {
      /* Clear the DMAMUX request generator overrun flag */
      hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
24004d7a:	68fb      	ldr	r3, [r7, #12]
24004d7c:	6f1b      	ldr	r3, [r3, #112]	; 0x70
24004d7e:	68fa      	ldr	r2, [r7, #12]
24004d80:	6f52      	ldr	r2, [r2, #116]	; 0x74
24004d82:	605a      	str	r2, [r3, #4]
    }
  }

  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
24004d84:	68fb      	ldr	r3, [r7, #12]
24004d86:	681b      	ldr	r3, [r3, #0]
24004d88:	4a3e      	ldr	r2, [pc, #248]	; (24004e84 <DMA_SetConfig+0x230>)
24004d8a:	4293      	cmp	r3, r2
24004d8c:	d04a      	beq.n	24004e24 <DMA_SetConfig+0x1d0>
24004d8e:	68fb      	ldr	r3, [r7, #12]
24004d90:	681b      	ldr	r3, [r3, #0]
24004d92:	4a3d      	ldr	r2, [pc, #244]	; (24004e88 <DMA_SetConfig+0x234>)
24004d94:	4293      	cmp	r3, r2
24004d96:	d045      	beq.n	24004e24 <DMA_SetConfig+0x1d0>
24004d98:	68fb      	ldr	r3, [r7, #12]
24004d9a:	681b      	ldr	r3, [r3, #0]
24004d9c:	4a3b      	ldr	r2, [pc, #236]	; (24004e8c <DMA_SetConfig+0x238>)
24004d9e:	4293      	cmp	r3, r2
24004da0:	d040      	beq.n	24004e24 <DMA_SetConfig+0x1d0>
24004da2:	68fb      	ldr	r3, [r7, #12]
24004da4:	681b      	ldr	r3, [r3, #0]
24004da6:	4a3a      	ldr	r2, [pc, #232]	; (24004e90 <DMA_SetConfig+0x23c>)
24004da8:	4293      	cmp	r3, r2
24004daa:	d03b      	beq.n	24004e24 <DMA_SetConfig+0x1d0>
24004dac:	68fb      	ldr	r3, [r7, #12]
24004dae:	681b      	ldr	r3, [r3, #0]
24004db0:	4a38      	ldr	r2, [pc, #224]	; (24004e94 <DMA_SetConfig+0x240>)
24004db2:	4293      	cmp	r3, r2
24004db4:	d036      	beq.n	24004e24 <DMA_SetConfig+0x1d0>
24004db6:	68fb      	ldr	r3, [r7, #12]
24004db8:	681b      	ldr	r3, [r3, #0]
24004dba:	4a37      	ldr	r2, [pc, #220]	; (24004e98 <DMA_SetConfig+0x244>)
24004dbc:	4293      	cmp	r3, r2
24004dbe:	d031      	beq.n	24004e24 <DMA_SetConfig+0x1d0>
24004dc0:	68fb      	ldr	r3, [r7, #12]
24004dc2:	681b      	ldr	r3, [r3, #0]
24004dc4:	4a35      	ldr	r2, [pc, #212]	; (24004e9c <DMA_SetConfig+0x248>)
24004dc6:	4293      	cmp	r3, r2
24004dc8:	d02c      	beq.n	24004e24 <DMA_SetConfig+0x1d0>
24004dca:	68fb      	ldr	r3, [r7, #12]
24004dcc:	681b      	ldr	r3, [r3, #0]
24004dce:	4a34      	ldr	r2, [pc, #208]	; (24004ea0 <DMA_SetConfig+0x24c>)
24004dd0:	4293      	cmp	r3, r2
24004dd2:	d027      	beq.n	24004e24 <DMA_SetConfig+0x1d0>
24004dd4:	68fb      	ldr	r3, [r7, #12]
24004dd6:	681b      	ldr	r3, [r3, #0]
24004dd8:	4a32      	ldr	r2, [pc, #200]	; (24004ea4 <DMA_SetConfig+0x250>)
24004dda:	4293      	cmp	r3, r2
24004ddc:	d022      	beq.n	24004e24 <DMA_SetConfig+0x1d0>
24004dde:	68fb      	ldr	r3, [r7, #12]
24004de0:	681b      	ldr	r3, [r3, #0]
24004de2:	4a31      	ldr	r2, [pc, #196]	; (24004ea8 <DMA_SetConfig+0x254>)
24004de4:	4293      	cmp	r3, r2
24004de6:	d01d      	beq.n	24004e24 <DMA_SetConfig+0x1d0>
24004de8:	68fb      	ldr	r3, [r7, #12]
24004dea:	681b      	ldr	r3, [r3, #0]
24004dec:	4a2f      	ldr	r2, [pc, #188]	; (24004eac <DMA_SetConfig+0x258>)
24004dee:	4293      	cmp	r3, r2
24004df0:	d018      	beq.n	24004e24 <DMA_SetConfig+0x1d0>
24004df2:	68fb      	ldr	r3, [r7, #12]
24004df4:	681b      	ldr	r3, [r3, #0]
24004df6:	4a2e      	ldr	r2, [pc, #184]	; (24004eb0 <DMA_SetConfig+0x25c>)
24004df8:	4293      	cmp	r3, r2
24004dfa:	d013      	beq.n	24004e24 <DMA_SetConfig+0x1d0>
24004dfc:	68fb      	ldr	r3, [r7, #12]
24004dfe:	681b      	ldr	r3, [r3, #0]
24004e00:	4a2c      	ldr	r2, [pc, #176]	; (24004eb4 <DMA_SetConfig+0x260>)
24004e02:	4293      	cmp	r3, r2
24004e04:	d00e      	beq.n	24004e24 <DMA_SetConfig+0x1d0>
24004e06:	68fb      	ldr	r3, [r7, #12]
24004e08:	681b      	ldr	r3, [r3, #0]
24004e0a:	4a2b      	ldr	r2, [pc, #172]	; (24004eb8 <DMA_SetConfig+0x264>)
24004e0c:	4293      	cmp	r3, r2
24004e0e:	d009      	beq.n	24004e24 <DMA_SetConfig+0x1d0>
24004e10:	68fb      	ldr	r3, [r7, #12]
24004e12:	681b      	ldr	r3, [r3, #0]
24004e14:	4a29      	ldr	r2, [pc, #164]	; (24004ebc <DMA_SetConfig+0x268>)
24004e16:	4293      	cmp	r3, r2
24004e18:	d004      	beq.n	24004e24 <DMA_SetConfig+0x1d0>
24004e1a:	68fb      	ldr	r3, [r7, #12]
24004e1c:	681b      	ldr	r3, [r3, #0]
24004e1e:	4a28      	ldr	r2, [pc, #160]	; (24004ec0 <DMA_SetConfig+0x26c>)
24004e20:	4293      	cmp	r3, r2
24004e22:	d101      	bne.n	24004e28 <DMA_SetConfig+0x1d4>
24004e24:	2301      	movs	r3, #1
24004e26:	e000      	b.n	24004e2a <DMA_SetConfig+0x1d6>
24004e28:	2300      	movs	r3, #0
24004e2a:	2b00      	cmp	r3, #0
24004e2c:	d05a      	beq.n	24004ee4 <DMA_SetConfig+0x290>
  {
    /* Clear all interrupt flags at correct offset within the register */
    regs_dma->IFCR = 0x3FUL << (hdma->StreamIndex & 0x1FU);
24004e2e:	68fb      	ldr	r3, [r7, #12]
24004e30:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
24004e32:	f003 031f 	and.w	r3, r3, #31
24004e36:	223f      	movs	r2, #63	; 0x3f
24004e38:	409a      	lsls	r2, r3
24004e3a:	697b      	ldr	r3, [r7, #20]
24004e3c:	609a      	str	r2, [r3, #8]

    /* Clear DBM bit */
    ((DMA_Stream_TypeDef *)hdma->Instance)->CR &= (uint32_t)(~DMA_SxCR_DBM);
24004e3e:	68fb      	ldr	r3, [r7, #12]
24004e40:	681b      	ldr	r3, [r3, #0]
24004e42:	681a      	ldr	r2, [r3, #0]
24004e44:	68fb      	ldr	r3, [r7, #12]
24004e46:	681b      	ldr	r3, [r3, #0]
24004e48:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
24004e4c:	601a      	str	r2, [r3, #0]

    /* Configure DMA Stream data length */
    ((DMA_Stream_TypeDef *)hdma->Instance)->NDTR = DataLength;
24004e4e:	68fb      	ldr	r3, [r7, #12]
24004e50:	681b      	ldr	r3, [r3, #0]
24004e52:	683a      	ldr	r2, [r7, #0]
24004e54:	605a      	str	r2, [r3, #4]

    /* Peripheral to Memory */
    if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
24004e56:	68fb      	ldr	r3, [r7, #12]
24004e58:	689b      	ldr	r3, [r3, #8]
24004e5a:	2b40      	cmp	r3, #64	; 0x40
24004e5c:	d108      	bne.n	24004e70 <DMA_SetConfig+0x21c>
    {
      /* Configure DMA Stream destination address */
      ((DMA_Stream_TypeDef *)hdma->Instance)->PAR = DstAddress;
24004e5e:	68fb      	ldr	r3, [r7, #12]
24004e60:	681b      	ldr	r3, [r3, #0]
24004e62:	687a      	ldr	r2, [r7, #4]
24004e64:	609a      	str	r2, [r3, #8]

      /* Configure DMA Stream source address */
      ((DMA_Stream_TypeDef *)hdma->Instance)->M0AR = SrcAddress;
24004e66:	68fb      	ldr	r3, [r7, #12]
24004e68:	681b      	ldr	r3, [r3, #0]
24004e6a:	68ba      	ldr	r2, [r7, #8]
24004e6c:	60da      	str	r2, [r3, #12]
  }
  else
  {
    /* Nothing To Do */
  }
}
24004e6e:	e087      	b.n	24004f80 <DMA_SetConfig+0x32c>
      ((DMA_Stream_TypeDef *)hdma->Instance)->PAR = SrcAddress;
24004e70:	68fb      	ldr	r3, [r7, #12]
24004e72:	681b      	ldr	r3, [r3, #0]
24004e74:	68ba      	ldr	r2, [r7, #8]
24004e76:	609a      	str	r2, [r3, #8]
      ((DMA_Stream_TypeDef *)hdma->Instance)->M0AR = DstAddress;
24004e78:	68fb      	ldr	r3, [r7, #12]
24004e7a:	681b      	ldr	r3, [r3, #0]
24004e7c:	687a      	ldr	r2, [r7, #4]
24004e7e:	60da      	str	r2, [r3, #12]
}
24004e80:	e07e      	b.n	24004f80 <DMA_SetConfig+0x32c>
24004e82:	bf00      	nop
24004e84:	40020010 	.word	0x40020010
24004e88:	40020028 	.word	0x40020028
24004e8c:	40020040 	.word	0x40020040
24004e90:	40020058 	.word	0x40020058
24004e94:	40020070 	.word	0x40020070
24004e98:	40020088 	.word	0x40020088
24004e9c:	400200a0 	.word	0x400200a0
24004ea0:	400200b8 	.word	0x400200b8
24004ea4:	40020410 	.word	0x40020410
24004ea8:	40020428 	.word	0x40020428
24004eac:	40020440 	.word	0x40020440
24004eb0:	40020458 	.word	0x40020458
24004eb4:	40020470 	.word	0x40020470
24004eb8:	40020488 	.word	0x40020488
24004ebc:	400204a0 	.word	0x400204a0
24004ec0:	400204b8 	.word	0x400204b8
24004ec4:	58025408 	.word	0x58025408
24004ec8:	5802541c 	.word	0x5802541c
24004ecc:	58025430 	.word	0x58025430
24004ed0:	58025444 	.word	0x58025444
24004ed4:	58025458 	.word	0x58025458
24004ed8:	5802546c 	.word	0x5802546c
24004edc:	58025480 	.word	0x58025480
24004ee0:	58025494 	.word	0x58025494
  else if(IS_BDMA_CHANNEL_INSTANCE(hdma->Instance) != 0U) /* BDMA instance(s) */
24004ee4:	68fb      	ldr	r3, [r7, #12]
24004ee6:	681b      	ldr	r3, [r3, #0]
24004ee8:	4a28      	ldr	r2, [pc, #160]	; (24004f8c <DMA_SetConfig+0x338>)
24004eea:	4293      	cmp	r3, r2
24004eec:	d022      	beq.n	24004f34 <DMA_SetConfig+0x2e0>
24004eee:	68fb      	ldr	r3, [r7, #12]
24004ef0:	681b      	ldr	r3, [r3, #0]
24004ef2:	4a27      	ldr	r2, [pc, #156]	; (24004f90 <DMA_SetConfig+0x33c>)
24004ef4:	4293      	cmp	r3, r2
24004ef6:	d01d      	beq.n	24004f34 <DMA_SetConfig+0x2e0>
24004ef8:	68fb      	ldr	r3, [r7, #12]
24004efa:	681b      	ldr	r3, [r3, #0]
24004efc:	4a25      	ldr	r2, [pc, #148]	; (24004f94 <DMA_SetConfig+0x340>)
24004efe:	4293      	cmp	r3, r2
24004f00:	d018      	beq.n	24004f34 <DMA_SetConfig+0x2e0>
24004f02:	68fb      	ldr	r3, [r7, #12]
24004f04:	681b      	ldr	r3, [r3, #0]
24004f06:	4a24      	ldr	r2, [pc, #144]	; (24004f98 <DMA_SetConfig+0x344>)
24004f08:	4293      	cmp	r3, r2
24004f0a:	d013      	beq.n	24004f34 <DMA_SetConfig+0x2e0>
24004f0c:	68fb      	ldr	r3, [r7, #12]
24004f0e:	681b      	ldr	r3, [r3, #0]
24004f10:	4a22      	ldr	r2, [pc, #136]	; (24004f9c <DMA_SetConfig+0x348>)
24004f12:	4293      	cmp	r3, r2
24004f14:	d00e      	beq.n	24004f34 <DMA_SetConfig+0x2e0>
24004f16:	68fb      	ldr	r3, [r7, #12]
24004f18:	681b      	ldr	r3, [r3, #0]
24004f1a:	4a21      	ldr	r2, [pc, #132]	; (24004fa0 <DMA_SetConfig+0x34c>)
24004f1c:	4293      	cmp	r3, r2
24004f1e:	d009      	beq.n	24004f34 <DMA_SetConfig+0x2e0>
24004f20:	68fb      	ldr	r3, [r7, #12]
24004f22:	681b      	ldr	r3, [r3, #0]
24004f24:	4a1f      	ldr	r2, [pc, #124]	; (24004fa4 <DMA_SetConfig+0x350>)
24004f26:	4293      	cmp	r3, r2
24004f28:	d004      	beq.n	24004f34 <DMA_SetConfig+0x2e0>
24004f2a:	68fb      	ldr	r3, [r7, #12]
24004f2c:	681b      	ldr	r3, [r3, #0]
24004f2e:	4a1e      	ldr	r2, [pc, #120]	; (24004fa8 <DMA_SetConfig+0x354>)
24004f30:	4293      	cmp	r3, r2
24004f32:	d101      	bne.n	24004f38 <DMA_SetConfig+0x2e4>
24004f34:	2301      	movs	r3, #1
24004f36:	e000      	b.n	24004f3a <DMA_SetConfig+0x2e6>
24004f38:	2300      	movs	r3, #0
24004f3a:	2b00      	cmp	r3, #0
24004f3c:	d020      	beq.n	24004f80 <DMA_SetConfig+0x32c>
    regs_bdma->IFCR = (BDMA_ISR_GIF0) << (hdma->StreamIndex & 0x1FU);
24004f3e:	68fb      	ldr	r3, [r7, #12]
24004f40:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
24004f42:	f003 031f 	and.w	r3, r3, #31
24004f46:	2201      	movs	r2, #1
24004f48:	409a      	lsls	r2, r3
24004f4a:	693b      	ldr	r3, [r7, #16]
24004f4c:	605a      	str	r2, [r3, #4]
    ((BDMA_Channel_TypeDef *)hdma->Instance)->CNDTR = DataLength;
24004f4e:	68fb      	ldr	r3, [r7, #12]
24004f50:	681b      	ldr	r3, [r3, #0]
24004f52:	683a      	ldr	r2, [r7, #0]
24004f54:	605a      	str	r2, [r3, #4]
    if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
24004f56:	68fb      	ldr	r3, [r7, #12]
24004f58:	689b      	ldr	r3, [r3, #8]
24004f5a:	2b40      	cmp	r3, #64	; 0x40
24004f5c:	d108      	bne.n	24004f70 <DMA_SetConfig+0x31c>
      ((BDMA_Channel_TypeDef *)hdma->Instance)->CPAR = DstAddress;
24004f5e:	68fb      	ldr	r3, [r7, #12]
24004f60:	681b      	ldr	r3, [r3, #0]
24004f62:	687a      	ldr	r2, [r7, #4]
24004f64:	609a      	str	r2, [r3, #8]
      ((BDMA_Channel_TypeDef *)hdma->Instance)->CM0AR = SrcAddress;
24004f66:	68fb      	ldr	r3, [r7, #12]
24004f68:	681b      	ldr	r3, [r3, #0]
24004f6a:	68ba      	ldr	r2, [r7, #8]
24004f6c:	60da      	str	r2, [r3, #12]
}
24004f6e:	e007      	b.n	24004f80 <DMA_SetConfig+0x32c>
      ((BDMA_Channel_TypeDef *)hdma->Instance)->CPAR = SrcAddress;
24004f70:	68fb      	ldr	r3, [r7, #12]
24004f72:	681b      	ldr	r3, [r3, #0]
24004f74:	68ba      	ldr	r2, [r7, #8]
24004f76:	609a      	str	r2, [r3, #8]
      ((BDMA_Channel_TypeDef *)hdma->Instance)->CM0AR = DstAddress;
24004f78:	68fb      	ldr	r3, [r7, #12]
24004f7a:	681b      	ldr	r3, [r3, #0]
24004f7c:	687a      	ldr	r2, [r7, #4]
24004f7e:	60da      	str	r2, [r3, #12]
}
24004f80:	bf00      	nop
24004f82:	371c      	adds	r7, #28
24004f84:	46bd      	mov	sp, r7
24004f86:	f85d 7b04 	ldr.w	r7, [sp], #4
24004f8a:	4770      	bx	lr
24004f8c:	58025408 	.word	0x58025408
24004f90:	5802541c 	.word	0x5802541c
24004f94:	58025430 	.word	0x58025430
24004f98:	58025444 	.word	0x58025444
24004f9c:	58025458 	.word	0x58025458
24004fa0:	5802546c 	.word	0x5802546c
24004fa4:	58025480 	.word	0x58025480
24004fa8:	58025494 	.word	0x58025494

24004fac <DMA_CalcBaseAndBitshift>:
  * @param  hdma:       pointer to a DMA_HandleTypeDef structure that contains
  *                     the configuration information for the specified DMA Stream.
  * @retval Stream base address
  */
static uint32_t DMA_CalcBaseAndBitshift(DMA_HandleTypeDef *hdma)
{
24004fac:	b480      	push	{r7}
24004fae:	b085      	sub	sp, #20
24004fb0:	af00      	add	r7, sp, #0
24004fb2:	6078      	str	r0, [r7, #4]
  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
24004fb4:	687b      	ldr	r3, [r7, #4]
24004fb6:	681b      	ldr	r3, [r3, #0]
24004fb8:	4a42      	ldr	r2, [pc, #264]	; (240050c4 <DMA_CalcBaseAndBitshift+0x118>)
24004fba:	4293      	cmp	r3, r2
24004fbc:	d04a      	beq.n	24005054 <DMA_CalcBaseAndBitshift+0xa8>
24004fbe:	687b      	ldr	r3, [r7, #4]
24004fc0:	681b      	ldr	r3, [r3, #0]
24004fc2:	4a41      	ldr	r2, [pc, #260]	; (240050c8 <DMA_CalcBaseAndBitshift+0x11c>)
24004fc4:	4293      	cmp	r3, r2
24004fc6:	d045      	beq.n	24005054 <DMA_CalcBaseAndBitshift+0xa8>
24004fc8:	687b      	ldr	r3, [r7, #4]
24004fca:	681b      	ldr	r3, [r3, #0]
24004fcc:	4a3f      	ldr	r2, [pc, #252]	; (240050cc <DMA_CalcBaseAndBitshift+0x120>)
24004fce:	4293      	cmp	r3, r2
24004fd0:	d040      	beq.n	24005054 <DMA_CalcBaseAndBitshift+0xa8>
24004fd2:	687b      	ldr	r3, [r7, #4]
24004fd4:	681b      	ldr	r3, [r3, #0]
24004fd6:	4a3e      	ldr	r2, [pc, #248]	; (240050d0 <DMA_CalcBaseAndBitshift+0x124>)
24004fd8:	4293      	cmp	r3, r2
24004fda:	d03b      	beq.n	24005054 <DMA_CalcBaseAndBitshift+0xa8>
24004fdc:	687b      	ldr	r3, [r7, #4]
24004fde:	681b      	ldr	r3, [r3, #0]
24004fe0:	4a3c      	ldr	r2, [pc, #240]	; (240050d4 <DMA_CalcBaseAndBitshift+0x128>)
24004fe2:	4293      	cmp	r3, r2
24004fe4:	d036      	beq.n	24005054 <DMA_CalcBaseAndBitshift+0xa8>
24004fe6:	687b      	ldr	r3, [r7, #4]
24004fe8:	681b      	ldr	r3, [r3, #0]
24004fea:	4a3b      	ldr	r2, [pc, #236]	; (240050d8 <DMA_CalcBaseAndBitshift+0x12c>)
24004fec:	4293      	cmp	r3, r2
24004fee:	d031      	beq.n	24005054 <DMA_CalcBaseAndBitshift+0xa8>
24004ff0:	687b      	ldr	r3, [r7, #4]
24004ff2:	681b      	ldr	r3, [r3, #0]
24004ff4:	4a39      	ldr	r2, [pc, #228]	; (240050dc <DMA_CalcBaseAndBitshift+0x130>)
24004ff6:	4293      	cmp	r3, r2
24004ff8:	d02c      	beq.n	24005054 <DMA_CalcBaseAndBitshift+0xa8>
24004ffa:	687b      	ldr	r3, [r7, #4]
24004ffc:	681b      	ldr	r3, [r3, #0]
24004ffe:	4a38      	ldr	r2, [pc, #224]	; (240050e0 <DMA_CalcBaseAndBitshift+0x134>)
24005000:	4293      	cmp	r3, r2
24005002:	d027      	beq.n	24005054 <DMA_CalcBaseAndBitshift+0xa8>
24005004:	687b      	ldr	r3, [r7, #4]
24005006:	681b      	ldr	r3, [r3, #0]
24005008:	4a36      	ldr	r2, [pc, #216]	; (240050e4 <DMA_CalcBaseAndBitshift+0x138>)
2400500a:	4293      	cmp	r3, r2
2400500c:	d022      	beq.n	24005054 <DMA_CalcBaseAndBitshift+0xa8>
2400500e:	687b      	ldr	r3, [r7, #4]
24005010:	681b      	ldr	r3, [r3, #0]
24005012:	4a35      	ldr	r2, [pc, #212]	; (240050e8 <DMA_CalcBaseAndBitshift+0x13c>)
24005014:	4293      	cmp	r3, r2
24005016:	d01d      	beq.n	24005054 <DMA_CalcBaseAndBitshift+0xa8>
24005018:	687b      	ldr	r3, [r7, #4]
2400501a:	681b      	ldr	r3, [r3, #0]
2400501c:	4a33      	ldr	r2, [pc, #204]	; (240050ec <DMA_CalcBaseAndBitshift+0x140>)
2400501e:	4293      	cmp	r3, r2
24005020:	d018      	beq.n	24005054 <DMA_CalcBaseAndBitshift+0xa8>
24005022:	687b      	ldr	r3, [r7, #4]
24005024:	681b      	ldr	r3, [r3, #0]
24005026:	4a32      	ldr	r2, [pc, #200]	; (240050f0 <DMA_CalcBaseAndBitshift+0x144>)
24005028:	4293      	cmp	r3, r2
2400502a:	d013      	beq.n	24005054 <DMA_CalcBaseAndBitshift+0xa8>
2400502c:	687b      	ldr	r3, [r7, #4]
2400502e:	681b      	ldr	r3, [r3, #0]
24005030:	4a30      	ldr	r2, [pc, #192]	; (240050f4 <DMA_CalcBaseAndBitshift+0x148>)
24005032:	4293      	cmp	r3, r2
24005034:	d00e      	beq.n	24005054 <DMA_CalcBaseAndBitshift+0xa8>
24005036:	687b      	ldr	r3, [r7, #4]
24005038:	681b      	ldr	r3, [r3, #0]
2400503a:	4a2f      	ldr	r2, [pc, #188]	; (240050f8 <DMA_CalcBaseAndBitshift+0x14c>)
2400503c:	4293      	cmp	r3, r2
2400503e:	d009      	beq.n	24005054 <DMA_CalcBaseAndBitshift+0xa8>
24005040:	687b      	ldr	r3, [r7, #4]
24005042:	681b      	ldr	r3, [r3, #0]
24005044:	4a2d      	ldr	r2, [pc, #180]	; (240050fc <DMA_CalcBaseAndBitshift+0x150>)
24005046:	4293      	cmp	r3, r2
24005048:	d004      	beq.n	24005054 <DMA_CalcBaseAndBitshift+0xa8>
2400504a:	687b      	ldr	r3, [r7, #4]
2400504c:	681b      	ldr	r3, [r3, #0]
2400504e:	4a2c      	ldr	r2, [pc, #176]	; (24005100 <DMA_CalcBaseAndBitshift+0x154>)
24005050:	4293      	cmp	r3, r2
24005052:	d101      	bne.n	24005058 <DMA_CalcBaseAndBitshift+0xac>
24005054:	2301      	movs	r3, #1
24005056:	e000      	b.n	2400505a <DMA_CalcBaseAndBitshift+0xae>
24005058:	2300      	movs	r3, #0
2400505a:	2b00      	cmp	r3, #0
2400505c:	d024      	beq.n	240050a8 <DMA_CalcBaseAndBitshift+0xfc>
  {
    uint32_t stream_number = (((uint32_t)((uint32_t*)hdma->Instance) & 0xFFU) - 16U) / 24U;
2400505e:	687b      	ldr	r3, [r7, #4]
24005060:	681b      	ldr	r3, [r3, #0]
24005062:	b2db      	uxtb	r3, r3
24005064:	3b10      	subs	r3, #16
24005066:	4a27      	ldr	r2, [pc, #156]	; (24005104 <DMA_CalcBaseAndBitshift+0x158>)
24005068:	fba2 2303 	umull	r2, r3, r2, r3
2400506c:	091b      	lsrs	r3, r3, #4
2400506e:	60fb      	str	r3, [r7, #12]

    /* lookup table for necessary bitshift of flags within status registers */
    static const uint8_t flagBitshiftOffset[8U] = {0U, 6U, 16U, 22U, 0U, 6U, 16U, 22U};
    hdma->StreamIndex = flagBitshiftOffset[stream_number & 0x7U];
24005070:	68fb      	ldr	r3, [r7, #12]
24005072:	f003 0307 	and.w	r3, r3, #7
24005076:	4a24      	ldr	r2, [pc, #144]	; (24005108 <DMA_CalcBaseAndBitshift+0x15c>)
24005078:	5cd3      	ldrb	r3, [r2, r3]
2400507a:	461a      	mov	r2, r3
2400507c:	687b      	ldr	r3, [r7, #4]
2400507e:	65da      	str	r2, [r3, #92]	; 0x5c

    if (stream_number > 3U)
24005080:	68fb      	ldr	r3, [r7, #12]
24005082:	2b03      	cmp	r3, #3
24005084:	d908      	bls.n	24005098 <DMA_CalcBaseAndBitshift+0xec>
    {
      /* return pointer to HISR and HIFCR */
      hdma->StreamBaseAddress = (((uint32_t)((uint32_t*)hdma->Instance) & (uint32_t)(~0x3FFU)) + 4U);
24005086:	687b      	ldr	r3, [r7, #4]
24005088:	681b      	ldr	r3, [r3, #0]
2400508a:	461a      	mov	r2, r3
2400508c:	4b1f      	ldr	r3, [pc, #124]	; (2400510c <DMA_CalcBaseAndBitshift+0x160>)
2400508e:	4013      	ands	r3, r2
24005090:	1d1a      	adds	r2, r3, #4
24005092:	687b      	ldr	r3, [r7, #4]
24005094:	659a      	str	r2, [r3, #88]	; 0x58
24005096:	e00d      	b.n	240050b4 <DMA_CalcBaseAndBitshift+0x108>
    }
    else
    {
      /* return pointer to LISR and LIFCR */
      hdma->StreamBaseAddress = ((uint32_t)((uint32_t*)hdma->Instance) & (uint32_t)(~0x3FFU));
24005098:	687b      	ldr	r3, [r7, #4]
2400509a:	681b      	ldr	r3, [r3, #0]
2400509c:	461a      	mov	r2, r3
2400509e:	4b1b      	ldr	r3, [pc, #108]	; (2400510c <DMA_CalcBaseAndBitshift+0x160>)
240050a0:	4013      	ands	r3, r2
240050a2:	687a      	ldr	r2, [r7, #4]
240050a4:	6593      	str	r3, [r2, #88]	; 0x58
240050a6:	e005      	b.n	240050b4 <DMA_CalcBaseAndBitshift+0x108>
    }
  }
  else /* BDMA instance(s) */
  {
    /* return pointer to ISR and IFCR */
    hdma->StreamBaseAddress = ((uint32_t)((uint32_t*)hdma->Instance) & (uint32_t)(~0xFFU));
240050a8:	687b      	ldr	r3, [r7, #4]
240050aa:	681b      	ldr	r3, [r3, #0]
240050ac:	f023 02ff 	bic.w	r2, r3, #255	; 0xff
240050b0:	687b      	ldr	r3, [r7, #4]
240050b2:	659a      	str	r2, [r3, #88]	; 0x58
  }

  return hdma->StreamBaseAddress;
240050b4:	687b      	ldr	r3, [r7, #4]
240050b6:	6d9b      	ldr	r3, [r3, #88]	; 0x58
}
240050b8:	4618      	mov	r0, r3
240050ba:	3714      	adds	r7, #20
240050bc:	46bd      	mov	sp, r7
240050be:	f85d 7b04 	ldr.w	r7, [sp], #4
240050c2:	4770      	bx	lr
240050c4:	40020010 	.word	0x40020010
240050c8:	40020028 	.word	0x40020028
240050cc:	40020040 	.word	0x40020040
240050d0:	40020058 	.word	0x40020058
240050d4:	40020070 	.word	0x40020070
240050d8:	40020088 	.word	0x40020088
240050dc:	400200a0 	.word	0x400200a0
240050e0:	400200b8 	.word	0x400200b8
240050e4:	40020410 	.word	0x40020410
240050e8:	40020428 	.word	0x40020428
240050ec:	40020440 	.word	0x40020440
240050f0:	40020458 	.word	0x40020458
240050f4:	40020470 	.word	0x40020470
240050f8:	40020488 	.word	0x40020488
240050fc:	400204a0 	.word	0x400204a0
24005100:	400204b8 	.word	0x400204b8
24005104:	aaaaaaab 	.word	0xaaaaaaab
24005108:	24016b68 	.word	0x24016b68
2400510c:	fffffc00 	.word	0xfffffc00

24005110 <DMA_CheckFifoParam>:
  * @param  hdma:       pointer to a DMA_HandleTypeDef structure that contains
  *                     the configuration information for the specified DMA Stream.
  * @retval HAL status
  */
static HAL_StatusTypeDef DMA_CheckFifoParam(DMA_HandleTypeDef *hdma)
{
24005110:	b480      	push	{r7}
24005112:	b085      	sub	sp, #20
24005114:	af00      	add	r7, sp, #0
24005116:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
24005118:	2300      	movs	r3, #0
2400511a:	73fb      	strb	r3, [r7, #15]

  /* Memory Data size equal to Byte */
  if (hdma->Init.MemDataAlignment == DMA_MDATAALIGN_BYTE)
2400511c:	687b      	ldr	r3, [r7, #4]
2400511e:	699b      	ldr	r3, [r3, #24]
24005120:	2b00      	cmp	r3, #0
24005122:	d120      	bne.n	24005166 <DMA_CheckFifoParam+0x56>
  {
    switch (hdma->Init.FIFOThreshold)
24005124:	687b      	ldr	r3, [r7, #4]
24005126:	6a9b      	ldr	r3, [r3, #40]	; 0x28
24005128:	2b03      	cmp	r3, #3
2400512a:	d858      	bhi.n	240051de <DMA_CheckFifoParam+0xce>
2400512c:	a201      	add	r2, pc, #4	; (adr r2, 24005134 <DMA_CheckFifoParam+0x24>)
2400512e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
24005132:	bf00      	nop
24005134:	24005145 	.word	0x24005145
24005138:	24005157 	.word	0x24005157
2400513c:	24005145 	.word	0x24005145
24005140:	240051df 	.word	0x240051df
    {
      case DMA_FIFO_THRESHOLD_1QUARTERFULL:
      case DMA_FIFO_THRESHOLD_3QUARTERSFULL:

        if ((hdma->Init.MemBurst & DMA_SxCR_MBURST_1) == DMA_SxCR_MBURST_1)
24005144:	687b      	ldr	r3, [r7, #4]
24005146:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24005148:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
2400514c:	2b00      	cmp	r3, #0
2400514e:	d048      	beq.n	240051e2 <DMA_CheckFifoParam+0xd2>
        {
          status = HAL_ERROR;
24005150:	2301      	movs	r3, #1
24005152:	73fb      	strb	r3, [r7, #15]
        }
        break;
24005154:	e045      	b.n	240051e2 <DMA_CheckFifoParam+0xd2>

      case DMA_FIFO_THRESHOLD_HALFFULL:
        if (hdma->Init.MemBurst == DMA_MBURST_INC16)
24005156:	687b      	ldr	r3, [r7, #4]
24005158:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2400515a:	f1b3 7fc0 	cmp.w	r3, #25165824	; 0x1800000
2400515e:	d142      	bne.n	240051e6 <DMA_CheckFifoParam+0xd6>
        {
          status = HAL_ERROR;
24005160:	2301      	movs	r3, #1
24005162:	73fb      	strb	r3, [r7, #15]
        }
        break;
24005164:	e03f      	b.n	240051e6 <DMA_CheckFifoParam+0xd6>
        break;
    }
  }

  /* Memory Data size equal to Half-Word */
  else if (hdma->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD)
24005166:	687b      	ldr	r3, [r7, #4]
24005168:	699b      	ldr	r3, [r3, #24]
2400516a:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
2400516e:	d123      	bne.n	240051b8 <DMA_CheckFifoParam+0xa8>
  {
    switch (hdma->Init.FIFOThreshold)
24005170:	687b      	ldr	r3, [r7, #4]
24005172:	6a9b      	ldr	r3, [r3, #40]	; 0x28
24005174:	2b03      	cmp	r3, #3
24005176:	d838      	bhi.n	240051ea <DMA_CheckFifoParam+0xda>
24005178:	a201      	add	r2, pc, #4	; (adr r2, 24005180 <DMA_CheckFifoParam+0x70>)
2400517a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
2400517e:	bf00      	nop
24005180:	24005191 	.word	0x24005191
24005184:	24005197 	.word	0x24005197
24005188:	24005191 	.word	0x24005191
2400518c:	240051a9 	.word	0x240051a9
    {
      case DMA_FIFO_THRESHOLD_1QUARTERFULL:
      case DMA_FIFO_THRESHOLD_3QUARTERSFULL:
        status = HAL_ERROR;
24005190:	2301      	movs	r3, #1
24005192:	73fb      	strb	r3, [r7, #15]
        break;
24005194:	e030      	b.n	240051f8 <DMA_CheckFifoParam+0xe8>

      case DMA_FIFO_THRESHOLD_HALFFULL:
        if ((hdma->Init.MemBurst & DMA_SxCR_MBURST_1) == DMA_SxCR_MBURST_1)
24005196:	687b      	ldr	r3, [r7, #4]
24005198:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2400519a:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
2400519e:	2b00      	cmp	r3, #0
240051a0:	d025      	beq.n	240051ee <DMA_CheckFifoParam+0xde>
        {
          status = HAL_ERROR;
240051a2:	2301      	movs	r3, #1
240051a4:	73fb      	strb	r3, [r7, #15]
        }
        break;
240051a6:	e022      	b.n	240051ee <DMA_CheckFifoParam+0xde>

      case DMA_FIFO_THRESHOLD_FULL:
        if (hdma->Init.MemBurst == DMA_MBURST_INC16)
240051a8:	687b      	ldr	r3, [r7, #4]
240051aa:	6adb      	ldr	r3, [r3, #44]	; 0x2c
240051ac:	f1b3 7fc0 	cmp.w	r3, #25165824	; 0x1800000
240051b0:	d11f      	bne.n	240051f2 <DMA_CheckFifoParam+0xe2>
        {
          status = HAL_ERROR;
240051b2:	2301      	movs	r3, #1
240051b4:	73fb      	strb	r3, [r7, #15]
        }
        break;
240051b6:	e01c      	b.n	240051f2 <DMA_CheckFifoParam+0xe2>
  }

  /* Memory Data size equal to Word */
  else
  {
    switch (hdma->Init.FIFOThreshold)
240051b8:	687b      	ldr	r3, [r7, #4]
240051ba:	6a9b      	ldr	r3, [r3, #40]	; 0x28
240051bc:	2b02      	cmp	r3, #2
240051be:	d902      	bls.n	240051c6 <DMA_CheckFifoParam+0xb6>
240051c0:	2b03      	cmp	r3, #3
240051c2:	d003      	beq.n	240051cc <DMA_CheckFifoParam+0xbc>
          status = HAL_ERROR;
        }
    break;

      default:
        break;
240051c4:	e018      	b.n	240051f8 <DMA_CheckFifoParam+0xe8>
        status = HAL_ERROR;
240051c6:	2301      	movs	r3, #1
240051c8:	73fb      	strb	r3, [r7, #15]
        break;
240051ca:	e015      	b.n	240051f8 <DMA_CheckFifoParam+0xe8>
        if ((hdma->Init.MemBurst & DMA_SxCR_MBURST_1) == DMA_SxCR_MBURST_1)
240051cc:	687b      	ldr	r3, [r7, #4]
240051ce:	6adb      	ldr	r3, [r3, #44]	; 0x2c
240051d0:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
240051d4:	2b00      	cmp	r3, #0
240051d6:	d00e      	beq.n	240051f6 <DMA_CheckFifoParam+0xe6>
          status = HAL_ERROR;
240051d8:	2301      	movs	r3, #1
240051da:	73fb      	strb	r3, [r7, #15]
    break;
240051dc:	e00b      	b.n	240051f6 <DMA_CheckFifoParam+0xe6>
        break;
240051de:	bf00      	nop
240051e0:	e00a      	b.n	240051f8 <DMA_CheckFifoParam+0xe8>
        break;
240051e2:	bf00      	nop
240051e4:	e008      	b.n	240051f8 <DMA_CheckFifoParam+0xe8>
        break;
240051e6:	bf00      	nop
240051e8:	e006      	b.n	240051f8 <DMA_CheckFifoParam+0xe8>
        break;
240051ea:	bf00      	nop
240051ec:	e004      	b.n	240051f8 <DMA_CheckFifoParam+0xe8>
        break;
240051ee:	bf00      	nop
240051f0:	e002      	b.n	240051f8 <DMA_CheckFifoParam+0xe8>
        break;
240051f2:	bf00      	nop
240051f4:	e000      	b.n	240051f8 <DMA_CheckFifoParam+0xe8>
    break;
240051f6:	bf00      	nop
    }
  }

  return status;
240051f8:	7bfb      	ldrb	r3, [r7, #15]
}
240051fa:	4618      	mov	r0, r3
240051fc:	3714      	adds	r7, #20
240051fe:	46bd      	mov	sp, r7
24005200:	f85d 7b04 	ldr.w	r7, [sp], #4
24005204:	4770      	bx	lr
24005206:	bf00      	nop

24005208 <DMA_CalcDMAMUXChannelBaseAndMask>:
  * @param  hdma:       pointer to a DMA_HandleTypeDef structure that contains
  *                     the configuration information for the specified DMA Stream.
  * @retval HAL status
  */
static void DMA_CalcDMAMUXChannelBaseAndMask(DMA_HandleTypeDef *hdma)
{
24005208:	b480      	push	{r7}
2400520a:	b085      	sub	sp, #20
2400520c:	af00      	add	r7, sp, #0
2400520e:	6078      	str	r0, [r7, #4]
  uint32_t stream_number;
  uint32_t stream_baseaddress = (uint32_t)((uint32_t*)hdma->Instance);
24005210:	687b      	ldr	r3, [r7, #4]
24005212:	681b      	ldr	r3, [r3, #0]
24005214:	60bb      	str	r3, [r7, #8]

  if(IS_BDMA_CHANNEL_DMAMUX_INSTANCE(hdma->Instance) != 0U)
24005216:	687b      	ldr	r3, [r7, #4]
24005218:	681b      	ldr	r3, [r3, #0]
2400521a:	4a38      	ldr	r2, [pc, #224]	; (240052fc <DMA_CalcDMAMUXChannelBaseAndMask+0xf4>)
2400521c:	4293      	cmp	r3, r2
2400521e:	d022      	beq.n	24005266 <DMA_CalcDMAMUXChannelBaseAndMask+0x5e>
24005220:	687b      	ldr	r3, [r7, #4]
24005222:	681b      	ldr	r3, [r3, #0]
24005224:	4a36      	ldr	r2, [pc, #216]	; (24005300 <DMA_CalcDMAMUXChannelBaseAndMask+0xf8>)
24005226:	4293      	cmp	r3, r2
24005228:	d01d      	beq.n	24005266 <DMA_CalcDMAMUXChannelBaseAndMask+0x5e>
2400522a:	687b      	ldr	r3, [r7, #4]
2400522c:	681b      	ldr	r3, [r3, #0]
2400522e:	4a35      	ldr	r2, [pc, #212]	; (24005304 <DMA_CalcDMAMUXChannelBaseAndMask+0xfc>)
24005230:	4293      	cmp	r3, r2
24005232:	d018      	beq.n	24005266 <DMA_CalcDMAMUXChannelBaseAndMask+0x5e>
24005234:	687b      	ldr	r3, [r7, #4]
24005236:	681b      	ldr	r3, [r3, #0]
24005238:	4a33      	ldr	r2, [pc, #204]	; (24005308 <DMA_CalcDMAMUXChannelBaseAndMask+0x100>)
2400523a:	4293      	cmp	r3, r2
2400523c:	d013      	beq.n	24005266 <DMA_CalcDMAMUXChannelBaseAndMask+0x5e>
2400523e:	687b      	ldr	r3, [r7, #4]
24005240:	681b      	ldr	r3, [r3, #0]
24005242:	4a32      	ldr	r2, [pc, #200]	; (2400530c <DMA_CalcDMAMUXChannelBaseAndMask+0x104>)
24005244:	4293      	cmp	r3, r2
24005246:	d00e      	beq.n	24005266 <DMA_CalcDMAMUXChannelBaseAndMask+0x5e>
24005248:	687b      	ldr	r3, [r7, #4]
2400524a:	681b      	ldr	r3, [r3, #0]
2400524c:	4a30      	ldr	r2, [pc, #192]	; (24005310 <DMA_CalcDMAMUXChannelBaseAndMask+0x108>)
2400524e:	4293      	cmp	r3, r2
24005250:	d009      	beq.n	24005266 <DMA_CalcDMAMUXChannelBaseAndMask+0x5e>
24005252:	687b      	ldr	r3, [r7, #4]
24005254:	681b      	ldr	r3, [r3, #0]
24005256:	4a2f      	ldr	r2, [pc, #188]	; (24005314 <DMA_CalcDMAMUXChannelBaseAndMask+0x10c>)
24005258:	4293      	cmp	r3, r2
2400525a:	d004      	beq.n	24005266 <DMA_CalcDMAMUXChannelBaseAndMask+0x5e>
2400525c:	687b      	ldr	r3, [r7, #4]
2400525e:	681b      	ldr	r3, [r3, #0]
24005260:	4a2d      	ldr	r2, [pc, #180]	; (24005318 <DMA_CalcDMAMUXChannelBaseAndMask+0x110>)
24005262:	4293      	cmp	r3, r2
24005264:	d101      	bne.n	2400526a <DMA_CalcDMAMUXChannelBaseAndMask+0x62>
24005266:	2301      	movs	r3, #1
24005268:	e000      	b.n	2400526c <DMA_CalcDMAMUXChannelBaseAndMask+0x64>
2400526a:	2300      	movs	r3, #0
2400526c:	2b00      	cmp	r3, #0
2400526e:	d01a      	beq.n	240052a6 <DMA_CalcDMAMUXChannelBaseAndMask+0x9e>
  {
    /* BDMA Channels are connected to DMAMUX2 channels */
    stream_number = (((uint32_t)((uint32_t*)hdma->Instance) & 0xFFU) - 8U) / 20U;
24005270:	687b      	ldr	r3, [r7, #4]
24005272:	681b      	ldr	r3, [r3, #0]
24005274:	b2db      	uxtb	r3, r3
24005276:	3b08      	subs	r3, #8
24005278:	4a28      	ldr	r2, [pc, #160]	; (2400531c <DMA_CalcDMAMUXChannelBaseAndMask+0x114>)
2400527a:	fba2 2303 	umull	r2, r3, r2, r3
2400527e:	091b      	lsrs	r3, r3, #4
24005280:	60fb      	str	r3, [r7, #12]
    hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)((uint32_t)(((uint32_t)DMAMUX2_Channel0) + (stream_number * 4U)));
24005282:	68fa      	ldr	r2, [r7, #12]
24005284:	4b26      	ldr	r3, [pc, #152]	; (24005320 <DMA_CalcDMAMUXChannelBaseAndMask+0x118>)
24005286:	4413      	add	r3, r2
24005288:	009b      	lsls	r3, r3, #2
2400528a:	461a      	mov	r2, r3
2400528c:	687b      	ldr	r3, [r7, #4]
2400528e:	661a      	str	r2, [r3, #96]	; 0x60
    hdma->DMAmuxChannelStatus = DMAMUX2_ChannelStatus;
24005290:	687b      	ldr	r3, [r7, #4]
24005292:	4a24      	ldr	r2, [pc, #144]	; (24005324 <DMA_CalcDMAMUXChannelBaseAndMask+0x11c>)
24005294:	665a      	str	r2, [r3, #100]	; 0x64
    hdma->DMAmuxChannelStatusMask = 1UL << (stream_number & 0x1FU);
24005296:	68fb      	ldr	r3, [r7, #12]
24005298:	f003 031f 	and.w	r3, r3, #31
2400529c:	2201      	movs	r2, #1
2400529e:	409a      	lsls	r2, r3
240052a0:	687b      	ldr	r3, [r7, #4]
240052a2:	669a      	str	r2, [r3, #104]	; 0x68
    }
    hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_Channel0) + (stream_number * 4U)));
    hdma->DMAmuxChannelStatus = DMAMUX1_ChannelStatus;
    hdma->DMAmuxChannelStatusMask = 1UL << (stream_number & 0x1FU);
  }
}
240052a4:	e024      	b.n	240052f0 <DMA_CalcDMAMUXChannelBaseAndMask+0xe8>
    stream_number = (((uint32_t)((uint32_t*)hdma->Instance) & 0xFFU) - 16U) / 24U;
240052a6:	687b      	ldr	r3, [r7, #4]
240052a8:	681b      	ldr	r3, [r3, #0]
240052aa:	b2db      	uxtb	r3, r3
240052ac:	3b10      	subs	r3, #16
240052ae:	4a1e      	ldr	r2, [pc, #120]	; (24005328 <DMA_CalcDMAMUXChannelBaseAndMask+0x120>)
240052b0:	fba2 2303 	umull	r2, r3, r2, r3
240052b4:	091b      	lsrs	r3, r3, #4
240052b6:	60fb      	str	r3, [r7, #12]
    if((stream_baseaddress <= ((uint32_t)DMA2_Stream7) ) && \
240052b8:	68bb      	ldr	r3, [r7, #8]
240052ba:	4a1c      	ldr	r2, [pc, #112]	; (2400532c <DMA_CalcDMAMUXChannelBaseAndMask+0x124>)
240052bc:	4293      	cmp	r3, r2
240052be:	d806      	bhi.n	240052ce <DMA_CalcDMAMUXChannelBaseAndMask+0xc6>
240052c0:	68bb      	ldr	r3, [r7, #8]
240052c2:	4a1b      	ldr	r2, [pc, #108]	; (24005330 <DMA_CalcDMAMUXChannelBaseAndMask+0x128>)
240052c4:	4293      	cmp	r3, r2
240052c6:	d902      	bls.n	240052ce <DMA_CalcDMAMUXChannelBaseAndMask+0xc6>
      stream_number += 8U;
240052c8:	68fb      	ldr	r3, [r7, #12]
240052ca:	3308      	adds	r3, #8
240052cc:	60fb      	str	r3, [r7, #12]
    hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_Channel0) + (stream_number * 4U)));
240052ce:	68fa      	ldr	r2, [r7, #12]
240052d0:	4b18      	ldr	r3, [pc, #96]	; (24005334 <DMA_CalcDMAMUXChannelBaseAndMask+0x12c>)
240052d2:	4413      	add	r3, r2
240052d4:	009b      	lsls	r3, r3, #2
240052d6:	461a      	mov	r2, r3
240052d8:	687b      	ldr	r3, [r7, #4]
240052da:	661a      	str	r2, [r3, #96]	; 0x60
    hdma->DMAmuxChannelStatus = DMAMUX1_ChannelStatus;
240052dc:	687b      	ldr	r3, [r7, #4]
240052de:	4a16      	ldr	r2, [pc, #88]	; (24005338 <DMA_CalcDMAMUXChannelBaseAndMask+0x130>)
240052e0:	665a      	str	r2, [r3, #100]	; 0x64
    hdma->DMAmuxChannelStatusMask = 1UL << (stream_number & 0x1FU);
240052e2:	68fb      	ldr	r3, [r7, #12]
240052e4:	f003 031f 	and.w	r3, r3, #31
240052e8:	2201      	movs	r2, #1
240052ea:	409a      	lsls	r2, r3
240052ec:	687b      	ldr	r3, [r7, #4]
240052ee:	669a      	str	r2, [r3, #104]	; 0x68
}
240052f0:	bf00      	nop
240052f2:	3714      	adds	r7, #20
240052f4:	46bd      	mov	sp, r7
240052f6:	f85d 7b04 	ldr.w	r7, [sp], #4
240052fa:	4770      	bx	lr
240052fc:	58025408 	.word	0x58025408
24005300:	5802541c 	.word	0x5802541c
24005304:	58025430 	.word	0x58025430
24005308:	58025444 	.word	0x58025444
2400530c:	58025458 	.word	0x58025458
24005310:	5802546c 	.word	0x5802546c
24005314:	58025480 	.word	0x58025480
24005318:	58025494 	.word	0x58025494
2400531c:	cccccccd 	.word	0xcccccccd
24005320:	16009600 	.word	0x16009600
24005324:	58025880 	.word	0x58025880
24005328:	aaaaaaab 	.word	0xaaaaaaab
2400532c:	400204b8 	.word	0x400204b8
24005330:	4002040f 	.word	0x4002040f
24005334:	10008200 	.word	0x10008200
24005338:	40020880 	.word	0x40020880

2400533c <DMA_CalcDMAMUXRequestGenBaseAndMask>:
  * @param  hdma:       pointer to a DMA_HandleTypeDef structure that contains
  *                     the configuration information for the specified DMA Stream.
  * @retval HAL status
  */
static void DMA_CalcDMAMUXRequestGenBaseAndMask(DMA_HandleTypeDef *hdma)
{
2400533c:	b480      	push	{r7}
2400533e:	b085      	sub	sp, #20
24005340:	af00      	add	r7, sp, #0
24005342:	6078      	str	r0, [r7, #4]
  uint32_t request =  hdma->Init.Request & DMAMUX_CxCR_DMAREQ_ID;
24005344:	687b      	ldr	r3, [r7, #4]
24005346:	685b      	ldr	r3, [r3, #4]
24005348:	b2db      	uxtb	r3, r3
2400534a:	60fb      	str	r3, [r7, #12]

  if((request >= DMA_REQUEST_GENERATOR0) && (request <= DMA_REQUEST_GENERATOR7))
2400534c:	68fb      	ldr	r3, [r7, #12]
2400534e:	2b00      	cmp	r3, #0
24005350:	d04a      	beq.n	240053e8 <DMA_CalcDMAMUXRequestGenBaseAndMask+0xac>
24005352:	68fb      	ldr	r3, [r7, #12]
24005354:	2b08      	cmp	r3, #8
24005356:	d847      	bhi.n	240053e8 <DMA_CalcDMAMUXRequestGenBaseAndMask+0xac>
  {
    if(IS_BDMA_CHANNEL_DMAMUX_INSTANCE(hdma->Instance) != 0U)
24005358:	687b      	ldr	r3, [r7, #4]
2400535a:	681b      	ldr	r3, [r3, #0]
2400535c:	4a25      	ldr	r2, [pc, #148]	; (240053f4 <DMA_CalcDMAMUXRequestGenBaseAndMask+0xb8>)
2400535e:	4293      	cmp	r3, r2
24005360:	d022      	beq.n	240053a8 <DMA_CalcDMAMUXRequestGenBaseAndMask+0x6c>
24005362:	687b      	ldr	r3, [r7, #4]
24005364:	681b      	ldr	r3, [r3, #0]
24005366:	4a24      	ldr	r2, [pc, #144]	; (240053f8 <DMA_CalcDMAMUXRequestGenBaseAndMask+0xbc>)
24005368:	4293      	cmp	r3, r2
2400536a:	d01d      	beq.n	240053a8 <DMA_CalcDMAMUXRequestGenBaseAndMask+0x6c>
2400536c:	687b      	ldr	r3, [r7, #4]
2400536e:	681b      	ldr	r3, [r3, #0]
24005370:	4a22      	ldr	r2, [pc, #136]	; (240053fc <DMA_CalcDMAMUXRequestGenBaseAndMask+0xc0>)
24005372:	4293      	cmp	r3, r2
24005374:	d018      	beq.n	240053a8 <DMA_CalcDMAMUXRequestGenBaseAndMask+0x6c>
24005376:	687b      	ldr	r3, [r7, #4]
24005378:	681b      	ldr	r3, [r3, #0]
2400537a:	4a21      	ldr	r2, [pc, #132]	; (24005400 <DMA_CalcDMAMUXRequestGenBaseAndMask+0xc4>)
2400537c:	4293      	cmp	r3, r2
2400537e:	d013      	beq.n	240053a8 <DMA_CalcDMAMUXRequestGenBaseAndMask+0x6c>
24005380:	687b      	ldr	r3, [r7, #4]
24005382:	681b      	ldr	r3, [r3, #0]
24005384:	4a1f      	ldr	r2, [pc, #124]	; (24005404 <DMA_CalcDMAMUXRequestGenBaseAndMask+0xc8>)
24005386:	4293      	cmp	r3, r2
24005388:	d00e      	beq.n	240053a8 <DMA_CalcDMAMUXRequestGenBaseAndMask+0x6c>
2400538a:	687b      	ldr	r3, [r7, #4]
2400538c:	681b      	ldr	r3, [r3, #0]
2400538e:	4a1e      	ldr	r2, [pc, #120]	; (24005408 <DMA_CalcDMAMUXRequestGenBaseAndMask+0xcc>)
24005390:	4293      	cmp	r3, r2
24005392:	d009      	beq.n	240053a8 <DMA_CalcDMAMUXRequestGenBaseAndMask+0x6c>
24005394:	687b      	ldr	r3, [r7, #4]
24005396:	681b      	ldr	r3, [r3, #0]
24005398:	4a1c      	ldr	r2, [pc, #112]	; (2400540c <DMA_CalcDMAMUXRequestGenBaseAndMask+0xd0>)
2400539a:	4293      	cmp	r3, r2
2400539c:	d004      	beq.n	240053a8 <DMA_CalcDMAMUXRequestGenBaseAndMask+0x6c>
2400539e:	687b      	ldr	r3, [r7, #4]
240053a0:	681b      	ldr	r3, [r3, #0]
240053a2:	4a1b      	ldr	r2, [pc, #108]	; (24005410 <DMA_CalcDMAMUXRequestGenBaseAndMask+0xd4>)
240053a4:	4293      	cmp	r3, r2
240053a6:	d101      	bne.n	240053ac <DMA_CalcDMAMUXRequestGenBaseAndMask+0x70>
240053a8:	2301      	movs	r3, #1
240053aa:	e000      	b.n	240053ae <DMA_CalcDMAMUXRequestGenBaseAndMask+0x72>
240053ac:	2300      	movs	r3, #0
240053ae:	2b00      	cmp	r3, #0
240053b0:	d00a      	beq.n	240053c8 <DMA_CalcDMAMUXRequestGenBaseAndMask+0x8c>
    {
      /* BDMA Channels are connected to DMAMUX2 request generator blocks */
      hdma->DMAmuxRequestGen = (DMAMUX_RequestGen_TypeDef *)((uint32_t)(((uint32_t)DMAMUX2_RequestGenerator0) + ((request - 1U) * 4U)));
240053b2:	68fa      	ldr	r2, [r7, #12]
240053b4:	4b17      	ldr	r3, [pc, #92]	; (24005414 <DMA_CalcDMAMUXRequestGenBaseAndMask+0xd8>)
240053b6:	4413      	add	r3, r2
240053b8:	009b      	lsls	r3, r3, #2
240053ba:	461a      	mov	r2, r3
240053bc:	687b      	ldr	r3, [r7, #4]
240053be:	66da      	str	r2, [r3, #108]	; 0x6c

      hdma->DMAmuxRequestGenStatus = DMAMUX2_RequestGenStatus;
240053c0:	687b      	ldr	r3, [r7, #4]
240053c2:	4a15      	ldr	r2, [pc, #84]	; (24005418 <DMA_CalcDMAMUXRequestGenBaseAndMask+0xdc>)
240053c4:	671a      	str	r2, [r3, #112]	; 0x70
240053c6:	e009      	b.n	240053dc <DMA_CalcDMAMUXRequestGenBaseAndMask+0xa0>
    }
    else
    {
      /* DMA1 and DMA2 Streams use DMAMUX1 request generator blocks */
      hdma->DMAmuxRequestGen = (DMAMUX_RequestGen_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_RequestGenerator0) + ((request - 1U) * 4U)));
240053c8:	68fa      	ldr	r2, [r7, #12]
240053ca:	4b14      	ldr	r3, [pc, #80]	; (2400541c <DMA_CalcDMAMUXRequestGenBaseAndMask+0xe0>)
240053cc:	4413      	add	r3, r2
240053ce:	009b      	lsls	r3, r3, #2
240053d0:	461a      	mov	r2, r3
240053d2:	687b      	ldr	r3, [r7, #4]
240053d4:	66da      	str	r2, [r3, #108]	; 0x6c

      hdma->DMAmuxRequestGenStatus = DMAMUX1_RequestGenStatus;
240053d6:	687b      	ldr	r3, [r7, #4]
240053d8:	4a11      	ldr	r2, [pc, #68]	; (24005420 <DMA_CalcDMAMUXRequestGenBaseAndMask+0xe4>)
240053da:	671a      	str	r2, [r3, #112]	; 0x70
    }

    hdma->DMAmuxRequestGenStatusMask = 1UL << (request - 1U);
240053dc:	68fb      	ldr	r3, [r7, #12]
240053de:	3b01      	subs	r3, #1
240053e0:	2201      	movs	r2, #1
240053e2:	409a      	lsls	r2, r3
240053e4:	687b      	ldr	r3, [r7, #4]
240053e6:	675a      	str	r2, [r3, #116]	; 0x74
  }
}
240053e8:	bf00      	nop
240053ea:	3714      	adds	r7, #20
240053ec:	46bd      	mov	sp, r7
240053ee:	f85d 7b04 	ldr.w	r7, [sp], #4
240053f2:	4770      	bx	lr
240053f4:	58025408 	.word	0x58025408
240053f8:	5802541c 	.word	0x5802541c
240053fc:	58025430 	.word	0x58025430
24005400:	58025444 	.word	0x58025444
24005404:	58025458 	.word	0x58025458
24005408:	5802546c 	.word	0x5802546c
2400540c:	58025480 	.word	0x58025480
24005410:	58025494 	.word	0x58025494
24005414:	1600963f 	.word	0x1600963f
24005418:	58025940 	.word	0x58025940
2400541c:	1000823f 	.word	0x1000823f
24005420:	40020940 	.word	0x40020940

24005424 <HAL_DMAEx_MultiBufferStart>:
  * @param  SecondMemAddress: The second memory Buffer address in case of multi buffer Transfer
  * @param  DataLength: The length of data to be transferred from source to destination
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMAEx_MultiBufferStart(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t SecondMemAddress, uint32_t DataLength)
{
24005424:	b580      	push	{r7, lr}
24005426:	b086      	sub	sp, #24
24005428:	af00      	add	r7, sp, #0
2400542a:	60f8      	str	r0, [r7, #12]
2400542c:	60b9      	str	r1, [r7, #8]
2400542e:	607a      	str	r2, [r7, #4]
24005430:	603b      	str	r3, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
24005432:	2300      	movs	r3, #0
24005434:	75fb      	strb	r3, [r7, #23]
  /* Check the parameters */
  assert_param(IS_DMA_BUFFER_SIZE(DataLength));
  assert_param(IS_DMA_ALL_INSTANCE(hdma->Instance));

  /* Memory-to-memory transfer not supported in double buffering mode */
  if (hdma->Init.Direction == DMA_MEMORY_TO_MEMORY)
24005436:	68fb      	ldr	r3, [r7, #12]
24005438:	689b      	ldr	r3, [r3, #8]
2400543a:	2b80      	cmp	r3, #128	; 0x80
2400543c:	d106      	bne.n	2400544c <HAL_DMAEx_MultiBufferStart+0x28>
  {
    hdma->ErrorCode = HAL_DMA_ERROR_NOT_SUPPORTED;
2400543e:	68fb      	ldr	r3, [r7, #12]
24005440:	f44f 7280 	mov.w	r2, #256	; 0x100
24005444:	655a      	str	r2, [r3, #84]	; 0x54
    status = HAL_ERROR;
24005446:	2301      	movs	r3, #1
24005448:	75fb      	strb	r3, [r7, #23]
2400544a:	e1c8      	b.n	240057de <HAL_DMAEx_MultiBufferStart+0x3ba>
  }
  else
  {
    /* Process Locked */
    __HAL_LOCK(hdma);
2400544c:	68fb      	ldr	r3, [r7, #12]
2400544e:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
24005452:	2b01      	cmp	r3, #1
24005454:	d101      	bne.n	2400545a <HAL_DMAEx_MultiBufferStart+0x36>
24005456:	2302      	movs	r3, #2
24005458:	e1c2      	b.n	240057e0 <HAL_DMAEx_MultiBufferStart+0x3bc>
2400545a:	68fb      	ldr	r3, [r7, #12]
2400545c:	2201      	movs	r2, #1
2400545e:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

    if(HAL_DMA_STATE_READY == hdma->State)
24005462:	68fb      	ldr	r3, [r7, #12]
24005464:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
24005468:	b2db      	uxtb	r3, r3
2400546a:	2b01      	cmp	r3, #1
2400546c:	f040 81b1 	bne.w	240057d2 <HAL_DMAEx_MultiBufferStart+0x3ae>
    {
      /* Change DMA peripheral state */
      hdma->State = HAL_DMA_STATE_BUSY;
24005470:	68fb      	ldr	r3, [r7, #12]
24005472:	2202      	movs	r2, #2
24005474:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

      /* Initialize the error code */
      hdma->ErrorCode = HAL_DMA_ERROR_NONE;
24005478:	68fb      	ldr	r3, [r7, #12]
2400547a:	2200      	movs	r2, #0
2400547c:	655a      	str	r2, [r3, #84]	; 0x54

      if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
2400547e:	68fb      	ldr	r3, [r7, #12]
24005480:	681b      	ldr	r3, [r3, #0]
24005482:	4a7f      	ldr	r2, [pc, #508]	; (24005680 <HAL_DMAEx_MultiBufferStart+0x25c>)
24005484:	4293      	cmp	r3, r2
24005486:	d04a      	beq.n	2400551e <HAL_DMAEx_MultiBufferStart+0xfa>
24005488:	68fb      	ldr	r3, [r7, #12]
2400548a:	681b      	ldr	r3, [r3, #0]
2400548c:	4a7d      	ldr	r2, [pc, #500]	; (24005684 <HAL_DMAEx_MultiBufferStart+0x260>)
2400548e:	4293      	cmp	r3, r2
24005490:	d045      	beq.n	2400551e <HAL_DMAEx_MultiBufferStart+0xfa>
24005492:	68fb      	ldr	r3, [r7, #12]
24005494:	681b      	ldr	r3, [r3, #0]
24005496:	4a7c      	ldr	r2, [pc, #496]	; (24005688 <HAL_DMAEx_MultiBufferStart+0x264>)
24005498:	4293      	cmp	r3, r2
2400549a:	d040      	beq.n	2400551e <HAL_DMAEx_MultiBufferStart+0xfa>
2400549c:	68fb      	ldr	r3, [r7, #12]
2400549e:	681b      	ldr	r3, [r3, #0]
240054a0:	4a7a      	ldr	r2, [pc, #488]	; (2400568c <HAL_DMAEx_MultiBufferStart+0x268>)
240054a2:	4293      	cmp	r3, r2
240054a4:	d03b      	beq.n	2400551e <HAL_DMAEx_MultiBufferStart+0xfa>
240054a6:	68fb      	ldr	r3, [r7, #12]
240054a8:	681b      	ldr	r3, [r3, #0]
240054aa:	4a79      	ldr	r2, [pc, #484]	; (24005690 <HAL_DMAEx_MultiBufferStart+0x26c>)
240054ac:	4293      	cmp	r3, r2
240054ae:	d036      	beq.n	2400551e <HAL_DMAEx_MultiBufferStart+0xfa>
240054b0:	68fb      	ldr	r3, [r7, #12]
240054b2:	681b      	ldr	r3, [r3, #0]
240054b4:	4a77      	ldr	r2, [pc, #476]	; (24005694 <HAL_DMAEx_MultiBufferStart+0x270>)
240054b6:	4293      	cmp	r3, r2
240054b8:	d031      	beq.n	2400551e <HAL_DMAEx_MultiBufferStart+0xfa>
240054ba:	68fb      	ldr	r3, [r7, #12]
240054bc:	681b      	ldr	r3, [r3, #0]
240054be:	4a76      	ldr	r2, [pc, #472]	; (24005698 <HAL_DMAEx_MultiBufferStart+0x274>)
240054c0:	4293      	cmp	r3, r2
240054c2:	d02c      	beq.n	2400551e <HAL_DMAEx_MultiBufferStart+0xfa>
240054c4:	68fb      	ldr	r3, [r7, #12]
240054c6:	681b      	ldr	r3, [r3, #0]
240054c8:	4a74      	ldr	r2, [pc, #464]	; (2400569c <HAL_DMAEx_MultiBufferStart+0x278>)
240054ca:	4293      	cmp	r3, r2
240054cc:	d027      	beq.n	2400551e <HAL_DMAEx_MultiBufferStart+0xfa>
240054ce:	68fb      	ldr	r3, [r7, #12]
240054d0:	681b      	ldr	r3, [r3, #0]
240054d2:	4a73      	ldr	r2, [pc, #460]	; (240056a0 <HAL_DMAEx_MultiBufferStart+0x27c>)
240054d4:	4293      	cmp	r3, r2
240054d6:	d022      	beq.n	2400551e <HAL_DMAEx_MultiBufferStart+0xfa>
240054d8:	68fb      	ldr	r3, [r7, #12]
240054da:	681b      	ldr	r3, [r3, #0]
240054dc:	4a71      	ldr	r2, [pc, #452]	; (240056a4 <HAL_DMAEx_MultiBufferStart+0x280>)
240054de:	4293      	cmp	r3, r2
240054e0:	d01d      	beq.n	2400551e <HAL_DMAEx_MultiBufferStart+0xfa>
240054e2:	68fb      	ldr	r3, [r7, #12]
240054e4:	681b      	ldr	r3, [r3, #0]
240054e6:	4a70      	ldr	r2, [pc, #448]	; (240056a8 <HAL_DMAEx_MultiBufferStart+0x284>)
240054e8:	4293      	cmp	r3, r2
240054ea:	d018      	beq.n	2400551e <HAL_DMAEx_MultiBufferStart+0xfa>
240054ec:	68fb      	ldr	r3, [r7, #12]
240054ee:	681b      	ldr	r3, [r3, #0]
240054f0:	4a6e      	ldr	r2, [pc, #440]	; (240056ac <HAL_DMAEx_MultiBufferStart+0x288>)
240054f2:	4293      	cmp	r3, r2
240054f4:	d013      	beq.n	2400551e <HAL_DMAEx_MultiBufferStart+0xfa>
240054f6:	68fb      	ldr	r3, [r7, #12]
240054f8:	681b      	ldr	r3, [r3, #0]
240054fa:	4a6d      	ldr	r2, [pc, #436]	; (240056b0 <HAL_DMAEx_MultiBufferStart+0x28c>)
240054fc:	4293      	cmp	r3, r2
240054fe:	d00e      	beq.n	2400551e <HAL_DMAEx_MultiBufferStart+0xfa>
24005500:	68fb      	ldr	r3, [r7, #12]
24005502:	681b      	ldr	r3, [r3, #0]
24005504:	4a6b      	ldr	r2, [pc, #428]	; (240056b4 <HAL_DMAEx_MultiBufferStart+0x290>)
24005506:	4293      	cmp	r3, r2
24005508:	d009      	beq.n	2400551e <HAL_DMAEx_MultiBufferStart+0xfa>
2400550a:	68fb      	ldr	r3, [r7, #12]
2400550c:	681b      	ldr	r3, [r3, #0]
2400550e:	4a6a      	ldr	r2, [pc, #424]	; (240056b8 <HAL_DMAEx_MultiBufferStart+0x294>)
24005510:	4293      	cmp	r3, r2
24005512:	d004      	beq.n	2400551e <HAL_DMAEx_MultiBufferStart+0xfa>
24005514:	68fb      	ldr	r3, [r7, #12]
24005516:	681b      	ldr	r3, [r3, #0]
24005518:	4a68      	ldr	r2, [pc, #416]	; (240056bc <HAL_DMAEx_MultiBufferStart+0x298>)
2400551a:	4293      	cmp	r3, r2
2400551c:	d101      	bne.n	24005522 <HAL_DMAEx_MultiBufferStart+0xfe>
2400551e:	2301      	movs	r3, #1
24005520:	e000      	b.n	24005524 <HAL_DMAEx_MultiBufferStart+0x100>
24005522:	2300      	movs	r3, #0
24005524:	2b00      	cmp	r3, #0
24005526:	d018      	beq.n	2400555a <HAL_DMAEx_MultiBufferStart+0x136>
      {
        /* Enable the Double buffer mode */
        ((DMA_Stream_TypeDef   *)hdma->Instance)->CR |= DMA_SxCR_DBM;
24005528:	68fb      	ldr	r3, [r7, #12]
2400552a:	681b      	ldr	r3, [r3, #0]
2400552c:	681a      	ldr	r2, [r3, #0]
2400552e:	68fb      	ldr	r3, [r7, #12]
24005530:	681b      	ldr	r3, [r3, #0]
24005532:	f442 2280 	orr.w	r2, r2, #262144	; 0x40000
24005536:	601a      	str	r2, [r3, #0]

        /* Configure DMA Stream destination address */
        ((DMA_Stream_TypeDef   *)hdma->Instance)->M1AR = SecondMemAddress;
24005538:	68fb      	ldr	r3, [r7, #12]
2400553a:	681b      	ldr	r3, [r3, #0]
2400553c:	683a      	ldr	r2, [r7, #0]
2400553e:	611a      	str	r2, [r3, #16]

        /* Calculate the interrupt clear flag register (IFCR) base address  */
        ifcRegister_Base = (uint32_t *)((uint32_t)(hdma->StreamBaseAddress + 8U));
24005540:	68fb      	ldr	r3, [r7, #12]
24005542:	6d9b      	ldr	r3, [r3, #88]	; 0x58
24005544:	3308      	adds	r3, #8
24005546:	613b      	str	r3, [r7, #16]

        /* Clear all flags */
        *ifcRegister_Base = 0x3FUL << (hdma->StreamIndex & 0x1FU);
24005548:	68fb      	ldr	r3, [r7, #12]
2400554a:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
2400554c:	f003 031f 	and.w	r3, r3, #31
24005550:	223f      	movs	r2, #63	; 0x3f
24005552:	409a      	lsls	r2, r3
24005554:	693b      	ldr	r3, [r7, #16]
24005556:	601a      	str	r2, [r3, #0]
24005558:	e018      	b.n	2400558c <HAL_DMAEx_MultiBufferStart+0x168>
      }
      else /* BDMA instance(s) */
      {
        /* Enable the Double buffer mode */
        ((BDMA_Channel_TypeDef   *)hdma->Instance)->CCR |= (BDMA_CCR_DBM | BDMA_CCR_CIRC);
2400555a:	68fb      	ldr	r3, [r7, #12]
2400555c:	681b      	ldr	r3, [r3, #0]
2400555e:	6819      	ldr	r1, [r3, #0]
24005560:	68fb      	ldr	r3, [r7, #12]
24005562:	681a      	ldr	r2, [r3, #0]
24005564:	f248 0320 	movw	r3, #32800	; 0x8020
24005568:	430b      	orrs	r3, r1
2400556a:	6013      	str	r3, [r2, #0]

        /* Configure DMA Stream destination address */
        ((BDMA_Channel_TypeDef   *)hdma->Instance)->CM1AR = SecondMemAddress;
2400556c:	68fb      	ldr	r3, [r7, #12]
2400556e:	681b      	ldr	r3, [r3, #0]
24005570:	683a      	ldr	r2, [r7, #0]
24005572:	611a      	str	r2, [r3, #16]

        /* Calculate the interrupt clear flag register (IFCR) base address  */
        ifcRegister_Base = (uint32_t *)((uint32_t)(hdma->StreamBaseAddress + 4U));
24005574:	68fb      	ldr	r3, [r7, #12]
24005576:	6d9b      	ldr	r3, [r3, #88]	; 0x58
24005578:	3304      	adds	r3, #4
2400557a:	613b      	str	r3, [r7, #16]

        /* Clear all flags */
        *ifcRegister_Base = (BDMA_ISR_GIF0) << (hdma->StreamIndex & 0x1FU);
2400557c:	68fb      	ldr	r3, [r7, #12]
2400557e:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
24005580:	f003 031f 	and.w	r3, r3, #31
24005584:	2201      	movs	r2, #1
24005586:	409a      	lsls	r2, r3
24005588:	693b      	ldr	r3, [r7, #16]
2400558a:	601a      	str	r2, [r3, #0]
      }

      if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
2400558c:	68fb      	ldr	r3, [r7, #12]
2400558e:	681b      	ldr	r3, [r3, #0]
24005590:	4a3b      	ldr	r2, [pc, #236]	; (24005680 <HAL_DMAEx_MultiBufferStart+0x25c>)
24005592:	4293      	cmp	r3, r2
24005594:	d072      	beq.n	2400567c <HAL_DMAEx_MultiBufferStart+0x258>
24005596:	68fb      	ldr	r3, [r7, #12]
24005598:	681b      	ldr	r3, [r3, #0]
2400559a:	4a3a      	ldr	r2, [pc, #232]	; (24005684 <HAL_DMAEx_MultiBufferStart+0x260>)
2400559c:	4293      	cmp	r3, r2
2400559e:	d06d      	beq.n	2400567c <HAL_DMAEx_MultiBufferStart+0x258>
240055a0:	68fb      	ldr	r3, [r7, #12]
240055a2:	681b      	ldr	r3, [r3, #0]
240055a4:	4a38      	ldr	r2, [pc, #224]	; (24005688 <HAL_DMAEx_MultiBufferStart+0x264>)
240055a6:	4293      	cmp	r3, r2
240055a8:	d068      	beq.n	2400567c <HAL_DMAEx_MultiBufferStart+0x258>
240055aa:	68fb      	ldr	r3, [r7, #12]
240055ac:	681b      	ldr	r3, [r3, #0]
240055ae:	4a37      	ldr	r2, [pc, #220]	; (2400568c <HAL_DMAEx_MultiBufferStart+0x268>)
240055b0:	4293      	cmp	r3, r2
240055b2:	d063      	beq.n	2400567c <HAL_DMAEx_MultiBufferStart+0x258>
240055b4:	68fb      	ldr	r3, [r7, #12]
240055b6:	681b      	ldr	r3, [r3, #0]
240055b8:	4a35      	ldr	r2, [pc, #212]	; (24005690 <HAL_DMAEx_MultiBufferStart+0x26c>)
240055ba:	4293      	cmp	r3, r2
240055bc:	d05e      	beq.n	2400567c <HAL_DMAEx_MultiBufferStart+0x258>
240055be:	68fb      	ldr	r3, [r7, #12]
240055c0:	681b      	ldr	r3, [r3, #0]
240055c2:	4a34      	ldr	r2, [pc, #208]	; (24005694 <HAL_DMAEx_MultiBufferStart+0x270>)
240055c4:	4293      	cmp	r3, r2
240055c6:	d059      	beq.n	2400567c <HAL_DMAEx_MultiBufferStart+0x258>
240055c8:	68fb      	ldr	r3, [r7, #12]
240055ca:	681b      	ldr	r3, [r3, #0]
240055cc:	4a32      	ldr	r2, [pc, #200]	; (24005698 <HAL_DMAEx_MultiBufferStart+0x274>)
240055ce:	4293      	cmp	r3, r2
240055d0:	d054      	beq.n	2400567c <HAL_DMAEx_MultiBufferStart+0x258>
240055d2:	68fb      	ldr	r3, [r7, #12]
240055d4:	681b      	ldr	r3, [r3, #0]
240055d6:	4a31      	ldr	r2, [pc, #196]	; (2400569c <HAL_DMAEx_MultiBufferStart+0x278>)
240055d8:	4293      	cmp	r3, r2
240055da:	d04f      	beq.n	2400567c <HAL_DMAEx_MultiBufferStart+0x258>
240055dc:	68fb      	ldr	r3, [r7, #12]
240055de:	681b      	ldr	r3, [r3, #0]
240055e0:	4a2f      	ldr	r2, [pc, #188]	; (240056a0 <HAL_DMAEx_MultiBufferStart+0x27c>)
240055e2:	4293      	cmp	r3, r2
240055e4:	d04a      	beq.n	2400567c <HAL_DMAEx_MultiBufferStart+0x258>
240055e6:	68fb      	ldr	r3, [r7, #12]
240055e8:	681b      	ldr	r3, [r3, #0]
240055ea:	4a2e      	ldr	r2, [pc, #184]	; (240056a4 <HAL_DMAEx_MultiBufferStart+0x280>)
240055ec:	4293      	cmp	r3, r2
240055ee:	d045      	beq.n	2400567c <HAL_DMAEx_MultiBufferStart+0x258>
240055f0:	68fb      	ldr	r3, [r7, #12]
240055f2:	681b      	ldr	r3, [r3, #0]
240055f4:	4a2c      	ldr	r2, [pc, #176]	; (240056a8 <HAL_DMAEx_MultiBufferStart+0x284>)
240055f6:	4293      	cmp	r3, r2
240055f8:	d040      	beq.n	2400567c <HAL_DMAEx_MultiBufferStart+0x258>
240055fa:	68fb      	ldr	r3, [r7, #12]
240055fc:	681b      	ldr	r3, [r3, #0]
240055fe:	4a2b      	ldr	r2, [pc, #172]	; (240056ac <HAL_DMAEx_MultiBufferStart+0x288>)
24005600:	4293      	cmp	r3, r2
24005602:	d03b      	beq.n	2400567c <HAL_DMAEx_MultiBufferStart+0x258>
24005604:	68fb      	ldr	r3, [r7, #12]
24005606:	681b      	ldr	r3, [r3, #0]
24005608:	4a29      	ldr	r2, [pc, #164]	; (240056b0 <HAL_DMAEx_MultiBufferStart+0x28c>)
2400560a:	4293      	cmp	r3, r2
2400560c:	d036      	beq.n	2400567c <HAL_DMAEx_MultiBufferStart+0x258>
2400560e:	68fb      	ldr	r3, [r7, #12]
24005610:	681b      	ldr	r3, [r3, #0]
24005612:	4a28      	ldr	r2, [pc, #160]	; (240056b4 <HAL_DMAEx_MultiBufferStart+0x290>)
24005614:	4293      	cmp	r3, r2
24005616:	d031      	beq.n	2400567c <HAL_DMAEx_MultiBufferStart+0x258>
24005618:	68fb      	ldr	r3, [r7, #12]
2400561a:	681b      	ldr	r3, [r3, #0]
2400561c:	4a26      	ldr	r2, [pc, #152]	; (240056b8 <HAL_DMAEx_MultiBufferStart+0x294>)
2400561e:	4293      	cmp	r3, r2
24005620:	d02c      	beq.n	2400567c <HAL_DMAEx_MultiBufferStart+0x258>
24005622:	68fb      	ldr	r3, [r7, #12]
24005624:	681b      	ldr	r3, [r3, #0]
24005626:	4a25      	ldr	r2, [pc, #148]	; (240056bc <HAL_DMAEx_MultiBufferStart+0x298>)
24005628:	4293      	cmp	r3, r2
2400562a:	d027      	beq.n	2400567c <HAL_DMAEx_MultiBufferStart+0x258>
2400562c:	68fb      	ldr	r3, [r7, #12]
2400562e:	681b      	ldr	r3, [r3, #0]
24005630:	4a23      	ldr	r2, [pc, #140]	; (240056c0 <HAL_DMAEx_MultiBufferStart+0x29c>)
24005632:	4293      	cmp	r3, r2
24005634:	d022      	beq.n	2400567c <HAL_DMAEx_MultiBufferStart+0x258>
24005636:	68fb      	ldr	r3, [r7, #12]
24005638:	681b      	ldr	r3, [r3, #0]
2400563a:	4a22      	ldr	r2, [pc, #136]	; (240056c4 <HAL_DMAEx_MultiBufferStart+0x2a0>)
2400563c:	4293      	cmp	r3, r2
2400563e:	d01d      	beq.n	2400567c <HAL_DMAEx_MultiBufferStart+0x258>
24005640:	68fb      	ldr	r3, [r7, #12]
24005642:	681b      	ldr	r3, [r3, #0]
24005644:	4a20      	ldr	r2, [pc, #128]	; (240056c8 <HAL_DMAEx_MultiBufferStart+0x2a4>)
24005646:	4293      	cmp	r3, r2
24005648:	d018      	beq.n	2400567c <HAL_DMAEx_MultiBufferStart+0x258>
2400564a:	68fb      	ldr	r3, [r7, #12]
2400564c:	681b      	ldr	r3, [r3, #0]
2400564e:	4a1f      	ldr	r2, [pc, #124]	; (240056cc <HAL_DMAEx_MultiBufferStart+0x2a8>)
24005650:	4293      	cmp	r3, r2
24005652:	d013      	beq.n	2400567c <HAL_DMAEx_MultiBufferStart+0x258>
24005654:	68fb      	ldr	r3, [r7, #12]
24005656:	681b      	ldr	r3, [r3, #0]
24005658:	4a1d      	ldr	r2, [pc, #116]	; (240056d0 <HAL_DMAEx_MultiBufferStart+0x2ac>)
2400565a:	4293      	cmp	r3, r2
2400565c:	d00e      	beq.n	2400567c <HAL_DMAEx_MultiBufferStart+0x258>
2400565e:	68fb      	ldr	r3, [r7, #12]
24005660:	681b      	ldr	r3, [r3, #0]
24005662:	4a1c      	ldr	r2, [pc, #112]	; (240056d4 <HAL_DMAEx_MultiBufferStart+0x2b0>)
24005664:	4293      	cmp	r3, r2
24005666:	d009      	beq.n	2400567c <HAL_DMAEx_MultiBufferStart+0x258>
24005668:	68fb      	ldr	r3, [r7, #12]
2400566a:	681b      	ldr	r3, [r3, #0]
2400566c:	4a1a      	ldr	r2, [pc, #104]	; (240056d8 <HAL_DMAEx_MultiBufferStart+0x2b4>)
2400566e:	4293      	cmp	r3, r2
24005670:	d004      	beq.n	2400567c <HAL_DMAEx_MultiBufferStart+0x258>
24005672:	68fb      	ldr	r3, [r7, #12]
24005674:	681b      	ldr	r3, [r3, #0]
24005676:	4a19      	ldr	r2, [pc, #100]	; (240056dc <HAL_DMAEx_MultiBufferStart+0x2b8>)
24005678:	4293      	cmp	r3, r2
2400567a:	d131      	bne.n	240056e0 <HAL_DMAEx_MultiBufferStart+0x2bc>
2400567c:	2301      	movs	r3, #1
2400567e:	e030      	b.n	240056e2 <HAL_DMAEx_MultiBufferStart+0x2be>
24005680:	40020010 	.word	0x40020010
24005684:	40020028 	.word	0x40020028
24005688:	40020040 	.word	0x40020040
2400568c:	40020058 	.word	0x40020058
24005690:	40020070 	.word	0x40020070
24005694:	40020088 	.word	0x40020088
24005698:	400200a0 	.word	0x400200a0
2400569c:	400200b8 	.word	0x400200b8
240056a0:	40020410 	.word	0x40020410
240056a4:	40020428 	.word	0x40020428
240056a8:	40020440 	.word	0x40020440
240056ac:	40020458 	.word	0x40020458
240056b0:	40020470 	.word	0x40020470
240056b4:	40020488 	.word	0x40020488
240056b8:	400204a0 	.word	0x400204a0
240056bc:	400204b8 	.word	0x400204b8
240056c0:	58025408 	.word	0x58025408
240056c4:	5802541c 	.word	0x5802541c
240056c8:	58025430 	.word	0x58025430
240056cc:	58025444 	.word	0x58025444
240056d0:	58025458 	.word	0x58025458
240056d4:	5802546c 	.word	0x5802546c
240056d8:	58025480 	.word	0x58025480
240056dc:	58025494 	.word	0x58025494
240056e0:	2300      	movs	r3, #0
240056e2:	2b00      	cmp	r3, #0
240056e4:	d013      	beq.n	2400570e <HAL_DMAEx_MultiBufferStart+0x2ea>
      {
        /* Configure the source, destination address and the data length */
        DMA_MultiBufferSetConfig(hdma, SrcAddress, DstAddress, DataLength);
240056e6:	6a3b      	ldr	r3, [r7, #32]
240056e8:	687a      	ldr	r2, [r7, #4]
240056ea:	68b9      	ldr	r1, [r7, #8]
240056ec:	68f8      	ldr	r0, [r7, #12]
240056ee:	f000 fea5 	bl	2400643c <DMA_MultiBufferSetConfig>

        /* Clear the DMAMUX synchro overrun flag */
        hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
240056f2:	68fb      	ldr	r3, [r7, #12]
240056f4:	6e5b      	ldr	r3, [r3, #100]	; 0x64
240056f6:	68fa      	ldr	r2, [r7, #12]
240056f8:	6e92      	ldr	r2, [r2, #104]	; 0x68
240056fa:	605a      	str	r2, [r3, #4]

        if(hdma->DMAmuxRequestGen != 0U)
240056fc:	68fb      	ldr	r3, [r7, #12]
240056fe:	6edb      	ldr	r3, [r3, #108]	; 0x6c
24005700:	2b00      	cmp	r3, #0
24005702:	d004      	beq.n	2400570e <HAL_DMAEx_MultiBufferStart+0x2ea>
        {
          /* Clear the DMAMUX request generator overrun flag */
          hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
24005704:	68fb      	ldr	r3, [r7, #12]
24005706:	6f1b      	ldr	r3, [r3, #112]	; 0x70
24005708:	68fa      	ldr	r2, [r7, #12]
2400570a:	6f52      	ldr	r2, [r2, #116]	; 0x74
2400570c:	605a      	str	r2, [r3, #4]
        }
      }

      /* Enable the peripheral */
      __HAL_DMA_ENABLE(hdma);
2400570e:	68fb      	ldr	r3, [r7, #12]
24005710:	681b      	ldr	r3, [r3, #0]
24005712:	4a35      	ldr	r2, [pc, #212]	; (240057e8 <HAL_DMAEx_MultiBufferStart+0x3c4>)
24005714:	4293      	cmp	r3, r2
24005716:	d04a      	beq.n	240057ae <HAL_DMAEx_MultiBufferStart+0x38a>
24005718:	68fb      	ldr	r3, [r7, #12]
2400571a:	681b      	ldr	r3, [r3, #0]
2400571c:	4a33      	ldr	r2, [pc, #204]	; (240057ec <HAL_DMAEx_MultiBufferStart+0x3c8>)
2400571e:	4293      	cmp	r3, r2
24005720:	d045      	beq.n	240057ae <HAL_DMAEx_MultiBufferStart+0x38a>
24005722:	68fb      	ldr	r3, [r7, #12]
24005724:	681b      	ldr	r3, [r3, #0]
24005726:	4a32      	ldr	r2, [pc, #200]	; (240057f0 <HAL_DMAEx_MultiBufferStart+0x3cc>)
24005728:	4293      	cmp	r3, r2
2400572a:	d040      	beq.n	240057ae <HAL_DMAEx_MultiBufferStart+0x38a>
2400572c:	68fb      	ldr	r3, [r7, #12]
2400572e:	681b      	ldr	r3, [r3, #0]
24005730:	4a30      	ldr	r2, [pc, #192]	; (240057f4 <HAL_DMAEx_MultiBufferStart+0x3d0>)
24005732:	4293      	cmp	r3, r2
24005734:	d03b      	beq.n	240057ae <HAL_DMAEx_MultiBufferStart+0x38a>
24005736:	68fb      	ldr	r3, [r7, #12]
24005738:	681b      	ldr	r3, [r3, #0]
2400573a:	4a2f      	ldr	r2, [pc, #188]	; (240057f8 <HAL_DMAEx_MultiBufferStart+0x3d4>)
2400573c:	4293      	cmp	r3, r2
2400573e:	d036      	beq.n	240057ae <HAL_DMAEx_MultiBufferStart+0x38a>
24005740:	68fb      	ldr	r3, [r7, #12]
24005742:	681b      	ldr	r3, [r3, #0]
24005744:	4a2d      	ldr	r2, [pc, #180]	; (240057fc <HAL_DMAEx_MultiBufferStart+0x3d8>)
24005746:	4293      	cmp	r3, r2
24005748:	d031      	beq.n	240057ae <HAL_DMAEx_MultiBufferStart+0x38a>
2400574a:	68fb      	ldr	r3, [r7, #12]
2400574c:	681b      	ldr	r3, [r3, #0]
2400574e:	4a2c      	ldr	r2, [pc, #176]	; (24005800 <HAL_DMAEx_MultiBufferStart+0x3dc>)
24005750:	4293      	cmp	r3, r2
24005752:	d02c      	beq.n	240057ae <HAL_DMAEx_MultiBufferStart+0x38a>
24005754:	68fb      	ldr	r3, [r7, #12]
24005756:	681b      	ldr	r3, [r3, #0]
24005758:	4a2a      	ldr	r2, [pc, #168]	; (24005804 <HAL_DMAEx_MultiBufferStart+0x3e0>)
2400575a:	4293      	cmp	r3, r2
2400575c:	d027      	beq.n	240057ae <HAL_DMAEx_MultiBufferStart+0x38a>
2400575e:	68fb      	ldr	r3, [r7, #12]
24005760:	681b      	ldr	r3, [r3, #0]
24005762:	4a29      	ldr	r2, [pc, #164]	; (24005808 <HAL_DMAEx_MultiBufferStart+0x3e4>)
24005764:	4293      	cmp	r3, r2
24005766:	d022      	beq.n	240057ae <HAL_DMAEx_MultiBufferStart+0x38a>
24005768:	68fb      	ldr	r3, [r7, #12]
2400576a:	681b      	ldr	r3, [r3, #0]
2400576c:	4a27      	ldr	r2, [pc, #156]	; (2400580c <HAL_DMAEx_MultiBufferStart+0x3e8>)
2400576e:	4293      	cmp	r3, r2
24005770:	d01d      	beq.n	240057ae <HAL_DMAEx_MultiBufferStart+0x38a>
24005772:	68fb      	ldr	r3, [r7, #12]
24005774:	681b      	ldr	r3, [r3, #0]
24005776:	4a26      	ldr	r2, [pc, #152]	; (24005810 <HAL_DMAEx_MultiBufferStart+0x3ec>)
24005778:	4293      	cmp	r3, r2
2400577a:	d018      	beq.n	240057ae <HAL_DMAEx_MultiBufferStart+0x38a>
2400577c:	68fb      	ldr	r3, [r7, #12]
2400577e:	681b      	ldr	r3, [r3, #0]
24005780:	4a24      	ldr	r2, [pc, #144]	; (24005814 <HAL_DMAEx_MultiBufferStart+0x3f0>)
24005782:	4293      	cmp	r3, r2
24005784:	d013      	beq.n	240057ae <HAL_DMAEx_MultiBufferStart+0x38a>
24005786:	68fb      	ldr	r3, [r7, #12]
24005788:	681b      	ldr	r3, [r3, #0]
2400578a:	4a23      	ldr	r2, [pc, #140]	; (24005818 <HAL_DMAEx_MultiBufferStart+0x3f4>)
2400578c:	4293      	cmp	r3, r2
2400578e:	d00e      	beq.n	240057ae <HAL_DMAEx_MultiBufferStart+0x38a>
24005790:	68fb      	ldr	r3, [r7, #12]
24005792:	681b      	ldr	r3, [r3, #0]
24005794:	4a21      	ldr	r2, [pc, #132]	; (2400581c <HAL_DMAEx_MultiBufferStart+0x3f8>)
24005796:	4293      	cmp	r3, r2
24005798:	d009      	beq.n	240057ae <HAL_DMAEx_MultiBufferStart+0x38a>
2400579a:	68fb      	ldr	r3, [r7, #12]
2400579c:	681b      	ldr	r3, [r3, #0]
2400579e:	4a20      	ldr	r2, [pc, #128]	; (24005820 <HAL_DMAEx_MultiBufferStart+0x3fc>)
240057a0:	4293      	cmp	r3, r2
240057a2:	d004      	beq.n	240057ae <HAL_DMAEx_MultiBufferStart+0x38a>
240057a4:	68fb      	ldr	r3, [r7, #12]
240057a6:	681b      	ldr	r3, [r3, #0]
240057a8:	4a1e      	ldr	r2, [pc, #120]	; (24005824 <HAL_DMAEx_MultiBufferStart+0x400>)
240057aa:	4293      	cmp	r3, r2
240057ac:	d108      	bne.n	240057c0 <HAL_DMAEx_MultiBufferStart+0x39c>
240057ae:	68fb      	ldr	r3, [r7, #12]
240057b0:	681b      	ldr	r3, [r3, #0]
240057b2:	681a      	ldr	r2, [r3, #0]
240057b4:	68fb      	ldr	r3, [r7, #12]
240057b6:	681b      	ldr	r3, [r3, #0]
240057b8:	f042 0201 	orr.w	r2, r2, #1
240057bc:	601a      	str	r2, [r3, #0]
240057be:	e00e      	b.n	240057de <HAL_DMAEx_MultiBufferStart+0x3ba>
240057c0:	68fb      	ldr	r3, [r7, #12]
240057c2:	681b      	ldr	r3, [r3, #0]
240057c4:	681a      	ldr	r2, [r3, #0]
240057c6:	68fb      	ldr	r3, [r7, #12]
240057c8:	681b      	ldr	r3, [r3, #0]
240057ca:	f042 0201 	orr.w	r2, r2, #1
240057ce:	601a      	str	r2, [r3, #0]
240057d0:	e005      	b.n	240057de <HAL_DMAEx_MultiBufferStart+0x3ba>
    }
    else
    {
      /* Set the error code to busy */
      hdma->ErrorCode = HAL_DMA_ERROR_BUSY;
240057d2:	68fb      	ldr	r3, [r7, #12]
240057d4:	f44f 6200 	mov.w	r2, #2048	; 0x800
240057d8:	655a      	str	r2, [r3, #84]	; 0x54

      /* Return error status */
      status = HAL_ERROR;
240057da:	2301      	movs	r3, #1
240057dc:	75fb      	strb	r3, [r7, #23]
    }
  }
  return status;
240057de:	7dfb      	ldrb	r3, [r7, #23]
}
240057e0:	4618      	mov	r0, r3
240057e2:	3718      	adds	r7, #24
240057e4:	46bd      	mov	sp, r7
240057e6:	bd80      	pop	{r7, pc}
240057e8:	40020010 	.word	0x40020010
240057ec:	40020028 	.word	0x40020028
240057f0:	40020040 	.word	0x40020040
240057f4:	40020058 	.word	0x40020058
240057f8:	40020070 	.word	0x40020070
240057fc:	40020088 	.word	0x40020088
24005800:	400200a0 	.word	0x400200a0
24005804:	400200b8 	.word	0x400200b8
24005808:	40020410 	.word	0x40020410
2400580c:	40020428 	.word	0x40020428
24005810:	40020440 	.word	0x40020440
24005814:	40020458 	.word	0x40020458
24005818:	40020470 	.word	0x40020470
2400581c:	40020488 	.word	0x40020488
24005820:	400204a0 	.word	0x400204a0
24005824:	400204b8 	.word	0x400204b8

24005828 <HAL_DMAEx_MultiBufferStart_IT>:
  * @param  SecondMemAddress: The second memory Buffer address in case of multi buffer Transfer
  * @param  DataLength: The length of data to be transferred from source to destination
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMAEx_MultiBufferStart_IT(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t SecondMemAddress, uint32_t DataLength)
{
24005828:	b580      	push	{r7, lr}
2400582a:	b086      	sub	sp, #24
2400582c:	af00      	add	r7, sp, #0
2400582e:	60f8      	str	r0, [r7, #12]
24005830:	60b9      	str	r1, [r7, #8]
24005832:	607a      	str	r2, [r7, #4]
24005834:	603b      	str	r3, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
24005836:	2300      	movs	r3, #0
24005838:	75fb      	strb	r3, [r7, #23]
  /* Check the parameters */
  assert_param(IS_DMA_BUFFER_SIZE(DataLength));
  assert_param(IS_DMA_ALL_INSTANCE(hdma->Instance));

  /* Memory-to-memory transfer not supported in double buffering mode */
  if(hdma->Init.Direction == DMA_MEMORY_TO_MEMORY)
2400583a:	68fb      	ldr	r3, [r7, #12]
2400583c:	689b      	ldr	r3, [r3, #8]
2400583e:	2b80      	cmp	r3, #128	; 0x80
24005840:	d105      	bne.n	2400584e <HAL_DMAEx_MultiBufferStart_IT+0x26>
  {
    hdma->ErrorCode = HAL_DMA_ERROR_NOT_SUPPORTED;
24005842:	68fb      	ldr	r3, [r7, #12]
24005844:	f44f 7280 	mov.w	r2, #256	; 0x100
24005848:	655a      	str	r2, [r3, #84]	; 0x54
    return HAL_ERROR;
2400584a:	2301      	movs	r3, #1
2400584c:	e325      	b.n	24005e9a <HAL_DMAEx_MultiBufferStart_IT+0x672>
  }

  /* Process locked */
  __HAL_LOCK(hdma);
2400584e:	68fb      	ldr	r3, [r7, #12]
24005850:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
24005854:	2b01      	cmp	r3, #1
24005856:	d101      	bne.n	2400585c <HAL_DMAEx_MultiBufferStart_IT+0x34>
24005858:	2302      	movs	r3, #2
2400585a:	e31e      	b.n	24005e9a <HAL_DMAEx_MultiBufferStart_IT+0x672>
2400585c:	68fb      	ldr	r3, [r7, #12]
2400585e:	2201      	movs	r2, #1
24005860:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

  if(HAL_DMA_STATE_READY == hdma->State)
24005864:	68fb      	ldr	r3, [r7, #12]
24005866:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
2400586a:	b2db      	uxtb	r3, r3
2400586c:	2b01      	cmp	r3, #1
2400586e:	f040 830d 	bne.w	24005e8c <HAL_DMAEx_MultiBufferStart_IT+0x664>
  {
    /* Change DMA peripheral state */
    hdma->State = HAL_DMA_STATE_BUSY;
24005872:	68fb      	ldr	r3, [r7, #12]
24005874:	2202      	movs	r2, #2
24005876:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

    /* Initialize the error code */
    hdma->ErrorCode = HAL_DMA_ERROR_NONE;
2400587a:	68fb      	ldr	r3, [r7, #12]
2400587c:	2200      	movs	r2, #0
2400587e:	655a      	str	r2, [r3, #84]	; 0x54

    if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
24005880:	68fb      	ldr	r3, [r7, #12]
24005882:	681b      	ldr	r3, [r3, #0]
24005884:	4a82      	ldr	r2, [pc, #520]	; (24005a90 <HAL_DMAEx_MultiBufferStart_IT+0x268>)
24005886:	4293      	cmp	r3, r2
24005888:	d04a      	beq.n	24005920 <HAL_DMAEx_MultiBufferStart_IT+0xf8>
2400588a:	68fb      	ldr	r3, [r7, #12]
2400588c:	681b      	ldr	r3, [r3, #0]
2400588e:	4a81      	ldr	r2, [pc, #516]	; (24005a94 <HAL_DMAEx_MultiBufferStart_IT+0x26c>)
24005890:	4293      	cmp	r3, r2
24005892:	d045      	beq.n	24005920 <HAL_DMAEx_MultiBufferStart_IT+0xf8>
24005894:	68fb      	ldr	r3, [r7, #12]
24005896:	681b      	ldr	r3, [r3, #0]
24005898:	4a7f      	ldr	r2, [pc, #508]	; (24005a98 <HAL_DMAEx_MultiBufferStart_IT+0x270>)
2400589a:	4293      	cmp	r3, r2
2400589c:	d040      	beq.n	24005920 <HAL_DMAEx_MultiBufferStart_IT+0xf8>
2400589e:	68fb      	ldr	r3, [r7, #12]
240058a0:	681b      	ldr	r3, [r3, #0]
240058a2:	4a7e      	ldr	r2, [pc, #504]	; (24005a9c <HAL_DMAEx_MultiBufferStart_IT+0x274>)
240058a4:	4293      	cmp	r3, r2
240058a6:	d03b      	beq.n	24005920 <HAL_DMAEx_MultiBufferStart_IT+0xf8>
240058a8:	68fb      	ldr	r3, [r7, #12]
240058aa:	681b      	ldr	r3, [r3, #0]
240058ac:	4a7c      	ldr	r2, [pc, #496]	; (24005aa0 <HAL_DMAEx_MultiBufferStart_IT+0x278>)
240058ae:	4293      	cmp	r3, r2
240058b0:	d036      	beq.n	24005920 <HAL_DMAEx_MultiBufferStart_IT+0xf8>
240058b2:	68fb      	ldr	r3, [r7, #12]
240058b4:	681b      	ldr	r3, [r3, #0]
240058b6:	4a7b      	ldr	r2, [pc, #492]	; (24005aa4 <HAL_DMAEx_MultiBufferStart_IT+0x27c>)
240058b8:	4293      	cmp	r3, r2
240058ba:	d031      	beq.n	24005920 <HAL_DMAEx_MultiBufferStart_IT+0xf8>
240058bc:	68fb      	ldr	r3, [r7, #12]
240058be:	681b      	ldr	r3, [r3, #0]
240058c0:	4a79      	ldr	r2, [pc, #484]	; (24005aa8 <HAL_DMAEx_MultiBufferStart_IT+0x280>)
240058c2:	4293      	cmp	r3, r2
240058c4:	d02c      	beq.n	24005920 <HAL_DMAEx_MultiBufferStart_IT+0xf8>
240058c6:	68fb      	ldr	r3, [r7, #12]
240058c8:	681b      	ldr	r3, [r3, #0]
240058ca:	4a78      	ldr	r2, [pc, #480]	; (24005aac <HAL_DMAEx_MultiBufferStart_IT+0x284>)
240058cc:	4293      	cmp	r3, r2
240058ce:	d027      	beq.n	24005920 <HAL_DMAEx_MultiBufferStart_IT+0xf8>
240058d0:	68fb      	ldr	r3, [r7, #12]
240058d2:	681b      	ldr	r3, [r3, #0]
240058d4:	4a76      	ldr	r2, [pc, #472]	; (24005ab0 <HAL_DMAEx_MultiBufferStart_IT+0x288>)
240058d6:	4293      	cmp	r3, r2
240058d8:	d022      	beq.n	24005920 <HAL_DMAEx_MultiBufferStart_IT+0xf8>
240058da:	68fb      	ldr	r3, [r7, #12]
240058dc:	681b      	ldr	r3, [r3, #0]
240058de:	4a75      	ldr	r2, [pc, #468]	; (24005ab4 <HAL_DMAEx_MultiBufferStart_IT+0x28c>)
240058e0:	4293      	cmp	r3, r2
240058e2:	d01d      	beq.n	24005920 <HAL_DMAEx_MultiBufferStart_IT+0xf8>
240058e4:	68fb      	ldr	r3, [r7, #12]
240058e6:	681b      	ldr	r3, [r3, #0]
240058e8:	4a73      	ldr	r2, [pc, #460]	; (24005ab8 <HAL_DMAEx_MultiBufferStart_IT+0x290>)
240058ea:	4293      	cmp	r3, r2
240058ec:	d018      	beq.n	24005920 <HAL_DMAEx_MultiBufferStart_IT+0xf8>
240058ee:	68fb      	ldr	r3, [r7, #12]
240058f0:	681b      	ldr	r3, [r3, #0]
240058f2:	4a72      	ldr	r2, [pc, #456]	; (24005abc <HAL_DMAEx_MultiBufferStart_IT+0x294>)
240058f4:	4293      	cmp	r3, r2
240058f6:	d013      	beq.n	24005920 <HAL_DMAEx_MultiBufferStart_IT+0xf8>
240058f8:	68fb      	ldr	r3, [r7, #12]
240058fa:	681b      	ldr	r3, [r3, #0]
240058fc:	4a70      	ldr	r2, [pc, #448]	; (24005ac0 <HAL_DMAEx_MultiBufferStart_IT+0x298>)
240058fe:	4293      	cmp	r3, r2
24005900:	d00e      	beq.n	24005920 <HAL_DMAEx_MultiBufferStart_IT+0xf8>
24005902:	68fb      	ldr	r3, [r7, #12]
24005904:	681b      	ldr	r3, [r3, #0]
24005906:	4a6f      	ldr	r2, [pc, #444]	; (24005ac4 <HAL_DMAEx_MultiBufferStart_IT+0x29c>)
24005908:	4293      	cmp	r3, r2
2400590a:	d009      	beq.n	24005920 <HAL_DMAEx_MultiBufferStart_IT+0xf8>
2400590c:	68fb      	ldr	r3, [r7, #12]
2400590e:	681b      	ldr	r3, [r3, #0]
24005910:	4a6d      	ldr	r2, [pc, #436]	; (24005ac8 <HAL_DMAEx_MultiBufferStart_IT+0x2a0>)
24005912:	4293      	cmp	r3, r2
24005914:	d004      	beq.n	24005920 <HAL_DMAEx_MultiBufferStart_IT+0xf8>
24005916:	68fb      	ldr	r3, [r7, #12]
24005918:	681b      	ldr	r3, [r3, #0]
2400591a:	4a6c      	ldr	r2, [pc, #432]	; (24005acc <HAL_DMAEx_MultiBufferStart_IT+0x2a4>)
2400591c:	4293      	cmp	r3, r2
2400591e:	d101      	bne.n	24005924 <HAL_DMAEx_MultiBufferStart_IT+0xfc>
24005920:	2301      	movs	r3, #1
24005922:	e000      	b.n	24005926 <HAL_DMAEx_MultiBufferStart_IT+0xfe>
24005924:	2300      	movs	r3, #0
24005926:	2b00      	cmp	r3, #0
24005928:	d018      	beq.n	2400595c <HAL_DMAEx_MultiBufferStart_IT+0x134>
    {
      /* Enable the Double buffer mode */
      ((DMA_Stream_TypeDef   *)hdma->Instance)->CR |= DMA_SxCR_DBM;
2400592a:	68fb      	ldr	r3, [r7, #12]
2400592c:	681b      	ldr	r3, [r3, #0]
2400592e:	681a      	ldr	r2, [r3, #0]
24005930:	68fb      	ldr	r3, [r7, #12]
24005932:	681b      	ldr	r3, [r3, #0]
24005934:	f442 2280 	orr.w	r2, r2, #262144	; 0x40000
24005938:	601a      	str	r2, [r3, #0]

      /* Configure DMA Stream destination address */
      ((DMA_Stream_TypeDef   *)hdma->Instance)->M1AR = SecondMemAddress;
2400593a:	68fb      	ldr	r3, [r7, #12]
2400593c:	681b      	ldr	r3, [r3, #0]
2400593e:	683a      	ldr	r2, [r7, #0]
24005940:	611a      	str	r2, [r3, #16]

      /* Calculate the interrupt clear flag register (IFCR) base address  */
      ifcRegister_Base = (uint32_t *)((uint32_t)(hdma->StreamBaseAddress + 8U));
24005942:	68fb      	ldr	r3, [r7, #12]
24005944:	6d9b      	ldr	r3, [r3, #88]	; 0x58
24005946:	3308      	adds	r3, #8
24005948:	613b      	str	r3, [r7, #16]

      /* Clear all flags */
      *ifcRegister_Base = 0x3FUL << (hdma->StreamIndex & 0x1FU);
2400594a:	68fb      	ldr	r3, [r7, #12]
2400594c:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
2400594e:	f003 031f 	and.w	r3, r3, #31
24005952:	223f      	movs	r2, #63	; 0x3f
24005954:	409a      	lsls	r2, r3
24005956:	693b      	ldr	r3, [r7, #16]
24005958:	601a      	str	r2, [r3, #0]
2400595a:	e018      	b.n	2400598e <HAL_DMAEx_MultiBufferStart_IT+0x166>
    }
    else /* BDMA instance(s) */
    {
      /* Enable the Double buffer mode */
      ((BDMA_Channel_TypeDef   *)hdma->Instance)->CCR |= (BDMA_CCR_DBM | BDMA_CCR_CIRC);
2400595c:	68fb      	ldr	r3, [r7, #12]
2400595e:	681b      	ldr	r3, [r3, #0]
24005960:	6819      	ldr	r1, [r3, #0]
24005962:	68fb      	ldr	r3, [r7, #12]
24005964:	681a      	ldr	r2, [r3, #0]
24005966:	f248 0320 	movw	r3, #32800	; 0x8020
2400596a:	430b      	orrs	r3, r1
2400596c:	6013      	str	r3, [r2, #0]

      /* Configure DMA Stream destination address */
      ((BDMA_Channel_TypeDef   *)hdma->Instance)->CM1AR = SecondMemAddress;
2400596e:	68fb      	ldr	r3, [r7, #12]
24005970:	681b      	ldr	r3, [r3, #0]
24005972:	683a      	ldr	r2, [r7, #0]
24005974:	611a      	str	r2, [r3, #16]

      /* Calculate the interrupt clear flag register (IFCR) base address  */
      ifcRegister_Base = (uint32_t *)((uint32_t)(hdma->StreamBaseAddress + 4U));
24005976:	68fb      	ldr	r3, [r7, #12]
24005978:	6d9b      	ldr	r3, [r3, #88]	; 0x58
2400597a:	3304      	adds	r3, #4
2400597c:	613b      	str	r3, [r7, #16]

      /* Clear all flags */
      *ifcRegister_Base = (BDMA_ISR_GIF0) << (hdma->StreamIndex & 0x1FU);
2400597e:	68fb      	ldr	r3, [r7, #12]
24005980:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
24005982:	f003 031f 	and.w	r3, r3, #31
24005986:	2201      	movs	r2, #1
24005988:	409a      	lsls	r2, r3
2400598a:	693b      	ldr	r3, [r7, #16]
2400598c:	601a      	str	r2, [r3, #0]
    }

    /* Configure the source, destination address and the data length */
    DMA_MultiBufferSetConfig(hdma, SrcAddress, DstAddress, DataLength);
2400598e:	6a3b      	ldr	r3, [r7, #32]
24005990:	687a      	ldr	r2, [r7, #4]
24005992:	68b9      	ldr	r1, [r7, #8]
24005994:	68f8      	ldr	r0, [r7, #12]
24005996:	f000 fd51 	bl	2400643c <DMA_MultiBufferSetConfig>

    if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
2400599a:	68fb      	ldr	r3, [r7, #12]
2400599c:	681b      	ldr	r3, [r3, #0]
2400599e:	4a3c      	ldr	r2, [pc, #240]	; (24005a90 <HAL_DMAEx_MultiBufferStart_IT+0x268>)
240059a0:	4293      	cmp	r3, r2
240059a2:	d072      	beq.n	24005a8a <HAL_DMAEx_MultiBufferStart_IT+0x262>
240059a4:	68fb      	ldr	r3, [r7, #12]
240059a6:	681b      	ldr	r3, [r3, #0]
240059a8:	4a3a      	ldr	r2, [pc, #232]	; (24005a94 <HAL_DMAEx_MultiBufferStart_IT+0x26c>)
240059aa:	4293      	cmp	r3, r2
240059ac:	d06d      	beq.n	24005a8a <HAL_DMAEx_MultiBufferStart_IT+0x262>
240059ae:	68fb      	ldr	r3, [r7, #12]
240059b0:	681b      	ldr	r3, [r3, #0]
240059b2:	4a39      	ldr	r2, [pc, #228]	; (24005a98 <HAL_DMAEx_MultiBufferStart_IT+0x270>)
240059b4:	4293      	cmp	r3, r2
240059b6:	d068      	beq.n	24005a8a <HAL_DMAEx_MultiBufferStart_IT+0x262>
240059b8:	68fb      	ldr	r3, [r7, #12]
240059ba:	681b      	ldr	r3, [r3, #0]
240059bc:	4a37      	ldr	r2, [pc, #220]	; (24005a9c <HAL_DMAEx_MultiBufferStart_IT+0x274>)
240059be:	4293      	cmp	r3, r2
240059c0:	d063      	beq.n	24005a8a <HAL_DMAEx_MultiBufferStart_IT+0x262>
240059c2:	68fb      	ldr	r3, [r7, #12]
240059c4:	681b      	ldr	r3, [r3, #0]
240059c6:	4a36      	ldr	r2, [pc, #216]	; (24005aa0 <HAL_DMAEx_MultiBufferStart_IT+0x278>)
240059c8:	4293      	cmp	r3, r2
240059ca:	d05e      	beq.n	24005a8a <HAL_DMAEx_MultiBufferStart_IT+0x262>
240059cc:	68fb      	ldr	r3, [r7, #12]
240059ce:	681b      	ldr	r3, [r3, #0]
240059d0:	4a34      	ldr	r2, [pc, #208]	; (24005aa4 <HAL_DMAEx_MultiBufferStart_IT+0x27c>)
240059d2:	4293      	cmp	r3, r2
240059d4:	d059      	beq.n	24005a8a <HAL_DMAEx_MultiBufferStart_IT+0x262>
240059d6:	68fb      	ldr	r3, [r7, #12]
240059d8:	681b      	ldr	r3, [r3, #0]
240059da:	4a33      	ldr	r2, [pc, #204]	; (24005aa8 <HAL_DMAEx_MultiBufferStart_IT+0x280>)
240059dc:	4293      	cmp	r3, r2
240059de:	d054      	beq.n	24005a8a <HAL_DMAEx_MultiBufferStart_IT+0x262>
240059e0:	68fb      	ldr	r3, [r7, #12]
240059e2:	681b      	ldr	r3, [r3, #0]
240059e4:	4a31      	ldr	r2, [pc, #196]	; (24005aac <HAL_DMAEx_MultiBufferStart_IT+0x284>)
240059e6:	4293      	cmp	r3, r2
240059e8:	d04f      	beq.n	24005a8a <HAL_DMAEx_MultiBufferStart_IT+0x262>
240059ea:	68fb      	ldr	r3, [r7, #12]
240059ec:	681b      	ldr	r3, [r3, #0]
240059ee:	4a30      	ldr	r2, [pc, #192]	; (24005ab0 <HAL_DMAEx_MultiBufferStart_IT+0x288>)
240059f0:	4293      	cmp	r3, r2
240059f2:	d04a      	beq.n	24005a8a <HAL_DMAEx_MultiBufferStart_IT+0x262>
240059f4:	68fb      	ldr	r3, [r7, #12]
240059f6:	681b      	ldr	r3, [r3, #0]
240059f8:	4a2e      	ldr	r2, [pc, #184]	; (24005ab4 <HAL_DMAEx_MultiBufferStart_IT+0x28c>)
240059fa:	4293      	cmp	r3, r2
240059fc:	d045      	beq.n	24005a8a <HAL_DMAEx_MultiBufferStart_IT+0x262>
240059fe:	68fb      	ldr	r3, [r7, #12]
24005a00:	681b      	ldr	r3, [r3, #0]
24005a02:	4a2d      	ldr	r2, [pc, #180]	; (24005ab8 <HAL_DMAEx_MultiBufferStart_IT+0x290>)
24005a04:	4293      	cmp	r3, r2
24005a06:	d040      	beq.n	24005a8a <HAL_DMAEx_MultiBufferStart_IT+0x262>
24005a08:	68fb      	ldr	r3, [r7, #12]
24005a0a:	681b      	ldr	r3, [r3, #0]
24005a0c:	4a2b      	ldr	r2, [pc, #172]	; (24005abc <HAL_DMAEx_MultiBufferStart_IT+0x294>)
24005a0e:	4293      	cmp	r3, r2
24005a10:	d03b      	beq.n	24005a8a <HAL_DMAEx_MultiBufferStart_IT+0x262>
24005a12:	68fb      	ldr	r3, [r7, #12]
24005a14:	681b      	ldr	r3, [r3, #0]
24005a16:	4a2a      	ldr	r2, [pc, #168]	; (24005ac0 <HAL_DMAEx_MultiBufferStart_IT+0x298>)
24005a18:	4293      	cmp	r3, r2
24005a1a:	d036      	beq.n	24005a8a <HAL_DMAEx_MultiBufferStart_IT+0x262>
24005a1c:	68fb      	ldr	r3, [r7, #12]
24005a1e:	681b      	ldr	r3, [r3, #0]
24005a20:	4a28      	ldr	r2, [pc, #160]	; (24005ac4 <HAL_DMAEx_MultiBufferStart_IT+0x29c>)
24005a22:	4293      	cmp	r3, r2
24005a24:	d031      	beq.n	24005a8a <HAL_DMAEx_MultiBufferStart_IT+0x262>
24005a26:	68fb      	ldr	r3, [r7, #12]
24005a28:	681b      	ldr	r3, [r3, #0]
24005a2a:	4a27      	ldr	r2, [pc, #156]	; (24005ac8 <HAL_DMAEx_MultiBufferStart_IT+0x2a0>)
24005a2c:	4293      	cmp	r3, r2
24005a2e:	d02c      	beq.n	24005a8a <HAL_DMAEx_MultiBufferStart_IT+0x262>
24005a30:	68fb      	ldr	r3, [r7, #12]
24005a32:	681b      	ldr	r3, [r3, #0]
24005a34:	4a25      	ldr	r2, [pc, #148]	; (24005acc <HAL_DMAEx_MultiBufferStart_IT+0x2a4>)
24005a36:	4293      	cmp	r3, r2
24005a38:	d027      	beq.n	24005a8a <HAL_DMAEx_MultiBufferStart_IT+0x262>
24005a3a:	68fb      	ldr	r3, [r7, #12]
24005a3c:	681b      	ldr	r3, [r3, #0]
24005a3e:	4a24      	ldr	r2, [pc, #144]	; (24005ad0 <HAL_DMAEx_MultiBufferStart_IT+0x2a8>)
24005a40:	4293      	cmp	r3, r2
24005a42:	d022      	beq.n	24005a8a <HAL_DMAEx_MultiBufferStart_IT+0x262>
24005a44:	68fb      	ldr	r3, [r7, #12]
24005a46:	681b      	ldr	r3, [r3, #0]
24005a48:	4a22      	ldr	r2, [pc, #136]	; (24005ad4 <HAL_DMAEx_MultiBufferStart_IT+0x2ac>)
24005a4a:	4293      	cmp	r3, r2
24005a4c:	d01d      	beq.n	24005a8a <HAL_DMAEx_MultiBufferStart_IT+0x262>
24005a4e:	68fb      	ldr	r3, [r7, #12]
24005a50:	681b      	ldr	r3, [r3, #0]
24005a52:	4a21      	ldr	r2, [pc, #132]	; (24005ad8 <HAL_DMAEx_MultiBufferStart_IT+0x2b0>)
24005a54:	4293      	cmp	r3, r2
24005a56:	d018      	beq.n	24005a8a <HAL_DMAEx_MultiBufferStart_IT+0x262>
24005a58:	68fb      	ldr	r3, [r7, #12]
24005a5a:	681b      	ldr	r3, [r3, #0]
24005a5c:	4a1f      	ldr	r2, [pc, #124]	; (24005adc <HAL_DMAEx_MultiBufferStart_IT+0x2b4>)
24005a5e:	4293      	cmp	r3, r2
24005a60:	d013      	beq.n	24005a8a <HAL_DMAEx_MultiBufferStart_IT+0x262>
24005a62:	68fb      	ldr	r3, [r7, #12]
24005a64:	681b      	ldr	r3, [r3, #0]
24005a66:	4a1e      	ldr	r2, [pc, #120]	; (24005ae0 <HAL_DMAEx_MultiBufferStart_IT+0x2b8>)
24005a68:	4293      	cmp	r3, r2
24005a6a:	d00e      	beq.n	24005a8a <HAL_DMAEx_MultiBufferStart_IT+0x262>
24005a6c:	68fb      	ldr	r3, [r7, #12]
24005a6e:	681b      	ldr	r3, [r3, #0]
24005a70:	4a1c      	ldr	r2, [pc, #112]	; (24005ae4 <HAL_DMAEx_MultiBufferStart_IT+0x2bc>)
24005a72:	4293      	cmp	r3, r2
24005a74:	d009      	beq.n	24005a8a <HAL_DMAEx_MultiBufferStart_IT+0x262>
24005a76:	68fb      	ldr	r3, [r7, #12]
24005a78:	681b      	ldr	r3, [r3, #0]
24005a7a:	4a1b      	ldr	r2, [pc, #108]	; (24005ae8 <HAL_DMAEx_MultiBufferStart_IT+0x2c0>)
24005a7c:	4293      	cmp	r3, r2
24005a7e:	d004      	beq.n	24005a8a <HAL_DMAEx_MultiBufferStart_IT+0x262>
24005a80:	68fb      	ldr	r3, [r7, #12]
24005a82:	681b      	ldr	r3, [r3, #0]
24005a84:	4a19      	ldr	r2, [pc, #100]	; (24005aec <HAL_DMAEx_MultiBufferStart_IT+0x2c4>)
24005a86:	4293      	cmp	r3, r2
24005a88:	d132      	bne.n	24005af0 <HAL_DMAEx_MultiBufferStart_IT+0x2c8>
24005a8a:	2301      	movs	r3, #1
24005a8c:	e031      	b.n	24005af2 <HAL_DMAEx_MultiBufferStart_IT+0x2ca>
24005a8e:	bf00      	nop
24005a90:	40020010 	.word	0x40020010
24005a94:	40020028 	.word	0x40020028
24005a98:	40020040 	.word	0x40020040
24005a9c:	40020058 	.word	0x40020058
24005aa0:	40020070 	.word	0x40020070
24005aa4:	40020088 	.word	0x40020088
24005aa8:	400200a0 	.word	0x400200a0
24005aac:	400200b8 	.word	0x400200b8
24005ab0:	40020410 	.word	0x40020410
24005ab4:	40020428 	.word	0x40020428
24005ab8:	40020440 	.word	0x40020440
24005abc:	40020458 	.word	0x40020458
24005ac0:	40020470 	.word	0x40020470
24005ac4:	40020488 	.word	0x40020488
24005ac8:	400204a0 	.word	0x400204a0
24005acc:	400204b8 	.word	0x400204b8
24005ad0:	58025408 	.word	0x58025408
24005ad4:	5802541c 	.word	0x5802541c
24005ad8:	58025430 	.word	0x58025430
24005adc:	58025444 	.word	0x58025444
24005ae0:	58025458 	.word	0x58025458
24005ae4:	5802546c 	.word	0x5802546c
24005ae8:	58025480 	.word	0x58025480
24005aec:	58025494 	.word	0x58025494
24005af0:	2300      	movs	r3, #0
24005af2:	2b00      	cmp	r3, #0
24005af4:	d00d      	beq.n	24005b12 <HAL_DMAEx_MultiBufferStart_IT+0x2ea>
    {
      /* Clear the DMAMUX synchro overrun flag */
      hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
24005af6:	68fb      	ldr	r3, [r7, #12]
24005af8:	6e5b      	ldr	r3, [r3, #100]	; 0x64
24005afa:	68fa      	ldr	r2, [r7, #12]
24005afc:	6e92      	ldr	r2, [r2, #104]	; 0x68
24005afe:	605a      	str	r2, [r3, #4]

      if(hdma->DMAmuxRequestGen != 0U)
24005b00:	68fb      	ldr	r3, [r7, #12]
24005b02:	6edb      	ldr	r3, [r3, #108]	; 0x6c
24005b04:	2b00      	cmp	r3, #0
24005b06:	d004      	beq.n	24005b12 <HAL_DMAEx_MultiBufferStart_IT+0x2ea>
      {
        /* Clear the DMAMUX request generator overrun flag */
        hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
24005b08:	68fb      	ldr	r3, [r7, #12]
24005b0a:	6f1b      	ldr	r3, [r3, #112]	; 0x70
24005b0c:	68fa      	ldr	r2, [r7, #12]
24005b0e:	6f52      	ldr	r2, [r2, #116]	; 0x74
24005b10:	605a      	str	r2, [r3, #4]
      }
    }

    if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
24005b12:	68fb      	ldr	r3, [r7, #12]
24005b14:	681b      	ldr	r3, [r3, #0]
24005b16:	4a85      	ldr	r2, [pc, #532]	; (24005d2c <HAL_DMAEx_MultiBufferStart_IT+0x504>)
24005b18:	4293      	cmp	r3, r2
24005b1a:	d04a      	beq.n	24005bb2 <HAL_DMAEx_MultiBufferStart_IT+0x38a>
24005b1c:	68fb      	ldr	r3, [r7, #12]
24005b1e:	681b      	ldr	r3, [r3, #0]
24005b20:	4a83      	ldr	r2, [pc, #524]	; (24005d30 <HAL_DMAEx_MultiBufferStart_IT+0x508>)
24005b22:	4293      	cmp	r3, r2
24005b24:	d045      	beq.n	24005bb2 <HAL_DMAEx_MultiBufferStart_IT+0x38a>
24005b26:	68fb      	ldr	r3, [r7, #12]
24005b28:	681b      	ldr	r3, [r3, #0]
24005b2a:	4a82      	ldr	r2, [pc, #520]	; (24005d34 <HAL_DMAEx_MultiBufferStart_IT+0x50c>)
24005b2c:	4293      	cmp	r3, r2
24005b2e:	d040      	beq.n	24005bb2 <HAL_DMAEx_MultiBufferStart_IT+0x38a>
24005b30:	68fb      	ldr	r3, [r7, #12]
24005b32:	681b      	ldr	r3, [r3, #0]
24005b34:	4a80      	ldr	r2, [pc, #512]	; (24005d38 <HAL_DMAEx_MultiBufferStart_IT+0x510>)
24005b36:	4293      	cmp	r3, r2
24005b38:	d03b      	beq.n	24005bb2 <HAL_DMAEx_MultiBufferStart_IT+0x38a>
24005b3a:	68fb      	ldr	r3, [r7, #12]
24005b3c:	681b      	ldr	r3, [r3, #0]
24005b3e:	4a7f      	ldr	r2, [pc, #508]	; (24005d3c <HAL_DMAEx_MultiBufferStart_IT+0x514>)
24005b40:	4293      	cmp	r3, r2
24005b42:	d036      	beq.n	24005bb2 <HAL_DMAEx_MultiBufferStart_IT+0x38a>
24005b44:	68fb      	ldr	r3, [r7, #12]
24005b46:	681b      	ldr	r3, [r3, #0]
24005b48:	4a7d      	ldr	r2, [pc, #500]	; (24005d40 <HAL_DMAEx_MultiBufferStart_IT+0x518>)
24005b4a:	4293      	cmp	r3, r2
24005b4c:	d031      	beq.n	24005bb2 <HAL_DMAEx_MultiBufferStart_IT+0x38a>
24005b4e:	68fb      	ldr	r3, [r7, #12]
24005b50:	681b      	ldr	r3, [r3, #0]
24005b52:	4a7c      	ldr	r2, [pc, #496]	; (24005d44 <HAL_DMAEx_MultiBufferStart_IT+0x51c>)
24005b54:	4293      	cmp	r3, r2
24005b56:	d02c      	beq.n	24005bb2 <HAL_DMAEx_MultiBufferStart_IT+0x38a>
24005b58:	68fb      	ldr	r3, [r7, #12]
24005b5a:	681b      	ldr	r3, [r3, #0]
24005b5c:	4a7a      	ldr	r2, [pc, #488]	; (24005d48 <HAL_DMAEx_MultiBufferStart_IT+0x520>)
24005b5e:	4293      	cmp	r3, r2
24005b60:	d027      	beq.n	24005bb2 <HAL_DMAEx_MultiBufferStart_IT+0x38a>
24005b62:	68fb      	ldr	r3, [r7, #12]
24005b64:	681b      	ldr	r3, [r3, #0]
24005b66:	4a79      	ldr	r2, [pc, #484]	; (24005d4c <HAL_DMAEx_MultiBufferStart_IT+0x524>)
24005b68:	4293      	cmp	r3, r2
24005b6a:	d022      	beq.n	24005bb2 <HAL_DMAEx_MultiBufferStart_IT+0x38a>
24005b6c:	68fb      	ldr	r3, [r7, #12]
24005b6e:	681b      	ldr	r3, [r3, #0]
24005b70:	4a77      	ldr	r2, [pc, #476]	; (24005d50 <HAL_DMAEx_MultiBufferStart_IT+0x528>)
24005b72:	4293      	cmp	r3, r2
24005b74:	d01d      	beq.n	24005bb2 <HAL_DMAEx_MultiBufferStart_IT+0x38a>
24005b76:	68fb      	ldr	r3, [r7, #12]
24005b78:	681b      	ldr	r3, [r3, #0]
24005b7a:	4a76      	ldr	r2, [pc, #472]	; (24005d54 <HAL_DMAEx_MultiBufferStart_IT+0x52c>)
24005b7c:	4293      	cmp	r3, r2
24005b7e:	d018      	beq.n	24005bb2 <HAL_DMAEx_MultiBufferStart_IT+0x38a>
24005b80:	68fb      	ldr	r3, [r7, #12]
24005b82:	681b      	ldr	r3, [r3, #0]
24005b84:	4a74      	ldr	r2, [pc, #464]	; (24005d58 <HAL_DMAEx_MultiBufferStart_IT+0x530>)
24005b86:	4293      	cmp	r3, r2
24005b88:	d013      	beq.n	24005bb2 <HAL_DMAEx_MultiBufferStart_IT+0x38a>
24005b8a:	68fb      	ldr	r3, [r7, #12]
24005b8c:	681b      	ldr	r3, [r3, #0]
24005b8e:	4a73      	ldr	r2, [pc, #460]	; (24005d5c <HAL_DMAEx_MultiBufferStart_IT+0x534>)
24005b90:	4293      	cmp	r3, r2
24005b92:	d00e      	beq.n	24005bb2 <HAL_DMAEx_MultiBufferStart_IT+0x38a>
24005b94:	68fb      	ldr	r3, [r7, #12]
24005b96:	681b      	ldr	r3, [r3, #0]
24005b98:	4a71      	ldr	r2, [pc, #452]	; (24005d60 <HAL_DMAEx_MultiBufferStart_IT+0x538>)
24005b9a:	4293      	cmp	r3, r2
24005b9c:	d009      	beq.n	24005bb2 <HAL_DMAEx_MultiBufferStart_IT+0x38a>
24005b9e:	68fb      	ldr	r3, [r7, #12]
24005ba0:	681b      	ldr	r3, [r3, #0]
24005ba2:	4a70      	ldr	r2, [pc, #448]	; (24005d64 <HAL_DMAEx_MultiBufferStart_IT+0x53c>)
24005ba4:	4293      	cmp	r3, r2
24005ba6:	d004      	beq.n	24005bb2 <HAL_DMAEx_MultiBufferStart_IT+0x38a>
24005ba8:	68fb      	ldr	r3, [r7, #12]
24005baa:	681b      	ldr	r3, [r3, #0]
24005bac:	4a6e      	ldr	r2, [pc, #440]	; (24005d68 <HAL_DMAEx_MultiBufferStart_IT+0x540>)
24005bae:	4293      	cmp	r3, r2
24005bb0:	d101      	bne.n	24005bb6 <HAL_DMAEx_MultiBufferStart_IT+0x38e>
24005bb2:	2301      	movs	r3, #1
24005bb4:	e000      	b.n	24005bb8 <HAL_DMAEx_MultiBufferStart_IT+0x390>
24005bb6:	2300      	movs	r3, #0
24005bb8:	2b00      	cmp	r3, #0
24005bba:	d022      	beq.n	24005c02 <HAL_DMAEx_MultiBufferStart_IT+0x3da>
    {
      /* Enable Common interrupts*/
      MODIFY_REG(((DMA_Stream_TypeDef   *)hdma->Instance)->CR, (DMA_IT_TC | DMA_IT_TE | DMA_IT_DME | DMA_IT_HT), (DMA_IT_TC | DMA_IT_TE | DMA_IT_DME));
24005bbc:	68fb      	ldr	r3, [r7, #12]
24005bbe:	681b      	ldr	r3, [r3, #0]
24005bc0:	681b      	ldr	r3, [r3, #0]
24005bc2:	f023 021e 	bic.w	r2, r3, #30
24005bc6:	68fb      	ldr	r3, [r7, #12]
24005bc8:	681b      	ldr	r3, [r3, #0]
24005bca:	f042 0216 	orr.w	r2, r2, #22
24005bce:	601a      	str	r2, [r3, #0]
      ((DMA_Stream_TypeDef   *)hdma->Instance)->FCR |= DMA_IT_FE;
24005bd0:	68fb      	ldr	r3, [r7, #12]
24005bd2:	681b      	ldr	r3, [r3, #0]
24005bd4:	695a      	ldr	r2, [r3, #20]
24005bd6:	68fb      	ldr	r3, [r7, #12]
24005bd8:	681b      	ldr	r3, [r3, #0]
24005bda:	f042 0280 	orr.w	r2, r2, #128	; 0x80
24005bde:	615a      	str	r2, [r3, #20]

      if((hdma->XferHalfCpltCallback != NULL) || (hdma->XferM1HalfCpltCallback != NULL))
24005be0:	68fb      	ldr	r3, [r7, #12]
24005be2:	6c1b      	ldr	r3, [r3, #64]	; 0x40
24005be4:	2b00      	cmp	r3, #0
24005be6:	d103      	bne.n	24005bf0 <HAL_DMAEx_MultiBufferStart_IT+0x3c8>
24005be8:	68fb      	ldr	r3, [r7, #12]
24005bea:	6c9b      	ldr	r3, [r3, #72]	; 0x48
24005bec:	2b00      	cmp	r3, #0
24005bee:	d022      	beq.n	24005c36 <HAL_DMAEx_MultiBufferStart_IT+0x40e>
      {
        /*Enable Half Transfer IT if corresponding Callback is set*/
        ((DMA_Stream_TypeDef   *)hdma->Instance)->CR  |= DMA_IT_HT;
24005bf0:	68fb      	ldr	r3, [r7, #12]
24005bf2:	681b      	ldr	r3, [r3, #0]
24005bf4:	681a      	ldr	r2, [r3, #0]
24005bf6:	68fb      	ldr	r3, [r7, #12]
24005bf8:	681b      	ldr	r3, [r3, #0]
24005bfa:	f042 0208 	orr.w	r2, r2, #8
24005bfe:	601a      	str	r2, [r3, #0]
24005c00:	e019      	b.n	24005c36 <HAL_DMAEx_MultiBufferStart_IT+0x40e>
      }
    }
    else /* BDMA instance(s) */
    {
      /* Enable Common interrupts*/
      MODIFY_REG(((BDMA_Channel_TypeDef   *)hdma->Instance)->CCR, (BDMA_CCR_TCIE | BDMA_CCR_HTIE | BDMA_CCR_TEIE), (BDMA_CCR_TCIE | BDMA_CCR_TEIE));
24005c02:	68fb      	ldr	r3, [r7, #12]
24005c04:	681b      	ldr	r3, [r3, #0]
24005c06:	681b      	ldr	r3, [r3, #0]
24005c08:	f023 020e 	bic.w	r2, r3, #14
24005c0c:	68fb      	ldr	r3, [r7, #12]
24005c0e:	681b      	ldr	r3, [r3, #0]
24005c10:	f042 020a 	orr.w	r2, r2, #10
24005c14:	601a      	str	r2, [r3, #0]

      if((hdma->XferHalfCpltCallback != NULL) || (hdma->XferM1HalfCpltCallback != NULL))
24005c16:	68fb      	ldr	r3, [r7, #12]
24005c18:	6c1b      	ldr	r3, [r3, #64]	; 0x40
24005c1a:	2b00      	cmp	r3, #0
24005c1c:	d103      	bne.n	24005c26 <HAL_DMAEx_MultiBufferStart_IT+0x3fe>
24005c1e:	68fb      	ldr	r3, [r7, #12]
24005c20:	6c9b      	ldr	r3, [r3, #72]	; 0x48
24005c22:	2b00      	cmp	r3, #0
24005c24:	d007      	beq.n	24005c36 <HAL_DMAEx_MultiBufferStart_IT+0x40e>
      {
        /*Enable Half Transfer IT if corresponding Callback is set*/
        ((BDMA_Channel_TypeDef   *)hdma->Instance)->CCR  |= BDMA_CCR_HTIE;
24005c26:	68fb      	ldr	r3, [r7, #12]
24005c28:	681b      	ldr	r3, [r3, #0]
24005c2a:	681a      	ldr	r2, [r3, #0]
24005c2c:	68fb      	ldr	r3, [r7, #12]
24005c2e:	681b      	ldr	r3, [r3, #0]
24005c30:	f042 0204 	orr.w	r2, r2, #4
24005c34:	601a      	str	r2, [r3, #0]
      }
    }

    if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
24005c36:	68fb      	ldr	r3, [r7, #12]
24005c38:	681b      	ldr	r3, [r3, #0]
24005c3a:	4a3c      	ldr	r2, [pc, #240]	; (24005d2c <HAL_DMAEx_MultiBufferStart_IT+0x504>)
24005c3c:	4293      	cmp	r3, r2
24005c3e:	d072      	beq.n	24005d26 <HAL_DMAEx_MultiBufferStart_IT+0x4fe>
24005c40:	68fb      	ldr	r3, [r7, #12]
24005c42:	681b      	ldr	r3, [r3, #0]
24005c44:	4a3a      	ldr	r2, [pc, #232]	; (24005d30 <HAL_DMAEx_MultiBufferStart_IT+0x508>)
24005c46:	4293      	cmp	r3, r2
24005c48:	d06d      	beq.n	24005d26 <HAL_DMAEx_MultiBufferStart_IT+0x4fe>
24005c4a:	68fb      	ldr	r3, [r7, #12]
24005c4c:	681b      	ldr	r3, [r3, #0]
24005c4e:	4a39      	ldr	r2, [pc, #228]	; (24005d34 <HAL_DMAEx_MultiBufferStart_IT+0x50c>)
24005c50:	4293      	cmp	r3, r2
24005c52:	d068      	beq.n	24005d26 <HAL_DMAEx_MultiBufferStart_IT+0x4fe>
24005c54:	68fb      	ldr	r3, [r7, #12]
24005c56:	681b      	ldr	r3, [r3, #0]
24005c58:	4a37      	ldr	r2, [pc, #220]	; (24005d38 <HAL_DMAEx_MultiBufferStart_IT+0x510>)
24005c5a:	4293      	cmp	r3, r2
24005c5c:	d063      	beq.n	24005d26 <HAL_DMAEx_MultiBufferStart_IT+0x4fe>
24005c5e:	68fb      	ldr	r3, [r7, #12]
24005c60:	681b      	ldr	r3, [r3, #0]
24005c62:	4a36      	ldr	r2, [pc, #216]	; (24005d3c <HAL_DMAEx_MultiBufferStart_IT+0x514>)
24005c64:	4293      	cmp	r3, r2
24005c66:	d05e      	beq.n	24005d26 <HAL_DMAEx_MultiBufferStart_IT+0x4fe>
24005c68:	68fb      	ldr	r3, [r7, #12]
24005c6a:	681b      	ldr	r3, [r3, #0]
24005c6c:	4a34      	ldr	r2, [pc, #208]	; (24005d40 <HAL_DMAEx_MultiBufferStart_IT+0x518>)
24005c6e:	4293      	cmp	r3, r2
24005c70:	d059      	beq.n	24005d26 <HAL_DMAEx_MultiBufferStart_IT+0x4fe>
24005c72:	68fb      	ldr	r3, [r7, #12]
24005c74:	681b      	ldr	r3, [r3, #0]
24005c76:	4a33      	ldr	r2, [pc, #204]	; (24005d44 <HAL_DMAEx_MultiBufferStart_IT+0x51c>)
24005c78:	4293      	cmp	r3, r2
24005c7a:	d054      	beq.n	24005d26 <HAL_DMAEx_MultiBufferStart_IT+0x4fe>
24005c7c:	68fb      	ldr	r3, [r7, #12]
24005c7e:	681b      	ldr	r3, [r3, #0]
24005c80:	4a31      	ldr	r2, [pc, #196]	; (24005d48 <HAL_DMAEx_MultiBufferStart_IT+0x520>)
24005c82:	4293      	cmp	r3, r2
24005c84:	d04f      	beq.n	24005d26 <HAL_DMAEx_MultiBufferStart_IT+0x4fe>
24005c86:	68fb      	ldr	r3, [r7, #12]
24005c88:	681b      	ldr	r3, [r3, #0]
24005c8a:	4a30      	ldr	r2, [pc, #192]	; (24005d4c <HAL_DMAEx_MultiBufferStart_IT+0x524>)
24005c8c:	4293      	cmp	r3, r2
24005c8e:	d04a      	beq.n	24005d26 <HAL_DMAEx_MultiBufferStart_IT+0x4fe>
24005c90:	68fb      	ldr	r3, [r7, #12]
24005c92:	681b      	ldr	r3, [r3, #0]
24005c94:	4a2e      	ldr	r2, [pc, #184]	; (24005d50 <HAL_DMAEx_MultiBufferStart_IT+0x528>)
24005c96:	4293      	cmp	r3, r2
24005c98:	d045      	beq.n	24005d26 <HAL_DMAEx_MultiBufferStart_IT+0x4fe>
24005c9a:	68fb      	ldr	r3, [r7, #12]
24005c9c:	681b      	ldr	r3, [r3, #0]
24005c9e:	4a2d      	ldr	r2, [pc, #180]	; (24005d54 <HAL_DMAEx_MultiBufferStart_IT+0x52c>)
24005ca0:	4293      	cmp	r3, r2
24005ca2:	d040      	beq.n	24005d26 <HAL_DMAEx_MultiBufferStart_IT+0x4fe>
24005ca4:	68fb      	ldr	r3, [r7, #12]
24005ca6:	681b      	ldr	r3, [r3, #0]
24005ca8:	4a2b      	ldr	r2, [pc, #172]	; (24005d58 <HAL_DMAEx_MultiBufferStart_IT+0x530>)
24005caa:	4293      	cmp	r3, r2
24005cac:	d03b      	beq.n	24005d26 <HAL_DMAEx_MultiBufferStart_IT+0x4fe>
24005cae:	68fb      	ldr	r3, [r7, #12]
24005cb0:	681b      	ldr	r3, [r3, #0]
24005cb2:	4a2a      	ldr	r2, [pc, #168]	; (24005d5c <HAL_DMAEx_MultiBufferStart_IT+0x534>)
24005cb4:	4293      	cmp	r3, r2
24005cb6:	d036      	beq.n	24005d26 <HAL_DMAEx_MultiBufferStart_IT+0x4fe>
24005cb8:	68fb      	ldr	r3, [r7, #12]
24005cba:	681b      	ldr	r3, [r3, #0]
24005cbc:	4a28      	ldr	r2, [pc, #160]	; (24005d60 <HAL_DMAEx_MultiBufferStart_IT+0x538>)
24005cbe:	4293      	cmp	r3, r2
24005cc0:	d031      	beq.n	24005d26 <HAL_DMAEx_MultiBufferStart_IT+0x4fe>
24005cc2:	68fb      	ldr	r3, [r7, #12]
24005cc4:	681b      	ldr	r3, [r3, #0]
24005cc6:	4a27      	ldr	r2, [pc, #156]	; (24005d64 <HAL_DMAEx_MultiBufferStart_IT+0x53c>)
24005cc8:	4293      	cmp	r3, r2
24005cca:	d02c      	beq.n	24005d26 <HAL_DMAEx_MultiBufferStart_IT+0x4fe>
24005ccc:	68fb      	ldr	r3, [r7, #12]
24005cce:	681b      	ldr	r3, [r3, #0]
24005cd0:	4a25      	ldr	r2, [pc, #148]	; (24005d68 <HAL_DMAEx_MultiBufferStart_IT+0x540>)
24005cd2:	4293      	cmp	r3, r2
24005cd4:	d027      	beq.n	24005d26 <HAL_DMAEx_MultiBufferStart_IT+0x4fe>
24005cd6:	68fb      	ldr	r3, [r7, #12]
24005cd8:	681b      	ldr	r3, [r3, #0]
24005cda:	4a24      	ldr	r2, [pc, #144]	; (24005d6c <HAL_DMAEx_MultiBufferStart_IT+0x544>)
24005cdc:	4293      	cmp	r3, r2
24005cde:	d022      	beq.n	24005d26 <HAL_DMAEx_MultiBufferStart_IT+0x4fe>
24005ce0:	68fb      	ldr	r3, [r7, #12]
24005ce2:	681b      	ldr	r3, [r3, #0]
24005ce4:	4a22      	ldr	r2, [pc, #136]	; (24005d70 <HAL_DMAEx_MultiBufferStart_IT+0x548>)
24005ce6:	4293      	cmp	r3, r2
24005ce8:	d01d      	beq.n	24005d26 <HAL_DMAEx_MultiBufferStart_IT+0x4fe>
24005cea:	68fb      	ldr	r3, [r7, #12]
24005cec:	681b      	ldr	r3, [r3, #0]
24005cee:	4a21      	ldr	r2, [pc, #132]	; (24005d74 <HAL_DMAEx_MultiBufferStart_IT+0x54c>)
24005cf0:	4293      	cmp	r3, r2
24005cf2:	d018      	beq.n	24005d26 <HAL_DMAEx_MultiBufferStart_IT+0x4fe>
24005cf4:	68fb      	ldr	r3, [r7, #12]
24005cf6:	681b      	ldr	r3, [r3, #0]
24005cf8:	4a1f      	ldr	r2, [pc, #124]	; (24005d78 <HAL_DMAEx_MultiBufferStart_IT+0x550>)
24005cfa:	4293      	cmp	r3, r2
24005cfc:	d013      	beq.n	24005d26 <HAL_DMAEx_MultiBufferStart_IT+0x4fe>
24005cfe:	68fb      	ldr	r3, [r7, #12]
24005d00:	681b      	ldr	r3, [r3, #0]
24005d02:	4a1e      	ldr	r2, [pc, #120]	; (24005d7c <HAL_DMAEx_MultiBufferStart_IT+0x554>)
24005d04:	4293      	cmp	r3, r2
24005d06:	d00e      	beq.n	24005d26 <HAL_DMAEx_MultiBufferStart_IT+0x4fe>
24005d08:	68fb      	ldr	r3, [r7, #12]
24005d0a:	681b      	ldr	r3, [r3, #0]
24005d0c:	4a1c      	ldr	r2, [pc, #112]	; (24005d80 <HAL_DMAEx_MultiBufferStart_IT+0x558>)
24005d0e:	4293      	cmp	r3, r2
24005d10:	d009      	beq.n	24005d26 <HAL_DMAEx_MultiBufferStart_IT+0x4fe>
24005d12:	68fb      	ldr	r3, [r7, #12]
24005d14:	681b      	ldr	r3, [r3, #0]
24005d16:	4a1b      	ldr	r2, [pc, #108]	; (24005d84 <HAL_DMAEx_MultiBufferStart_IT+0x55c>)
24005d18:	4293      	cmp	r3, r2
24005d1a:	d004      	beq.n	24005d26 <HAL_DMAEx_MultiBufferStart_IT+0x4fe>
24005d1c:	68fb      	ldr	r3, [r7, #12]
24005d1e:	681b      	ldr	r3, [r3, #0]
24005d20:	4a19      	ldr	r2, [pc, #100]	; (24005d88 <HAL_DMAEx_MultiBufferStart_IT+0x560>)
24005d22:	4293      	cmp	r3, r2
24005d24:	d132      	bne.n	24005d8c <HAL_DMAEx_MultiBufferStart_IT+0x564>
24005d26:	2301      	movs	r3, #1
24005d28:	e031      	b.n	24005d8e <HAL_DMAEx_MultiBufferStart_IT+0x566>
24005d2a:	bf00      	nop
24005d2c:	40020010 	.word	0x40020010
24005d30:	40020028 	.word	0x40020028
24005d34:	40020040 	.word	0x40020040
24005d38:	40020058 	.word	0x40020058
24005d3c:	40020070 	.word	0x40020070
24005d40:	40020088 	.word	0x40020088
24005d44:	400200a0 	.word	0x400200a0
24005d48:	400200b8 	.word	0x400200b8
24005d4c:	40020410 	.word	0x40020410
24005d50:	40020428 	.word	0x40020428
24005d54:	40020440 	.word	0x40020440
24005d58:	40020458 	.word	0x40020458
24005d5c:	40020470 	.word	0x40020470
24005d60:	40020488 	.word	0x40020488
24005d64:	400204a0 	.word	0x400204a0
24005d68:	400204b8 	.word	0x400204b8
24005d6c:	58025408 	.word	0x58025408
24005d70:	5802541c 	.word	0x5802541c
24005d74:	58025430 	.word	0x58025430
24005d78:	58025444 	.word	0x58025444
24005d7c:	58025458 	.word	0x58025458
24005d80:	5802546c 	.word	0x5802546c
24005d84:	58025480 	.word	0x58025480
24005d88:	58025494 	.word	0x58025494
24005d8c:	2300      	movs	r3, #0
24005d8e:	2b00      	cmp	r3, #0
24005d90:	d01a      	beq.n	24005dc8 <HAL_DMAEx_MultiBufferStart_IT+0x5a0>
    {
      /* Check if DMAMUX Synchronization is enabled*/
      if((hdma->DMAmuxChannel->CCR & DMAMUX_CxCR_SE) != 0U)
24005d92:	68fb      	ldr	r3, [r7, #12]
24005d94:	6e1b      	ldr	r3, [r3, #96]	; 0x60
24005d96:	681b      	ldr	r3, [r3, #0]
24005d98:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
24005d9c:	2b00      	cmp	r3, #0
24005d9e:	d007      	beq.n	24005db0 <HAL_DMAEx_MultiBufferStart_IT+0x588>
      {
        /* Enable DMAMUX sync overrun IT*/
        hdma->DMAmuxChannel->CCR |= DMAMUX_CxCR_SOIE;
24005da0:	68fb      	ldr	r3, [r7, #12]
24005da2:	6e1b      	ldr	r3, [r3, #96]	; 0x60
24005da4:	681a      	ldr	r2, [r3, #0]
24005da6:	68fb      	ldr	r3, [r7, #12]
24005da8:	6e1b      	ldr	r3, [r3, #96]	; 0x60
24005daa:	f442 7280 	orr.w	r2, r2, #256	; 0x100
24005dae:	601a      	str	r2, [r3, #0]
      }

      if(hdma->DMAmuxRequestGen != 0U)
24005db0:	68fb      	ldr	r3, [r7, #12]
24005db2:	6edb      	ldr	r3, [r3, #108]	; 0x6c
24005db4:	2b00      	cmp	r3, #0
24005db6:	d007      	beq.n	24005dc8 <HAL_DMAEx_MultiBufferStart_IT+0x5a0>
      {
        /* if using DMAMUX request generator, enable the DMAMUX request generator overrun IT*/
        /* enable the request gen overrun IT*/
        hdma->DMAmuxRequestGen->RGCR |= DMAMUX_RGxCR_OIE;
24005db8:	68fb      	ldr	r3, [r7, #12]
24005dba:	6edb      	ldr	r3, [r3, #108]	; 0x6c
24005dbc:	681a      	ldr	r2, [r3, #0]
24005dbe:	68fb      	ldr	r3, [r7, #12]
24005dc0:	6edb      	ldr	r3, [r3, #108]	; 0x6c
24005dc2:	f442 7280 	orr.w	r2, r2, #256	; 0x100
24005dc6:	601a      	str	r2, [r3, #0]
      }
    }

    /* Enable the peripheral */
    __HAL_DMA_ENABLE(hdma);
24005dc8:	68fb      	ldr	r3, [r7, #12]
24005dca:	681b      	ldr	r3, [r3, #0]
24005dcc:	4a35      	ldr	r2, [pc, #212]	; (24005ea4 <HAL_DMAEx_MultiBufferStart_IT+0x67c>)
24005dce:	4293      	cmp	r3, r2
24005dd0:	d04a      	beq.n	24005e68 <HAL_DMAEx_MultiBufferStart_IT+0x640>
24005dd2:	68fb      	ldr	r3, [r7, #12]
24005dd4:	681b      	ldr	r3, [r3, #0]
24005dd6:	4a34      	ldr	r2, [pc, #208]	; (24005ea8 <HAL_DMAEx_MultiBufferStart_IT+0x680>)
24005dd8:	4293      	cmp	r3, r2
24005dda:	d045      	beq.n	24005e68 <HAL_DMAEx_MultiBufferStart_IT+0x640>
24005ddc:	68fb      	ldr	r3, [r7, #12]
24005dde:	681b      	ldr	r3, [r3, #0]
24005de0:	4a32      	ldr	r2, [pc, #200]	; (24005eac <HAL_DMAEx_MultiBufferStart_IT+0x684>)
24005de2:	4293      	cmp	r3, r2
24005de4:	d040      	beq.n	24005e68 <HAL_DMAEx_MultiBufferStart_IT+0x640>
24005de6:	68fb      	ldr	r3, [r7, #12]
24005de8:	681b      	ldr	r3, [r3, #0]
24005dea:	4a31      	ldr	r2, [pc, #196]	; (24005eb0 <HAL_DMAEx_MultiBufferStart_IT+0x688>)
24005dec:	4293      	cmp	r3, r2
24005dee:	d03b      	beq.n	24005e68 <HAL_DMAEx_MultiBufferStart_IT+0x640>
24005df0:	68fb      	ldr	r3, [r7, #12]
24005df2:	681b      	ldr	r3, [r3, #0]
24005df4:	4a2f      	ldr	r2, [pc, #188]	; (24005eb4 <HAL_DMAEx_MultiBufferStart_IT+0x68c>)
24005df6:	4293      	cmp	r3, r2
24005df8:	d036      	beq.n	24005e68 <HAL_DMAEx_MultiBufferStart_IT+0x640>
24005dfa:	68fb      	ldr	r3, [r7, #12]
24005dfc:	681b      	ldr	r3, [r3, #0]
24005dfe:	4a2e      	ldr	r2, [pc, #184]	; (24005eb8 <HAL_DMAEx_MultiBufferStart_IT+0x690>)
24005e00:	4293      	cmp	r3, r2
24005e02:	d031      	beq.n	24005e68 <HAL_DMAEx_MultiBufferStart_IT+0x640>
24005e04:	68fb      	ldr	r3, [r7, #12]
24005e06:	681b      	ldr	r3, [r3, #0]
24005e08:	4a2c      	ldr	r2, [pc, #176]	; (24005ebc <HAL_DMAEx_MultiBufferStart_IT+0x694>)
24005e0a:	4293      	cmp	r3, r2
24005e0c:	d02c      	beq.n	24005e68 <HAL_DMAEx_MultiBufferStart_IT+0x640>
24005e0e:	68fb      	ldr	r3, [r7, #12]
24005e10:	681b      	ldr	r3, [r3, #0]
24005e12:	4a2b      	ldr	r2, [pc, #172]	; (24005ec0 <HAL_DMAEx_MultiBufferStart_IT+0x698>)
24005e14:	4293      	cmp	r3, r2
24005e16:	d027      	beq.n	24005e68 <HAL_DMAEx_MultiBufferStart_IT+0x640>
24005e18:	68fb      	ldr	r3, [r7, #12]
24005e1a:	681b      	ldr	r3, [r3, #0]
24005e1c:	4a29      	ldr	r2, [pc, #164]	; (24005ec4 <HAL_DMAEx_MultiBufferStart_IT+0x69c>)
24005e1e:	4293      	cmp	r3, r2
24005e20:	d022      	beq.n	24005e68 <HAL_DMAEx_MultiBufferStart_IT+0x640>
24005e22:	68fb      	ldr	r3, [r7, #12]
24005e24:	681b      	ldr	r3, [r3, #0]
24005e26:	4a28      	ldr	r2, [pc, #160]	; (24005ec8 <HAL_DMAEx_MultiBufferStart_IT+0x6a0>)
24005e28:	4293      	cmp	r3, r2
24005e2a:	d01d      	beq.n	24005e68 <HAL_DMAEx_MultiBufferStart_IT+0x640>
24005e2c:	68fb      	ldr	r3, [r7, #12]
24005e2e:	681b      	ldr	r3, [r3, #0]
24005e30:	4a26      	ldr	r2, [pc, #152]	; (24005ecc <HAL_DMAEx_MultiBufferStart_IT+0x6a4>)
24005e32:	4293      	cmp	r3, r2
24005e34:	d018      	beq.n	24005e68 <HAL_DMAEx_MultiBufferStart_IT+0x640>
24005e36:	68fb      	ldr	r3, [r7, #12]
24005e38:	681b      	ldr	r3, [r3, #0]
24005e3a:	4a25      	ldr	r2, [pc, #148]	; (24005ed0 <HAL_DMAEx_MultiBufferStart_IT+0x6a8>)
24005e3c:	4293      	cmp	r3, r2
24005e3e:	d013      	beq.n	24005e68 <HAL_DMAEx_MultiBufferStart_IT+0x640>
24005e40:	68fb      	ldr	r3, [r7, #12]
24005e42:	681b      	ldr	r3, [r3, #0]
24005e44:	4a23      	ldr	r2, [pc, #140]	; (24005ed4 <HAL_DMAEx_MultiBufferStart_IT+0x6ac>)
24005e46:	4293      	cmp	r3, r2
24005e48:	d00e      	beq.n	24005e68 <HAL_DMAEx_MultiBufferStart_IT+0x640>
24005e4a:	68fb      	ldr	r3, [r7, #12]
24005e4c:	681b      	ldr	r3, [r3, #0]
24005e4e:	4a22      	ldr	r2, [pc, #136]	; (24005ed8 <HAL_DMAEx_MultiBufferStart_IT+0x6b0>)
24005e50:	4293      	cmp	r3, r2
24005e52:	d009      	beq.n	24005e68 <HAL_DMAEx_MultiBufferStart_IT+0x640>
24005e54:	68fb      	ldr	r3, [r7, #12]
24005e56:	681b      	ldr	r3, [r3, #0]
24005e58:	4a20      	ldr	r2, [pc, #128]	; (24005edc <HAL_DMAEx_MultiBufferStart_IT+0x6b4>)
24005e5a:	4293      	cmp	r3, r2
24005e5c:	d004      	beq.n	24005e68 <HAL_DMAEx_MultiBufferStart_IT+0x640>
24005e5e:	68fb      	ldr	r3, [r7, #12]
24005e60:	681b      	ldr	r3, [r3, #0]
24005e62:	4a1f      	ldr	r2, [pc, #124]	; (24005ee0 <HAL_DMAEx_MultiBufferStart_IT+0x6b8>)
24005e64:	4293      	cmp	r3, r2
24005e66:	d108      	bne.n	24005e7a <HAL_DMAEx_MultiBufferStart_IT+0x652>
24005e68:	68fb      	ldr	r3, [r7, #12]
24005e6a:	681b      	ldr	r3, [r3, #0]
24005e6c:	681a      	ldr	r2, [r3, #0]
24005e6e:	68fb      	ldr	r3, [r7, #12]
24005e70:	681b      	ldr	r3, [r3, #0]
24005e72:	f042 0201 	orr.w	r2, r2, #1
24005e76:	601a      	str	r2, [r3, #0]
24005e78:	e00e      	b.n	24005e98 <HAL_DMAEx_MultiBufferStart_IT+0x670>
24005e7a:	68fb      	ldr	r3, [r7, #12]
24005e7c:	681b      	ldr	r3, [r3, #0]
24005e7e:	681a      	ldr	r2, [r3, #0]
24005e80:	68fb      	ldr	r3, [r7, #12]
24005e82:	681b      	ldr	r3, [r3, #0]
24005e84:	f042 0201 	orr.w	r2, r2, #1
24005e88:	601a      	str	r2, [r3, #0]
24005e8a:	e005      	b.n	24005e98 <HAL_DMAEx_MultiBufferStart_IT+0x670>
  }
  else
  {
    /* Set the error code to busy */
    hdma->ErrorCode = HAL_DMA_ERROR_BUSY;
24005e8c:	68fb      	ldr	r3, [r7, #12]
24005e8e:	f44f 6200 	mov.w	r2, #2048	; 0x800
24005e92:	655a      	str	r2, [r3, #84]	; 0x54

    /* Return error status */
    status = HAL_ERROR;
24005e94:	2301      	movs	r3, #1
24005e96:	75fb      	strb	r3, [r7, #23]
  }
  return status;
24005e98:	7dfb      	ldrb	r3, [r7, #23]
}
24005e9a:	4618      	mov	r0, r3
24005e9c:	3718      	adds	r7, #24
24005e9e:	46bd      	mov	sp, r7
24005ea0:	bd80      	pop	{r7, pc}
24005ea2:	bf00      	nop
24005ea4:	40020010 	.word	0x40020010
24005ea8:	40020028 	.word	0x40020028
24005eac:	40020040 	.word	0x40020040
24005eb0:	40020058 	.word	0x40020058
24005eb4:	40020070 	.word	0x40020070
24005eb8:	40020088 	.word	0x40020088
24005ebc:	400200a0 	.word	0x400200a0
24005ec0:	400200b8 	.word	0x400200b8
24005ec4:	40020410 	.word	0x40020410
24005ec8:	40020428 	.word	0x40020428
24005ecc:	40020440 	.word	0x40020440
24005ed0:	40020458 	.word	0x40020458
24005ed4:	40020470 	.word	0x40020470
24005ed8:	40020488 	.word	0x40020488
24005edc:	400204a0 	.word	0x400204a0
24005ee0:	400204b8 	.word	0x400204b8

24005ee4 <HAL_DMAEx_ChangeMemory>:
  *         MEMORY1 and the MEMORY1 address can be changed only when the current
  *         transfer use MEMORY0.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMAEx_ChangeMemory(DMA_HandleTypeDef *hdma, uint32_t Address, HAL_DMA_MemoryTypeDef memory)
{
24005ee4:	b480      	push	{r7}
24005ee6:	b085      	sub	sp, #20
24005ee8:	af00      	add	r7, sp, #0
24005eea:	60f8      	str	r0, [r7, #12]
24005eec:	60b9      	str	r1, [r7, #8]
24005eee:	4613      	mov	r3, r2
24005ef0:	71fb      	strb	r3, [r7, #7]
  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
24005ef2:	68fb      	ldr	r3, [r7, #12]
24005ef4:	681b      	ldr	r3, [r3, #0]
24005ef6:	4a39      	ldr	r2, [pc, #228]	; (24005fdc <HAL_DMAEx_ChangeMemory+0xf8>)
24005ef8:	4293      	cmp	r3, r2
24005efa:	d04a      	beq.n	24005f92 <HAL_DMAEx_ChangeMemory+0xae>
24005efc:	68fb      	ldr	r3, [r7, #12]
24005efe:	681b      	ldr	r3, [r3, #0]
24005f00:	4a37      	ldr	r2, [pc, #220]	; (24005fe0 <HAL_DMAEx_ChangeMemory+0xfc>)
24005f02:	4293      	cmp	r3, r2
24005f04:	d045      	beq.n	24005f92 <HAL_DMAEx_ChangeMemory+0xae>
24005f06:	68fb      	ldr	r3, [r7, #12]
24005f08:	681b      	ldr	r3, [r3, #0]
24005f0a:	4a36      	ldr	r2, [pc, #216]	; (24005fe4 <HAL_DMAEx_ChangeMemory+0x100>)
24005f0c:	4293      	cmp	r3, r2
24005f0e:	d040      	beq.n	24005f92 <HAL_DMAEx_ChangeMemory+0xae>
24005f10:	68fb      	ldr	r3, [r7, #12]
24005f12:	681b      	ldr	r3, [r3, #0]
24005f14:	4a34      	ldr	r2, [pc, #208]	; (24005fe8 <HAL_DMAEx_ChangeMemory+0x104>)
24005f16:	4293      	cmp	r3, r2
24005f18:	d03b      	beq.n	24005f92 <HAL_DMAEx_ChangeMemory+0xae>
24005f1a:	68fb      	ldr	r3, [r7, #12]
24005f1c:	681b      	ldr	r3, [r3, #0]
24005f1e:	4a33      	ldr	r2, [pc, #204]	; (24005fec <HAL_DMAEx_ChangeMemory+0x108>)
24005f20:	4293      	cmp	r3, r2
24005f22:	d036      	beq.n	24005f92 <HAL_DMAEx_ChangeMemory+0xae>
24005f24:	68fb      	ldr	r3, [r7, #12]
24005f26:	681b      	ldr	r3, [r3, #0]
24005f28:	4a31      	ldr	r2, [pc, #196]	; (24005ff0 <HAL_DMAEx_ChangeMemory+0x10c>)
24005f2a:	4293      	cmp	r3, r2
24005f2c:	d031      	beq.n	24005f92 <HAL_DMAEx_ChangeMemory+0xae>
24005f2e:	68fb      	ldr	r3, [r7, #12]
24005f30:	681b      	ldr	r3, [r3, #0]
24005f32:	4a30      	ldr	r2, [pc, #192]	; (24005ff4 <HAL_DMAEx_ChangeMemory+0x110>)
24005f34:	4293      	cmp	r3, r2
24005f36:	d02c      	beq.n	24005f92 <HAL_DMAEx_ChangeMemory+0xae>
24005f38:	68fb      	ldr	r3, [r7, #12]
24005f3a:	681b      	ldr	r3, [r3, #0]
24005f3c:	4a2e      	ldr	r2, [pc, #184]	; (24005ff8 <HAL_DMAEx_ChangeMemory+0x114>)
24005f3e:	4293      	cmp	r3, r2
24005f40:	d027      	beq.n	24005f92 <HAL_DMAEx_ChangeMemory+0xae>
24005f42:	68fb      	ldr	r3, [r7, #12]
24005f44:	681b      	ldr	r3, [r3, #0]
24005f46:	4a2d      	ldr	r2, [pc, #180]	; (24005ffc <HAL_DMAEx_ChangeMemory+0x118>)
24005f48:	4293      	cmp	r3, r2
24005f4a:	d022      	beq.n	24005f92 <HAL_DMAEx_ChangeMemory+0xae>
24005f4c:	68fb      	ldr	r3, [r7, #12]
24005f4e:	681b      	ldr	r3, [r3, #0]
24005f50:	4a2b      	ldr	r2, [pc, #172]	; (24006000 <HAL_DMAEx_ChangeMemory+0x11c>)
24005f52:	4293      	cmp	r3, r2
24005f54:	d01d      	beq.n	24005f92 <HAL_DMAEx_ChangeMemory+0xae>
24005f56:	68fb      	ldr	r3, [r7, #12]
24005f58:	681b      	ldr	r3, [r3, #0]
24005f5a:	4a2a      	ldr	r2, [pc, #168]	; (24006004 <HAL_DMAEx_ChangeMemory+0x120>)
24005f5c:	4293      	cmp	r3, r2
24005f5e:	d018      	beq.n	24005f92 <HAL_DMAEx_ChangeMemory+0xae>
24005f60:	68fb      	ldr	r3, [r7, #12]
24005f62:	681b      	ldr	r3, [r3, #0]
24005f64:	4a28      	ldr	r2, [pc, #160]	; (24006008 <HAL_DMAEx_ChangeMemory+0x124>)
24005f66:	4293      	cmp	r3, r2
24005f68:	d013      	beq.n	24005f92 <HAL_DMAEx_ChangeMemory+0xae>
24005f6a:	68fb      	ldr	r3, [r7, #12]
24005f6c:	681b      	ldr	r3, [r3, #0]
24005f6e:	4a27      	ldr	r2, [pc, #156]	; (2400600c <HAL_DMAEx_ChangeMemory+0x128>)
24005f70:	4293      	cmp	r3, r2
24005f72:	d00e      	beq.n	24005f92 <HAL_DMAEx_ChangeMemory+0xae>
24005f74:	68fb      	ldr	r3, [r7, #12]
24005f76:	681b      	ldr	r3, [r3, #0]
24005f78:	4a25      	ldr	r2, [pc, #148]	; (24006010 <HAL_DMAEx_ChangeMemory+0x12c>)
24005f7a:	4293      	cmp	r3, r2
24005f7c:	d009      	beq.n	24005f92 <HAL_DMAEx_ChangeMemory+0xae>
24005f7e:	68fb      	ldr	r3, [r7, #12]
24005f80:	681b      	ldr	r3, [r3, #0]
24005f82:	4a24      	ldr	r2, [pc, #144]	; (24006014 <HAL_DMAEx_ChangeMemory+0x130>)
24005f84:	4293      	cmp	r3, r2
24005f86:	d004      	beq.n	24005f92 <HAL_DMAEx_ChangeMemory+0xae>
24005f88:	68fb      	ldr	r3, [r7, #12]
24005f8a:	681b      	ldr	r3, [r3, #0]
24005f8c:	4a22      	ldr	r2, [pc, #136]	; (24006018 <HAL_DMAEx_ChangeMemory+0x134>)
24005f8e:	4293      	cmp	r3, r2
24005f90:	d101      	bne.n	24005f96 <HAL_DMAEx_ChangeMemory+0xb2>
24005f92:	2301      	movs	r3, #1
24005f94:	e000      	b.n	24005f98 <HAL_DMAEx_ChangeMemory+0xb4>
24005f96:	2300      	movs	r3, #0
24005f98:	2b00      	cmp	r3, #0
24005f9a:	d00c      	beq.n	24005fb6 <HAL_DMAEx_ChangeMemory+0xd2>
  {
    if(memory == MEMORY0)
24005f9c:	79fb      	ldrb	r3, [r7, #7]
24005f9e:	2b00      	cmp	r3, #0
24005fa0:	d104      	bne.n	24005fac <HAL_DMAEx_ChangeMemory+0xc8>
    {
      /* change the memory0 address */
      ((DMA_Stream_TypeDef   *)hdma->Instance)->M0AR = Address;
24005fa2:	68fb      	ldr	r3, [r7, #12]
24005fa4:	681b      	ldr	r3, [r3, #0]
24005fa6:	68ba      	ldr	r2, [r7, #8]
24005fa8:	60da      	str	r2, [r3, #12]
24005faa:	e010      	b.n	24005fce <HAL_DMAEx_ChangeMemory+0xea>
    }
    else
    {
      /* change the memory1 address */
      ((DMA_Stream_TypeDef   *)hdma->Instance)->M1AR = Address;
24005fac:	68fb      	ldr	r3, [r7, #12]
24005fae:	681b      	ldr	r3, [r3, #0]
24005fb0:	68ba      	ldr	r2, [r7, #8]
24005fb2:	611a      	str	r2, [r3, #16]
24005fb4:	e00b      	b.n	24005fce <HAL_DMAEx_ChangeMemory+0xea>
    }
  }
  else /* BDMA instance(s) */
  {
    if(memory == MEMORY0)
24005fb6:	79fb      	ldrb	r3, [r7, #7]
24005fb8:	2b00      	cmp	r3, #0
24005fba:	d104      	bne.n	24005fc6 <HAL_DMAEx_ChangeMemory+0xe2>
    {
      /* change the memory0 address */
      ((BDMA_Channel_TypeDef   *)hdma->Instance)->CM0AR = Address;
24005fbc:	68fb      	ldr	r3, [r7, #12]
24005fbe:	681b      	ldr	r3, [r3, #0]
24005fc0:	68ba      	ldr	r2, [r7, #8]
24005fc2:	60da      	str	r2, [r3, #12]
24005fc4:	e003      	b.n	24005fce <HAL_DMAEx_ChangeMemory+0xea>
    }
    else
    {
      /* change the memory1 address */
      ((BDMA_Channel_TypeDef   *)hdma->Instance)->CM1AR = Address;
24005fc6:	68fb      	ldr	r3, [r7, #12]
24005fc8:	681b      	ldr	r3, [r3, #0]
24005fca:	68ba      	ldr	r2, [r7, #8]
24005fcc:	611a      	str	r2, [r3, #16]
    }
  }

  return HAL_OK;
24005fce:	2300      	movs	r3, #0
}
24005fd0:	4618      	mov	r0, r3
24005fd2:	3714      	adds	r7, #20
24005fd4:	46bd      	mov	sp, r7
24005fd6:	f85d 7b04 	ldr.w	r7, [sp], #4
24005fda:	4770      	bx	lr
24005fdc:	40020010 	.word	0x40020010
24005fe0:	40020028 	.word	0x40020028
24005fe4:	40020040 	.word	0x40020040
24005fe8:	40020058 	.word	0x40020058
24005fec:	40020070 	.word	0x40020070
24005ff0:	40020088 	.word	0x40020088
24005ff4:	400200a0 	.word	0x400200a0
24005ff8:	400200b8 	.word	0x400200b8
24005ffc:	40020410 	.word	0x40020410
24006000:	40020428 	.word	0x40020428
24006004:	40020440 	.word	0x40020440
24006008:	40020458 	.word	0x40020458
2400600c:	40020470 	.word	0x40020470
24006010:	40020488 	.word	0x40020488
24006014:	400204a0 	.word	0x400204a0
24006018:	400204b8 	.word	0x400204b8

2400601c <HAL_DMAEx_ConfigMuxSync>:
  *                     the configuration information for the specified DMA Stream.
  * @param  pSyncConfig : pointer to HAL_DMA_MuxSyncConfigTypeDef : contains the DMAMUX synchronization parameters
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMAEx_ConfigMuxSync(DMA_HandleTypeDef *hdma, HAL_DMA_MuxSyncConfigTypeDef *pSyncConfig)
{
2400601c:	b480      	push	{r7}
2400601e:	b085      	sub	sp, #20
24006020:	af00      	add	r7, sp, #0
24006022:	6078      	str	r0, [r7, #4]
24006024:	6039      	str	r1, [r7, #0]
  uint32_t syncSignalID = 0;
24006026:	2300      	movs	r3, #0
24006028:	60fb      	str	r3, [r7, #12]
  uint32_t syncPolarity = 0;
2400602a:	2300      	movs	r3, #0
2400602c:	60bb      	str	r3, [r7, #8]
  assert_param(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance));
  assert_param(IS_DMAMUX_SYNC_STATE(pSyncConfig->SyncEnable));
  assert_param(IS_DMAMUX_SYNC_EVENT(pSyncConfig->EventEnable));
  assert_param(IS_DMAMUX_SYNC_REQUEST_NUMBER(pSyncConfig->RequestNumber));

  if(pSyncConfig->SyncEnable == ENABLE)
2400602e:	683b      	ldr	r3, [r7, #0]
24006030:	7a1b      	ldrb	r3, [r3, #8]
24006032:	2b01      	cmp	r3, #1
24006034:	d155      	bne.n	240060e2 <HAL_DMAEx_ConfigMuxSync+0xc6>
  {
    assert_param(IS_DMAMUX_SYNC_POLARITY(pSyncConfig->SyncPolarity));

    if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
24006036:	687b      	ldr	r3, [r7, #4]
24006038:	681b      	ldr	r3, [r3, #0]
2400603a:	4a4b      	ldr	r2, [pc, #300]	; (24006168 <HAL_DMAEx_ConfigMuxSync+0x14c>)
2400603c:	4293      	cmp	r3, r2
2400603e:	d049      	beq.n	240060d4 <HAL_DMAEx_ConfigMuxSync+0xb8>
24006040:	687b      	ldr	r3, [r7, #4]
24006042:	681b      	ldr	r3, [r3, #0]
24006044:	4a49      	ldr	r2, [pc, #292]	; (2400616c <HAL_DMAEx_ConfigMuxSync+0x150>)
24006046:	4293      	cmp	r3, r2
24006048:	d044      	beq.n	240060d4 <HAL_DMAEx_ConfigMuxSync+0xb8>
2400604a:	687b      	ldr	r3, [r7, #4]
2400604c:	681b      	ldr	r3, [r3, #0]
2400604e:	4a48      	ldr	r2, [pc, #288]	; (24006170 <HAL_DMAEx_ConfigMuxSync+0x154>)
24006050:	4293      	cmp	r3, r2
24006052:	d03f      	beq.n	240060d4 <HAL_DMAEx_ConfigMuxSync+0xb8>
24006054:	687b      	ldr	r3, [r7, #4]
24006056:	681b      	ldr	r3, [r3, #0]
24006058:	4a46      	ldr	r2, [pc, #280]	; (24006174 <HAL_DMAEx_ConfigMuxSync+0x158>)
2400605a:	4293      	cmp	r3, r2
2400605c:	d03a      	beq.n	240060d4 <HAL_DMAEx_ConfigMuxSync+0xb8>
2400605e:	687b      	ldr	r3, [r7, #4]
24006060:	681b      	ldr	r3, [r3, #0]
24006062:	4a45      	ldr	r2, [pc, #276]	; (24006178 <HAL_DMAEx_ConfigMuxSync+0x15c>)
24006064:	4293      	cmp	r3, r2
24006066:	d035      	beq.n	240060d4 <HAL_DMAEx_ConfigMuxSync+0xb8>
24006068:	687b      	ldr	r3, [r7, #4]
2400606a:	681b      	ldr	r3, [r3, #0]
2400606c:	4a43      	ldr	r2, [pc, #268]	; (2400617c <HAL_DMAEx_ConfigMuxSync+0x160>)
2400606e:	4293      	cmp	r3, r2
24006070:	d030      	beq.n	240060d4 <HAL_DMAEx_ConfigMuxSync+0xb8>
24006072:	687b      	ldr	r3, [r7, #4]
24006074:	681b      	ldr	r3, [r3, #0]
24006076:	4a42      	ldr	r2, [pc, #264]	; (24006180 <HAL_DMAEx_ConfigMuxSync+0x164>)
24006078:	4293      	cmp	r3, r2
2400607a:	d02b      	beq.n	240060d4 <HAL_DMAEx_ConfigMuxSync+0xb8>
2400607c:	687b      	ldr	r3, [r7, #4]
2400607e:	681b      	ldr	r3, [r3, #0]
24006080:	4a40      	ldr	r2, [pc, #256]	; (24006184 <HAL_DMAEx_ConfigMuxSync+0x168>)
24006082:	4293      	cmp	r3, r2
24006084:	d026      	beq.n	240060d4 <HAL_DMAEx_ConfigMuxSync+0xb8>
24006086:	687b      	ldr	r3, [r7, #4]
24006088:	681b      	ldr	r3, [r3, #0]
2400608a:	4a3f      	ldr	r2, [pc, #252]	; (24006188 <HAL_DMAEx_ConfigMuxSync+0x16c>)
2400608c:	4293      	cmp	r3, r2
2400608e:	d021      	beq.n	240060d4 <HAL_DMAEx_ConfigMuxSync+0xb8>
24006090:	687b      	ldr	r3, [r7, #4]
24006092:	681b      	ldr	r3, [r3, #0]
24006094:	4a3d      	ldr	r2, [pc, #244]	; (2400618c <HAL_DMAEx_ConfigMuxSync+0x170>)
24006096:	4293      	cmp	r3, r2
24006098:	d01c      	beq.n	240060d4 <HAL_DMAEx_ConfigMuxSync+0xb8>
2400609a:	687b      	ldr	r3, [r7, #4]
2400609c:	681b      	ldr	r3, [r3, #0]
2400609e:	4a3c      	ldr	r2, [pc, #240]	; (24006190 <HAL_DMAEx_ConfigMuxSync+0x174>)
240060a0:	4293      	cmp	r3, r2
240060a2:	d017      	beq.n	240060d4 <HAL_DMAEx_ConfigMuxSync+0xb8>
240060a4:	687b      	ldr	r3, [r7, #4]
240060a6:	681b      	ldr	r3, [r3, #0]
240060a8:	4a3a      	ldr	r2, [pc, #232]	; (24006194 <HAL_DMAEx_ConfigMuxSync+0x178>)
240060aa:	4293      	cmp	r3, r2
240060ac:	d012      	beq.n	240060d4 <HAL_DMAEx_ConfigMuxSync+0xb8>
240060ae:	687b      	ldr	r3, [r7, #4]
240060b0:	681b      	ldr	r3, [r3, #0]
240060b2:	4a39      	ldr	r2, [pc, #228]	; (24006198 <HAL_DMAEx_ConfigMuxSync+0x17c>)
240060b4:	4293      	cmp	r3, r2
240060b6:	d00d      	beq.n	240060d4 <HAL_DMAEx_ConfigMuxSync+0xb8>
240060b8:	687b      	ldr	r3, [r7, #4]
240060ba:	681b      	ldr	r3, [r3, #0]
240060bc:	4a37      	ldr	r2, [pc, #220]	; (2400619c <HAL_DMAEx_ConfigMuxSync+0x180>)
240060be:	4293      	cmp	r3, r2
240060c0:	d008      	beq.n	240060d4 <HAL_DMAEx_ConfigMuxSync+0xb8>
240060c2:	687b      	ldr	r3, [r7, #4]
240060c4:	681b      	ldr	r3, [r3, #0]
240060c6:	4a36      	ldr	r2, [pc, #216]	; (240061a0 <HAL_DMAEx_ConfigMuxSync+0x184>)
240060c8:	4293      	cmp	r3, r2
240060ca:	d003      	beq.n	240060d4 <HAL_DMAEx_ConfigMuxSync+0xb8>
240060cc:	687b      	ldr	r3, [r7, #4]
240060ce:	681b      	ldr	r3, [r3, #0]
240060d0:	4a34      	ldr	r2, [pc, #208]	; (240061a4 <HAL_DMAEx_ConfigMuxSync+0x188>)
240060d2:	4293      	cmp	r3, r2
240060d4:	bf00      	nop
    }
    else
    {
      assert_param(IS_BDMA_DMAMUX_SYNC_SIGNAL_ID(pSyncConfig->SyncSignalID));
    }
    syncSignalID = pSyncConfig->SyncSignalID;
240060d6:	683b      	ldr	r3, [r7, #0]
240060d8:	681b      	ldr	r3, [r3, #0]
240060da:	60fb      	str	r3, [r7, #12]
    syncPolarity = pSyncConfig->SyncPolarity;
240060dc:	683b      	ldr	r3, [r7, #0]
240060de:	685b      	ldr	r3, [r3, #4]
240060e0:	60bb      	str	r3, [r7, #8]
  }

  /*Check if the DMA state is ready */
  if(hdma->State == HAL_DMA_STATE_READY)
240060e2:	687b      	ldr	r3, [r7, #4]
240060e4:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
240060e8:	b2db      	uxtb	r3, r3
240060ea:	2b01      	cmp	r3, #1
240060ec:	d131      	bne.n	24006152 <HAL_DMAEx_ConfigMuxSync+0x136>
  {
    /* Process Locked */
    __HAL_LOCK(hdma);
240060ee:	687b      	ldr	r3, [r7, #4]
240060f0:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
240060f4:	2b01      	cmp	r3, #1
240060f6:	d101      	bne.n	240060fc <HAL_DMAEx_ConfigMuxSync+0xe0>
240060f8:	2302      	movs	r3, #2
240060fa:	e02f      	b.n	2400615c <HAL_DMAEx_ConfigMuxSync+0x140>
240060fc:	687b      	ldr	r3, [r7, #4]
240060fe:	2201      	movs	r2, #1
24006100:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

    /* Disable the synchronization and event generation before applying a new config */
    CLEAR_BIT(hdma->DMAmuxChannel->CCR,(DMAMUX_CxCR_SE | DMAMUX_CxCR_EGE));
24006104:	687b      	ldr	r3, [r7, #4]
24006106:	6e1b      	ldr	r3, [r3, #96]	; 0x60
24006108:	681a      	ldr	r2, [r3, #0]
2400610a:	687b      	ldr	r3, [r7, #4]
2400610c:	6e1b      	ldr	r3, [r3, #96]	; 0x60
2400610e:	f422 3281 	bic.w	r2, r2, #66048	; 0x10200
24006112:	601a      	str	r2, [r3, #0]

    /* Set the new synchronization parameters (and keep the request ID filled during the Init)*/
    MODIFY_REG( hdma->DMAmuxChannel->CCR, \
24006114:	687b      	ldr	r3, [r7, #4]
24006116:	6e1b      	ldr	r3, [r3, #96]	; 0x60
24006118:	681b      	ldr	r3, [r3, #0]
2400611a:	b2d9      	uxtb	r1, r3
2400611c:	68fb      	ldr	r3, [r7, #12]
2400611e:	061a      	lsls	r2, r3, #24
24006120:	683b      	ldr	r3, [r7, #0]
24006122:	68db      	ldr	r3, [r3, #12]
24006124:	3b01      	subs	r3, #1
24006126:	04db      	lsls	r3, r3, #19
24006128:	431a      	orrs	r2, r3
2400612a:	68bb      	ldr	r3, [r7, #8]
2400612c:	431a      	orrs	r2, r3
2400612e:	683b      	ldr	r3, [r7, #0]
24006130:	7a1b      	ldrb	r3, [r3, #8]
24006132:	041b      	lsls	r3, r3, #16
24006134:	431a      	orrs	r2, r3
24006136:	683b      	ldr	r3, [r7, #0]
24006138:	7a5b      	ldrb	r3, [r3, #9]
2400613a:	025b      	lsls	r3, r3, #9
2400613c:	431a      	orrs	r2, r3
2400613e:	687b      	ldr	r3, [r7, #4]
24006140:	6e1b      	ldr	r3, [r3, #96]	; 0x60
24006142:	430a      	orrs	r2, r1
24006144:	601a      	str	r2, [r3, #0]
               ((pSyncConfig->RequestNumber - 1U) << DMAMUX_CxCR_NBREQ_Pos) | \
               syncPolarity | ((uint32_t)pSyncConfig->SyncEnable << DMAMUX_CxCR_SE_Pos)    | \
               ((uint32_t)pSyncConfig->EventEnable << DMAMUX_CxCR_EGE_Pos));

      /* Process Locked */
    __HAL_UNLOCK(hdma);
24006146:	687b      	ldr	r3, [r7, #4]
24006148:	2200      	movs	r2, #0
2400614a:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

    return HAL_OK;
2400614e:	2300      	movs	r3, #0
24006150:	e004      	b.n	2400615c <HAL_DMAEx_ConfigMuxSync+0x140>
  }
  else
  {
    /* Set the error code to busy */
    hdma->ErrorCode = HAL_DMA_ERROR_BUSY;
24006152:	687b      	ldr	r3, [r7, #4]
24006154:	f44f 6200 	mov.w	r2, #2048	; 0x800
24006158:	655a      	str	r2, [r3, #84]	; 0x54

    /* Return error status */
    return HAL_ERROR;
2400615a:	2301      	movs	r3, #1
  }
}
2400615c:	4618      	mov	r0, r3
2400615e:	3714      	adds	r7, #20
24006160:	46bd      	mov	sp, r7
24006162:	f85d 7b04 	ldr.w	r7, [sp], #4
24006166:	4770      	bx	lr
24006168:	40020010 	.word	0x40020010
2400616c:	40020028 	.word	0x40020028
24006170:	40020040 	.word	0x40020040
24006174:	40020058 	.word	0x40020058
24006178:	40020070 	.word	0x40020070
2400617c:	40020088 	.word	0x40020088
24006180:	400200a0 	.word	0x400200a0
24006184:	400200b8 	.word	0x400200b8
24006188:	40020410 	.word	0x40020410
2400618c:	40020428 	.word	0x40020428
24006190:	40020440 	.word	0x40020440
24006194:	40020458 	.word	0x40020458
24006198:	40020470 	.word	0x40020470
2400619c:	40020488 	.word	0x40020488
240061a0:	400204a0 	.word	0x400204a0
240061a4:	400204b8 	.word	0x400204b8

240061a8 <HAL_DMAEx_ConfigMuxRequestGenerator>:
  *         contains the request generator parameters.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMAEx_ConfigMuxRequestGenerator (DMA_HandleTypeDef *hdma, HAL_DMA_MuxRequestGeneratorConfigTypeDef *pRequestGeneratorConfig)
{
240061a8:	b480      	push	{r7}
240061aa:	b085      	sub	sp, #20
240061ac:	af00      	add	r7, sp, #0
240061ae:	6078      	str	r0, [r7, #4]
240061b0:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef status;
  HAL_DMA_StateTypeDef temp_state = hdma->State;
240061b2:	687b      	ldr	r3, [r7, #4]
240061b4:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
240061b8:	73bb      	strb	r3, [r7, #14]

  /* Check the parameters */
  assert_param(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance));

  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
240061ba:	687b      	ldr	r3, [r7, #4]
240061bc:	681b      	ldr	r3, [r3, #0]
240061be:	4a47      	ldr	r2, [pc, #284]	; (240062dc <HAL_DMAEx_ConfigMuxRequestGenerator+0x134>)
240061c0:	4293      	cmp	r3, r2
240061c2:	d049      	beq.n	24006258 <HAL_DMAEx_ConfigMuxRequestGenerator+0xb0>
240061c4:	687b      	ldr	r3, [r7, #4]
240061c6:	681b      	ldr	r3, [r3, #0]
240061c8:	4a45      	ldr	r2, [pc, #276]	; (240062e0 <HAL_DMAEx_ConfigMuxRequestGenerator+0x138>)
240061ca:	4293      	cmp	r3, r2
240061cc:	d044      	beq.n	24006258 <HAL_DMAEx_ConfigMuxRequestGenerator+0xb0>
240061ce:	687b      	ldr	r3, [r7, #4]
240061d0:	681b      	ldr	r3, [r3, #0]
240061d2:	4a44      	ldr	r2, [pc, #272]	; (240062e4 <HAL_DMAEx_ConfigMuxRequestGenerator+0x13c>)
240061d4:	4293      	cmp	r3, r2
240061d6:	d03f      	beq.n	24006258 <HAL_DMAEx_ConfigMuxRequestGenerator+0xb0>
240061d8:	687b      	ldr	r3, [r7, #4]
240061da:	681b      	ldr	r3, [r3, #0]
240061dc:	4a42      	ldr	r2, [pc, #264]	; (240062e8 <HAL_DMAEx_ConfigMuxRequestGenerator+0x140>)
240061de:	4293      	cmp	r3, r2
240061e0:	d03a      	beq.n	24006258 <HAL_DMAEx_ConfigMuxRequestGenerator+0xb0>
240061e2:	687b      	ldr	r3, [r7, #4]
240061e4:	681b      	ldr	r3, [r3, #0]
240061e6:	4a41      	ldr	r2, [pc, #260]	; (240062ec <HAL_DMAEx_ConfigMuxRequestGenerator+0x144>)
240061e8:	4293      	cmp	r3, r2
240061ea:	d035      	beq.n	24006258 <HAL_DMAEx_ConfigMuxRequestGenerator+0xb0>
240061ec:	687b      	ldr	r3, [r7, #4]
240061ee:	681b      	ldr	r3, [r3, #0]
240061f0:	4a3f      	ldr	r2, [pc, #252]	; (240062f0 <HAL_DMAEx_ConfigMuxRequestGenerator+0x148>)
240061f2:	4293      	cmp	r3, r2
240061f4:	d030      	beq.n	24006258 <HAL_DMAEx_ConfigMuxRequestGenerator+0xb0>
240061f6:	687b      	ldr	r3, [r7, #4]
240061f8:	681b      	ldr	r3, [r3, #0]
240061fa:	4a3e      	ldr	r2, [pc, #248]	; (240062f4 <HAL_DMAEx_ConfigMuxRequestGenerator+0x14c>)
240061fc:	4293      	cmp	r3, r2
240061fe:	d02b      	beq.n	24006258 <HAL_DMAEx_ConfigMuxRequestGenerator+0xb0>
24006200:	687b      	ldr	r3, [r7, #4]
24006202:	681b      	ldr	r3, [r3, #0]
24006204:	4a3c      	ldr	r2, [pc, #240]	; (240062f8 <HAL_DMAEx_ConfigMuxRequestGenerator+0x150>)
24006206:	4293      	cmp	r3, r2
24006208:	d026      	beq.n	24006258 <HAL_DMAEx_ConfigMuxRequestGenerator+0xb0>
2400620a:	687b      	ldr	r3, [r7, #4]
2400620c:	681b      	ldr	r3, [r3, #0]
2400620e:	4a3b      	ldr	r2, [pc, #236]	; (240062fc <HAL_DMAEx_ConfigMuxRequestGenerator+0x154>)
24006210:	4293      	cmp	r3, r2
24006212:	d021      	beq.n	24006258 <HAL_DMAEx_ConfigMuxRequestGenerator+0xb0>
24006214:	687b      	ldr	r3, [r7, #4]
24006216:	681b      	ldr	r3, [r3, #0]
24006218:	4a39      	ldr	r2, [pc, #228]	; (24006300 <HAL_DMAEx_ConfigMuxRequestGenerator+0x158>)
2400621a:	4293      	cmp	r3, r2
2400621c:	d01c      	beq.n	24006258 <HAL_DMAEx_ConfigMuxRequestGenerator+0xb0>
2400621e:	687b      	ldr	r3, [r7, #4]
24006220:	681b      	ldr	r3, [r3, #0]
24006222:	4a38      	ldr	r2, [pc, #224]	; (24006304 <HAL_DMAEx_ConfigMuxRequestGenerator+0x15c>)
24006224:	4293      	cmp	r3, r2
24006226:	d017      	beq.n	24006258 <HAL_DMAEx_ConfigMuxRequestGenerator+0xb0>
24006228:	687b      	ldr	r3, [r7, #4]
2400622a:	681b      	ldr	r3, [r3, #0]
2400622c:	4a36      	ldr	r2, [pc, #216]	; (24006308 <HAL_DMAEx_ConfigMuxRequestGenerator+0x160>)
2400622e:	4293      	cmp	r3, r2
24006230:	d012      	beq.n	24006258 <HAL_DMAEx_ConfigMuxRequestGenerator+0xb0>
24006232:	687b      	ldr	r3, [r7, #4]
24006234:	681b      	ldr	r3, [r3, #0]
24006236:	4a35      	ldr	r2, [pc, #212]	; (2400630c <HAL_DMAEx_ConfigMuxRequestGenerator+0x164>)
24006238:	4293      	cmp	r3, r2
2400623a:	d00d      	beq.n	24006258 <HAL_DMAEx_ConfigMuxRequestGenerator+0xb0>
2400623c:	687b      	ldr	r3, [r7, #4]
2400623e:	681b      	ldr	r3, [r3, #0]
24006240:	4a33      	ldr	r2, [pc, #204]	; (24006310 <HAL_DMAEx_ConfigMuxRequestGenerator+0x168>)
24006242:	4293      	cmp	r3, r2
24006244:	d008      	beq.n	24006258 <HAL_DMAEx_ConfigMuxRequestGenerator+0xb0>
24006246:	687b      	ldr	r3, [r7, #4]
24006248:	681b      	ldr	r3, [r3, #0]
2400624a:	4a32      	ldr	r2, [pc, #200]	; (24006314 <HAL_DMAEx_ConfigMuxRequestGenerator+0x16c>)
2400624c:	4293      	cmp	r3, r2
2400624e:	d003      	beq.n	24006258 <HAL_DMAEx_ConfigMuxRequestGenerator+0xb0>
24006250:	687b      	ldr	r3, [r7, #4]
24006252:	681b      	ldr	r3, [r3, #0]
24006254:	4a30      	ldr	r2, [pc, #192]	; (24006318 <HAL_DMAEx_ConfigMuxRequestGenerator+0x170>)
24006256:	4293      	cmp	r3, r2
24006258:	bf00      	nop
  assert_param(IS_DMAMUX_REQUEST_GEN_REQUEST_NUMBER(pRequestGeneratorConfig->RequestNumber));

  /* check if the DMA state is ready
     and DMA is using a DMAMUX request generator block
  */
  if(hdma->DMAmuxRequestGen == 0U)
2400625a:	687b      	ldr	r3, [r7, #4]
2400625c:	6edb      	ldr	r3, [r3, #108]	; 0x6c
2400625e:	2b00      	cmp	r3, #0
24006260:	d105      	bne.n	2400626e <HAL_DMAEx_ConfigMuxRequestGenerator+0xc6>
  {
    /* Set the error code to busy */
    hdma->ErrorCode = HAL_DMA_ERROR_PARAM;
24006262:	687b      	ldr	r3, [r7, #4]
24006264:	2240      	movs	r2, #64	; 0x40
24006266:	655a      	str	r2, [r3, #84]	; 0x54

    /* error status */
    status = HAL_ERROR;
24006268:	2301      	movs	r3, #1
2400626a:	73fb      	strb	r3, [r7, #15]
2400626c:	e02e      	b.n	240062cc <HAL_DMAEx_ConfigMuxRequestGenerator+0x124>
  }
  else if(((hdma->DMAmuxRequestGen->RGCR & DMAMUX_RGxCR_GE) == 0U) && (temp_state == HAL_DMA_STATE_READY))
2400626e:	687b      	ldr	r3, [r7, #4]
24006270:	6edb      	ldr	r3, [r3, #108]	; 0x6c
24006272:	681b      	ldr	r3, [r3, #0]
24006274:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
24006278:	2b00      	cmp	r3, #0
2400627a:	d121      	bne.n	240062c0 <HAL_DMAEx_ConfigMuxRequestGenerator+0x118>
2400627c:	7bbb      	ldrb	r3, [r7, #14]
2400627e:	2b01      	cmp	r3, #1
24006280:	d11e      	bne.n	240062c0 <HAL_DMAEx_ConfigMuxRequestGenerator+0x118>
  {
    /* RequestGenerator must be disable prior to the configuration i.e GE bit is 0 */

    /* Process Locked */
    __HAL_LOCK(hdma);
24006282:	687b      	ldr	r3, [r7, #4]
24006284:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
24006288:	2b01      	cmp	r3, #1
2400628a:	d101      	bne.n	24006290 <HAL_DMAEx_ConfigMuxRequestGenerator+0xe8>
2400628c:	2302      	movs	r3, #2
2400628e:	e01e      	b.n	240062ce <HAL_DMAEx_ConfigMuxRequestGenerator+0x126>
24006290:	687b      	ldr	r3, [r7, #4]
24006292:	2201      	movs	r2, #1
24006294:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

    /* Set the request generator new parameters */
    hdma->DMAmuxRequestGen->RGCR = pRequestGeneratorConfig->SignalID | \
24006298:	683b      	ldr	r3, [r7, #0]
2400629a:	681a      	ldr	r2, [r3, #0]
                                  ((pRequestGeneratorConfig->RequestNumber - 1U) << DMAMUX_RGxCR_GNBREQ_Pos)| \
2400629c:	683b      	ldr	r3, [r7, #0]
2400629e:	689b      	ldr	r3, [r3, #8]
240062a0:	3b01      	subs	r3, #1
240062a2:	04db      	lsls	r3, r3, #19
    hdma->DMAmuxRequestGen->RGCR = pRequestGeneratorConfig->SignalID | \
240062a4:	ea42 0103 	orr.w	r1, r2, r3
                                  pRequestGeneratorConfig->Polarity;
240062a8:	683b      	ldr	r3, [r7, #0]
240062aa:	685a      	ldr	r2, [r3, #4]
    hdma->DMAmuxRequestGen->RGCR = pRequestGeneratorConfig->SignalID | \
240062ac:	687b      	ldr	r3, [r7, #4]
240062ae:	6edb      	ldr	r3, [r3, #108]	; 0x6c
                                  ((pRequestGeneratorConfig->RequestNumber - 1U) << DMAMUX_RGxCR_GNBREQ_Pos)| \
240062b0:	430a      	orrs	r2, r1
    hdma->DMAmuxRequestGen->RGCR = pRequestGeneratorConfig->SignalID | \
240062b2:	601a      	str	r2, [r3, #0]
    /* Process Locked */
    __HAL_UNLOCK(hdma);
240062b4:	687b      	ldr	r3, [r7, #4]
240062b6:	2200      	movs	r2, #0
240062b8:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

    return HAL_OK;
240062bc:	2300      	movs	r3, #0
240062be:	e006      	b.n	240062ce <HAL_DMAEx_ConfigMuxRequestGenerator+0x126>
  }
  else
  {
    /* Set the error code to busy */
    hdma->ErrorCode = HAL_DMA_ERROR_BUSY;
240062c0:	687b      	ldr	r3, [r7, #4]
240062c2:	f44f 6200 	mov.w	r2, #2048	; 0x800
240062c6:	655a      	str	r2, [r3, #84]	; 0x54

    /* error status */
    status = HAL_ERROR;
240062c8:	2301      	movs	r3, #1
240062ca:	73fb      	strb	r3, [r7, #15]
  }

  return status;
240062cc:	7bfb      	ldrb	r3, [r7, #15]
}
240062ce:	4618      	mov	r0, r3
240062d0:	3714      	adds	r7, #20
240062d2:	46bd      	mov	sp, r7
240062d4:	f85d 7b04 	ldr.w	r7, [sp], #4
240062d8:	4770      	bx	lr
240062da:	bf00      	nop
240062dc:	40020010 	.word	0x40020010
240062e0:	40020028 	.word	0x40020028
240062e4:	40020040 	.word	0x40020040
240062e8:	40020058 	.word	0x40020058
240062ec:	40020070 	.word	0x40020070
240062f0:	40020088 	.word	0x40020088
240062f4:	400200a0 	.word	0x400200a0
240062f8:	400200b8 	.word	0x400200b8
240062fc:	40020410 	.word	0x40020410
24006300:	40020428 	.word	0x40020428
24006304:	40020440 	.word	0x40020440
24006308:	40020458 	.word	0x40020458
2400630c:	40020470 	.word	0x40020470
24006310:	40020488 	.word	0x40020488
24006314:	400204a0 	.word	0x400204a0
24006318:	400204b8 	.word	0x400204b8

2400631c <HAL_DMAEx_EnableMuxRequestGenerator>:
  * @param  hdma:       pointer to a DMA_HandleTypeDef structure that contains
  *                     the configuration information for the specified DMA Stream.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMAEx_EnableMuxRequestGenerator (DMA_HandleTypeDef *hdma)
{
2400631c:	b480      	push	{r7}
2400631e:	b083      	sub	sp, #12
24006320:	af00      	add	r7, sp, #0
24006322:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance));

  /* check if the DMA state is ready
     and DMA is using a DMAMUX request generator block */
  if((hdma->State != HAL_DMA_STATE_RESET) && (hdma->DMAmuxRequestGen != 0U))
24006324:	687b      	ldr	r3, [r7, #4]
24006326:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
2400632a:	b2db      	uxtb	r3, r3
2400632c:	2b00      	cmp	r3, #0
2400632e:	d00d      	beq.n	2400634c <HAL_DMAEx_EnableMuxRequestGenerator+0x30>
24006330:	687b      	ldr	r3, [r7, #4]
24006332:	6edb      	ldr	r3, [r3, #108]	; 0x6c
24006334:	2b00      	cmp	r3, #0
24006336:	d009      	beq.n	2400634c <HAL_DMAEx_EnableMuxRequestGenerator+0x30>
  {
    /* Enable the request generator*/
    hdma->DMAmuxRequestGen->RGCR |= DMAMUX_RGxCR_GE;
24006338:	687b      	ldr	r3, [r7, #4]
2400633a:	6edb      	ldr	r3, [r3, #108]	; 0x6c
2400633c:	681a      	ldr	r2, [r3, #0]
2400633e:	687b      	ldr	r3, [r7, #4]
24006340:	6edb      	ldr	r3, [r3, #108]	; 0x6c
24006342:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
24006346:	601a      	str	r2, [r3, #0]

   return HAL_OK;
24006348:	2300      	movs	r3, #0
2400634a:	e000      	b.n	2400634e <HAL_DMAEx_EnableMuxRequestGenerator+0x32>
 }
 else
 {
   return HAL_ERROR;
2400634c:	2301      	movs	r3, #1
 }
}
2400634e:	4618      	mov	r0, r3
24006350:	370c      	adds	r7, #12
24006352:	46bd      	mov	sp, r7
24006354:	f85d 7b04 	ldr.w	r7, [sp], #4
24006358:	4770      	bx	lr

2400635a <HAL_DMAEx_DisableMuxRequestGenerator>:
  * @param  hdma:       pointer to a DMA_HandleTypeDef structure that contains
  *                     the configuration information for the specified DMA Stream.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMAEx_DisableMuxRequestGenerator (DMA_HandleTypeDef *hdma)
{
2400635a:	b480      	push	{r7}
2400635c:	b083      	sub	sp, #12
2400635e:	af00      	add	r7, sp, #0
24006360:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance));

  /* check if the DMA state is ready
     and DMA is using a DMAMUX request generator block */
  if((hdma->State != HAL_DMA_STATE_RESET) && (hdma->DMAmuxRequestGen != 0U))
24006362:	687b      	ldr	r3, [r7, #4]
24006364:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
24006368:	b2db      	uxtb	r3, r3
2400636a:	2b00      	cmp	r3, #0
2400636c:	d00d      	beq.n	2400638a <HAL_DMAEx_DisableMuxRequestGenerator+0x30>
2400636e:	687b      	ldr	r3, [r7, #4]
24006370:	6edb      	ldr	r3, [r3, #108]	; 0x6c
24006372:	2b00      	cmp	r3, #0
24006374:	d009      	beq.n	2400638a <HAL_DMAEx_DisableMuxRequestGenerator+0x30>
  {
    /* Disable the request generator*/
    hdma->DMAmuxRequestGen->RGCR &= ~DMAMUX_RGxCR_GE;
24006376:	687b      	ldr	r3, [r7, #4]
24006378:	6edb      	ldr	r3, [r3, #108]	; 0x6c
2400637a:	681a      	ldr	r2, [r3, #0]
2400637c:	687b      	ldr	r3, [r7, #4]
2400637e:	6edb      	ldr	r3, [r3, #108]	; 0x6c
24006380:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
24006384:	601a      	str	r2, [r3, #0]

   return HAL_OK;
24006386:	2300      	movs	r3, #0
24006388:	e000      	b.n	2400638c <HAL_DMAEx_DisableMuxRequestGenerator+0x32>
 }
 else
 {
   return HAL_ERROR;
2400638a:	2301      	movs	r3, #1
 }
}
2400638c:	4618      	mov	r0, r3
2400638e:	370c      	adds	r7, #12
24006390:	46bd      	mov	sp, r7
24006392:	f85d 7b04 	ldr.w	r7, [sp], #4
24006396:	4770      	bx	lr

24006398 <HAL_DMAEx_MUX_IRQHandler>:
  * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Stream.
  * @retval None
  */
void HAL_DMAEx_MUX_IRQHandler(DMA_HandleTypeDef *hdma)
{
24006398:	b580      	push	{r7, lr}
2400639a:	b082      	sub	sp, #8
2400639c:	af00      	add	r7, sp, #0
2400639e:	6078      	str	r0, [r7, #4]
  /* Check for DMAMUX Synchronization overrun */
  if((hdma->DMAmuxChannelStatus->CSR & hdma->DMAmuxChannelStatusMask) != 0U)
240063a0:	687b      	ldr	r3, [r7, #4]
240063a2:	6e5b      	ldr	r3, [r3, #100]	; 0x64
240063a4:	681a      	ldr	r2, [r3, #0]
240063a6:	687b      	ldr	r3, [r7, #4]
240063a8:	6e9b      	ldr	r3, [r3, #104]	; 0x68
240063aa:	4013      	ands	r3, r2
240063ac:	2b00      	cmp	r3, #0
240063ae:	d01a      	beq.n	240063e6 <HAL_DMAEx_MUX_IRQHandler+0x4e>
  {
    /* Disable the synchro overrun interrupt */
    hdma->DMAmuxChannel->CCR &= ~DMAMUX_CxCR_SOIE;
240063b0:	687b      	ldr	r3, [r7, #4]
240063b2:	6e1b      	ldr	r3, [r3, #96]	; 0x60
240063b4:	681a      	ldr	r2, [r3, #0]
240063b6:	687b      	ldr	r3, [r7, #4]
240063b8:	6e1b      	ldr	r3, [r3, #96]	; 0x60
240063ba:	f422 7280 	bic.w	r2, r2, #256	; 0x100
240063be:	601a      	str	r2, [r3, #0]

    /* Clear the DMAMUX synchro overrun flag */
    hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
240063c0:	687b      	ldr	r3, [r7, #4]
240063c2:	6e5b      	ldr	r3, [r3, #100]	; 0x64
240063c4:	687a      	ldr	r2, [r7, #4]
240063c6:	6e92      	ldr	r2, [r2, #104]	; 0x68
240063c8:	605a      	str	r2, [r3, #4]

    /* Update error code */
    hdma->ErrorCode |= HAL_DMA_ERROR_SYNC;
240063ca:	687b      	ldr	r3, [r7, #4]
240063cc:	6d5b      	ldr	r3, [r3, #84]	; 0x54
240063ce:	f443 7200 	orr.w	r2, r3, #512	; 0x200
240063d2:	687b      	ldr	r3, [r7, #4]
240063d4:	655a      	str	r2, [r3, #84]	; 0x54

    if(hdma->XferErrorCallback != NULL)
240063d6:	687b      	ldr	r3, [r7, #4]
240063d8:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
240063da:	2b00      	cmp	r3, #0
240063dc:	d003      	beq.n	240063e6 <HAL_DMAEx_MUX_IRQHandler+0x4e>
    {
      /* Transfer error callback */
      hdma->XferErrorCallback(hdma);
240063de:	687b      	ldr	r3, [r7, #4]
240063e0:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
240063e2:	6878      	ldr	r0, [r7, #4]
240063e4:	4798      	blx	r3
    }
  }

  if(hdma->DMAmuxRequestGen != 0)
240063e6:	687b      	ldr	r3, [r7, #4]
240063e8:	6edb      	ldr	r3, [r3, #108]	; 0x6c
240063ea:	2b00      	cmp	r3, #0
240063ec:	d022      	beq.n	24006434 <HAL_DMAEx_MUX_IRQHandler+0x9c>
  {
   /* if using a DMAMUX request generator block Check for DMAMUX request generator overrun */
    if((hdma->DMAmuxRequestGenStatus->RGSR & hdma->DMAmuxRequestGenStatusMask) != 0U)
240063ee:	687b      	ldr	r3, [r7, #4]
240063f0:	6f1b      	ldr	r3, [r3, #112]	; 0x70
240063f2:	681a      	ldr	r2, [r3, #0]
240063f4:	687b      	ldr	r3, [r7, #4]
240063f6:	6f5b      	ldr	r3, [r3, #116]	; 0x74
240063f8:	4013      	ands	r3, r2
240063fa:	2b00      	cmp	r3, #0
240063fc:	d01a      	beq.n	24006434 <HAL_DMAEx_MUX_IRQHandler+0x9c>
    {
      /* Disable the request gen overrun interrupt */
      hdma->DMAmuxRequestGen->RGCR &= ~DMAMUX_RGxCR_OIE;
240063fe:	687b      	ldr	r3, [r7, #4]
24006400:	6edb      	ldr	r3, [r3, #108]	; 0x6c
24006402:	681a      	ldr	r2, [r3, #0]
24006404:	687b      	ldr	r3, [r7, #4]
24006406:	6edb      	ldr	r3, [r3, #108]	; 0x6c
24006408:	f422 7280 	bic.w	r2, r2, #256	; 0x100
2400640c:	601a      	str	r2, [r3, #0]

      /* Clear the DMAMUX request generator overrun flag */
      hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
2400640e:	687b      	ldr	r3, [r7, #4]
24006410:	6f1b      	ldr	r3, [r3, #112]	; 0x70
24006412:	687a      	ldr	r2, [r7, #4]
24006414:	6f52      	ldr	r2, [r2, #116]	; 0x74
24006416:	605a      	str	r2, [r3, #4]

      /* Update error code */
      hdma->ErrorCode |= HAL_DMA_ERROR_REQGEN;
24006418:	687b      	ldr	r3, [r7, #4]
2400641a:	6d5b      	ldr	r3, [r3, #84]	; 0x54
2400641c:	f443 6280 	orr.w	r2, r3, #1024	; 0x400
24006420:	687b      	ldr	r3, [r7, #4]
24006422:	655a      	str	r2, [r3, #84]	; 0x54

      if(hdma->XferErrorCallback != NULL)
24006424:	687b      	ldr	r3, [r7, #4]
24006426:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
24006428:	2b00      	cmp	r3, #0
2400642a:	d003      	beq.n	24006434 <HAL_DMAEx_MUX_IRQHandler+0x9c>
      {
        /* Transfer error callback */
        hdma->XferErrorCallback(hdma);
2400642c:	687b      	ldr	r3, [r7, #4]
2400642e:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
24006430:	6878      	ldr	r0, [r7, #4]
24006432:	4798      	blx	r3
      }
    }
  }
}
24006434:	bf00      	nop
24006436:	3708      	adds	r7, #8
24006438:	46bd      	mov	sp, r7
2400643a:	bd80      	pop	{r7, pc}

2400643c <DMA_MultiBufferSetConfig>:
  * @param  DstAddress: The destination memory Buffer address
  * @param  DataLength: The length of data to be transferred from source to destination
  * @retval HAL status
  */
static void DMA_MultiBufferSetConfig(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
{
2400643c:	b480      	push	{r7}
2400643e:	b085      	sub	sp, #20
24006440:	af00      	add	r7, sp, #0
24006442:	60f8      	str	r0, [r7, #12]
24006444:	60b9      	str	r1, [r7, #8]
24006446:	607a      	str	r2, [r7, #4]
24006448:	603b      	str	r3, [r7, #0]
  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
2400644a:	68fb      	ldr	r3, [r7, #12]
2400644c:	681b      	ldr	r3, [r3, #0]
2400644e:	4a46      	ldr	r2, [pc, #280]	; (24006568 <DMA_MultiBufferSetConfig+0x12c>)
24006450:	4293      	cmp	r3, r2
24006452:	d04a      	beq.n	240064ea <DMA_MultiBufferSetConfig+0xae>
24006454:	68fb      	ldr	r3, [r7, #12]
24006456:	681b      	ldr	r3, [r3, #0]
24006458:	4a44      	ldr	r2, [pc, #272]	; (2400656c <DMA_MultiBufferSetConfig+0x130>)
2400645a:	4293      	cmp	r3, r2
2400645c:	d045      	beq.n	240064ea <DMA_MultiBufferSetConfig+0xae>
2400645e:	68fb      	ldr	r3, [r7, #12]
24006460:	681b      	ldr	r3, [r3, #0]
24006462:	4a43      	ldr	r2, [pc, #268]	; (24006570 <DMA_MultiBufferSetConfig+0x134>)
24006464:	4293      	cmp	r3, r2
24006466:	d040      	beq.n	240064ea <DMA_MultiBufferSetConfig+0xae>
24006468:	68fb      	ldr	r3, [r7, #12]
2400646a:	681b      	ldr	r3, [r3, #0]
2400646c:	4a41      	ldr	r2, [pc, #260]	; (24006574 <DMA_MultiBufferSetConfig+0x138>)
2400646e:	4293      	cmp	r3, r2
24006470:	d03b      	beq.n	240064ea <DMA_MultiBufferSetConfig+0xae>
24006472:	68fb      	ldr	r3, [r7, #12]
24006474:	681b      	ldr	r3, [r3, #0]
24006476:	4a40      	ldr	r2, [pc, #256]	; (24006578 <DMA_MultiBufferSetConfig+0x13c>)
24006478:	4293      	cmp	r3, r2
2400647a:	d036      	beq.n	240064ea <DMA_MultiBufferSetConfig+0xae>
2400647c:	68fb      	ldr	r3, [r7, #12]
2400647e:	681b      	ldr	r3, [r3, #0]
24006480:	4a3e      	ldr	r2, [pc, #248]	; (2400657c <DMA_MultiBufferSetConfig+0x140>)
24006482:	4293      	cmp	r3, r2
24006484:	d031      	beq.n	240064ea <DMA_MultiBufferSetConfig+0xae>
24006486:	68fb      	ldr	r3, [r7, #12]
24006488:	681b      	ldr	r3, [r3, #0]
2400648a:	4a3d      	ldr	r2, [pc, #244]	; (24006580 <DMA_MultiBufferSetConfig+0x144>)
2400648c:	4293      	cmp	r3, r2
2400648e:	d02c      	beq.n	240064ea <DMA_MultiBufferSetConfig+0xae>
24006490:	68fb      	ldr	r3, [r7, #12]
24006492:	681b      	ldr	r3, [r3, #0]
24006494:	4a3b      	ldr	r2, [pc, #236]	; (24006584 <DMA_MultiBufferSetConfig+0x148>)
24006496:	4293      	cmp	r3, r2
24006498:	d027      	beq.n	240064ea <DMA_MultiBufferSetConfig+0xae>
2400649a:	68fb      	ldr	r3, [r7, #12]
2400649c:	681b      	ldr	r3, [r3, #0]
2400649e:	4a3a      	ldr	r2, [pc, #232]	; (24006588 <DMA_MultiBufferSetConfig+0x14c>)
240064a0:	4293      	cmp	r3, r2
240064a2:	d022      	beq.n	240064ea <DMA_MultiBufferSetConfig+0xae>
240064a4:	68fb      	ldr	r3, [r7, #12]
240064a6:	681b      	ldr	r3, [r3, #0]
240064a8:	4a38      	ldr	r2, [pc, #224]	; (2400658c <DMA_MultiBufferSetConfig+0x150>)
240064aa:	4293      	cmp	r3, r2
240064ac:	d01d      	beq.n	240064ea <DMA_MultiBufferSetConfig+0xae>
240064ae:	68fb      	ldr	r3, [r7, #12]
240064b0:	681b      	ldr	r3, [r3, #0]
240064b2:	4a37      	ldr	r2, [pc, #220]	; (24006590 <DMA_MultiBufferSetConfig+0x154>)
240064b4:	4293      	cmp	r3, r2
240064b6:	d018      	beq.n	240064ea <DMA_MultiBufferSetConfig+0xae>
240064b8:	68fb      	ldr	r3, [r7, #12]
240064ba:	681b      	ldr	r3, [r3, #0]
240064bc:	4a35      	ldr	r2, [pc, #212]	; (24006594 <DMA_MultiBufferSetConfig+0x158>)
240064be:	4293      	cmp	r3, r2
240064c0:	d013      	beq.n	240064ea <DMA_MultiBufferSetConfig+0xae>
240064c2:	68fb      	ldr	r3, [r7, #12]
240064c4:	681b      	ldr	r3, [r3, #0]
240064c6:	4a34      	ldr	r2, [pc, #208]	; (24006598 <DMA_MultiBufferSetConfig+0x15c>)
240064c8:	4293      	cmp	r3, r2
240064ca:	d00e      	beq.n	240064ea <DMA_MultiBufferSetConfig+0xae>
240064cc:	68fb      	ldr	r3, [r7, #12]
240064ce:	681b      	ldr	r3, [r3, #0]
240064d0:	4a32      	ldr	r2, [pc, #200]	; (2400659c <DMA_MultiBufferSetConfig+0x160>)
240064d2:	4293      	cmp	r3, r2
240064d4:	d009      	beq.n	240064ea <DMA_MultiBufferSetConfig+0xae>
240064d6:	68fb      	ldr	r3, [r7, #12]
240064d8:	681b      	ldr	r3, [r3, #0]
240064da:	4a31      	ldr	r2, [pc, #196]	; (240065a0 <DMA_MultiBufferSetConfig+0x164>)
240064dc:	4293      	cmp	r3, r2
240064de:	d004      	beq.n	240064ea <DMA_MultiBufferSetConfig+0xae>
240064e0:	68fb      	ldr	r3, [r7, #12]
240064e2:	681b      	ldr	r3, [r3, #0]
240064e4:	4a2f      	ldr	r2, [pc, #188]	; (240065a4 <DMA_MultiBufferSetConfig+0x168>)
240064e6:	4293      	cmp	r3, r2
240064e8:	d101      	bne.n	240064ee <DMA_MultiBufferSetConfig+0xb2>
240064ea:	2301      	movs	r3, #1
240064ec:	e000      	b.n	240064f0 <DMA_MultiBufferSetConfig+0xb4>
240064ee:	2300      	movs	r3, #0
240064f0:	2b00      	cmp	r3, #0
240064f2:	d019      	beq.n	24006528 <DMA_MultiBufferSetConfig+0xec>
  {
    /* Configure DMA Stream data length */
    ((DMA_Stream_TypeDef   *)hdma->Instance)->NDTR = DataLength;
240064f4:	68fb      	ldr	r3, [r7, #12]
240064f6:	681b      	ldr	r3, [r3, #0]
240064f8:	683a      	ldr	r2, [r7, #0]
240064fa:	605a      	str	r2, [r3, #4]

    /* Peripheral to Memory */
    if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
240064fc:	68fb      	ldr	r3, [r7, #12]
240064fe:	689b      	ldr	r3, [r3, #8]
24006500:	2b40      	cmp	r3, #64	; 0x40
24006502:	d108      	bne.n	24006516 <DMA_MultiBufferSetConfig+0xda>
    {
      /* Configure DMA Stream destination address */
      ((DMA_Stream_TypeDef   *)hdma->Instance)->PAR = DstAddress;
24006504:	68fb      	ldr	r3, [r7, #12]
24006506:	681b      	ldr	r3, [r3, #0]
24006508:	687a      	ldr	r2, [r7, #4]
2400650a:	609a      	str	r2, [r3, #8]

      /* Configure DMA Stream source address */
      ((DMA_Stream_TypeDef   *)hdma->Instance)->M0AR = SrcAddress;
2400650c:	68fb      	ldr	r3, [r7, #12]
2400650e:	681b      	ldr	r3, [r3, #0]
24006510:	68ba      	ldr	r2, [r7, #8]
24006512:	60da      	str	r2, [r3, #12]

      /* Configure DMA Stream destination address */
      ((BDMA_Channel_TypeDef   *)hdma->Instance)->CM0AR = DstAddress;
    }
  }
}
24006514:	e021      	b.n	2400655a <DMA_MultiBufferSetConfig+0x11e>
      ((DMA_Stream_TypeDef   *)hdma->Instance)->PAR = SrcAddress;
24006516:	68fb      	ldr	r3, [r7, #12]
24006518:	681b      	ldr	r3, [r3, #0]
2400651a:	68ba      	ldr	r2, [r7, #8]
2400651c:	609a      	str	r2, [r3, #8]
      ((DMA_Stream_TypeDef   *)hdma->Instance)->M0AR = DstAddress;
2400651e:	68fb      	ldr	r3, [r7, #12]
24006520:	681b      	ldr	r3, [r3, #0]
24006522:	687a      	ldr	r2, [r7, #4]
24006524:	60da      	str	r2, [r3, #12]
}
24006526:	e018      	b.n	2400655a <DMA_MultiBufferSetConfig+0x11e>
    ((BDMA_Channel_TypeDef   *)hdma->Instance)->CNDTR = DataLength;
24006528:	68fb      	ldr	r3, [r7, #12]
2400652a:	681b      	ldr	r3, [r3, #0]
2400652c:	683a      	ldr	r2, [r7, #0]
2400652e:	605a      	str	r2, [r3, #4]
    if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
24006530:	68fb      	ldr	r3, [r7, #12]
24006532:	689b      	ldr	r3, [r3, #8]
24006534:	2b40      	cmp	r3, #64	; 0x40
24006536:	d108      	bne.n	2400654a <DMA_MultiBufferSetConfig+0x10e>
      ((BDMA_Channel_TypeDef   *)hdma->Instance)->CPAR = DstAddress;
24006538:	68fb      	ldr	r3, [r7, #12]
2400653a:	681b      	ldr	r3, [r3, #0]
2400653c:	687a      	ldr	r2, [r7, #4]
2400653e:	609a      	str	r2, [r3, #8]
      ((BDMA_Channel_TypeDef   *)hdma->Instance)->CM0AR = SrcAddress;
24006540:	68fb      	ldr	r3, [r7, #12]
24006542:	681b      	ldr	r3, [r3, #0]
24006544:	68ba      	ldr	r2, [r7, #8]
24006546:	60da      	str	r2, [r3, #12]
}
24006548:	e007      	b.n	2400655a <DMA_MultiBufferSetConfig+0x11e>
      ((BDMA_Channel_TypeDef   *)hdma->Instance)->CPAR = SrcAddress;
2400654a:	68fb      	ldr	r3, [r7, #12]
2400654c:	681b      	ldr	r3, [r3, #0]
2400654e:	68ba      	ldr	r2, [r7, #8]
24006550:	609a      	str	r2, [r3, #8]
      ((BDMA_Channel_TypeDef   *)hdma->Instance)->CM0AR = DstAddress;
24006552:	68fb      	ldr	r3, [r7, #12]
24006554:	681b      	ldr	r3, [r3, #0]
24006556:	687a      	ldr	r2, [r7, #4]
24006558:	60da      	str	r2, [r3, #12]
}
2400655a:	bf00      	nop
2400655c:	3714      	adds	r7, #20
2400655e:	46bd      	mov	sp, r7
24006560:	f85d 7b04 	ldr.w	r7, [sp], #4
24006564:	4770      	bx	lr
24006566:	bf00      	nop
24006568:	40020010 	.word	0x40020010
2400656c:	40020028 	.word	0x40020028
24006570:	40020040 	.word	0x40020040
24006574:	40020058 	.word	0x40020058
24006578:	40020070 	.word	0x40020070
2400657c:	40020088 	.word	0x40020088
24006580:	400200a0 	.word	0x400200a0
24006584:	400200b8 	.word	0x400200b8
24006588:	40020410 	.word	0x40020410
2400658c:	40020428 	.word	0x40020428
24006590:	40020440 	.word	0x40020440
24006594:	40020458 	.word	0x40020458
24006598:	40020470 	.word	0x40020470
2400659c:	40020488 	.word	0x40020488
240065a0:	400204a0 	.word	0x400204a0
240065a4:	400204b8 	.word	0x400204b8

240065a8 <HAL_EXTI_SetConfigLine>:
  * @param  hexti Exti handle.
  * @param  pExtiConfig Pointer on EXTI configuration to be set.
  * @retval HAL Status.
  */
HAL_StatusTypeDef HAL_EXTI_SetConfigLine(EXTI_HandleTypeDef *hexti, EXTI_ConfigTypeDef *pExtiConfig)
{
240065a8:	b480      	push	{r7}
240065aa:	b089      	sub	sp, #36	; 0x24
240065ac:	af00      	add	r7, sp, #0
240065ae:	6078      	str	r0, [r7, #4]
240065b0:	6039      	str	r1, [r7, #0]
  uint32_t maskline;
  uint32_t offset;
  uint32_t pcrlinepos;

  /* Check null pointer */
  if ((hexti == NULL) || (pExtiConfig == NULL))
240065b2:	687b      	ldr	r3, [r7, #4]
240065b4:	2b00      	cmp	r3, #0
240065b6:	d002      	beq.n	240065be <HAL_EXTI_SetConfigLine+0x16>
240065b8:	683b      	ldr	r3, [r7, #0]
240065ba:	2b00      	cmp	r3, #0
240065bc:	d101      	bne.n	240065c2 <HAL_EXTI_SetConfigLine+0x1a>
  {
    return HAL_ERROR;
240065be:	2301      	movs	r3, #1
240065c0:	e10b      	b.n	240067da <HAL_EXTI_SetConfigLine+0x232>
  /* Check the parameters */
  assert_param(IS_EXTI_LINE(pExtiConfig->Line));
  assert_param(IS_EXTI_MODE(pExtiConfig->Mode));

  /* Assign line number to handle */
  hexti->Line = pExtiConfig->Line;
240065c2:	683b      	ldr	r3, [r7, #0]
240065c4:	681a      	ldr	r2, [r3, #0]
240065c6:	687b      	ldr	r3, [r7, #4]
240065c8:	601a      	str	r2, [r3, #0]

  /* compute line register offset and line mask */
  offset = ((pExtiConfig->Line & EXTI_REG_MASK) >> EXTI_REG_SHIFT);
240065ca:	683b      	ldr	r3, [r7, #0]
240065cc:	681b      	ldr	r3, [r3, #0]
240065ce:	0c1b      	lsrs	r3, r3, #16
240065d0:	f003 0303 	and.w	r3, r3, #3
240065d4:	613b      	str	r3, [r7, #16]
  linepos = (pExtiConfig->Line & EXTI_PIN_MASK);
240065d6:	683b      	ldr	r3, [r7, #0]
240065d8:	681b      	ldr	r3, [r3, #0]
240065da:	f003 031f 	and.w	r3, r3, #31
240065de:	60fb      	str	r3, [r7, #12]
  maskline = (1UL << linepos);
240065e0:	2201      	movs	r2, #1
240065e2:	68fb      	ldr	r3, [r7, #12]
240065e4:	fa02 f303 	lsl.w	r3, r2, r3
240065e8:	60bb      	str	r3, [r7, #8]

  /* Configure triggers for configurable lines */
  if ((pExtiConfig->Line & EXTI_CONFIG) != 0x00U)
240065ea:	683b      	ldr	r3, [r7, #0]
240065ec:	681b      	ldr	r3, [r3, #0]
240065ee:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
240065f2:	2b00      	cmp	r3, #0
240065f4:	d064      	beq.n	240066c0 <HAL_EXTI_SetConfigLine+0x118>
  {
    assert_param(IS_EXTI_TRIGGER(pExtiConfig->Trigger));

    /* Configure rising trigger */
    regaddr = (__IO uint32_t *)(&EXTI->RTSR1 + (EXTI_CONFIG_OFFSET * offset));
240065f6:	693b      	ldr	r3, [r7, #16]
240065f8:	015b      	lsls	r3, r3, #5
240065fa:	f103 43b0 	add.w	r3, r3, #1476395008	; 0x58000000
240065fe:	61fb      	str	r3, [r7, #28]
    regval = *regaddr;
24006600:	69fb      	ldr	r3, [r7, #28]
24006602:	681b      	ldr	r3, [r3, #0]
24006604:	61bb      	str	r3, [r7, #24]

    /* Mask or set line */
    if ((pExtiConfig->Trigger & EXTI_TRIGGER_RISING) != 0x00U)
24006606:	683b      	ldr	r3, [r7, #0]
24006608:	689b      	ldr	r3, [r3, #8]
2400660a:	f003 0301 	and.w	r3, r3, #1
2400660e:	2b00      	cmp	r3, #0
24006610:	d004      	beq.n	2400661c <HAL_EXTI_SetConfigLine+0x74>
    {
      regval |= maskline;
24006612:	69ba      	ldr	r2, [r7, #24]
24006614:	68bb      	ldr	r3, [r7, #8]
24006616:	4313      	orrs	r3, r2
24006618:	61bb      	str	r3, [r7, #24]
2400661a:	e004      	b.n	24006626 <HAL_EXTI_SetConfigLine+0x7e>
    }
    else
    {
      regval &= ~maskline;
2400661c:	68bb      	ldr	r3, [r7, #8]
2400661e:	43db      	mvns	r3, r3
24006620:	69ba      	ldr	r2, [r7, #24]
24006622:	4013      	ands	r3, r2
24006624:	61bb      	str	r3, [r7, #24]
    }

    /* Store rising trigger mode */
    *regaddr = regval;
24006626:	69fb      	ldr	r3, [r7, #28]
24006628:	69ba      	ldr	r2, [r7, #24]
2400662a:	601a      	str	r2, [r3, #0]

    /* Configure falling trigger */
    regaddr = (__IO uint32_t *)(&EXTI->FTSR1 + (EXTI_CONFIG_OFFSET * offset));
2400662c:	693b      	ldr	r3, [r7, #16]
2400662e:	015a      	lsls	r2, r3, #5
24006630:	4b6d      	ldr	r3, [pc, #436]	; (240067e8 <HAL_EXTI_SetConfigLine+0x240>)
24006632:	4413      	add	r3, r2
24006634:	61fb      	str	r3, [r7, #28]
    regval = *regaddr;
24006636:	69fb      	ldr	r3, [r7, #28]
24006638:	681b      	ldr	r3, [r3, #0]
2400663a:	61bb      	str	r3, [r7, #24]

    /* Mask or set line */
    if ((pExtiConfig->Trigger & EXTI_TRIGGER_FALLING) != 0x00U)
2400663c:	683b      	ldr	r3, [r7, #0]
2400663e:	689b      	ldr	r3, [r3, #8]
24006640:	f003 0302 	and.w	r3, r3, #2
24006644:	2b00      	cmp	r3, #0
24006646:	d004      	beq.n	24006652 <HAL_EXTI_SetConfigLine+0xaa>
    {
      regval |= maskline;
24006648:	69ba      	ldr	r2, [r7, #24]
2400664a:	68bb      	ldr	r3, [r7, #8]
2400664c:	4313      	orrs	r3, r2
2400664e:	61bb      	str	r3, [r7, #24]
24006650:	e004      	b.n	2400665c <HAL_EXTI_SetConfigLine+0xb4>
    }
    else
    {
      regval &= ~maskline;
24006652:	68bb      	ldr	r3, [r7, #8]
24006654:	43db      	mvns	r3, r3
24006656:	69ba      	ldr	r2, [r7, #24]
24006658:	4013      	ands	r3, r2
2400665a:	61bb      	str	r3, [r7, #24]
    }

    /* Store falling trigger mode */
    *regaddr = regval;
2400665c:	69fb      	ldr	r3, [r7, #28]
2400665e:	69ba      	ldr	r2, [r7, #24]
24006660:	601a      	str	r2, [r3, #0]

    /* Configure gpio port selection in case of gpio exti line */
    if ((pExtiConfig->Line & EXTI_GPIO) == EXTI_GPIO)
24006662:	683b      	ldr	r3, [r7, #0]
24006664:	681b      	ldr	r3, [r3, #0]
24006666:	f003 63c0 	and.w	r3, r3, #100663296	; 0x6000000
2400666a:	f1b3 6fc0 	cmp.w	r3, #100663296	; 0x6000000
2400666e:	d127      	bne.n	240066c0 <HAL_EXTI_SetConfigLine+0x118>
    {
      assert_param(IS_EXTI_GPIO_PORT(pExtiConfig->GPIOSel));
      assert_param(IS_EXTI_GPIO_PIN(linepos));

      regval = SYSCFG->EXTICR[(linepos >> 2U) & 0x03UL];
24006670:	4a5e      	ldr	r2, [pc, #376]	; (240067ec <HAL_EXTI_SetConfigLine+0x244>)
24006672:	68fb      	ldr	r3, [r7, #12]
24006674:	089b      	lsrs	r3, r3, #2
24006676:	f003 0303 	and.w	r3, r3, #3
2400667a:	3302      	adds	r3, #2
2400667c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
24006680:	61bb      	str	r3, [r7, #24]
      regval &= ~(SYSCFG_EXTICR1_EXTI0 << (SYSCFG_EXTICR1_EXTI1_Pos * (linepos & 0x03U)));
24006682:	68fb      	ldr	r3, [r7, #12]
24006684:	f003 0303 	and.w	r3, r3, #3
24006688:	009b      	lsls	r3, r3, #2
2400668a:	220f      	movs	r2, #15
2400668c:	fa02 f303 	lsl.w	r3, r2, r3
24006690:	43db      	mvns	r3, r3
24006692:	69ba      	ldr	r2, [r7, #24]
24006694:	4013      	ands	r3, r2
24006696:	61bb      	str	r3, [r7, #24]
      regval |= (pExtiConfig->GPIOSel << (SYSCFG_EXTICR1_EXTI1_Pos * (linepos & 0x03U)));
24006698:	683b      	ldr	r3, [r7, #0]
2400669a:	68da      	ldr	r2, [r3, #12]
2400669c:	68fb      	ldr	r3, [r7, #12]
2400669e:	f003 0303 	and.w	r3, r3, #3
240066a2:	009b      	lsls	r3, r3, #2
240066a4:	fa02 f303 	lsl.w	r3, r2, r3
240066a8:	69ba      	ldr	r2, [r7, #24]
240066aa:	4313      	orrs	r3, r2
240066ac:	61bb      	str	r3, [r7, #24]
      SYSCFG->EXTICR[(linepos >> 2U) & 0x03UL] = regval;
240066ae:	494f      	ldr	r1, [pc, #316]	; (240067ec <HAL_EXTI_SetConfigLine+0x244>)
240066b0:	68fb      	ldr	r3, [r7, #12]
240066b2:	089b      	lsrs	r3, r3, #2
240066b4:	f003 0303 	and.w	r3, r3, #3
240066b8:	3302      	adds	r3, #2
240066ba:	69ba      	ldr	r2, [r7, #24]
240066bc:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
  }

  /* Configure interrupt mode : read current mode */
  regaddr = (__IO uint32_t *)(&EXTI->IMR1 + (EXTI_MODE_OFFSET * offset));
240066c0:	693b      	ldr	r3, [r7, #16]
240066c2:	011a      	lsls	r2, r3, #4
240066c4:	4b4a      	ldr	r3, [pc, #296]	; (240067f0 <HAL_EXTI_SetConfigLine+0x248>)
240066c6:	4413      	add	r3, r2
240066c8:	61fb      	str	r3, [r7, #28]
  regval = *regaddr;
240066ca:	69fb      	ldr	r3, [r7, #28]
240066cc:	681b      	ldr	r3, [r3, #0]
240066ce:	61bb      	str	r3, [r7, #24]

  /* Mask or set line */
  if ((pExtiConfig->Mode & EXTI_MODE_INTERRUPT) != 0x00U)
240066d0:	683b      	ldr	r3, [r7, #0]
240066d2:	685b      	ldr	r3, [r3, #4]
240066d4:	f003 0301 	and.w	r3, r3, #1
240066d8:	2b00      	cmp	r3, #0
240066da:	d004      	beq.n	240066e6 <HAL_EXTI_SetConfigLine+0x13e>
  {
    regval |= maskline;
240066dc:	69ba      	ldr	r2, [r7, #24]
240066de:	68bb      	ldr	r3, [r7, #8]
240066e0:	4313      	orrs	r3, r2
240066e2:	61bb      	str	r3, [r7, #24]
240066e4:	e004      	b.n	240066f0 <HAL_EXTI_SetConfigLine+0x148>
  }
  else
  {
    regval &= ~maskline;
240066e6:	68bb      	ldr	r3, [r7, #8]
240066e8:	43db      	mvns	r3, r3
240066ea:	69ba      	ldr	r2, [r7, #24]
240066ec:	4013      	ands	r3, r2
240066ee:	61bb      	str	r3, [r7, #24]
  }

  /* Store interrupt mode */
  *regaddr = regval;
240066f0:	69fb      	ldr	r3, [r7, #28]
240066f2:	69ba      	ldr	r2, [r7, #24]
240066f4:	601a      	str	r2, [r3, #0]

  /* The event mode cannot be configured if the line does not support it */
  assert_param(((pExtiConfig->Line & EXTI_EVENT) == EXTI_EVENT) || ((pExtiConfig->Mode & EXTI_MODE_EVENT) != EXTI_MODE_EVENT));

  /* Configure event mode : read current mode */
  regaddr = (__IO uint32_t *)(&EXTI->EMR1 + (EXTI_MODE_OFFSET * offset));
240066f6:	693b      	ldr	r3, [r7, #16]
240066f8:	011a      	lsls	r2, r3, #4
240066fa:	4b3e      	ldr	r3, [pc, #248]	; (240067f4 <HAL_EXTI_SetConfigLine+0x24c>)
240066fc:	4413      	add	r3, r2
240066fe:	61fb      	str	r3, [r7, #28]
  regval = *regaddr;
24006700:	69fb      	ldr	r3, [r7, #28]
24006702:	681b      	ldr	r3, [r3, #0]
24006704:	61bb      	str	r3, [r7, #24]

  /* Mask or set line */
  if ((pExtiConfig->Mode & EXTI_MODE_EVENT) != 0x00U)
24006706:	683b      	ldr	r3, [r7, #0]
24006708:	685b      	ldr	r3, [r3, #4]
2400670a:	f003 0302 	and.w	r3, r3, #2
2400670e:	2b00      	cmp	r3, #0
24006710:	d004      	beq.n	2400671c <HAL_EXTI_SetConfigLine+0x174>
  {
    regval |= maskline;
24006712:	69ba      	ldr	r2, [r7, #24]
24006714:	68bb      	ldr	r3, [r7, #8]
24006716:	4313      	orrs	r3, r2
24006718:	61bb      	str	r3, [r7, #24]
2400671a:	e004      	b.n	24006726 <HAL_EXTI_SetConfigLine+0x17e>
  }
  else
  {
    regval &= ~maskline;
2400671c:	68bb      	ldr	r3, [r7, #8]
2400671e:	43db      	mvns	r3, r3
24006720:	69ba      	ldr	r2, [r7, #24]
24006722:	4013      	ands	r3, r2
24006724:	61bb      	str	r3, [r7, #24]
  }

  /* Store event mode */
  *regaddr = regval;
24006726:	69fb      	ldr	r3, [r7, #28]
24006728:	69ba      	ldr	r2, [r7, #24]
2400672a:	601a      	str	r2, [r3, #0]
  /* Store event mode */
  *regaddr = regval;
#endif /* DUAL_CORE */

  /* Configure the D3 PendClear source in case of Wakeup target is Any */
  if ((pExtiConfig->Line & EXTI_TARGET_MASK) == EXTI_TARGET_MSK_ALL)
2400672c:	683b      	ldr	r3, [r7, #0]
2400672e:	681b      	ldr	r3, [r3, #0]
24006730:	f403 1340 	and.w	r3, r3, #3145728	; 0x300000
24006734:	f5b3 1f40 	cmp.w	r3, #3145728	; 0x300000
24006738:	d14e      	bne.n	240067d8 <HAL_EXTI_SetConfigLine+0x230>
  {
    assert_param(IS_EXTI_D3_PENDCLR_SRC(pExtiConfig->PendClearSource));

    /*Calc the PMR register address for the given line */
    regaddr = (__IO uint32_t *)(&EXTI->D3PMR1 + (EXTI_CONFIG_OFFSET * offset));
2400673a:	693b      	ldr	r3, [r7, #16]
2400673c:	015a      	lsls	r2, r3, #5
2400673e:	4b2e      	ldr	r3, [pc, #184]	; (240067f8 <HAL_EXTI_SetConfigLine+0x250>)
24006740:	4413      	add	r3, r2
24006742:	61fb      	str	r3, [r7, #28]
    regval = *regaddr;
24006744:	69fb      	ldr	r3, [r7, #28]
24006746:	681b      	ldr	r3, [r3, #0]
24006748:	61bb      	str	r3, [r7, #24]

    if(pExtiConfig->PendClearSource == EXTI_D3_PENDCLR_SRC_NONE)
2400674a:	683b      	ldr	r3, [r7, #0]
2400674c:	691b      	ldr	r3, [r3, #16]
2400674e:	2b00      	cmp	r3, #0
24006750:	d108      	bne.n	24006764 <HAL_EXTI_SetConfigLine+0x1bc>
    {
      /* Clear D3PMRx register for the given line */
      regval &= ~maskline;
24006752:	68bb      	ldr	r3, [r7, #8]
24006754:	43db      	mvns	r3, r3
24006756:	69ba      	ldr	r2, [r7, #24]
24006758:	4013      	ands	r3, r2
2400675a:	61bb      	str	r3, [r7, #24]
      /* Store D3PMRx register value */
      *regaddr = regval;
2400675c:	69fb      	ldr	r3, [r7, #28]
2400675e:	69ba      	ldr	r2, [r7, #24]
24006760:	601a      	str	r2, [r3, #0]
24006762:	e039      	b.n	240067d8 <HAL_EXTI_SetConfigLine+0x230>
    }
    else
    {
      /* Set D3PMRx register to 1 for the given line */
      regval |= maskline;
24006764:	69ba      	ldr	r2, [r7, #24]
24006766:	68bb      	ldr	r3, [r7, #8]
24006768:	4313      	orrs	r3, r2
2400676a:	61bb      	str	r3, [r7, #24]
      /* Store D3PMRx register value */
      *regaddr = regval;
2400676c:	69fb      	ldr	r3, [r7, #28]
2400676e:	69ba      	ldr	r2, [r7, #24]
24006770:	601a      	str	r2, [r3, #0]

      if(linepos < 16UL)
24006772:	68fb      	ldr	r3, [r7, #12]
24006774:	2b0f      	cmp	r3, #15
24006776:	d80a      	bhi.n	2400678e <HAL_EXTI_SetConfigLine+0x1e6>
      {
        regaddr = (__IO uint32_t *)(&EXTI->D3PCR1L + (EXTI_CONFIG_OFFSET * offset));
24006778:	693b      	ldr	r3, [r7, #16]
2400677a:	015a      	lsls	r2, r3, #5
2400677c:	4b1f      	ldr	r3, [pc, #124]	; (240067fc <HAL_EXTI_SetConfigLine+0x254>)
2400677e:	4413      	add	r3, r2
24006780:	61fb      	str	r3, [r7, #28]
        pcrlinepos = 1UL << linepos;
24006782:	2201      	movs	r2, #1
24006784:	68fb      	ldr	r3, [r7, #12]
24006786:	fa02 f303 	lsl.w	r3, r2, r3
2400678a:	617b      	str	r3, [r7, #20]
2400678c:	e00a      	b.n	240067a4 <HAL_EXTI_SetConfigLine+0x1fc>
      }
      else
      {
        regaddr = (__IO uint32_t *)(&EXTI->D3PCR1H + (EXTI_CONFIG_OFFSET * offset));
2400678e:	693b      	ldr	r3, [r7, #16]
24006790:	015a      	lsls	r2, r3, #5
24006792:	4b1b      	ldr	r3, [pc, #108]	; (24006800 <HAL_EXTI_SetConfigLine+0x258>)
24006794:	4413      	add	r3, r2
24006796:	61fb      	str	r3, [r7, #28]
        pcrlinepos = 1UL << (linepos - 16UL);
24006798:	68fb      	ldr	r3, [r7, #12]
2400679a:	3b10      	subs	r3, #16
2400679c:	2201      	movs	r2, #1
2400679e:	fa02 f303 	lsl.w	r3, r2, r3
240067a2:	617b      	str	r3, [r7, #20]
      }

      regval = (*regaddr & (~(pcrlinepos * pcrlinepos * 3UL))) | (pcrlinepos * pcrlinepos * (pExtiConfig->PendClearSource - 1UL));
240067a4:	69fb      	ldr	r3, [r7, #28]
240067a6:	6819      	ldr	r1, [r3, #0]
240067a8:	697b      	ldr	r3, [r7, #20]
240067aa:	697a      	ldr	r2, [r7, #20]
240067ac:	fb02 f203 	mul.w	r2, r2, r3
240067b0:	4613      	mov	r3, r2
240067b2:	005b      	lsls	r3, r3, #1
240067b4:	4413      	add	r3, r2
240067b6:	43db      	mvns	r3, r3
240067b8:	ea01 0203 	and.w	r2, r1, r3
240067bc:	697b      	ldr	r3, [r7, #20]
240067be:	6979      	ldr	r1, [r7, #20]
240067c0:	fb01 f303 	mul.w	r3, r1, r3
240067c4:	6839      	ldr	r1, [r7, #0]
240067c6:	6909      	ldr	r1, [r1, #16]
240067c8:	3901      	subs	r1, #1
240067ca:	fb01 f303 	mul.w	r3, r1, r3
240067ce:	4313      	orrs	r3, r2
240067d0:	61bb      	str	r3, [r7, #24]
      *regaddr = regval;
240067d2:	69fb      	ldr	r3, [r7, #28]
240067d4:	69ba      	ldr	r2, [r7, #24]
240067d6:	601a      	str	r2, [r3, #0]
    }
  }

  return HAL_OK;
240067d8:	2300      	movs	r3, #0
}
240067da:	4618      	mov	r0, r3
240067dc:	3724      	adds	r7, #36	; 0x24
240067de:	46bd      	mov	sp, r7
240067e0:	f85d 7b04 	ldr.w	r7, [sp], #4
240067e4:	4770      	bx	lr
240067e6:	bf00      	nop
240067e8:	58000004 	.word	0x58000004
240067ec:	58000400 	.word	0x58000400
240067f0:	58000080 	.word	0x58000080
240067f4:	58000084 	.word	0x58000084
240067f8:	5800000c 	.word	0x5800000c
240067fc:	58000010 	.word	0x58000010
24006800:	58000014 	.word	0x58000014

24006804 <HAL_EXTI_GetConfigLine>:
  * @param  hexti Exti handle.
  * @param  pExtiConfig Pointer on structure to store Exti configuration.
  * @retval HAL Status.
  */
HAL_StatusTypeDef HAL_EXTI_GetConfigLine(EXTI_HandleTypeDef *hexti, EXTI_ConfigTypeDef *pExtiConfig)
{
24006804:	b480      	push	{r7}
24006806:	b089      	sub	sp, #36	; 0x24
24006808:	af00      	add	r7, sp, #0
2400680a:	6078      	str	r0, [r7, #4]
2400680c:	6039      	str	r1, [r7, #0]
  uint32_t maskline;
  uint32_t offset;
  uint32_t pcrlinepos;

  /* Check null pointer */
  if ((hexti == NULL) || (pExtiConfig == NULL))
2400680e:	687b      	ldr	r3, [r7, #4]
24006810:	2b00      	cmp	r3, #0
24006812:	d002      	beq.n	2400681a <HAL_EXTI_GetConfigLine+0x16>
24006814:	683b      	ldr	r3, [r7, #0]
24006816:	2b00      	cmp	r3, #0
24006818:	d101      	bne.n	2400681e <HAL_EXTI_GetConfigLine+0x1a>
  {
    return HAL_ERROR;
2400681a:	2301      	movs	r3, #1
2400681c:	e0d4      	b.n	240069c8 <HAL_EXTI_GetConfigLine+0x1c4>

  /* Check the parameter */
  assert_param(IS_EXTI_LINE(hexti->Line));

  /* Store handle line number to configuration structure */
  pExtiConfig->Line = hexti->Line;
2400681e:	687b      	ldr	r3, [r7, #4]
24006820:	681a      	ldr	r2, [r3, #0]
24006822:	683b      	ldr	r3, [r7, #0]
24006824:	601a      	str	r2, [r3, #0]

  /* compute line register offset and line mask */
  offset = ((pExtiConfig->Line & EXTI_REG_MASK) >> EXTI_REG_SHIFT);
24006826:	683b      	ldr	r3, [r7, #0]
24006828:	681b      	ldr	r3, [r3, #0]
2400682a:	0c1b      	lsrs	r3, r3, #16
2400682c:	f003 0303 	and.w	r3, r3, #3
24006830:	617b      	str	r3, [r7, #20]
  linepos = (pExtiConfig->Line & EXTI_PIN_MASK);
24006832:	683b      	ldr	r3, [r7, #0]
24006834:	681b      	ldr	r3, [r3, #0]
24006836:	f003 031f 	and.w	r3, r3, #31
2400683a:	613b      	str	r3, [r7, #16]
  maskline = (1UL << linepos);
2400683c:	2201      	movs	r2, #1
2400683e:	693b      	ldr	r3, [r7, #16]
24006840:	fa02 f303 	lsl.w	r3, r2, r3
24006844:	60fb      	str	r3, [r7, #12]

  /* 1] Get core mode : interrupt */
  regaddr = (__IO uint32_t *)(&EXTI->IMR1 + (EXTI_MODE_OFFSET * offset));
24006846:	697b      	ldr	r3, [r7, #20]
24006848:	011a      	lsls	r2, r3, #4
2400684a:	4b62      	ldr	r3, [pc, #392]	; (240069d4 <HAL_EXTI_GetConfigLine+0x1d0>)
2400684c:	4413      	add	r3, r2
2400684e:	61fb      	str	r3, [r7, #28]
  regval = *regaddr;
24006850:	69fb      	ldr	r3, [r7, #28]
24006852:	681b      	ldr	r3, [r3, #0]
24006854:	60bb      	str	r3, [r7, #8]

  pExtiConfig->Mode = EXTI_MODE_NONE;
24006856:	683b      	ldr	r3, [r7, #0]
24006858:	2200      	movs	r2, #0
2400685a:	605a      	str	r2, [r3, #4]

  /* Check if selected line is enable */
  if ((regval & maskline) != 0x00U)
2400685c:	68ba      	ldr	r2, [r7, #8]
2400685e:	68fb      	ldr	r3, [r7, #12]
24006860:	4013      	ands	r3, r2
24006862:	2b00      	cmp	r3, #0
24006864:	d002      	beq.n	2400686c <HAL_EXTI_GetConfigLine+0x68>
  {
    pExtiConfig->Mode = EXTI_MODE_INTERRUPT;
24006866:	683b      	ldr	r3, [r7, #0]
24006868:	2201      	movs	r2, #1
2400686a:	605a      	str	r2, [r3, #4]
  }

  /* Get event mode */
  regaddr = (__IO uint32_t *)(&EXTI->EMR1 + (EXTI_MODE_OFFSET * offset));
2400686c:	697b      	ldr	r3, [r7, #20]
2400686e:	011a      	lsls	r2, r3, #4
24006870:	4b59      	ldr	r3, [pc, #356]	; (240069d8 <HAL_EXTI_GetConfigLine+0x1d4>)
24006872:	4413      	add	r3, r2
24006874:	61fb      	str	r3, [r7, #28]
  regval = *regaddr;
24006876:	69fb      	ldr	r3, [r7, #28]
24006878:	681b      	ldr	r3, [r3, #0]
2400687a:	60bb      	str	r3, [r7, #8]

  /* Check if selected line is enable */
  if ((regval & maskline) != 0x00U)
2400687c:	68ba      	ldr	r2, [r7, #8]
2400687e:	68fb      	ldr	r3, [r7, #12]
24006880:	4013      	ands	r3, r2
24006882:	2b00      	cmp	r3, #0
24006884:	d005      	beq.n	24006892 <HAL_EXTI_GetConfigLine+0x8e>
  {
    pExtiConfig->Mode |= EXTI_MODE_EVENT;
24006886:	683b      	ldr	r3, [r7, #0]
24006888:	685b      	ldr	r3, [r3, #4]
2400688a:	f043 0202 	orr.w	r2, r3, #2
2400688e:	683b      	ldr	r3, [r7, #0]
24006890:	605a      	str	r2, [r3, #4]
    pExtiConfig->Mode |= EXTI_MODE_CORE2_EVENT;
  }
#endif /*DUAL_CORE*/

  /* 2] Get trigger for configurable lines : rising */
  if ((pExtiConfig->Line & EXTI_CONFIG) != 0x00U)
24006892:	683b      	ldr	r3, [r7, #0]
24006894:	681b      	ldr	r3, [r3, #0]
24006896:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
2400689a:	2b00      	cmp	r3, #0
2400689c:	d046      	beq.n	2400692c <HAL_EXTI_GetConfigLine+0x128>
  {
    regaddr = (__IO uint32_t *)(&EXTI->RTSR1 + (EXTI_CONFIG_OFFSET * offset));
2400689e:	697b      	ldr	r3, [r7, #20]
240068a0:	015b      	lsls	r3, r3, #5
240068a2:	f103 43b0 	add.w	r3, r3, #1476395008	; 0x58000000
240068a6:	61fb      	str	r3, [r7, #28]
    regval = *regaddr;
240068a8:	69fb      	ldr	r3, [r7, #28]
240068aa:	681b      	ldr	r3, [r3, #0]
240068ac:	60bb      	str	r3, [r7, #8]

    /* Check if configuration of selected line is enable */
    if ((regval & maskline) != 0x00U)
240068ae:	68ba      	ldr	r2, [r7, #8]
240068b0:	68fb      	ldr	r3, [r7, #12]
240068b2:	4013      	ands	r3, r2
240068b4:	2b00      	cmp	r3, #0
240068b6:	d003      	beq.n	240068c0 <HAL_EXTI_GetConfigLine+0xbc>
    {
      pExtiConfig->Trigger = EXTI_TRIGGER_RISING;
240068b8:	683b      	ldr	r3, [r7, #0]
240068ba:	2201      	movs	r2, #1
240068bc:	609a      	str	r2, [r3, #8]
240068be:	e002      	b.n	240068c6 <HAL_EXTI_GetConfigLine+0xc2>
    }
    else
    {
      pExtiConfig->Trigger = EXTI_TRIGGER_NONE;
240068c0:	683b      	ldr	r3, [r7, #0]
240068c2:	2200      	movs	r2, #0
240068c4:	609a      	str	r2, [r3, #8]
    }

    /* Get falling configuration */
    regaddr = (__IO uint32_t *)(&EXTI->FTSR1 + (EXTI_CONFIG_OFFSET * offset));
240068c6:	697b      	ldr	r3, [r7, #20]
240068c8:	015a      	lsls	r2, r3, #5
240068ca:	4b44      	ldr	r3, [pc, #272]	; (240069dc <HAL_EXTI_GetConfigLine+0x1d8>)
240068cc:	4413      	add	r3, r2
240068ce:	61fb      	str	r3, [r7, #28]
    regval = *regaddr;
240068d0:	69fb      	ldr	r3, [r7, #28]
240068d2:	681b      	ldr	r3, [r3, #0]
240068d4:	60bb      	str	r3, [r7, #8]

    /* Check if configuration of selected line is enable */
    if ((regval & maskline) != 0x00U)
240068d6:	68ba      	ldr	r2, [r7, #8]
240068d8:	68fb      	ldr	r3, [r7, #12]
240068da:	4013      	ands	r3, r2
240068dc:	2b00      	cmp	r3, #0
240068de:	d005      	beq.n	240068ec <HAL_EXTI_GetConfigLine+0xe8>
    {
      pExtiConfig->Trigger |= EXTI_TRIGGER_FALLING;
240068e0:	683b      	ldr	r3, [r7, #0]
240068e2:	689b      	ldr	r3, [r3, #8]
240068e4:	f043 0202 	orr.w	r2, r3, #2
240068e8:	683b      	ldr	r3, [r7, #0]
240068ea:	609a      	str	r2, [r3, #8]
    }

    /* Get Gpio port selection for gpio lines */
    if ((pExtiConfig->Line & EXTI_GPIO) == EXTI_GPIO)
240068ec:	683b      	ldr	r3, [r7, #0]
240068ee:	681b      	ldr	r3, [r3, #0]
240068f0:	f003 63c0 	and.w	r3, r3, #100663296	; 0x6000000
240068f4:	f1b3 6fc0 	cmp.w	r3, #100663296	; 0x6000000
240068f8:	d114      	bne.n	24006924 <HAL_EXTI_GetConfigLine+0x120>
    {
      assert_param(IS_EXTI_GPIO_PIN(linepos));

      regval = SYSCFG->EXTICR[(linepos >> 2U) & 0x03UL];
240068fa:	4a39      	ldr	r2, [pc, #228]	; (240069e0 <HAL_EXTI_GetConfigLine+0x1dc>)
240068fc:	693b      	ldr	r3, [r7, #16]
240068fe:	089b      	lsrs	r3, r3, #2
24006900:	f003 0303 	and.w	r3, r3, #3
24006904:	3302      	adds	r3, #2
24006906:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
2400690a:	60bb      	str	r3, [r7, #8]
      pExtiConfig->GPIOSel = ((regval << (SYSCFG_EXTICR1_EXTI1_Pos * (3UL - (linepos & 0x03UL)))) >> 24U);
2400690c:	693b      	ldr	r3, [r7, #16]
2400690e:	43db      	mvns	r3, r3
24006910:	f003 0303 	and.w	r3, r3, #3
24006914:	009b      	lsls	r3, r3, #2
24006916:	68ba      	ldr	r2, [r7, #8]
24006918:	fa02 f303 	lsl.w	r3, r2, r3
2400691c:	0e1a      	lsrs	r2, r3, #24
2400691e:	683b      	ldr	r3, [r7, #0]
24006920:	60da      	str	r2, [r3, #12]
24006922:	e009      	b.n	24006938 <HAL_EXTI_GetConfigLine+0x134>
    }
    else
    {
      pExtiConfig->GPIOSel = 0x00U;
24006924:	683b      	ldr	r3, [r7, #0]
24006926:	2200      	movs	r2, #0
24006928:	60da      	str	r2, [r3, #12]
2400692a:	e005      	b.n	24006938 <HAL_EXTI_GetConfigLine+0x134>
    }
  }
  else
  {
    pExtiConfig->Trigger = EXTI_TRIGGER_NONE;
2400692c:	683b      	ldr	r3, [r7, #0]
2400692e:	2200      	movs	r2, #0
24006930:	609a      	str	r2, [r3, #8]
    pExtiConfig->GPIOSel = 0x00U;
24006932:	683b      	ldr	r3, [r7, #0]
24006934:	2200      	movs	r2, #0
24006936:	60da      	str	r2, [r3, #12]
  }

  /* 3] Get D3 Pend Clear source */
  if ((pExtiConfig->Line & EXTI_TARGET_MASK) == EXTI_TARGET_MSK_ALL)
24006938:	683b      	ldr	r3, [r7, #0]
2400693a:	681b      	ldr	r3, [r3, #0]
2400693c:	f403 1340 	and.w	r3, r3, #3145728	; 0x300000
24006940:	f5b3 1f40 	cmp.w	r3, #3145728	; 0x300000
24006944:	d13c      	bne.n	240069c0 <HAL_EXTI_GetConfigLine+0x1bc>
  {
    regaddr = (__IO uint32_t *)(&EXTI->D3PMR1 + (EXTI_CONFIG_OFFSET * offset));
24006946:	697b      	ldr	r3, [r7, #20]
24006948:	015a      	lsls	r2, r3, #5
2400694a:	4b26      	ldr	r3, [pc, #152]	; (240069e4 <HAL_EXTI_GetConfigLine+0x1e0>)
2400694c:	4413      	add	r3, r2
2400694e:	61fb      	str	r3, [r7, #28]
    if(((*regaddr) & linepos) == 0UL)
24006950:	69fb      	ldr	r3, [r7, #28]
24006952:	681a      	ldr	r2, [r3, #0]
24006954:	693b      	ldr	r3, [r7, #16]
24006956:	4013      	ands	r3, r2
24006958:	2b00      	cmp	r3, #0
2400695a:	d103      	bne.n	24006964 <HAL_EXTI_GetConfigLine+0x160>
    {
      /* if PMR unset, then no pend clear source is used */
      pExtiConfig->PendClearSource = EXTI_D3_PENDCLR_SRC_NONE;
2400695c:	683b      	ldr	r3, [r7, #0]
2400695e:	2200      	movs	r2, #0
24006960:	611a      	str	r2, [r3, #16]
24006962:	e030      	b.n	240069c6 <HAL_EXTI_GetConfigLine+0x1c2>
    }
    else
    {
      /* if wakeup target is any and PMR set, the read pend clear source from  D3PCRxL/H */
      if(linepos < 16UL)
24006964:	693b      	ldr	r3, [r7, #16]
24006966:	2b0f      	cmp	r3, #15
24006968:	d80a      	bhi.n	24006980 <HAL_EXTI_GetConfigLine+0x17c>
      {
        regaddr = (__IO uint32_t *)(&EXTI->D3PCR1L + (EXTI_CONFIG_OFFSET * offset));
2400696a:	697b      	ldr	r3, [r7, #20]
2400696c:	015a      	lsls	r2, r3, #5
2400696e:	4b1e      	ldr	r3, [pc, #120]	; (240069e8 <HAL_EXTI_GetConfigLine+0x1e4>)
24006970:	4413      	add	r3, r2
24006972:	61fb      	str	r3, [r7, #28]
        pcrlinepos = 1UL << linepos;
24006974:	2201      	movs	r2, #1
24006976:	693b      	ldr	r3, [r7, #16]
24006978:	fa02 f303 	lsl.w	r3, r2, r3
2400697c:	61bb      	str	r3, [r7, #24]
2400697e:	e00a      	b.n	24006996 <HAL_EXTI_GetConfigLine+0x192>
      }
      else
      {
        regaddr = (__IO uint32_t *)(&EXTI->D3PCR1H + (EXTI_CONFIG_OFFSET * offset));
24006980:	697b      	ldr	r3, [r7, #20]
24006982:	015a      	lsls	r2, r3, #5
24006984:	4b19      	ldr	r3, [pc, #100]	; (240069ec <HAL_EXTI_GetConfigLine+0x1e8>)
24006986:	4413      	add	r3, r2
24006988:	61fb      	str	r3, [r7, #28]
        pcrlinepos = 1UL << (linepos - 16UL);
2400698a:	693b      	ldr	r3, [r7, #16]
2400698c:	3b10      	subs	r3, #16
2400698e:	2201      	movs	r2, #1
24006990:	fa02 f303 	lsl.w	r3, r2, r3
24006994:	61bb      	str	r3, [r7, #24]
      }

      pExtiConfig->PendClearSource = 1UL + ((*regaddr & (pcrlinepos * pcrlinepos * 3UL)) / (pcrlinepos * pcrlinepos));
24006996:	69fb      	ldr	r3, [r7, #28]
24006998:	6819      	ldr	r1, [r3, #0]
2400699a:	69bb      	ldr	r3, [r7, #24]
2400699c:	69ba      	ldr	r2, [r7, #24]
2400699e:	fb02 f203 	mul.w	r2, r2, r3
240069a2:	4613      	mov	r3, r2
240069a4:	005b      	lsls	r3, r3, #1
240069a6:	4413      	add	r3, r2
240069a8:	ea01 0203 	and.w	r2, r1, r3
240069ac:	69bb      	ldr	r3, [r7, #24]
240069ae:	69b9      	ldr	r1, [r7, #24]
240069b0:	fb01 f303 	mul.w	r3, r1, r3
240069b4:	fbb2 f3f3 	udiv	r3, r2, r3
240069b8:	1c5a      	adds	r2, r3, #1
240069ba:	683b      	ldr	r3, [r7, #0]
240069bc:	611a      	str	r2, [r3, #16]
240069be:	e002      	b.n	240069c6 <HAL_EXTI_GetConfigLine+0x1c2>
    }
  }
  else
  {
    /* if line wakeup target is not any, then no pend clear source is used  */
    pExtiConfig->PendClearSource = EXTI_D3_PENDCLR_SRC_NONE;
240069c0:	683b      	ldr	r3, [r7, #0]
240069c2:	2200      	movs	r2, #0
240069c4:	611a      	str	r2, [r3, #16]
  }

  return HAL_OK;
240069c6:	2300      	movs	r3, #0
}
240069c8:	4618      	mov	r0, r3
240069ca:	3724      	adds	r7, #36	; 0x24
240069cc:	46bd      	mov	sp, r7
240069ce:	f85d 7b04 	ldr.w	r7, [sp], #4
240069d2:	4770      	bx	lr
240069d4:	58000080 	.word	0x58000080
240069d8:	58000084 	.word	0x58000084
240069dc:	58000004 	.word	0x58000004
240069e0:	58000400 	.word	0x58000400
240069e4:	5800000c 	.word	0x5800000c
240069e8:	58000010 	.word	0x58000010
240069ec:	58000014 	.word	0x58000014

240069f0 <HAL_EXTI_ClearConfigLine>:
  * @brief  Clear whole configuration of a dedicated Exti line.
  * @param  hexti Exti handle.
  * @retval HAL Status.
  */
HAL_StatusTypeDef HAL_EXTI_ClearConfigLine(EXTI_HandleTypeDef *hexti)
{
240069f0:	b480      	push	{r7}
240069f2:	b089      	sub	sp, #36	; 0x24
240069f4:	af00      	add	r7, sp, #0
240069f6:	6078      	str	r0, [r7, #4]
  uint32_t maskline;
  uint32_t offset;
  uint32_t pcrlinepos;

  /* Check null pointer */
  if (hexti == NULL)
240069f8:	687b      	ldr	r3, [r7, #4]
240069fa:	2b00      	cmp	r3, #0
240069fc:	d101      	bne.n	24006a02 <HAL_EXTI_ClearConfigLine+0x12>
  {
    return HAL_ERROR;
240069fe:	2301      	movs	r3, #1
24006a00:	e0ac      	b.n	24006b5c <HAL_EXTI_ClearConfigLine+0x16c>

  /* Check the parameter */
  assert_param(IS_EXTI_LINE(hexti->Line));

  /* compute line register offset and line mask */
  offset = ((hexti->Line & EXTI_REG_MASK) >> EXTI_REG_SHIFT);
24006a02:	687b      	ldr	r3, [r7, #4]
24006a04:	681b      	ldr	r3, [r3, #0]
24006a06:	0c1b      	lsrs	r3, r3, #16
24006a08:	f003 0303 	and.w	r3, r3, #3
24006a0c:	617b      	str	r3, [r7, #20]
  linepos = (hexti->Line & EXTI_PIN_MASK);
24006a0e:	687b      	ldr	r3, [r7, #4]
24006a10:	681b      	ldr	r3, [r3, #0]
24006a12:	f003 031f 	and.w	r3, r3, #31
24006a16:	613b      	str	r3, [r7, #16]
  maskline = (1UL << linepos);
24006a18:	2201      	movs	r2, #1
24006a1a:	693b      	ldr	r3, [r7, #16]
24006a1c:	fa02 f303 	lsl.w	r3, r2, r3
24006a20:	60fb      	str	r3, [r7, #12]

  /* 1] Clear interrupt mode */
  regaddr = (__IO uint32_t *)(&EXTI->IMR1 + (EXTI_MODE_OFFSET * offset));
24006a22:	697b      	ldr	r3, [r7, #20]
24006a24:	011a      	lsls	r2, r3, #4
24006a26:	4b50      	ldr	r3, [pc, #320]	; (24006b68 <HAL_EXTI_ClearConfigLine+0x178>)
24006a28:	4413      	add	r3, r2
24006a2a:	61fb      	str	r3, [r7, #28]
  regval = (*regaddr & ~maskline);
24006a2c:	69fb      	ldr	r3, [r7, #28]
24006a2e:	681a      	ldr	r2, [r3, #0]
24006a30:	68fb      	ldr	r3, [r7, #12]
24006a32:	43db      	mvns	r3, r3
24006a34:	4013      	ands	r3, r2
24006a36:	60bb      	str	r3, [r7, #8]
  *regaddr = regval;
24006a38:	69fb      	ldr	r3, [r7, #28]
24006a3a:	68ba      	ldr	r2, [r7, #8]
24006a3c:	601a      	str	r2, [r3, #0]

  /* 2] Clear event mode */
  regaddr = (__IO uint32_t *)(&EXTI->EMR1 + (EXTI_MODE_OFFSET * offset));
24006a3e:	697b      	ldr	r3, [r7, #20]
24006a40:	011a      	lsls	r2, r3, #4
24006a42:	4b4a      	ldr	r3, [pc, #296]	; (24006b6c <HAL_EXTI_ClearConfigLine+0x17c>)
24006a44:	4413      	add	r3, r2
24006a46:	61fb      	str	r3, [r7, #28]
  regval = (*regaddr & ~maskline);
24006a48:	69fb      	ldr	r3, [r7, #28]
24006a4a:	681a      	ldr	r2, [r3, #0]
24006a4c:	68fb      	ldr	r3, [r7, #12]
24006a4e:	43db      	mvns	r3, r3
24006a50:	4013      	ands	r3, r2
24006a52:	60bb      	str	r3, [r7, #8]
  *regaddr = regval;
24006a54:	69fb      	ldr	r3, [r7, #28]
24006a56:	68ba      	ldr	r2, [r7, #8]
24006a58:	601a      	str	r2, [r3, #0]
  regval = (*regaddr & ~maskline);
  *regaddr = regval;
#endif /* DUAL_CORE */

  /* 3] Clear triggers in case of configurable lines */
  if ((hexti->Line & EXTI_CONFIG) != 0x00U)
24006a5a:	687b      	ldr	r3, [r7, #4]
24006a5c:	681b      	ldr	r3, [r3, #0]
24006a5e:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
24006a62:	2b00      	cmp	r3, #0
24006a64:	d03f      	beq.n	24006ae6 <HAL_EXTI_ClearConfigLine+0xf6>
  {
    regaddr = (__IO uint32_t *)(&EXTI->RTSR1 + (EXTI_CONFIG_OFFSET * offset));
24006a66:	697b      	ldr	r3, [r7, #20]
24006a68:	015b      	lsls	r3, r3, #5
24006a6a:	f103 43b0 	add.w	r3, r3, #1476395008	; 0x58000000
24006a6e:	61fb      	str	r3, [r7, #28]
    regval = (*regaddr & ~maskline);
24006a70:	69fb      	ldr	r3, [r7, #28]
24006a72:	681a      	ldr	r2, [r3, #0]
24006a74:	68fb      	ldr	r3, [r7, #12]
24006a76:	43db      	mvns	r3, r3
24006a78:	4013      	ands	r3, r2
24006a7a:	60bb      	str	r3, [r7, #8]
    *regaddr = regval;
24006a7c:	69fb      	ldr	r3, [r7, #28]
24006a7e:	68ba      	ldr	r2, [r7, #8]
24006a80:	601a      	str	r2, [r3, #0]

    regaddr = (__IO uint32_t *)(&EXTI->FTSR1 + (EXTI_CONFIG_OFFSET * offset));
24006a82:	697b      	ldr	r3, [r7, #20]
24006a84:	015a      	lsls	r2, r3, #5
24006a86:	4b3a      	ldr	r3, [pc, #232]	; (24006b70 <HAL_EXTI_ClearConfigLine+0x180>)
24006a88:	4413      	add	r3, r2
24006a8a:	61fb      	str	r3, [r7, #28]
    regval = (*regaddr & ~maskline);
24006a8c:	69fb      	ldr	r3, [r7, #28]
24006a8e:	681a      	ldr	r2, [r3, #0]
24006a90:	68fb      	ldr	r3, [r7, #12]
24006a92:	43db      	mvns	r3, r3
24006a94:	4013      	ands	r3, r2
24006a96:	60bb      	str	r3, [r7, #8]
    *regaddr = regval;
24006a98:	69fb      	ldr	r3, [r7, #28]
24006a9a:	68ba      	ldr	r2, [r7, #8]
24006a9c:	601a      	str	r2, [r3, #0]

    /* Get Gpio port selection for gpio lines */
    if ((hexti->Line & EXTI_GPIO) == EXTI_GPIO)
24006a9e:	687b      	ldr	r3, [r7, #4]
24006aa0:	681b      	ldr	r3, [r3, #0]
24006aa2:	f003 63c0 	and.w	r3, r3, #100663296	; 0x6000000
24006aa6:	f1b3 6fc0 	cmp.w	r3, #100663296	; 0x6000000
24006aaa:	d11c      	bne.n	24006ae6 <HAL_EXTI_ClearConfigLine+0xf6>
    {
      assert_param(IS_EXTI_GPIO_PIN(linepos));

      regval = SYSCFG->EXTICR[(linepos >> 2U) & 0x03UL];
24006aac:	4a31      	ldr	r2, [pc, #196]	; (24006b74 <HAL_EXTI_ClearConfigLine+0x184>)
24006aae:	693b      	ldr	r3, [r7, #16]
24006ab0:	089b      	lsrs	r3, r3, #2
24006ab2:	f003 0303 	and.w	r3, r3, #3
24006ab6:	3302      	adds	r3, #2
24006ab8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
24006abc:	60bb      	str	r3, [r7, #8]
      regval &= ~(SYSCFG_EXTICR1_EXTI0 << (SYSCFG_EXTICR1_EXTI1_Pos * (linepos & 0x03UL)));
24006abe:	693b      	ldr	r3, [r7, #16]
24006ac0:	f003 0303 	and.w	r3, r3, #3
24006ac4:	009b      	lsls	r3, r3, #2
24006ac6:	220f      	movs	r2, #15
24006ac8:	fa02 f303 	lsl.w	r3, r2, r3
24006acc:	43db      	mvns	r3, r3
24006ace:	68ba      	ldr	r2, [r7, #8]
24006ad0:	4013      	ands	r3, r2
24006ad2:	60bb      	str	r3, [r7, #8]
      SYSCFG->EXTICR[(linepos >> 2U) & 0x03UL] = regval;
24006ad4:	4927      	ldr	r1, [pc, #156]	; (24006b74 <HAL_EXTI_ClearConfigLine+0x184>)
24006ad6:	693b      	ldr	r3, [r7, #16]
24006ad8:	089b      	lsrs	r3, r3, #2
24006ada:	f003 0303 	and.w	r3, r3, #3
24006ade:	3302      	adds	r3, #2
24006ae0:	68ba      	ldr	r2, [r7, #8]
24006ae2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
  }

  /* 4] Clear D3 Config lines */
  if ((hexti->Line & EXTI_TARGET_MASK) == EXTI_TARGET_MSK_ALL)
24006ae6:	687b      	ldr	r3, [r7, #4]
24006ae8:	681b      	ldr	r3, [r3, #0]
24006aea:	f403 1340 	and.w	r3, r3, #3145728	; 0x300000
24006aee:	f5b3 1f40 	cmp.w	r3, #3145728	; 0x300000
24006af2:	d132      	bne.n	24006b5a <HAL_EXTI_ClearConfigLine+0x16a>
  {
    regaddr = (__IO uint32_t *)(&EXTI->D3PMR1 + (EXTI_CONFIG_OFFSET * offset));
24006af4:	697b      	ldr	r3, [r7, #20]
24006af6:	015a      	lsls	r2, r3, #5
24006af8:	4b1f      	ldr	r3, [pc, #124]	; (24006b78 <HAL_EXTI_ClearConfigLine+0x188>)
24006afa:	4413      	add	r3, r2
24006afc:	61fb      	str	r3, [r7, #28]
    *regaddr = (*regaddr & ~maskline);
24006afe:	69fb      	ldr	r3, [r7, #28]
24006b00:	681a      	ldr	r2, [r3, #0]
24006b02:	68fb      	ldr	r3, [r7, #12]
24006b04:	43db      	mvns	r3, r3
24006b06:	401a      	ands	r2, r3
24006b08:	69fb      	ldr	r3, [r7, #28]
24006b0a:	601a      	str	r2, [r3, #0]

    if(linepos < 16UL)
24006b0c:	693b      	ldr	r3, [r7, #16]
24006b0e:	2b0f      	cmp	r3, #15
24006b10:	d80a      	bhi.n	24006b28 <HAL_EXTI_ClearConfigLine+0x138>
    {
      regaddr = (__IO uint32_t *)(&EXTI->D3PCR1L + (EXTI_CONFIG_OFFSET * offset));
24006b12:	697b      	ldr	r3, [r7, #20]
24006b14:	015a      	lsls	r2, r3, #5
24006b16:	4b19      	ldr	r3, [pc, #100]	; (24006b7c <HAL_EXTI_ClearConfigLine+0x18c>)
24006b18:	4413      	add	r3, r2
24006b1a:	61fb      	str	r3, [r7, #28]
      pcrlinepos = 1UL << linepos;
24006b1c:	2201      	movs	r2, #1
24006b1e:	693b      	ldr	r3, [r7, #16]
24006b20:	fa02 f303 	lsl.w	r3, r2, r3
24006b24:	61bb      	str	r3, [r7, #24]
24006b26:	e00a      	b.n	24006b3e <HAL_EXTI_ClearConfigLine+0x14e>
    }
    else
    {
      regaddr = (__IO uint32_t *)(&EXTI->D3PCR1H + (EXTI_CONFIG_OFFSET * offset));
24006b28:	697b      	ldr	r3, [r7, #20]
24006b2a:	015a      	lsls	r2, r3, #5
24006b2c:	4b14      	ldr	r3, [pc, #80]	; (24006b80 <HAL_EXTI_ClearConfigLine+0x190>)
24006b2e:	4413      	add	r3, r2
24006b30:	61fb      	str	r3, [r7, #28]
      pcrlinepos = 1UL << (linepos - 16UL);
24006b32:	693b      	ldr	r3, [r7, #16]
24006b34:	3b10      	subs	r3, #16
24006b36:	2201      	movs	r2, #1
24006b38:	fa02 f303 	lsl.w	r3, r2, r3
24006b3c:	61bb      	str	r3, [r7, #24]
    }

    /*Clear D3 PendClear source */
    *regaddr &= (~(pcrlinepos * pcrlinepos * 3UL));
24006b3e:	69fb      	ldr	r3, [r7, #28]
24006b40:	6819      	ldr	r1, [r3, #0]
24006b42:	69bb      	ldr	r3, [r7, #24]
24006b44:	69ba      	ldr	r2, [r7, #24]
24006b46:	fb02 f203 	mul.w	r2, r2, r3
24006b4a:	4613      	mov	r3, r2
24006b4c:	005b      	lsls	r3, r3, #1
24006b4e:	4413      	add	r3, r2
24006b50:	43db      	mvns	r3, r3
24006b52:	ea01 0203 	and.w	r2, r1, r3
24006b56:	69fb      	ldr	r3, [r7, #28]
24006b58:	601a      	str	r2, [r3, #0]
  }

  return HAL_OK;
24006b5a:	2300      	movs	r3, #0
}
24006b5c:	4618      	mov	r0, r3
24006b5e:	3724      	adds	r7, #36	; 0x24
24006b60:	46bd      	mov	sp, r7
24006b62:	f85d 7b04 	ldr.w	r7, [sp], #4
24006b66:	4770      	bx	lr
24006b68:	58000080 	.word	0x58000080
24006b6c:	58000084 	.word	0x58000084
24006b70:	58000004 	.word	0x58000004
24006b74:	58000400 	.word	0x58000400
24006b78:	5800000c 	.word	0x5800000c
24006b7c:	58000010 	.word	0x58000010
24006b80:	58000014 	.word	0x58000014

24006b84 <HAL_EXTI_RegisterCallback>:
  *         This parameter can be one of @arg @ref EXTI_CallbackIDTypeDef values.
  * @param  pPendingCbfn function pointer to be stored as callback.
  * @retval HAL Status.
  */
HAL_StatusTypeDef HAL_EXTI_RegisterCallback(EXTI_HandleTypeDef *hexti, EXTI_CallbackIDTypeDef CallbackID, void (*pPendingCbfn)(void))
{
24006b84:	b480      	push	{r7}
24006b86:	b087      	sub	sp, #28
24006b88:	af00      	add	r7, sp, #0
24006b8a:	60f8      	str	r0, [r7, #12]
24006b8c:	460b      	mov	r3, r1
24006b8e:	607a      	str	r2, [r7, #4]
24006b90:	72fb      	strb	r3, [r7, #11]
  HAL_StatusTypeDef status = HAL_OK;
24006b92:	2300      	movs	r3, #0
24006b94:	75fb      	strb	r3, [r7, #23]

  /* Check null pointer */
  if (hexti == NULL)
24006b96:	68fb      	ldr	r3, [r7, #12]
24006b98:	2b00      	cmp	r3, #0
24006b9a:	d101      	bne.n	24006ba0 <HAL_EXTI_RegisterCallback+0x1c>
  {
    return HAL_ERROR;
24006b9c:	2301      	movs	r3, #1
24006b9e:	e00a      	b.n	24006bb6 <HAL_EXTI_RegisterCallback+0x32>
  }

  switch (CallbackID)
24006ba0:	7afb      	ldrb	r3, [r7, #11]
24006ba2:	2b00      	cmp	r3, #0
24006ba4:	d103      	bne.n	24006bae <HAL_EXTI_RegisterCallback+0x2a>
  {
    case  HAL_EXTI_COMMON_CB_ID:
      hexti->PendingCallback = pPendingCbfn;
24006ba6:	68fb      	ldr	r3, [r7, #12]
24006ba8:	687a      	ldr	r2, [r7, #4]
24006baa:	605a      	str	r2, [r3, #4]
      break;
24006bac:	e002      	b.n	24006bb4 <HAL_EXTI_RegisterCallback+0x30>

    default:
      status = HAL_ERROR;
24006bae:	2301      	movs	r3, #1
24006bb0:	75fb      	strb	r3, [r7, #23]
      break;
24006bb2:	bf00      	nop
  }

  return status;
24006bb4:	7dfb      	ldrb	r3, [r7, #23]
}
24006bb6:	4618      	mov	r0, r3
24006bb8:	371c      	adds	r7, #28
24006bba:	46bd      	mov	sp, r7
24006bbc:	f85d 7b04 	ldr.w	r7, [sp], #4
24006bc0:	4770      	bx	lr

24006bc2 <HAL_EXTI_GetHandle>:
  * @param  ExtiLine Exti line number.
  *         This parameter can be from 0 to @ref EXTI_LINE_NB.
  * @retval HAL Status.
  */
HAL_StatusTypeDef HAL_EXTI_GetHandle(EXTI_HandleTypeDef *hexti, uint32_t ExtiLine)
{
24006bc2:	b480      	push	{r7}
24006bc4:	b083      	sub	sp, #12
24006bc6:	af00      	add	r7, sp, #0
24006bc8:	6078      	str	r0, [r7, #4]
24006bca:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_EXTI_LINE(ExtiLine));

  /* Check null pointer */
  if (hexti == NULL)
24006bcc:	687b      	ldr	r3, [r7, #4]
24006bce:	2b00      	cmp	r3, #0
24006bd0:	d101      	bne.n	24006bd6 <HAL_EXTI_GetHandle+0x14>
  {
    return HAL_ERROR;
24006bd2:	2301      	movs	r3, #1
24006bd4:	e003      	b.n	24006bde <HAL_EXTI_GetHandle+0x1c>
  }
  else
  {
    /* Store line number as handle private field */
    hexti->Line = ExtiLine;
24006bd6:	687b      	ldr	r3, [r7, #4]
24006bd8:	683a      	ldr	r2, [r7, #0]
24006bda:	601a      	str	r2, [r3, #0]

    return HAL_OK;
24006bdc:	2300      	movs	r3, #0
  }
}
24006bde:	4618      	mov	r0, r3
24006be0:	370c      	adds	r7, #12
24006be2:	46bd      	mov	sp, r7
24006be4:	f85d 7b04 	ldr.w	r7, [sp], #4
24006be8:	4770      	bx	lr
	...

24006bec <HAL_EXTI_IRQHandler>:
  * @brief  Handle EXTI interrupt request.
  * @param  hexti Exti handle.
  * @retval none.
  */
void HAL_EXTI_IRQHandler(EXTI_HandleTypeDef *hexti)
{
24006bec:	b580      	push	{r7, lr}
24006bee:	b086      	sub	sp, #24
24006bf0:	af00      	add	r7, sp, #0
24006bf2:	6078      	str	r0, [r7, #4]
  uint32_t regval;
  uint32_t maskline;
  uint32_t offset;

  /* Compute line register offset and line mask */
  offset = ((hexti->Line & EXTI_REG_MASK) >> EXTI_REG_SHIFT);
24006bf4:	687b      	ldr	r3, [r7, #4]
24006bf6:	681b      	ldr	r3, [r3, #0]
24006bf8:	0c1b      	lsrs	r3, r3, #16
24006bfa:	f003 0303 	and.w	r3, r3, #3
24006bfe:	617b      	str	r3, [r7, #20]
  maskline = (1UL << (hexti->Line & EXTI_PIN_MASK));
24006c00:	687b      	ldr	r3, [r7, #4]
24006c02:	681b      	ldr	r3, [r3, #0]
24006c04:	f003 031f 	and.w	r3, r3, #31
24006c08:	2201      	movs	r2, #1
24006c0a:	fa02 f303 	lsl.w	r3, r2, r3
24006c0e:	613b      	str	r3, [r7, #16]
  {
    /* Get pending register address */
    regaddr = (__IO uint32_t *)(&EXTI->C2PR1 + (EXTI_MODE_OFFSET * offset));
  }
#else
  regaddr = (__IO uint32_t *)(&EXTI->PR1 + (EXTI_MODE_OFFSET * offset));
24006c10:	697b      	ldr	r3, [r7, #20]
24006c12:	011a      	lsls	r2, r3, #4
24006c14:	4b0c      	ldr	r3, [pc, #48]	; (24006c48 <HAL_EXTI_IRQHandler+0x5c>)
24006c16:	4413      	add	r3, r2
24006c18:	60fb      	str	r3, [r7, #12]
#endif /* DUAL_CORE */

  /* Get pending bit  */
  regval = (*regaddr & maskline);
24006c1a:	68fb      	ldr	r3, [r7, #12]
24006c1c:	681b      	ldr	r3, [r3, #0]
24006c1e:	693a      	ldr	r2, [r7, #16]
24006c20:	4013      	ands	r3, r2
24006c22:	60bb      	str	r3, [r7, #8]

  if (regval != 0x00U)
24006c24:	68bb      	ldr	r3, [r7, #8]
24006c26:	2b00      	cmp	r3, #0
24006c28:	d009      	beq.n	24006c3e <HAL_EXTI_IRQHandler+0x52>
  {
    /* Clear pending bit */
    *regaddr = maskline;
24006c2a:	68fb      	ldr	r3, [r7, #12]
24006c2c:	693a      	ldr	r2, [r7, #16]
24006c2e:	601a      	str	r2, [r3, #0]

    /* Call callback */
    if (hexti->PendingCallback != NULL)
24006c30:	687b      	ldr	r3, [r7, #4]
24006c32:	685b      	ldr	r3, [r3, #4]
24006c34:	2b00      	cmp	r3, #0
24006c36:	d002      	beq.n	24006c3e <HAL_EXTI_IRQHandler+0x52>
    {
      hexti->PendingCallback();
24006c38:	687b      	ldr	r3, [r7, #4]
24006c3a:	685b      	ldr	r3, [r3, #4]
24006c3c:	4798      	blx	r3
    }
  }
}
24006c3e:	bf00      	nop
24006c40:	3718      	adds	r7, #24
24006c42:	46bd      	mov	sp, r7
24006c44:	bd80      	pop	{r7, pc}
24006c46:	bf00      	nop
24006c48:	58000088 	.word	0x58000088

24006c4c <HAL_EXTI_GetPending>:
  *           @arg @ref EXTI_TRIGGER_RISING_FALLING
  *         This parameter is kept for compatibility with other series.
  * @retval 1 if interrupt is pending else 0.
  */
uint32_t HAL_EXTI_GetPending(EXTI_HandleTypeDef *hexti, uint32_t Edge)
{
24006c4c:	b480      	push	{r7}
24006c4e:	b089      	sub	sp, #36	; 0x24
24006c50:	af00      	add	r7, sp, #0
24006c52:	6078      	str	r0, [r7, #4]
24006c54:	6039      	str	r1, [r7, #0]
  assert_param(IS_EXTI_LINE(hexti->Line));
  assert_param(IS_EXTI_CONFIG_LINE(hexti->Line));
  assert_param(IS_EXTI_PENDING_EDGE(Edge));

  /* compute line register offset and line mask */
  offset = ((hexti->Line & EXTI_REG_MASK) >> EXTI_REG_SHIFT);
24006c56:	687b      	ldr	r3, [r7, #4]
24006c58:	681b      	ldr	r3, [r3, #0]
24006c5a:	0c1b      	lsrs	r3, r3, #16
24006c5c:	f003 0303 	and.w	r3, r3, #3
24006c60:	61fb      	str	r3, [r7, #28]
  linepos = (hexti->Line & EXTI_PIN_MASK);
24006c62:	687b      	ldr	r3, [r7, #4]
24006c64:	681b      	ldr	r3, [r3, #0]
24006c66:	f003 031f 	and.w	r3, r3, #31
24006c6a:	61bb      	str	r3, [r7, #24]
  maskline = (1UL << linepos);
24006c6c:	2201      	movs	r2, #1
24006c6e:	69bb      	ldr	r3, [r7, #24]
24006c70:	fa02 f303 	lsl.w	r3, r2, r3
24006c74:	617b      	str	r3, [r7, #20]
  {
    /* Get pending register address */
    regaddr = (__IO uint32_t *)(&EXTI->C2PR1 + (EXTI_MODE_OFFSET * offset));
  }
#else
  regaddr = (__IO uint32_t *)(&EXTI->PR1 + (EXTI_MODE_OFFSET * offset));
24006c76:	69fb      	ldr	r3, [r7, #28]
24006c78:	011a      	lsls	r2, r3, #4
24006c7a:	4b09      	ldr	r3, [pc, #36]	; (24006ca0 <HAL_EXTI_GetPending+0x54>)
24006c7c:	4413      	add	r3, r2
24006c7e:	613b      	str	r3, [r7, #16]
#endif /* DUAL_CORE */

  /* return 1 if bit is set else 0 */
  regval = ((*regaddr & maskline) >> linepos);
24006c80:	693b      	ldr	r3, [r7, #16]
24006c82:	681a      	ldr	r2, [r3, #0]
24006c84:	697b      	ldr	r3, [r7, #20]
24006c86:	401a      	ands	r2, r3
24006c88:	69bb      	ldr	r3, [r7, #24]
24006c8a:	fa22 f303 	lsr.w	r3, r2, r3
24006c8e:	60fb      	str	r3, [r7, #12]
  return regval;
24006c90:	68fb      	ldr	r3, [r7, #12]
}
24006c92:	4618      	mov	r0, r3
24006c94:	3724      	adds	r7, #36	; 0x24
24006c96:	46bd      	mov	sp, r7
24006c98:	f85d 7b04 	ldr.w	r7, [sp], #4
24006c9c:	4770      	bx	lr
24006c9e:	bf00      	nop
24006ca0:	58000088 	.word	0x58000088

24006ca4 <HAL_EXTI_ClearPending>:
  *           @arg @ref EXTI_TRIGGER_RISING_FALLING
  *         This parameter is kept for compatibility with other series.
  * @retval None.
  */
void HAL_EXTI_ClearPending(EXTI_HandleTypeDef *hexti, uint32_t Edge)
{
24006ca4:	b480      	push	{r7}
24006ca6:	b087      	sub	sp, #28
24006ca8:	af00      	add	r7, sp, #0
24006caa:	6078      	str	r0, [r7, #4]
24006cac:	6039      	str	r1, [r7, #0]
  assert_param(IS_EXTI_LINE(hexti->Line));
  assert_param(IS_EXTI_CONFIG_LINE(hexti->Line));
  assert_param(IS_EXTI_PENDING_EDGE(Edge));

  /* compute line register offset and line mask */
  offset = ((hexti->Line & EXTI_REG_MASK) >> EXTI_REG_SHIFT);
24006cae:	687b      	ldr	r3, [r7, #4]
24006cb0:	681b      	ldr	r3, [r3, #0]
24006cb2:	0c1b      	lsrs	r3, r3, #16
24006cb4:	f003 0303 	and.w	r3, r3, #3
24006cb8:	617b      	str	r3, [r7, #20]
  maskline = (1UL << (hexti->Line & EXTI_PIN_MASK));
24006cba:	687b      	ldr	r3, [r7, #4]
24006cbc:	681b      	ldr	r3, [r3, #0]
24006cbe:	f003 031f 	and.w	r3, r3, #31
24006cc2:	2201      	movs	r2, #1
24006cc4:	fa02 f303 	lsl.w	r3, r2, r3
24006cc8:	613b      	str	r3, [r7, #16]
  {
    /* Get pending register address */
    regaddr = (__IO uint32_t *)(&EXTI->C2PR1 + (EXTI_MODE_OFFSET * offset));
  }
#else
  regaddr = (__IO uint32_t *)(&EXTI->PR1 + (EXTI_MODE_OFFSET * offset));
24006cca:	697b      	ldr	r3, [r7, #20]
24006ccc:	011a      	lsls	r2, r3, #4
24006cce:	4b06      	ldr	r3, [pc, #24]	; (24006ce8 <HAL_EXTI_ClearPending+0x44>)
24006cd0:	4413      	add	r3, r2
24006cd2:	60fb      	str	r3, [r7, #12]
#endif /* DUAL_CORE */

  /* Clear Pending bit */
  *regaddr =  maskline;
24006cd4:	68fb      	ldr	r3, [r7, #12]
24006cd6:	693a      	ldr	r2, [r7, #16]
24006cd8:	601a      	str	r2, [r3, #0]
}
24006cda:	bf00      	nop
24006cdc:	371c      	adds	r7, #28
24006cde:	46bd      	mov	sp, r7
24006ce0:	f85d 7b04 	ldr.w	r7, [sp], #4
24006ce4:	4770      	bx	lr
24006ce6:	bf00      	nop
24006ce8:	58000088 	.word	0x58000088

24006cec <HAL_EXTI_GenerateSWI>:
  * @brief  Generate a software interrupt for a dedicated line.
  * @param  hexti Exti handle.
  * @retval None.
  */
void HAL_EXTI_GenerateSWI(EXTI_HandleTypeDef *hexti)
{
24006cec:	b480      	push	{r7}
24006cee:	b087      	sub	sp, #28
24006cf0:	af00      	add	r7, sp, #0
24006cf2:	6078      	str	r0, [r7, #4]
  /* Check parameters */
  assert_param(IS_EXTI_LINE(hexti->Line));
  assert_param(IS_EXTI_CONFIG_LINE(hexti->Line));

  /* compute line register offset and line mask */
  offset = ((hexti->Line & EXTI_REG_MASK) >> EXTI_REG_SHIFT);
24006cf4:	687b      	ldr	r3, [r7, #4]
24006cf6:	681b      	ldr	r3, [r3, #0]
24006cf8:	0c1b      	lsrs	r3, r3, #16
24006cfa:	f003 0303 	and.w	r3, r3, #3
24006cfe:	617b      	str	r3, [r7, #20]
  maskline = (1UL << (hexti->Line & EXTI_PIN_MASK));
24006d00:	687b      	ldr	r3, [r7, #4]
24006d02:	681b      	ldr	r3, [r3, #0]
24006d04:	f003 031f 	and.w	r3, r3, #31
24006d08:	2201      	movs	r2, #1
24006d0a:	fa02 f303 	lsl.w	r3, r2, r3
24006d0e:	613b      	str	r3, [r7, #16]

  regaddr = (__IO uint32_t *)(&EXTI->SWIER1 + (EXTI_CONFIG_OFFSET * offset));
24006d10:	697b      	ldr	r3, [r7, #20]
24006d12:	015a      	lsls	r2, r3, #5
24006d14:	4b05      	ldr	r3, [pc, #20]	; (24006d2c <HAL_EXTI_GenerateSWI+0x40>)
24006d16:	4413      	add	r3, r2
24006d18:	60fb      	str	r3, [r7, #12]
  *regaddr = maskline;
24006d1a:	68fb      	ldr	r3, [r7, #12]
24006d1c:	693a      	ldr	r2, [r7, #16]
24006d1e:	601a      	str	r2, [r3, #0]
}
24006d20:	bf00      	nop
24006d22:	371c      	adds	r7, #28
24006d24:	46bd      	mov	sp, r7
24006d26:	f85d 7b04 	ldr.w	r7, [sp], #4
24006d2a:	4770      	bx	lr
24006d2c:	58000008 	.word	0x58000008

24006d30 <HAL_FLASH_Program>:
  * @param  DataAddress specifies the address of data to be programmed
  *
  * @retval HAL_StatusTypeDef HAL Status
  */
HAL_StatusTypeDef HAL_FLASH_Program(uint32_t TypeProgram, uint32_t FlashAddress, uint32_t DataAddress)
{
24006d30:	b580      	push	{r7, lr}
24006d32:	b08a      	sub	sp, #40	; 0x28
24006d34:	af00      	add	r7, sp, #0
24006d36:	60f8      	str	r0, [r7, #12]
24006d38:	60b9      	str	r1, [r7, #8]
24006d3a:	607a      	str	r2, [r7, #4]
  HAL_StatusTypeDef status;
  __IO uint32_t *dest_addr = (__IO uint32_t *)FlashAddress;
24006d3c:	68bb      	ldr	r3, [r7, #8]
24006d3e:	623b      	str	r3, [r7, #32]
  __IO uint32_t *src_addr = (__IO uint32_t*)DataAddress;
24006d40:	687b      	ldr	r3, [r7, #4]
24006d42:	61fb      	str	r3, [r7, #28]
  uint32_t bank;
  uint8_t row_index = FLASH_NB_32BITWORD_IN_FLASHWORD;
24006d44:	2308      	movs	r3, #8
24006d46:	75fb      	strb	r3, [r7, #23]
  /* Check the parameters */
  assert_param(IS_FLASH_TYPEPROGRAM(TypeProgram));
  assert_param(IS_FLASH_PROGRAM_ADDRESS(FlashAddress));

  /* Process Locked */
  __HAL_LOCK(&pFlash);
24006d48:	4b38      	ldr	r3, [pc, #224]	; (24006e2c <HAL_FLASH_Program+0xfc>)
24006d4a:	7d1b      	ldrb	r3, [r3, #20]
24006d4c:	2b01      	cmp	r3, #1
24006d4e:	d101      	bne.n	24006d54 <HAL_FLASH_Program+0x24>
24006d50:	2302      	movs	r3, #2
24006d52:	e067      	b.n	24006e24 <HAL_FLASH_Program+0xf4>
24006d54:	4b35      	ldr	r3, [pc, #212]	; (24006e2c <HAL_FLASH_Program+0xfc>)
24006d56:	2201      	movs	r2, #1
24006d58:	751a      	strb	r2, [r3, #20]

#if defined (FLASH_OPTCR_PG_OTP)
  if((IS_FLASH_PROGRAM_ADDRESS_BANK1(FlashAddress)) || (IS_FLASH_PROGRAM_ADDRESS_OTP(FlashAddress)))
#else
  if(IS_FLASH_PROGRAM_ADDRESS_BANK1(FlashAddress))
24006d5a:	68bb      	ldr	r3, [r7, #8]
24006d5c:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
24006d60:	d306      	bcc.n	24006d70 <HAL_FLASH_Program+0x40>
24006d62:	68bb      	ldr	r3, [r7, #8]
24006d64:	f1b3 6f01 	cmp.w	r3, #135266304	; 0x8100000
24006d68:	d202      	bcs.n	24006d70 <HAL_FLASH_Program+0x40>
#endif /* FLASH_OPTCR_PG_OTP */
  {
    bank = FLASH_BANK_1;
24006d6a:	2301      	movs	r3, #1
24006d6c:	61bb      	str	r3, [r7, #24]
24006d6e:	e001      	b.n	24006d74 <HAL_FLASH_Program+0x44>
  }
  else
  {
    bank = FLASH_BANK_2;
24006d70:	2302      	movs	r3, #2
24006d72:	61bb      	str	r3, [r7, #24]
  }

  /* Reset error code */
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
24006d74:	4b2d      	ldr	r3, [pc, #180]	; (24006e2c <HAL_FLASH_Program+0xfc>)
24006d76:	2200      	movs	r2, #0
24006d78:	619a      	str	r2, [r3, #24]

  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, bank);
24006d7a:	69b9      	ldr	r1, [r7, #24]
24006d7c:	f24c 3050 	movw	r0, #50000	; 0xc350
24006d80:	f000 fb20 	bl	240073c4 <FLASH_WaitForLastOperation>
24006d84:	4603      	mov	r3, r0
24006d86:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27

  if(status == HAL_OK)
24006d8a:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
24006d8e:	2b00      	cmp	r3, #0
24006d90:	d143      	bne.n	24006e1a <HAL_FLASH_Program+0xea>
  {
    if(bank == FLASH_BANK_1)
24006d92:	69bb      	ldr	r3, [r7, #24]
24006d94:	2b01      	cmp	r3, #1
24006d96:	d106      	bne.n	24006da6 <HAL_FLASH_Program+0x76>
      }
      else
#endif /* FLASH_OPTCR_PG_OTP */
      {
        /* Set PG bit */
        SET_BIT(FLASH->CR1, FLASH_CR_PG);
24006d98:	4b25      	ldr	r3, [pc, #148]	; (24006e30 <HAL_FLASH_Program+0x100>)
24006d9a:	68db      	ldr	r3, [r3, #12]
24006d9c:	4a24      	ldr	r2, [pc, #144]	; (24006e30 <HAL_FLASH_Program+0x100>)
24006d9e:	f043 0302 	orr.w	r3, r3, #2
24006da2:	60d3      	str	r3, [r2, #12]
24006da4:	e007      	b.n	24006db6 <HAL_FLASH_Program+0x86>
      }
    }
    else
    {
      /* Set PG bit */
      SET_BIT(FLASH->CR2, FLASH_CR_PG);
24006da6:	4b22      	ldr	r3, [pc, #136]	; (24006e30 <HAL_FLASH_Program+0x100>)
24006da8:	f8d3 310c 	ldr.w	r3, [r3, #268]	; 0x10c
24006dac:	4a20      	ldr	r2, [pc, #128]	; (24006e30 <HAL_FLASH_Program+0x100>)
24006dae:	f043 0302 	orr.w	r3, r3, #2
24006db2:	f8c2 310c 	str.w	r3, [r2, #268]	; 0x10c
24006db6:	f3bf 8f6f 	isb	sy
  __ASM volatile ("dsb 0xF":::"memory");
24006dba:	f3bf 8f4f 	dsb	sy
#endif /* FLASH_OPTCR_PG_OTP */
    {
      /* Program the flash word */
      do
      {
        *dest_addr = *src_addr;
24006dbe:	69fb      	ldr	r3, [r7, #28]
24006dc0:	681a      	ldr	r2, [r3, #0]
24006dc2:	6a3b      	ldr	r3, [r7, #32]
24006dc4:	601a      	str	r2, [r3, #0]
        dest_addr++;
24006dc6:	6a3b      	ldr	r3, [r7, #32]
24006dc8:	3304      	adds	r3, #4
24006dca:	623b      	str	r3, [r7, #32]
        src_addr++;
24006dcc:	69fb      	ldr	r3, [r7, #28]
24006dce:	3304      	adds	r3, #4
24006dd0:	61fb      	str	r3, [r7, #28]
        row_index--;
24006dd2:	7dfb      	ldrb	r3, [r7, #23]
24006dd4:	3b01      	subs	r3, #1
24006dd6:	75fb      	strb	r3, [r7, #23]
     } while (row_index != 0U);
24006dd8:	7dfb      	ldrb	r3, [r7, #23]
24006dda:	2b00      	cmp	r3, #0
24006ddc:	d1ef      	bne.n	24006dbe <HAL_FLASH_Program+0x8e>
  __ASM volatile ("isb 0xF":::"memory");
24006dde:	f3bf 8f6f 	isb	sy
  __ASM volatile ("dsb 0xF":::"memory");
24006de2:	f3bf 8f4f 	dsb	sy

    __ISB();
    __DSB();

    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, bank);
24006de6:	69b9      	ldr	r1, [r7, #24]
24006de8:	f24c 3050 	movw	r0, #50000	; 0xc350
24006dec:	f000 faea 	bl	240073c4 <FLASH_WaitForLastOperation>
24006df0:	4603      	mov	r3, r0
24006df2:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
      CLEAR_BIT(FLASH->OPTCR, FLASH_OPTCR_PG_OTP);
    }
    else
#endif /* FLASH_OPTCR_PG_OTP */
    {
      if(bank == FLASH_BANK_1)
24006df6:	69bb      	ldr	r3, [r7, #24]
24006df8:	2b01      	cmp	r3, #1
24006dfa:	d106      	bne.n	24006e0a <HAL_FLASH_Program+0xda>
      {
        /* If the program operation is completed, disable the PG */
        CLEAR_BIT(FLASH->CR1, FLASH_CR_PG);
24006dfc:	4b0c      	ldr	r3, [pc, #48]	; (24006e30 <HAL_FLASH_Program+0x100>)
24006dfe:	68db      	ldr	r3, [r3, #12]
24006e00:	4a0b      	ldr	r2, [pc, #44]	; (24006e30 <HAL_FLASH_Program+0x100>)
24006e02:	f023 0302 	bic.w	r3, r3, #2
24006e06:	60d3      	str	r3, [r2, #12]
24006e08:	e007      	b.n	24006e1a <HAL_FLASH_Program+0xea>
      }
      else
      {
        /* If the program operation is completed, disable the PG */
        CLEAR_BIT(FLASH->CR2, FLASH_CR_PG);
24006e0a:	4b09      	ldr	r3, [pc, #36]	; (24006e30 <HAL_FLASH_Program+0x100>)
24006e0c:	f8d3 310c 	ldr.w	r3, [r3, #268]	; 0x10c
24006e10:	4a07      	ldr	r2, [pc, #28]	; (24006e30 <HAL_FLASH_Program+0x100>)
24006e12:	f023 0302 	bic.w	r3, r3, #2
24006e16:	f8c2 310c 	str.w	r3, [r2, #268]	; 0x10c
      }
    }
  }

  /* Process Unlocked */
  __HAL_UNLOCK(&pFlash);
24006e1a:	4b04      	ldr	r3, [pc, #16]	; (24006e2c <HAL_FLASH_Program+0xfc>)
24006e1c:	2200      	movs	r2, #0
24006e1e:	751a      	strb	r2, [r3, #20]

  return status;
24006e20:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
}
24006e24:	4618      	mov	r0, r3
24006e26:	3728      	adds	r7, #40	; 0x28
24006e28:	46bd      	mov	sp, r7
24006e2a:	bd80      	pop	{r7, pc}
24006e2c:	2400054c 	.word	0x2400054c
24006e30:	52002000 	.word	0x52002000

24006e34 <HAL_FLASH_Program_IT>:
  * @param  DataAddress specifies the address of data (256 bits) to be programmed
  *
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_FLASH_Program_IT(uint32_t TypeProgram, uint32_t FlashAddress, uint32_t DataAddress)
{
24006e34:	b580      	push	{r7, lr}
24006e36:	b088      	sub	sp, #32
24006e38:	af00      	add	r7, sp, #0
24006e3a:	60f8      	str	r0, [r7, #12]
24006e3c:	60b9      	str	r1, [r7, #8]
24006e3e:	607a      	str	r2, [r7, #4]
  HAL_StatusTypeDef status;
  __IO uint32_t *dest_addr = (__IO uint32_t*)FlashAddress;
24006e40:	68bb      	ldr	r3, [r7, #8]
24006e42:	61fb      	str	r3, [r7, #28]
  __IO uint32_t *src_addr = (__IO uint32_t*)DataAddress;
24006e44:	687b      	ldr	r3, [r7, #4]
24006e46:	61bb      	str	r3, [r7, #24]
  uint32_t bank;
  uint8_t row_index = FLASH_NB_32BITWORD_IN_FLASHWORD;
24006e48:	2308      	movs	r3, #8
24006e4a:	74fb      	strb	r3, [r7, #19]
  /* Check the parameters */
  assert_param(IS_FLASH_TYPEPROGRAM(TypeProgram));
  assert_param(IS_FLASH_PROGRAM_ADDRESS(FlashAddress));

  /* Process Locked */
  __HAL_LOCK(&pFlash);
24006e4c:	4b36      	ldr	r3, [pc, #216]	; (24006f28 <HAL_FLASH_Program_IT+0xf4>)
24006e4e:	7d1b      	ldrb	r3, [r3, #20]
24006e50:	2b01      	cmp	r3, #1
24006e52:	d101      	bne.n	24006e58 <HAL_FLASH_Program_IT+0x24>
24006e54:	2302      	movs	r3, #2
24006e56:	e062      	b.n	24006f1e <HAL_FLASH_Program_IT+0xea>
24006e58:	4b33      	ldr	r3, [pc, #204]	; (24006f28 <HAL_FLASH_Program_IT+0xf4>)
24006e5a:	2201      	movs	r2, #1
24006e5c:	751a      	strb	r2, [r3, #20]

  /* Reset error code */
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
24006e5e:	4b32      	ldr	r3, [pc, #200]	; (24006f28 <HAL_FLASH_Program_IT+0xf4>)
24006e60:	2200      	movs	r2, #0
24006e62:	619a      	str	r2, [r3, #24]

#if defined (FLASH_OPTCR_PG_OTP)
  if((IS_FLASH_PROGRAM_ADDRESS_BANK1(FlashAddress)) || (IS_FLASH_PROGRAM_ADDRESS_OTP(FlashAddress)))
#else
  if(IS_FLASH_PROGRAM_ADDRESS_BANK1(FlashAddress))
24006e64:	68bb      	ldr	r3, [r7, #8]
24006e66:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
24006e6a:	d306      	bcc.n	24006e7a <HAL_FLASH_Program_IT+0x46>
24006e6c:	68bb      	ldr	r3, [r7, #8]
24006e6e:	f1b3 6f01 	cmp.w	r3, #135266304	; 0x8100000
24006e72:	d202      	bcs.n	24006e7a <HAL_FLASH_Program_IT+0x46>
#endif /* FLASH_OPTCR_PG_OTP */
  {
    bank = FLASH_BANK_1;
24006e74:	2301      	movs	r3, #1
24006e76:	617b      	str	r3, [r7, #20]
24006e78:	e001      	b.n	24006e7e <HAL_FLASH_Program_IT+0x4a>
  }
  else
  {
    bank = FLASH_BANK_2;
24006e7a:	2302      	movs	r3, #2
24006e7c:	617b      	str	r3, [r7, #20]
  }

  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, bank);
24006e7e:	6979      	ldr	r1, [r7, #20]
24006e80:	f24c 3050 	movw	r0, #50000	; 0xc350
24006e84:	f000 fa9e 	bl	240073c4 <FLASH_WaitForLastOperation>
24006e88:	4603      	mov	r3, r0
24006e8a:	74bb      	strb	r3, [r7, #18]

  if (status != HAL_OK)
24006e8c:	7cbb      	ldrb	r3, [r7, #18]
24006e8e:	2b00      	cmp	r3, #0
24006e90:	d003      	beq.n	24006e9a <HAL_FLASH_Program_IT+0x66>
  {
    /* Process Unlocked */
    __HAL_UNLOCK(&pFlash);
24006e92:	4b25      	ldr	r3, [pc, #148]	; (24006f28 <HAL_FLASH_Program_IT+0xf4>)
24006e94:	2200      	movs	r2, #0
24006e96:	751a      	strb	r2, [r3, #20]
24006e98:	e040      	b.n	24006f1c <HAL_FLASH_Program_IT+0xe8>
  }
  else
  {
    pFlash.Address = FlashAddress;
24006e9a:	4a23      	ldr	r2, [pc, #140]	; (24006f28 <HAL_FLASH_Program_IT+0xf4>)
24006e9c:	68bb      	ldr	r3, [r7, #8]
24006e9e:	6113      	str	r3, [r2, #16]

    if(bank == FLASH_BANK_1)
24006ea0:	697b      	ldr	r3, [r7, #20]
24006ea2:	2b01      	cmp	r3, #1
24006ea4:	d10f      	bne.n	24006ec6 <HAL_FLASH_Program_IT+0x92>
    {
      /* Set internal variables used by the IRQ handler */
      pFlash.ProcedureOnGoing = FLASH_PROC_PROGRAM_BANK1;
24006ea6:	4b20      	ldr	r3, [pc, #128]	; (24006f28 <HAL_FLASH_Program_IT+0xf4>)
24006ea8:	2203      	movs	r2, #3
24006eaa:	701a      	strb	r2, [r3, #0]
      }
      else
#endif /* FLASH_OPTCR_PG_OTP */
      {
        /* Set PG bit */
        SET_BIT(FLASH->CR1, FLASH_CR_PG);
24006eac:	4b1f      	ldr	r3, [pc, #124]	; (24006f2c <HAL_FLASH_Program_IT+0xf8>)
24006eae:	68db      	ldr	r3, [r3, #12]
24006eb0:	4a1e      	ldr	r2, [pc, #120]	; (24006f2c <HAL_FLASH_Program_IT+0xf8>)
24006eb2:	f043 0302 	orr.w	r3, r3, #2
24006eb6:	60d3      	str	r3, [r2, #12]
      }

      /* Enable End of Operation and Error interrupts for Bank 1 */
#if defined (FLASH_CR_OPERRIE)
      __HAL_FLASH_ENABLE_IT_BANK1(FLASH_IT_EOP_BANK1     | FLASH_IT_WRPERR_BANK1 | FLASH_IT_PGSERR_BANK1 | \
24006eb8:	4b1c      	ldr	r3, [pc, #112]	; (24006f2c <HAL_FLASH_Program_IT+0xf8>)
24006eba:	68db      	ldr	r3, [r3, #12]
24006ebc:	4a1b      	ldr	r2, [pc, #108]	; (24006f2c <HAL_FLASH_Program_IT+0xf8>)
24006ebe:	f443 03de 	orr.w	r3, r3, #7274496	; 0x6f0000
24006ec2:	60d3      	str	r3, [r2, #12]
24006ec4:	e012      	b.n	24006eec <HAL_FLASH_Program_IT+0xb8>
#endif /* FLASH_CR_OPERRIE */
    }
    else
    {
      /* Set internal variables used by the IRQ handler */
      pFlash.ProcedureOnGoing = FLASH_PROC_PROGRAM_BANK2;
24006ec6:	4b18      	ldr	r3, [pc, #96]	; (24006f28 <HAL_FLASH_Program_IT+0xf4>)
24006ec8:	2206      	movs	r2, #6
24006eca:	701a      	strb	r2, [r3, #0]

      /* Set PG bit */
      SET_BIT(FLASH->CR2, FLASH_CR_PG);
24006ecc:	4b17      	ldr	r3, [pc, #92]	; (24006f2c <HAL_FLASH_Program_IT+0xf8>)
24006ece:	f8d3 310c 	ldr.w	r3, [r3, #268]	; 0x10c
24006ed2:	4a16      	ldr	r2, [pc, #88]	; (24006f2c <HAL_FLASH_Program_IT+0xf8>)
24006ed4:	f043 0302 	orr.w	r3, r3, #2
24006ed8:	f8c2 310c 	str.w	r3, [r2, #268]	; 0x10c

      /* Enable End of Operation and Error interrupts for Bank2 */
#if defined (FLASH_CR_OPERRIE)
      __HAL_FLASH_ENABLE_IT_BANK2(FLASH_IT_EOP_BANK2     | FLASH_IT_WRPERR_BANK2 | FLASH_IT_PGSERR_BANK2 | \
24006edc:	4b13      	ldr	r3, [pc, #76]	; (24006f2c <HAL_FLASH_Program_IT+0xf8>)
24006ede:	f8d3 310c 	ldr.w	r3, [r3, #268]	; 0x10c
24006ee2:	4a12      	ldr	r2, [pc, #72]	; (24006f2c <HAL_FLASH_Program_IT+0xf8>)
24006ee4:	f443 03de 	orr.w	r3, r3, #7274496	; 0x6f0000
24006ee8:	f8c2 310c 	str.w	r3, [r2, #268]	; 0x10c
  __ASM volatile ("isb 0xF":::"memory");
24006eec:	f3bf 8f6f 	isb	sy
  __ASM volatile ("dsb 0xF":::"memory");
24006ef0:	f3bf 8f4f 	dsb	sy
#endif /* FLASH_OPTCR_PG_OTP */
    {
      /* Program the flash word */
      do
      {
        *dest_addr = *src_addr;
24006ef4:	69bb      	ldr	r3, [r7, #24]
24006ef6:	681a      	ldr	r2, [r3, #0]
24006ef8:	69fb      	ldr	r3, [r7, #28]
24006efa:	601a      	str	r2, [r3, #0]
        dest_addr++;
24006efc:	69fb      	ldr	r3, [r7, #28]
24006efe:	3304      	adds	r3, #4
24006f00:	61fb      	str	r3, [r7, #28]
        src_addr++;
24006f02:	69bb      	ldr	r3, [r7, #24]
24006f04:	3304      	adds	r3, #4
24006f06:	61bb      	str	r3, [r7, #24]
        row_index--;
24006f08:	7cfb      	ldrb	r3, [r7, #19]
24006f0a:	3b01      	subs	r3, #1
24006f0c:	74fb      	strb	r3, [r7, #19]
      } while (row_index != 0U);
24006f0e:	7cfb      	ldrb	r3, [r7, #19]
24006f10:	2b00      	cmp	r3, #0
24006f12:	d1ef      	bne.n	24006ef4 <HAL_FLASH_Program_IT+0xc0>
  __ASM volatile ("isb 0xF":::"memory");
24006f14:	f3bf 8f6f 	isb	sy
  __ASM volatile ("dsb 0xF":::"memory");
24006f18:	f3bf 8f4f 	dsb	sy

    __ISB();
    __DSB();
  }

  return status;
24006f1c:	7cbb      	ldrb	r3, [r7, #18]
}
24006f1e:	4618      	mov	r0, r3
24006f20:	3720      	adds	r7, #32
24006f22:	46bd      	mov	sp, r7
24006f24:	bd80      	pop	{r7, pc}
24006f26:	bf00      	nop
24006f28:	2400054c 	.word	0x2400054c
24006f2c:	52002000 	.word	0x52002000

24006f30 <HAL_FLASH_IRQHandler>:
/**
  * @brief This function handles FLASH interrupt request.
  * @retval None
  */
void HAL_FLASH_IRQHandler(void)
{
24006f30:	b580      	push	{r7, lr}
24006f32:	b084      	sub	sp, #16
24006f34:	af00      	add	r7, sp, #0
  uint32_t temp;
  uint32_t errorflag;
  FLASH_ProcedureTypeDef procedure;

  /* Check FLASH Bank1 End of Operation flag  */
  if(__HAL_FLASH_GET_FLAG_BANK1(FLASH_SR_EOP) != RESET)
24006f36:	4b95      	ldr	r3, [pc, #596]	; (2400718c <HAL_FLASH_IRQHandler+0x25c>)
24006f38:	691b      	ldr	r3, [r3, #16]
24006f3a:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
24006f3e:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
24006f42:	d15c      	bne.n	24006ffe <HAL_FLASH_IRQHandler+0xce>
  {
    if(pFlash.ProcedureOnGoing == FLASH_PROC_SECTERASE_BANK1)
24006f44:	4b92      	ldr	r3, [pc, #584]	; (24007190 <HAL_FLASH_IRQHandler+0x260>)
24006f46:	781b      	ldrb	r3, [r3, #0]
24006f48:	b2db      	uxtb	r3, r3
24006f4a:	2b01      	cmp	r3, #1
24006f4c:	d132      	bne.n	24006fb4 <HAL_FLASH_IRQHandler+0x84>
    {
      /* Nb of sector to erased can be decreased */
      pFlash.NbSectorsToErase--;
24006f4e:	4b90      	ldr	r3, [pc, #576]	; (24007190 <HAL_FLASH_IRQHandler+0x260>)
24006f50:	685b      	ldr	r3, [r3, #4]
24006f52:	3b01      	subs	r3, #1
24006f54:	4a8e      	ldr	r2, [pc, #568]	; (24007190 <HAL_FLASH_IRQHandler+0x260>)
24006f56:	6053      	str	r3, [r2, #4]

      /* Check if there are still sectors to erase */
      if(pFlash.NbSectorsToErase != 0U)
24006f58:	4b8d      	ldr	r3, [pc, #564]	; (24007190 <HAL_FLASH_IRQHandler+0x260>)
24006f5a:	685b      	ldr	r3, [r3, #4]
24006f5c:	2b00      	cmp	r3, #0
24006f5e:	d018      	beq.n	24006f92 <HAL_FLASH_IRQHandler+0x62>
      {
        /* Indicate user which sector has been erased */
        HAL_FLASH_EndOfOperationCallback(pFlash.Sector);
24006f60:	4b8b      	ldr	r3, [pc, #556]	; (24007190 <HAL_FLASH_IRQHandler+0x260>)
24006f62:	68db      	ldr	r3, [r3, #12]
24006f64:	4618      	mov	r0, r3
24006f66:	f000 f93d 	bl	240071e4 <HAL_FLASH_EndOfOperationCallback>

        /* Clear bank 1 End of Operation pending bit */
        __HAL_FLASH_CLEAR_FLAG_BANK1(FLASH_FLAG_EOP_BANK1);
24006f6a:	4b88      	ldr	r3, [pc, #544]	; (2400718c <HAL_FLASH_IRQHandler+0x25c>)
24006f6c:	f44f 3280 	mov.w	r2, #65536	; 0x10000
24006f70:	615a      	str	r2, [r3, #20]

        /* Increment sector number */
        pFlash.Sector++;
24006f72:	4b87      	ldr	r3, [pc, #540]	; (24007190 <HAL_FLASH_IRQHandler+0x260>)
24006f74:	68db      	ldr	r3, [r3, #12]
24006f76:	3301      	adds	r3, #1
24006f78:	4a85      	ldr	r2, [pc, #532]	; (24007190 <HAL_FLASH_IRQHandler+0x260>)
24006f7a:	60d3      	str	r3, [r2, #12]
        temp = pFlash.Sector;
24006f7c:	4b84      	ldr	r3, [pc, #528]	; (24007190 <HAL_FLASH_IRQHandler+0x260>)
24006f7e:	68db      	ldr	r3, [r3, #12]
24006f80:	60fb      	str	r3, [r7, #12]
        FLASH_Erase_Sector(temp, FLASH_BANK_1, pFlash.VoltageForErase);
24006f82:	4b83      	ldr	r3, [pc, #524]	; (24007190 <HAL_FLASH_IRQHandler+0x260>)
24006f84:	689b      	ldr	r3, [r3, #8]
24006f86:	461a      	mov	r2, r3
24006f88:	2101      	movs	r1, #1
24006f8a:	68f8      	ldr	r0, [r7, #12]
24006f8c:	f000 ff9e 	bl	24007ecc <FLASH_Erase_Sector>
24006f90:	e035      	b.n	24006ffe <HAL_FLASH_IRQHandler+0xce>
      }
      else
      {
        /* No more sectors to Erase, user callback can be called */
        /* Reset Sector and stop Erase sectors procedure */
        pFlash.Sector = 0xFFFFFFFFU;
24006f92:	4b7f      	ldr	r3, [pc, #508]	; (24007190 <HAL_FLASH_IRQHandler+0x260>)
24006f94:	f04f 32ff 	mov.w	r2, #4294967295
24006f98:	60da      	str	r2, [r3, #12]
        pFlash.ProcedureOnGoing = FLASH_PROC_NONE;
24006f9a:	4b7d      	ldr	r3, [pc, #500]	; (24007190 <HAL_FLASH_IRQHandler+0x260>)
24006f9c:	2200      	movs	r2, #0
24006f9e:	701a      	strb	r2, [r3, #0]

        /* FLASH EOP interrupt user callback */
        HAL_FLASH_EndOfOperationCallback(pFlash.Sector);
24006fa0:	4b7b      	ldr	r3, [pc, #492]	; (24007190 <HAL_FLASH_IRQHandler+0x260>)
24006fa2:	68db      	ldr	r3, [r3, #12]
24006fa4:	4618      	mov	r0, r3
24006fa6:	f000 f91d 	bl	240071e4 <HAL_FLASH_EndOfOperationCallback>

        /* Clear FLASH End of Operation pending bit */
        __HAL_FLASH_CLEAR_FLAG_BANK1(FLASH_FLAG_EOP_BANK1);
24006faa:	4b78      	ldr	r3, [pc, #480]	; (2400718c <HAL_FLASH_IRQHandler+0x25c>)
24006fac:	f44f 3280 	mov.w	r2, #65536	; 0x10000
24006fb0:	615a      	str	r2, [r3, #20]
24006fb2:	e024      	b.n	24006ffe <HAL_FLASH_IRQHandler+0xce>
      }
    }
    else
    {
      procedure = pFlash.ProcedureOnGoing;
24006fb4:	4b76      	ldr	r3, [pc, #472]	; (24007190 <HAL_FLASH_IRQHandler+0x260>)
24006fb6:	781b      	ldrb	r3, [r3, #0]
24006fb8:	72fb      	strb	r3, [r7, #11]

      if((procedure == FLASH_PROC_MASSERASE_BANK1) || (procedure == FLASH_PROC_ALLBANK_MASSERASE))
24006fba:	7afb      	ldrb	r3, [r7, #11]
24006fbc:	2b02      	cmp	r3, #2
24006fbe:	d002      	beq.n	24006fc6 <HAL_FLASH_IRQHandler+0x96>
24006fc0:	7afb      	ldrb	r3, [r7, #11]
24006fc2:	2b07      	cmp	r3, #7
24006fc4:	d103      	bne.n	24006fce <HAL_FLASH_IRQHandler+0x9e>
      {
        /* MassErase ended. Return the selected bank */
        /* FLASH EOP interrupt user callback */
        HAL_FLASH_EndOfOperationCallback(FLASH_BANK_1);
24006fc6:	2001      	movs	r0, #1
24006fc8:	f000 f90c 	bl	240071e4 <HAL_FLASH_EndOfOperationCallback>
24006fcc:	e007      	b.n	24006fde <HAL_FLASH_IRQHandler+0xae>
      }
      else if(procedure == FLASH_PROC_PROGRAM_BANK1)
24006fce:	7afb      	ldrb	r3, [r7, #11]
24006fd0:	2b03      	cmp	r3, #3
24006fd2:	d104      	bne.n	24006fde <HAL_FLASH_IRQHandler+0xae>
      {
        /* Program ended. Return the selected address */
        /* FLASH EOP interrupt user callback */
        HAL_FLASH_EndOfOperationCallback(pFlash.Address);
24006fd4:	4b6e      	ldr	r3, [pc, #440]	; (24007190 <HAL_FLASH_IRQHandler+0x260>)
24006fd6:	691b      	ldr	r3, [r3, #16]
24006fd8:	4618      	mov	r0, r3
24006fda:	f000 f903 	bl	240071e4 <HAL_FLASH_EndOfOperationCallback>
      else
      {
        /* Nothing to do */
      }

      if((procedure != FLASH_PROC_SECTERASE_BANK2) && \
24006fde:	7afb      	ldrb	r3, [r7, #11]
24006fe0:	2b04      	cmp	r3, #4
24006fe2:	d00c      	beq.n	24006ffe <HAL_FLASH_IRQHandler+0xce>
24006fe4:	7afb      	ldrb	r3, [r7, #11]
24006fe6:	2b05      	cmp	r3, #5
24006fe8:	d009      	beq.n	24006ffe <HAL_FLASH_IRQHandler+0xce>
         (procedure != FLASH_PROC_MASSERASE_BANK2) && \
24006fea:	7afb      	ldrb	r3, [r7, #11]
24006fec:	2b06      	cmp	r3, #6
24006fee:	d006      	beq.n	24006ffe <HAL_FLASH_IRQHandler+0xce>
         (procedure != FLASH_PROC_PROGRAM_BANK2))
      {
        pFlash.ProcedureOnGoing = FLASH_PROC_NONE;
24006ff0:	4b67      	ldr	r3, [pc, #412]	; (24007190 <HAL_FLASH_IRQHandler+0x260>)
24006ff2:	2200      	movs	r2, #0
24006ff4:	701a      	strb	r2, [r3, #0]
        /* Clear FLASH End of Operation pending bit */
        __HAL_FLASH_CLEAR_FLAG_BANK1(FLASH_FLAG_EOP_BANK1);
24006ff6:	4b65      	ldr	r3, [pc, #404]	; (2400718c <HAL_FLASH_IRQHandler+0x25c>)
24006ff8:	f44f 3280 	mov.w	r2, #65536	; 0x10000
24006ffc:	615a      	str	r2, [r3, #20]
      }
    }
  }

  /* Check FLASH Bank2 End of Operation flag  */
  if(__HAL_FLASH_GET_FLAG_BANK2(FLASH_SR_EOP) != RESET)
24006ffe:	4b63      	ldr	r3, [pc, #396]	; (2400718c <HAL_FLASH_IRQHandler+0x25c>)
24007000:	f8d3 3110 	ldr.w	r3, [r3, #272]	; 0x110
24007004:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
24007008:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
2400700c:	d15f      	bne.n	240070ce <HAL_FLASH_IRQHandler+0x19e>
  {
    if(pFlash.ProcedureOnGoing == FLASH_PROC_SECTERASE_BANK2)
2400700e:	4b60      	ldr	r3, [pc, #384]	; (24007190 <HAL_FLASH_IRQHandler+0x260>)
24007010:	781b      	ldrb	r3, [r3, #0]
24007012:	b2db      	uxtb	r3, r3
24007014:	2b04      	cmp	r3, #4
24007016:	d134      	bne.n	24007082 <HAL_FLASH_IRQHandler+0x152>
    {
      /*Nb of sector to erased can be decreased*/
      pFlash.NbSectorsToErase--;
24007018:	4b5d      	ldr	r3, [pc, #372]	; (24007190 <HAL_FLASH_IRQHandler+0x260>)
2400701a:	685b      	ldr	r3, [r3, #4]
2400701c:	3b01      	subs	r3, #1
2400701e:	4a5c      	ldr	r2, [pc, #368]	; (24007190 <HAL_FLASH_IRQHandler+0x260>)
24007020:	6053      	str	r3, [r2, #4]

      /* Check if there are still sectors to erase*/
      if(pFlash.NbSectorsToErase != 0U)
24007022:	4b5b      	ldr	r3, [pc, #364]	; (24007190 <HAL_FLASH_IRQHandler+0x260>)
24007024:	685b      	ldr	r3, [r3, #4]
24007026:	2b00      	cmp	r3, #0
24007028:	d019      	beq.n	2400705e <HAL_FLASH_IRQHandler+0x12e>
      {
        /*Indicate user which sector has been erased*/
        HAL_FLASH_EndOfOperationCallback(pFlash.Sector);
2400702a:	4b59      	ldr	r3, [pc, #356]	; (24007190 <HAL_FLASH_IRQHandler+0x260>)
2400702c:	68db      	ldr	r3, [r3, #12]
2400702e:	4618      	mov	r0, r3
24007030:	f000 f8d8 	bl	240071e4 <HAL_FLASH_EndOfOperationCallback>

        /* Clear bank 2 End of Operation pending bit */
        __HAL_FLASH_CLEAR_FLAG_BANK2(FLASH_FLAG_EOP_BANK2);
24007034:	4b55      	ldr	r3, [pc, #340]	; (2400718c <HAL_FLASH_IRQHandler+0x25c>)
24007036:	f44f 3280 	mov.w	r2, #65536	; 0x10000
2400703a:	f8c3 2114 	str.w	r2, [r3, #276]	; 0x114

        /*Increment sector number*/
        pFlash.Sector++;
2400703e:	4b54      	ldr	r3, [pc, #336]	; (24007190 <HAL_FLASH_IRQHandler+0x260>)
24007040:	68db      	ldr	r3, [r3, #12]
24007042:	3301      	adds	r3, #1
24007044:	4a52      	ldr	r2, [pc, #328]	; (24007190 <HAL_FLASH_IRQHandler+0x260>)
24007046:	60d3      	str	r3, [r2, #12]
        temp = pFlash.Sector;
24007048:	4b51      	ldr	r3, [pc, #324]	; (24007190 <HAL_FLASH_IRQHandler+0x260>)
2400704a:	68db      	ldr	r3, [r3, #12]
2400704c:	60fb      	str	r3, [r7, #12]
        FLASH_Erase_Sector(temp, FLASH_BANK_2, pFlash.VoltageForErase);
2400704e:	4b50      	ldr	r3, [pc, #320]	; (24007190 <HAL_FLASH_IRQHandler+0x260>)
24007050:	689b      	ldr	r3, [r3, #8]
24007052:	461a      	mov	r2, r3
24007054:	2102      	movs	r1, #2
24007056:	68f8      	ldr	r0, [r7, #12]
24007058:	f000 ff38 	bl	24007ecc <FLASH_Erase_Sector>
2400705c:	e037      	b.n	240070ce <HAL_FLASH_IRQHandler+0x19e>
      }
      else
      {
        /* No more sectors to Erase, user callback can be called */
        /* Reset Sector and stop Erase sectors procedure */
        pFlash.Sector = 0xFFFFFFFFU;
2400705e:	4b4c      	ldr	r3, [pc, #304]	; (24007190 <HAL_FLASH_IRQHandler+0x260>)
24007060:	f04f 32ff 	mov.w	r2, #4294967295
24007064:	60da      	str	r2, [r3, #12]
        pFlash.ProcedureOnGoing = FLASH_PROC_NONE;
24007066:	4b4a      	ldr	r3, [pc, #296]	; (24007190 <HAL_FLASH_IRQHandler+0x260>)
24007068:	2200      	movs	r2, #0
2400706a:	701a      	strb	r2, [r3, #0]

        /* FLASH EOP interrupt user callback */
        HAL_FLASH_EndOfOperationCallback(pFlash.Sector);
2400706c:	4b48      	ldr	r3, [pc, #288]	; (24007190 <HAL_FLASH_IRQHandler+0x260>)
2400706e:	68db      	ldr	r3, [r3, #12]
24007070:	4618      	mov	r0, r3
24007072:	f000 f8b7 	bl	240071e4 <HAL_FLASH_EndOfOperationCallback>

        /* Clear FLASH End of Operation pending bit */
        __HAL_FLASH_CLEAR_FLAG_BANK2(FLASH_FLAG_EOP_BANK2);
24007076:	4b45      	ldr	r3, [pc, #276]	; (2400718c <HAL_FLASH_IRQHandler+0x25c>)
24007078:	f44f 3280 	mov.w	r2, #65536	; 0x10000
2400707c:	f8c3 2114 	str.w	r2, [r3, #276]	; 0x114
24007080:	e025      	b.n	240070ce <HAL_FLASH_IRQHandler+0x19e>
      }
    }
    else
    {
      procedure = pFlash.ProcedureOnGoing;
24007082:	4b43      	ldr	r3, [pc, #268]	; (24007190 <HAL_FLASH_IRQHandler+0x260>)
24007084:	781b      	ldrb	r3, [r3, #0]
24007086:	72fb      	strb	r3, [r7, #11]

      if((procedure == FLASH_PROC_MASSERASE_BANK2) || (procedure == FLASH_PROC_ALLBANK_MASSERASE))
24007088:	7afb      	ldrb	r3, [r7, #11]
2400708a:	2b05      	cmp	r3, #5
2400708c:	d002      	beq.n	24007094 <HAL_FLASH_IRQHandler+0x164>
2400708e:	7afb      	ldrb	r3, [r7, #11]
24007090:	2b07      	cmp	r3, #7
24007092:	d103      	bne.n	2400709c <HAL_FLASH_IRQHandler+0x16c>
      {
        /*MassErase ended. Return the selected bank*/
        /* FLASH EOP interrupt user callback */
        HAL_FLASH_EndOfOperationCallback(FLASH_BANK_2);
24007094:	2002      	movs	r0, #2
24007096:	f000 f8a5 	bl	240071e4 <HAL_FLASH_EndOfOperationCallback>
2400709a:	e007      	b.n	240070ac <HAL_FLASH_IRQHandler+0x17c>
      }
      else if(procedure == FLASH_PROC_PROGRAM_BANK2)
2400709c:	7afb      	ldrb	r3, [r7, #11]
2400709e:	2b06      	cmp	r3, #6
240070a0:	d104      	bne.n	240070ac <HAL_FLASH_IRQHandler+0x17c>
      {
        /* Program ended. Return the selected address */
        /* FLASH EOP interrupt user callback */
        HAL_FLASH_EndOfOperationCallback(pFlash.Address);
240070a2:	4b3b      	ldr	r3, [pc, #236]	; (24007190 <HAL_FLASH_IRQHandler+0x260>)
240070a4:	691b      	ldr	r3, [r3, #16]
240070a6:	4618      	mov	r0, r3
240070a8:	f000 f89c 	bl	240071e4 <HAL_FLASH_EndOfOperationCallback>
      else
      {
        /* Nothing to do */
      }

      if((procedure != FLASH_PROC_SECTERASE_BANK1) && \
240070ac:	7afb      	ldrb	r3, [r7, #11]
240070ae:	2b01      	cmp	r3, #1
240070b0:	d00d      	beq.n	240070ce <HAL_FLASH_IRQHandler+0x19e>
240070b2:	7afb      	ldrb	r3, [r7, #11]
240070b4:	2b02      	cmp	r3, #2
240070b6:	d00a      	beq.n	240070ce <HAL_FLASH_IRQHandler+0x19e>
         (procedure != FLASH_PROC_MASSERASE_BANK1) && \
240070b8:	7afb      	ldrb	r3, [r7, #11]
240070ba:	2b03      	cmp	r3, #3
240070bc:	d007      	beq.n	240070ce <HAL_FLASH_IRQHandler+0x19e>
         (procedure != FLASH_PROC_PROGRAM_BANK1))
      {
        pFlash.ProcedureOnGoing = FLASH_PROC_NONE;
240070be:	4b34      	ldr	r3, [pc, #208]	; (24007190 <HAL_FLASH_IRQHandler+0x260>)
240070c0:	2200      	movs	r2, #0
240070c2:	701a      	strb	r2, [r3, #0]
        /* Clear FLASH End of Operation pending bit */
        __HAL_FLASH_CLEAR_FLAG_BANK2(FLASH_FLAG_EOP_BANK2);
240070c4:	4b31      	ldr	r3, [pc, #196]	; (2400718c <HAL_FLASH_IRQHandler+0x25c>)
240070c6:	f44f 3280 	mov.w	r2, #65536	; 0x10000
240070ca:	f8c3 2114 	str.w	r2, [r3, #276]	; 0x114
    }
  }

  /* Check FLASH Bank1 operation error flags */
#if defined (FLASH_SR_OPERR)
  errorflag = FLASH->SR1 & (FLASH_FLAG_WRPERR_BANK1 | FLASH_FLAG_PGSERR_BANK1 | FLASH_FLAG_STRBERR_BANK1 | \
240070ce:	4b2f      	ldr	r3, [pc, #188]	; (2400718c <HAL_FLASH_IRQHandler+0x25c>)
240070d0:	691b      	ldr	r3, [r3, #16]
240070d2:	f403 03dc 	and.w	r3, r3, #7208960	; 0x6e0000
240070d6:	607b      	str	r3, [r7, #4]
#else
  errorflag = FLASH->SR1 & (FLASH_FLAG_WRPERR_BANK1 | FLASH_FLAG_PGSERR_BANK1 | FLASH_FLAG_STRBERR_BANK1 | \
                            FLASH_FLAG_INCERR_BANK1);
#endif /* FLASH_SR_OPERR */

  if(errorflag != 0U)
240070d8:	687b      	ldr	r3, [r7, #4]
240070da:	2b00      	cmp	r3, #0
240070dc:	d028      	beq.n	24007130 <HAL_FLASH_IRQHandler+0x200>
  {
    /* Save the error code */
    pFlash.ErrorCode |= errorflag;
240070de:	4b2c      	ldr	r3, [pc, #176]	; (24007190 <HAL_FLASH_IRQHandler+0x260>)
240070e0:	699a      	ldr	r2, [r3, #24]
240070e2:	687b      	ldr	r3, [r7, #4]
240070e4:	4313      	orrs	r3, r2
240070e6:	4a2a      	ldr	r2, [pc, #168]	; (24007190 <HAL_FLASH_IRQHandler+0x260>)
240070e8:	6193      	str	r3, [r2, #24]

    /* Clear error programming flags */
    __HAL_FLASH_CLEAR_FLAG_BANK1(errorflag);
240070ea:	4a28      	ldr	r2, [pc, #160]	; (2400718c <HAL_FLASH_IRQHandler+0x25c>)
240070ec:	687b      	ldr	r3, [r7, #4]
240070ee:	6153      	str	r3, [r2, #20]

    procedure = pFlash.ProcedureOnGoing;
240070f0:	4b27      	ldr	r3, [pc, #156]	; (24007190 <HAL_FLASH_IRQHandler+0x260>)
240070f2:	781b      	ldrb	r3, [r3, #0]
240070f4:	72fb      	strb	r3, [r7, #11]

    if(procedure == FLASH_PROC_SECTERASE_BANK1)
240070f6:	7afb      	ldrb	r3, [r7, #11]
240070f8:	2b01      	cmp	r3, #1
240070fa:	d107      	bne.n	2400710c <HAL_FLASH_IRQHandler+0x1dc>
    {
      /* Return the faulty sector */
      temp = pFlash.Sector;
240070fc:	4b24      	ldr	r3, [pc, #144]	; (24007190 <HAL_FLASH_IRQHandler+0x260>)
240070fe:	68db      	ldr	r3, [r3, #12]
24007100:	60fb      	str	r3, [r7, #12]
      pFlash.Sector = 0xFFFFFFFFU;
24007102:	4b23      	ldr	r3, [pc, #140]	; (24007190 <HAL_FLASH_IRQHandler+0x260>)
24007104:	f04f 32ff 	mov.w	r2, #4294967295
24007108:	60da      	str	r2, [r3, #12]
2400710a:	e00b      	b.n	24007124 <HAL_FLASH_IRQHandler+0x1f4>
    }
    else if((procedure == FLASH_PROC_MASSERASE_BANK1) || (procedure == FLASH_PROC_ALLBANK_MASSERASE))
2400710c:	7afb      	ldrb	r3, [r7, #11]
2400710e:	2b02      	cmp	r3, #2
24007110:	d002      	beq.n	24007118 <HAL_FLASH_IRQHandler+0x1e8>
24007112:	7afb      	ldrb	r3, [r7, #11]
24007114:	2b07      	cmp	r3, #7
24007116:	d102      	bne.n	2400711e <HAL_FLASH_IRQHandler+0x1ee>
    {
      /* Return the faulty bank */
      temp = FLASH_BANK_1;
24007118:	2301      	movs	r3, #1
2400711a:	60fb      	str	r3, [r7, #12]
2400711c:	e002      	b.n	24007124 <HAL_FLASH_IRQHandler+0x1f4>
    }
    else
    {
      /* Return the faulty address */
      temp = pFlash.Address;
2400711e:	4b1c      	ldr	r3, [pc, #112]	; (24007190 <HAL_FLASH_IRQHandler+0x260>)
24007120:	691b      	ldr	r3, [r3, #16]
24007122:	60fb      	str	r3, [r7, #12]
    }

    /* Stop the procedure ongoing*/
    pFlash.ProcedureOnGoing = FLASH_PROC_NONE;
24007124:	4b1a      	ldr	r3, [pc, #104]	; (24007190 <HAL_FLASH_IRQHandler+0x260>)
24007126:	2200      	movs	r2, #0
24007128:	701a      	strb	r2, [r3, #0]

    /* FLASH error interrupt user callback */
    HAL_FLASH_OperationErrorCallback(temp);
2400712a:	68f8      	ldr	r0, [r7, #12]
2400712c:	f000 f864 	bl	240071f8 <HAL_FLASH_OperationErrorCallback>
  }

  /* Check FLASH Bank2 operation error flags */
#if defined (FLASH_SR_OPERR)
  errorflag = FLASH->SR2 & ((FLASH_FLAG_WRPERR_BANK2 | FLASH_FLAG_PGSERR_BANK2 | FLASH_FLAG_STRBERR_BANK2 | \
24007130:	4b16      	ldr	r3, [pc, #88]	; (2400718c <HAL_FLASH_IRQHandler+0x25c>)
24007132:	f8d3 3110 	ldr.w	r3, [r3, #272]	; 0x110
24007136:	f403 03dc 	and.w	r3, r3, #7208960	; 0x6e0000
2400713a:	607b      	str	r3, [r7, #4]
#else
  errorflag = FLASH->SR2 & ((FLASH_FLAG_WRPERR_BANK2 | FLASH_FLAG_PGSERR_BANK2 | FLASH_FLAG_STRBERR_BANK2 | \
                             FLASH_FLAG_INCERR_BANK2) & 0x7FFFFFFFU);
#endif /* FLASH_SR_OPERR */

  if(errorflag != 0U)
2400713c:	687b      	ldr	r3, [r7, #4]
2400713e:	2b00      	cmp	r3, #0
24007140:	d031      	beq.n	240071a6 <HAL_FLASH_IRQHandler+0x276>
  {
    /* Save the error code */
    pFlash.ErrorCode |= (errorflag | 0x80000000U);
24007142:	4b13      	ldr	r3, [pc, #76]	; (24007190 <HAL_FLASH_IRQHandler+0x260>)
24007144:	699a      	ldr	r2, [r3, #24]
24007146:	687b      	ldr	r3, [r7, #4]
24007148:	4313      	orrs	r3, r2
2400714a:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
2400714e:	4a10      	ldr	r2, [pc, #64]	; (24007190 <HAL_FLASH_IRQHandler+0x260>)
24007150:	6193      	str	r3, [r2, #24]

    /* Clear error programming flags */
    __HAL_FLASH_CLEAR_FLAG_BANK2(errorflag);
24007152:	4a0e      	ldr	r2, [pc, #56]	; (2400718c <HAL_FLASH_IRQHandler+0x25c>)
24007154:	687b      	ldr	r3, [r7, #4]
24007156:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
2400715a:	f8c2 3114 	str.w	r3, [r2, #276]	; 0x114

    procedure = pFlash.ProcedureOnGoing;
2400715e:	4b0c      	ldr	r3, [pc, #48]	; (24007190 <HAL_FLASH_IRQHandler+0x260>)
24007160:	781b      	ldrb	r3, [r3, #0]
24007162:	72fb      	strb	r3, [r7, #11]

    if(procedure== FLASH_PROC_SECTERASE_BANK2)
24007164:	7afb      	ldrb	r3, [r7, #11]
24007166:	2b04      	cmp	r3, #4
24007168:	d107      	bne.n	2400717a <HAL_FLASH_IRQHandler+0x24a>
    {
      /*return the faulty sector*/
      temp = pFlash.Sector;
2400716a:	4b09      	ldr	r3, [pc, #36]	; (24007190 <HAL_FLASH_IRQHandler+0x260>)
2400716c:	68db      	ldr	r3, [r3, #12]
2400716e:	60fb      	str	r3, [r7, #12]
      pFlash.Sector = 0xFFFFFFFFU;
24007170:	4b07      	ldr	r3, [pc, #28]	; (24007190 <HAL_FLASH_IRQHandler+0x260>)
24007172:	f04f 32ff 	mov.w	r2, #4294967295
24007176:	60da      	str	r2, [r3, #12]
24007178:	e00f      	b.n	2400719a <HAL_FLASH_IRQHandler+0x26a>
    }
    else if((procedure == FLASH_PROC_MASSERASE_BANK2) || (procedure == FLASH_PROC_ALLBANK_MASSERASE))
2400717a:	7afb      	ldrb	r3, [r7, #11]
2400717c:	2b05      	cmp	r3, #5
2400717e:	d002      	beq.n	24007186 <HAL_FLASH_IRQHandler+0x256>
24007180:	7afb      	ldrb	r3, [r7, #11]
24007182:	2b07      	cmp	r3, #7
24007184:	d106      	bne.n	24007194 <HAL_FLASH_IRQHandler+0x264>
    {
      /*return the faulty bank*/
      temp = FLASH_BANK_2;
24007186:	2302      	movs	r3, #2
24007188:	60fb      	str	r3, [r7, #12]
2400718a:	e006      	b.n	2400719a <HAL_FLASH_IRQHandler+0x26a>
2400718c:	52002000 	.word	0x52002000
24007190:	2400054c 	.word	0x2400054c
    }
    else
    {
      /*return the faulty address*/
      temp = pFlash.Address;
24007194:	4b11      	ldr	r3, [pc, #68]	; (240071dc <HAL_FLASH_IRQHandler+0x2ac>)
24007196:	691b      	ldr	r3, [r3, #16]
24007198:	60fb      	str	r3, [r7, #12]
    }

    /*Stop the procedure ongoing*/
    pFlash.ProcedureOnGoing = FLASH_PROC_NONE;
2400719a:	4b10      	ldr	r3, [pc, #64]	; (240071dc <HAL_FLASH_IRQHandler+0x2ac>)
2400719c:	2200      	movs	r2, #0
2400719e:	701a      	strb	r2, [r3, #0]

    /* FLASH error interrupt user callback */
    HAL_FLASH_OperationErrorCallback(temp);
240071a0:	68f8      	ldr	r0, [r7, #12]
240071a2:	f000 f829 	bl	240071f8 <HAL_FLASH_OperationErrorCallback>
  }

  if(pFlash.ProcedureOnGoing == FLASH_PROC_NONE)
240071a6:	4b0d      	ldr	r3, [pc, #52]	; (240071dc <HAL_FLASH_IRQHandler+0x2ac>)
240071a8:	781b      	ldrb	r3, [r3, #0]
240071aa:	b2db      	uxtb	r3, r3
240071ac:	2b00      	cmp	r3, #0
240071ae:	d110      	bne.n	240071d2 <HAL_FLASH_IRQHandler+0x2a2>
  {
#if defined (FLASH_CR_OPERRIE)
    /* Disable Bank1 Operation and Error source interrupt */
    __HAL_FLASH_DISABLE_IT_BANK1(FLASH_IT_EOP_BANK1    | FLASH_IT_WRPERR_BANK1 | FLASH_IT_PGSERR_BANK1 | \
240071b0:	4b0b      	ldr	r3, [pc, #44]	; (240071e0 <HAL_FLASH_IRQHandler+0x2b0>)
240071b2:	68db      	ldr	r3, [r3, #12]
240071b4:	4a0a      	ldr	r2, [pc, #40]	; (240071e0 <HAL_FLASH_IRQHandler+0x2b0>)
240071b6:	f423 03de 	bic.w	r3, r3, #7274496	; 0x6f0000
240071ba:	60d3      	str	r3, [r2, #12]
                                 FLASH_IT_STRBERR_BANK1 | FLASH_IT_INCERR_BANK1 | FLASH_IT_OPERR_BANK1);

    /* Disable Bank2 Operation and Error source interrupt */
    __HAL_FLASH_DISABLE_IT_BANK2(FLASH_IT_EOP_BANK2    | FLASH_IT_WRPERR_BANK2 | FLASH_IT_PGSERR_BANK2 | \
240071bc:	4b08      	ldr	r3, [pc, #32]	; (240071e0 <HAL_FLASH_IRQHandler+0x2b0>)
240071be:	f8d3 310c 	ldr.w	r3, [r3, #268]	; 0x10c
240071c2:	4a07      	ldr	r2, [pc, #28]	; (240071e0 <HAL_FLASH_IRQHandler+0x2b0>)
240071c4:	f423 03de 	bic.w	r3, r3, #7274496	; 0x6f0000
240071c8:	f8c2 310c 	str.w	r3, [r2, #268]	; 0x10c
    __HAL_FLASH_DISABLE_IT_BANK2(FLASH_IT_EOP_BANK2    | FLASH_IT_WRPERR_BANK2 | FLASH_IT_PGSERR_BANK2 | \
                                 FLASH_IT_STRBERR_BANK2 | FLASH_IT_INCERR_BANK2);
#endif /* FLASH_CR_OPERRIE */

    /* Process Unlocked */
    __HAL_UNLOCK(&pFlash);
240071cc:	4b03      	ldr	r3, [pc, #12]	; (240071dc <HAL_FLASH_IRQHandler+0x2ac>)
240071ce:	2200      	movs	r2, #0
240071d0:	751a      	strb	r2, [r3, #20]
  }
}
240071d2:	bf00      	nop
240071d4:	3710      	adds	r7, #16
240071d6:	46bd      	mov	sp, r7
240071d8:	bd80      	pop	{r7, pc}
240071da:	bf00      	nop
240071dc:	2400054c 	.word	0x2400054c
240071e0:	52002000 	.word	0x52002000

240071e4 <HAL_FLASH_EndOfOperationCallback>:
  *                    (if 0xFFFFFFFF, it means that all the selected sectors have been erased)
  *                  Program: Address which was selected for data program
  * @retval None
  */
__weak void HAL_FLASH_EndOfOperationCallback(uint32_t ReturnValue)
{
240071e4:	b480      	push	{r7}
240071e6:	b083      	sub	sp, #12
240071e8:	af00      	add	r7, sp, #0
240071ea:	6078      	str	r0, [r7, #4]
  UNUSED(ReturnValue);

  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_FLASH_EndOfOperationCallback could be implemented in the user file
   */
}
240071ec:	bf00      	nop
240071ee:	370c      	adds	r7, #12
240071f0:	46bd      	mov	sp, r7
240071f2:	f85d 7b04 	ldr.w	r7, [sp], #4
240071f6:	4770      	bx	lr

240071f8 <HAL_FLASH_OperationErrorCallback>:
  *                 Sectors Erase: Sector number which returned an error
  *                 Program: Address which was selected for data program
  * @retval None
  */
__weak void HAL_FLASH_OperationErrorCallback(uint32_t ReturnValue)
{
240071f8:	b480      	push	{r7}
240071fa:	b083      	sub	sp, #12
240071fc:	af00      	add	r7, sp, #0
240071fe:	6078      	str	r0, [r7, #4]
  UNUSED(ReturnValue);

  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_FLASH_OperationErrorCallback could be implemented in the user file
   */
}
24007200:	bf00      	nop
24007202:	370c      	adds	r7, #12
24007204:	46bd      	mov	sp, r7
24007206:	f85d 7b04 	ldr.w	r7, [sp], #4
2400720a:	4770      	bx	lr

2400720c <HAL_FLASH_Unlock>:
/**
  * @brief  Unlock the FLASH control registers access
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_FLASH_Unlock(void)
{
2400720c:	b480      	push	{r7}
2400720e:	af00      	add	r7, sp, #0
  if(READ_BIT(FLASH->CR1, FLASH_CR_LOCK) != 0U)
24007210:	4b18      	ldr	r3, [pc, #96]	; (24007274 <HAL_FLASH_Unlock+0x68>)
24007212:	68db      	ldr	r3, [r3, #12]
24007214:	f003 0301 	and.w	r3, r3, #1
24007218:	2b00      	cmp	r3, #0
2400721a:	d00d      	beq.n	24007238 <HAL_FLASH_Unlock+0x2c>
  {
    /* Authorize the FLASH Bank1 Registers access */
    WRITE_REG(FLASH->KEYR1, FLASH_KEY1);
2400721c:	4b15      	ldr	r3, [pc, #84]	; (24007274 <HAL_FLASH_Unlock+0x68>)
2400721e:	4a16      	ldr	r2, [pc, #88]	; (24007278 <HAL_FLASH_Unlock+0x6c>)
24007220:	605a      	str	r2, [r3, #4]
    WRITE_REG(FLASH->KEYR1, FLASH_KEY2);
24007222:	4b14      	ldr	r3, [pc, #80]	; (24007274 <HAL_FLASH_Unlock+0x68>)
24007224:	4a15      	ldr	r2, [pc, #84]	; (2400727c <HAL_FLASH_Unlock+0x70>)
24007226:	605a      	str	r2, [r3, #4]

    /* Verify Flash Bank1 is unlocked */
    if (READ_BIT(FLASH->CR1, FLASH_CR_LOCK) != 0U)
24007228:	4b12      	ldr	r3, [pc, #72]	; (24007274 <HAL_FLASH_Unlock+0x68>)
2400722a:	68db      	ldr	r3, [r3, #12]
2400722c:	f003 0301 	and.w	r3, r3, #1
24007230:	2b00      	cmp	r3, #0
24007232:	d001      	beq.n	24007238 <HAL_FLASH_Unlock+0x2c>
    {
      return HAL_ERROR;
24007234:	2301      	movs	r3, #1
24007236:	e018      	b.n	2400726a <HAL_FLASH_Unlock+0x5e>
    }
  }

  if(READ_BIT(FLASH->CR2, FLASH_CR_LOCK) != 0U)
24007238:	4b0e      	ldr	r3, [pc, #56]	; (24007274 <HAL_FLASH_Unlock+0x68>)
2400723a:	f8d3 310c 	ldr.w	r3, [r3, #268]	; 0x10c
2400723e:	f003 0301 	and.w	r3, r3, #1
24007242:	2b00      	cmp	r3, #0
24007244:	d010      	beq.n	24007268 <HAL_FLASH_Unlock+0x5c>
  {
    /* Authorize the FLASH Bank2 Registers access */
    WRITE_REG(FLASH->KEYR2, FLASH_KEY1);
24007246:	4b0b      	ldr	r3, [pc, #44]	; (24007274 <HAL_FLASH_Unlock+0x68>)
24007248:	4a0b      	ldr	r2, [pc, #44]	; (24007278 <HAL_FLASH_Unlock+0x6c>)
2400724a:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
    WRITE_REG(FLASH->KEYR2, FLASH_KEY2);
2400724e:	4b09      	ldr	r3, [pc, #36]	; (24007274 <HAL_FLASH_Unlock+0x68>)
24007250:	4a0a      	ldr	r2, [pc, #40]	; (2400727c <HAL_FLASH_Unlock+0x70>)
24007252:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104

    /* Verify Flash Bank2 is unlocked */
    if (READ_BIT(FLASH->CR2, FLASH_CR_LOCK) != 0U)
24007256:	4b07      	ldr	r3, [pc, #28]	; (24007274 <HAL_FLASH_Unlock+0x68>)
24007258:	f8d3 310c 	ldr.w	r3, [r3, #268]	; 0x10c
2400725c:	f003 0301 	and.w	r3, r3, #1
24007260:	2b00      	cmp	r3, #0
24007262:	d001      	beq.n	24007268 <HAL_FLASH_Unlock+0x5c>
    {
      return HAL_ERROR;
24007264:	2301      	movs	r3, #1
24007266:	e000      	b.n	2400726a <HAL_FLASH_Unlock+0x5e>
    }
  }

  return HAL_OK;
24007268:	2300      	movs	r3, #0
}
2400726a:	4618      	mov	r0, r3
2400726c:	46bd      	mov	sp, r7
2400726e:	f85d 7b04 	ldr.w	r7, [sp], #4
24007272:	4770      	bx	lr
24007274:	52002000 	.word	0x52002000
24007278:	45670123 	.word	0x45670123
2400727c:	cdef89ab 	.word	0xcdef89ab

24007280 <HAL_FLASH_Lock>:
/**
  * @brief  Locks the FLASH control registers access
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_FLASH_Lock(void)
{
24007280:	b480      	push	{r7}
24007282:	af00      	add	r7, sp, #0
  /* Set the LOCK Bit to lock the FLASH Bank1 Control Register access */
  SET_BIT(FLASH->CR1, FLASH_CR_LOCK);
24007284:	4b12      	ldr	r3, [pc, #72]	; (240072d0 <HAL_FLASH_Lock+0x50>)
24007286:	68db      	ldr	r3, [r3, #12]
24007288:	4a11      	ldr	r2, [pc, #68]	; (240072d0 <HAL_FLASH_Lock+0x50>)
2400728a:	f043 0301 	orr.w	r3, r3, #1
2400728e:	60d3      	str	r3, [r2, #12]

  /* Verify Flash Bank1 is locked */
  if (READ_BIT(FLASH->CR1, FLASH_CR_LOCK) == 0U)
24007290:	4b0f      	ldr	r3, [pc, #60]	; (240072d0 <HAL_FLASH_Lock+0x50>)
24007292:	68db      	ldr	r3, [r3, #12]
24007294:	f003 0301 	and.w	r3, r3, #1
24007298:	2b00      	cmp	r3, #0
2400729a:	d101      	bne.n	240072a0 <HAL_FLASH_Lock+0x20>
  {
    return HAL_ERROR;
2400729c:	2301      	movs	r3, #1
2400729e:	e011      	b.n	240072c4 <HAL_FLASH_Lock+0x44>
  }

  /* Set the LOCK Bit to lock the FLASH Bank2 Control Register access */
  SET_BIT(FLASH->CR2, FLASH_CR_LOCK);
240072a0:	4b0b      	ldr	r3, [pc, #44]	; (240072d0 <HAL_FLASH_Lock+0x50>)
240072a2:	f8d3 310c 	ldr.w	r3, [r3, #268]	; 0x10c
240072a6:	4a0a      	ldr	r2, [pc, #40]	; (240072d0 <HAL_FLASH_Lock+0x50>)
240072a8:	f043 0301 	orr.w	r3, r3, #1
240072ac:	f8c2 310c 	str.w	r3, [r2, #268]	; 0x10c

  /* Verify Flash Bank2 is locked */
  if (READ_BIT(FLASH->CR2, FLASH_CR_LOCK) == 0U)
240072b0:	4b07      	ldr	r3, [pc, #28]	; (240072d0 <HAL_FLASH_Lock+0x50>)
240072b2:	f8d3 310c 	ldr.w	r3, [r3, #268]	; 0x10c
240072b6:	f003 0301 	and.w	r3, r3, #1
240072ba:	2b00      	cmp	r3, #0
240072bc:	d101      	bne.n	240072c2 <HAL_FLASH_Lock+0x42>
  {
    return HAL_ERROR;
240072be:	2301      	movs	r3, #1
240072c0:	e000      	b.n	240072c4 <HAL_FLASH_Lock+0x44>
  }

  return HAL_OK;
240072c2:	2300      	movs	r3, #0
}
240072c4:	4618      	mov	r0, r3
240072c6:	46bd      	mov	sp, r7
240072c8:	f85d 7b04 	ldr.w	r7, [sp], #4
240072cc:	4770      	bx	lr
240072ce:	bf00      	nop
240072d0:	52002000 	.word	0x52002000

240072d4 <HAL_FLASH_OB_Unlock>:
/**
  * @brief  Unlock the FLASH Option Control Registers access.
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_FLASH_OB_Unlock(void)
{
240072d4:	b480      	push	{r7}
240072d6:	af00      	add	r7, sp, #0
  if(READ_BIT(FLASH->OPTCR, FLASH_OPTCR_OPTLOCK) != 0U)
240072d8:	4b0c      	ldr	r3, [pc, #48]	; (2400730c <HAL_FLASH_OB_Unlock+0x38>)
240072da:	699b      	ldr	r3, [r3, #24]
240072dc:	f003 0301 	and.w	r3, r3, #1
240072e0:	2b00      	cmp	r3, #0
240072e2:	d00d      	beq.n	24007300 <HAL_FLASH_OB_Unlock+0x2c>
  {
    /* Authorizes the Option Byte registers programming */
    WRITE_REG(FLASH->OPTKEYR, FLASH_OPT_KEY1);
240072e4:	4b09      	ldr	r3, [pc, #36]	; (2400730c <HAL_FLASH_OB_Unlock+0x38>)
240072e6:	4a0a      	ldr	r2, [pc, #40]	; (24007310 <HAL_FLASH_OB_Unlock+0x3c>)
240072e8:	609a      	str	r2, [r3, #8]
    WRITE_REG(FLASH->OPTKEYR, FLASH_OPT_KEY2);
240072ea:	4b08      	ldr	r3, [pc, #32]	; (2400730c <HAL_FLASH_OB_Unlock+0x38>)
240072ec:	4a09      	ldr	r2, [pc, #36]	; (24007314 <HAL_FLASH_OB_Unlock+0x40>)
240072ee:	609a      	str	r2, [r3, #8]

    /* Verify that the Option Bytes are unlocked */
    if (READ_BIT(FLASH->OPTCR, FLASH_OPTCR_OPTLOCK) != 0U)
240072f0:	4b06      	ldr	r3, [pc, #24]	; (2400730c <HAL_FLASH_OB_Unlock+0x38>)
240072f2:	699b      	ldr	r3, [r3, #24]
240072f4:	f003 0301 	and.w	r3, r3, #1
240072f8:	2b00      	cmp	r3, #0
240072fa:	d001      	beq.n	24007300 <HAL_FLASH_OB_Unlock+0x2c>
    {
      return HAL_ERROR;
240072fc:	2301      	movs	r3, #1
240072fe:	e000      	b.n	24007302 <HAL_FLASH_OB_Unlock+0x2e>
    }
  }

  return HAL_OK;
24007300:	2300      	movs	r3, #0
}
24007302:	4618      	mov	r0, r3
24007304:	46bd      	mov	sp, r7
24007306:	f85d 7b04 	ldr.w	r7, [sp], #4
2400730a:	4770      	bx	lr
2400730c:	52002000 	.word	0x52002000
24007310:	08192a3b 	.word	0x08192a3b
24007314:	4c5d6e7f 	.word	0x4c5d6e7f

24007318 <HAL_FLASH_OB_Lock>:
/**
  * @brief  Lock the FLASH Option Control Registers access.
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_FLASH_OB_Lock(void)
{
24007318:	b480      	push	{r7}
2400731a:	af00      	add	r7, sp, #0
  /* Set the OPTLOCK Bit to lock the FLASH Option Byte Registers access */
  SET_BIT(FLASH->OPTCR, FLASH_OPTCR_OPTLOCK);
2400731c:	4b09      	ldr	r3, [pc, #36]	; (24007344 <HAL_FLASH_OB_Lock+0x2c>)
2400731e:	699b      	ldr	r3, [r3, #24]
24007320:	4a08      	ldr	r2, [pc, #32]	; (24007344 <HAL_FLASH_OB_Lock+0x2c>)
24007322:	f043 0301 	orr.w	r3, r3, #1
24007326:	6193      	str	r3, [r2, #24]

  /* Verify that the Option Bytes are locked */
  if (READ_BIT(FLASH->OPTCR, FLASH_OPTCR_OPTLOCK) == 0U)
24007328:	4b06      	ldr	r3, [pc, #24]	; (24007344 <HAL_FLASH_OB_Lock+0x2c>)
2400732a:	699b      	ldr	r3, [r3, #24]
2400732c:	f003 0301 	and.w	r3, r3, #1
24007330:	2b00      	cmp	r3, #0
24007332:	d101      	bne.n	24007338 <HAL_FLASH_OB_Lock+0x20>
  {
    return HAL_ERROR;
24007334:	2301      	movs	r3, #1
24007336:	e000      	b.n	2400733a <HAL_FLASH_OB_Lock+0x22>
  }

  return HAL_OK;
24007338:	2300      	movs	r3, #0
}
2400733a:	4618      	mov	r0, r3
2400733c:	46bd      	mov	sp, r7
2400733e:	f85d 7b04 	ldr.w	r7, [sp], #4
24007342:	4770      	bx	lr
24007344:	52002000 	.word	0x52002000

24007348 <HAL_FLASH_OB_Launch>:
/**
  * @brief  Launch the option bytes loading.
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_FLASH_OB_Launch(void)
{
24007348:	b580      	push	{r7, lr}
2400734a:	b082      	sub	sp, #8
2400734c:	af00      	add	r7, sp, #0
  HAL_StatusTypeDef status;

  /* Wait for CRC computation to be completed */
  if (FLASH_CRC_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_1) != HAL_OK)
2400734e:	2101      	movs	r1, #1
24007350:	f24c 3050 	movw	r0, #50000	; 0xc350
24007354:	f000 f90e 	bl	24007574 <FLASH_CRC_WaitForLastOperation>
24007358:	4603      	mov	r3, r0
2400735a:	2b00      	cmp	r3, #0
2400735c:	d002      	beq.n	24007364 <HAL_FLASH_OB_Launch+0x1c>
  {
    status = HAL_ERROR;
2400735e:	2301      	movs	r3, #1
24007360:	71fb      	strb	r3, [r7, #7]
24007362:	e00c      	b.n	2400737e <HAL_FLASH_OB_Launch+0x36>
  }
  else if (FLASH_CRC_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_2) != HAL_OK)
24007364:	2102      	movs	r1, #2
24007366:	f24c 3050 	movw	r0, #50000	; 0xc350
2400736a:	f000 f903 	bl	24007574 <FLASH_CRC_WaitForLastOperation>
2400736e:	4603      	mov	r3, r0
24007370:	2b00      	cmp	r3, #0
24007372:	d002      	beq.n	2400737a <HAL_FLASH_OB_Launch+0x32>
  {
    status = HAL_ERROR;
24007374:	2301      	movs	r3, #1
24007376:	71fb      	strb	r3, [r7, #7]
24007378:	e001      	b.n	2400737e <HAL_FLASH_OB_Launch+0x36>
  }
  else
  {
    status = HAL_OK;
2400737a:	2300      	movs	r3, #0
2400737c:	71fb      	strb	r3, [r7, #7]
  }

  if (status == HAL_OK)
2400737e:	79fb      	ldrb	r3, [r7, #7]
24007380:	2b00      	cmp	r3, #0
24007382:	d10b      	bne.n	2400739c <HAL_FLASH_OB_Launch+0x54>
  {
    /* Set OPTSTRT Bit */
    SET_BIT(FLASH->OPTCR, FLASH_OPTCR_OPTSTART);
24007384:	4b08      	ldr	r3, [pc, #32]	; (240073a8 <HAL_FLASH_OB_Launch+0x60>)
24007386:	699b      	ldr	r3, [r3, #24]
24007388:	4a07      	ldr	r2, [pc, #28]	; (240073a8 <HAL_FLASH_OB_Launch+0x60>)
2400738a:	f043 0302 	orr.w	r3, r3, #2
2400738e:	6193      	str	r3, [r2, #24]

    /* Wait for OB change operation to be completed */
    status = FLASH_OB_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
24007390:	f24c 3050 	movw	r0, #50000	; 0xc350
24007394:	f000 f8b2 	bl	240074fc <FLASH_OB_WaitForLastOperation>
24007398:	4603      	mov	r3, r0
2400739a:	71fb      	strb	r3, [r7, #7]
  }

  return status;
2400739c:	79fb      	ldrb	r3, [r7, #7]
}
2400739e:	4618      	mov	r0, r3
240073a0:	3708      	adds	r7, #8
240073a2:	46bd      	mov	sp, r7
240073a4:	bd80      	pop	{r7, pc}
240073a6:	bf00      	nop
240073a8:	52002000 	.word	0x52002000

240073ac <HAL_FLASH_GetError>:
  *            @arg HAL_FLASH_ERROR_DBECC_BANK2: Double Detection ECC on Bank 2
  *            @arg HAL_FLASH_ERROR_CRCRD_BANK2: CRC Read Error on Bank 2
*/

uint32_t HAL_FLASH_GetError(void)
{
240073ac:	b480      	push	{r7}
240073ae:	af00      	add	r7, sp, #0
   return pFlash.ErrorCode;
240073b0:	4b03      	ldr	r3, [pc, #12]	; (240073c0 <HAL_FLASH_GetError+0x14>)
240073b2:	699b      	ldr	r3, [r3, #24]
}
240073b4:	4618      	mov	r0, r3
240073b6:	46bd      	mov	sp, r7
240073b8:	f85d 7b04 	ldr.w	r7, [sp], #4
240073bc:	4770      	bx	lr
240073be:	bf00      	nop
240073c0:	2400054c 	.word	0x2400054c

240073c4 <FLASH_WaitForLastOperation>:
  * @param  Timeout maximum flash operation timeout
  * @param  Bank flash FLASH_BANK_1 or FLASH_BANK_2
  * @retval HAL_StatusTypeDef HAL Status
  */
HAL_StatusTypeDef FLASH_WaitForLastOperation(uint32_t Timeout, uint32_t Bank)
{
240073c4:	b580      	push	{r7, lr}
240073c6:	b086      	sub	sp, #24
240073c8:	af00      	add	r7, sp, #0
240073ca:	6078      	str	r0, [r7, #4]
240073cc:	6039      	str	r1, [r7, #0]
  /* Wait for the FLASH operation to complete by polling on QW flag to be reset.
     Even if the FLASH operation fails, the QW flag will be reset and an error
     flag will be set */

  uint32_t bsyflag, errorflag;
  uint32_t tickstart = HAL_GetTick();
240073ce:	f7f9 fa41 	bl	24000854 <HAL_GetTick>
240073d2:	60f8      	str	r0, [r7, #12]

  assert_param(IS_FLASH_BANK_EXCLUSIVE(Bank));

  /* Select bsyflag depending on Bank */
  if(Bank == FLASH_BANK_1)
240073d4:	683b      	ldr	r3, [r7, #0]
240073d6:	2b01      	cmp	r3, #1
240073d8:	d102      	bne.n	240073e0 <FLASH_WaitForLastOperation+0x1c>
  {
    bsyflag = FLASH_FLAG_QW_BANK1;
240073da:	2304      	movs	r3, #4
240073dc:	617b      	str	r3, [r7, #20]
240073de:	e013      	b.n	24007408 <FLASH_WaitForLastOperation+0x44>
  }
  else
  {
    bsyflag = FLASH_FLAG_QW_BANK2;
240073e0:	4b41      	ldr	r3, [pc, #260]	; (240074e8 <FLASH_WaitForLastOperation+0x124>)
240073e2:	617b      	str	r3, [r7, #20]
  }

  while(__HAL_FLASH_GET_FLAG(bsyflag))
240073e4:	e010      	b.n	24007408 <FLASH_WaitForLastOperation+0x44>
  {
    if(Timeout != HAL_MAX_DELAY)
240073e6:	687b      	ldr	r3, [r7, #4]
240073e8:	f1b3 3fff 	cmp.w	r3, #4294967295
240073ec:	d00c      	beq.n	24007408 <FLASH_WaitForLastOperation+0x44>
    {
      if(((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
240073ee:	f7f9 fa31 	bl	24000854 <HAL_GetTick>
240073f2:	4602      	mov	r2, r0
240073f4:	68fb      	ldr	r3, [r7, #12]
240073f6:	1ad3      	subs	r3, r2, r3
240073f8:	687a      	ldr	r2, [r7, #4]
240073fa:	429a      	cmp	r2, r3
240073fc:	d302      	bcc.n	24007404 <FLASH_WaitForLastOperation+0x40>
240073fe:	687b      	ldr	r3, [r7, #4]
24007400:	2b00      	cmp	r3, #0
24007402:	d101      	bne.n	24007408 <FLASH_WaitForLastOperation+0x44>
      {
        return HAL_TIMEOUT;
24007404:	2303      	movs	r3, #3
24007406:	e06a      	b.n	240074de <FLASH_WaitForLastOperation+0x11a>
  while(__HAL_FLASH_GET_FLAG(bsyflag))
24007408:	697a      	ldr	r2, [r7, #20]
2400740a:	4b38      	ldr	r3, [pc, #224]	; (240074ec <FLASH_WaitForLastOperation+0x128>)
2400740c:	4013      	ands	r3, r2
2400740e:	697a      	ldr	r2, [r7, #20]
24007410:	429a      	cmp	r2, r3
24007412:	d10a      	bne.n	2400742a <FLASH_WaitForLastOperation+0x66>
24007414:	4b36      	ldr	r3, [pc, #216]	; (240074f0 <FLASH_WaitForLastOperation+0x12c>)
24007416:	691a      	ldr	r2, [r3, #16]
24007418:	697b      	ldr	r3, [r7, #20]
2400741a:	4013      	ands	r3, r2
2400741c:	697a      	ldr	r2, [r7, #20]
2400741e:	429a      	cmp	r2, r3
24007420:	bf0c      	ite	eq
24007422:	2301      	moveq	r3, #1
24007424:	2300      	movne	r3, #0
24007426:	b2db      	uxtb	r3, r3
24007428:	e00c      	b.n	24007444 <FLASH_WaitForLastOperation+0x80>
2400742a:	4b31      	ldr	r3, [pc, #196]	; (240074f0 <FLASH_WaitForLastOperation+0x12c>)
2400742c:	f8d3 3110 	ldr.w	r3, [r3, #272]	; 0x110
24007430:	43da      	mvns	r2, r3
24007432:	697b      	ldr	r3, [r7, #20]
24007434:	4013      	ands	r3, r2
24007436:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
2400743a:	2b00      	cmp	r3, #0
2400743c:	bf0c      	ite	eq
2400743e:	2301      	moveq	r3, #1
24007440:	2300      	movne	r3, #0
24007442:	b2db      	uxtb	r3, r3
24007444:	2b00      	cmp	r3, #0
24007446:	d1ce      	bne.n	240073e6 <FLASH_WaitForLastOperation+0x22>
      }
    }
  }

  /* Get Error Flags */
  if (Bank == FLASH_BANK_1)
24007448:	683b      	ldr	r3, [r7, #0]
2400744a:	2b01      	cmp	r3, #1
2400744c:	d105      	bne.n	2400745a <FLASH_WaitForLastOperation+0x96>
  {
    errorflag = FLASH->SR1 & FLASH_FLAG_ALL_ERRORS_BANK1;
2400744e:	4b28      	ldr	r3, [pc, #160]	; (240074f0 <FLASH_WaitForLastOperation+0x12c>)
24007450:	691a      	ldr	r2, [r3, #16]
24007452:	4b28      	ldr	r3, [pc, #160]	; (240074f4 <FLASH_WaitForLastOperation+0x130>)
24007454:	4013      	ands	r3, r2
24007456:	613b      	str	r3, [r7, #16]
24007458:	e007      	b.n	2400746a <FLASH_WaitForLastOperation+0xa6>
  }
  else
  {
    errorflag = (FLASH->SR2 & FLASH_FLAG_ALL_ERRORS_BANK2) | 0x80000000U;
2400745a:	4b25      	ldr	r3, [pc, #148]	; (240074f0 <FLASH_WaitForLastOperation+0x12c>)
2400745c:	f8d3 2110 	ldr.w	r2, [r3, #272]	; 0x110
24007460:	4b24      	ldr	r3, [pc, #144]	; (240074f4 <FLASH_WaitForLastOperation+0x130>)
24007462:	4013      	ands	r3, r2
24007464:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
24007468:	613b      	str	r3, [r7, #16]
  }

  /* In case of error reported in Flash SR1 or SR2 registers (ECCC not managed as an error) */
  if((errorflag & 0x7DFFFFFFU) != 0U)
2400746a:	693b      	ldr	r3, [r7, #16]
2400746c:	f023 4302 	bic.w	r3, r3, #2181038080	; 0x82000000
24007470:	2b00      	cmp	r3, #0
24007472:	d017      	beq.n	240074a4 <FLASH_WaitForLastOperation+0xe0>
  {
    /*Save the error code*/
    pFlash.ErrorCode |= errorflag;
24007474:	4b20      	ldr	r3, [pc, #128]	; (240074f8 <FLASH_WaitForLastOperation+0x134>)
24007476:	699a      	ldr	r2, [r3, #24]
24007478:	693b      	ldr	r3, [r7, #16]
2400747a:	4313      	orrs	r3, r2
2400747c:	4a1e      	ldr	r2, [pc, #120]	; (240074f8 <FLASH_WaitForLastOperation+0x134>)
2400747e:	6193      	str	r3, [r2, #24]

    /* Clear error programming flags */
    __HAL_FLASH_CLEAR_FLAG(errorflag);
24007480:	693a      	ldr	r2, [r7, #16]
24007482:	4b1a      	ldr	r3, [pc, #104]	; (240074ec <FLASH_WaitForLastOperation+0x128>)
24007484:	4013      	ands	r3, r2
24007486:	693a      	ldr	r2, [r7, #16]
24007488:	429a      	cmp	r2, r3
2400748a:	d103      	bne.n	24007494 <FLASH_WaitForLastOperation+0xd0>
2400748c:	4a18      	ldr	r2, [pc, #96]	; (240074f0 <FLASH_WaitForLastOperation+0x12c>)
2400748e:	693b      	ldr	r3, [r7, #16]
24007490:	6153      	str	r3, [r2, #20]
24007492:	e005      	b.n	240074a0 <FLASH_WaitForLastOperation+0xdc>
24007494:	4a16      	ldr	r2, [pc, #88]	; (240074f0 <FLASH_WaitForLastOperation+0x12c>)
24007496:	693b      	ldr	r3, [r7, #16]
24007498:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
2400749c:	f8c2 3114 	str.w	r3, [r2, #276]	; 0x114

    return HAL_ERROR;
240074a0:	2301      	movs	r3, #1
240074a2:	e01c      	b.n	240074de <FLASH_WaitForLastOperation+0x11a>
  }

  /* Check FLASH End of Operation flag  */
  if(Bank == FLASH_BANK_1)
240074a4:	683b      	ldr	r3, [r7, #0]
240074a6:	2b01      	cmp	r3, #1
240074a8:	d10b      	bne.n	240074c2 <FLASH_WaitForLastOperation+0xfe>
  {
    if (__HAL_FLASH_GET_FLAG_BANK1(FLASH_FLAG_EOP_BANK1))
240074aa:	4b11      	ldr	r3, [pc, #68]	; (240074f0 <FLASH_WaitForLastOperation+0x12c>)
240074ac:	691b      	ldr	r3, [r3, #16]
240074ae:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
240074b2:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
240074b6:	d111      	bne.n	240074dc <FLASH_WaitForLastOperation+0x118>
    {
      /* Clear FLASH End of Operation pending bit */
      __HAL_FLASH_CLEAR_FLAG_BANK1(FLASH_FLAG_EOP_BANK1);
240074b8:	4b0d      	ldr	r3, [pc, #52]	; (240074f0 <FLASH_WaitForLastOperation+0x12c>)
240074ba:	f44f 3280 	mov.w	r2, #65536	; 0x10000
240074be:	615a      	str	r2, [r3, #20]
240074c0:	e00c      	b.n	240074dc <FLASH_WaitForLastOperation+0x118>
    }
  }
  else
  {
    if (__HAL_FLASH_GET_FLAG_BANK2(FLASH_FLAG_EOP_BANK2))
240074c2:	4b0b      	ldr	r3, [pc, #44]	; (240074f0 <FLASH_WaitForLastOperation+0x12c>)
240074c4:	f8d3 3110 	ldr.w	r3, [r3, #272]	; 0x110
240074c8:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
240074cc:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
240074d0:	d104      	bne.n	240074dc <FLASH_WaitForLastOperation+0x118>
    {
      /* Clear FLASH End of Operation pending bit */
      __HAL_FLASH_CLEAR_FLAG_BANK2(FLASH_FLAG_EOP_BANK2);
240074d2:	4b07      	ldr	r3, [pc, #28]	; (240074f0 <FLASH_WaitForLastOperation+0x12c>)
240074d4:	f44f 3280 	mov.w	r2, #65536	; 0x10000
240074d8:	f8c3 2114 	str.w	r2, [r3, #276]	; 0x114
    }
  }

  return HAL_OK;
240074dc:	2300      	movs	r3, #0
}
240074de:	4618      	mov	r0, r3
240074e0:	3718      	adds	r7, #24
240074e2:	46bd      	mov	sp, r7
240074e4:	bd80      	pop	{r7, pc}
240074e6:	bf00      	nop
240074e8:	80000004 	.word	0x80000004
240074ec:	1fef000f 	.word	0x1fef000f
240074f0:	52002000 	.word	0x52002000
240074f4:	17ee0000 	.word	0x17ee0000
240074f8:	2400054c 	.word	0x2400054c

240074fc <FLASH_OB_WaitForLastOperation>:
  * @brief  Wait for a FLASH Option Bytes change operation to complete.
  * @param  Timeout maximum flash operation timeout
  * @retval HAL_StatusTypeDef HAL Status
  */
HAL_StatusTypeDef FLASH_OB_WaitForLastOperation(uint32_t Timeout)
{
240074fc:	b580      	push	{r7, lr}
240074fe:	b084      	sub	sp, #16
24007500:	af00      	add	r7, sp, #0
24007502:	6078      	str	r0, [r7, #4]
  /* Get timeout */
  uint32_t tickstart = HAL_GetTick();
24007504:	f7f9 f9a6 	bl	24000854 <HAL_GetTick>
24007508:	60f8      	str	r0, [r7, #12]

  /* Wait for the FLASH Option Bytes change operation to complete by polling on OPT_BUSY flag to be reset */
  while(READ_BIT(FLASH->OPTSR_CUR, FLASH_OPTSR_OPT_BUSY) != 0U)
2400750a:	e010      	b.n	2400752e <FLASH_OB_WaitForLastOperation+0x32>
  {
    if(Timeout != HAL_MAX_DELAY)
2400750c:	687b      	ldr	r3, [r7, #4]
2400750e:	f1b3 3fff 	cmp.w	r3, #4294967295
24007512:	d00c      	beq.n	2400752e <FLASH_OB_WaitForLastOperation+0x32>
    {
      if(((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
24007514:	f7f9 f99e 	bl	24000854 <HAL_GetTick>
24007518:	4602      	mov	r2, r0
2400751a:	68fb      	ldr	r3, [r7, #12]
2400751c:	1ad3      	subs	r3, r2, r3
2400751e:	687a      	ldr	r2, [r7, #4]
24007520:	429a      	cmp	r2, r3
24007522:	d302      	bcc.n	2400752a <FLASH_OB_WaitForLastOperation+0x2e>
24007524:	687b      	ldr	r3, [r7, #4]
24007526:	2b00      	cmp	r3, #0
24007528:	d101      	bne.n	2400752e <FLASH_OB_WaitForLastOperation+0x32>
      {
        return HAL_TIMEOUT;
2400752a:	2303      	movs	r3, #3
2400752c:	e01a      	b.n	24007564 <FLASH_OB_WaitForLastOperation+0x68>
  while(READ_BIT(FLASH->OPTSR_CUR, FLASH_OPTSR_OPT_BUSY) != 0U)
2400752e:	4b0f      	ldr	r3, [pc, #60]	; (2400756c <FLASH_OB_WaitForLastOperation+0x70>)
24007530:	69db      	ldr	r3, [r3, #28]
24007532:	f003 0301 	and.w	r3, r3, #1
24007536:	2b00      	cmp	r3, #0
24007538:	d1e8      	bne.n	2400750c <FLASH_OB_WaitForLastOperation+0x10>
      }
    }
  }

  /* Check option byte change error */
  if(READ_BIT(FLASH->OPTSR_CUR, FLASH_OPTSR_OPTCHANGEERR) != 0U)
2400753a:	4b0c      	ldr	r3, [pc, #48]	; (2400756c <FLASH_OB_WaitForLastOperation+0x70>)
2400753c:	69db      	ldr	r3, [r3, #28]
2400753e:	f003 4380 	and.w	r3, r3, #1073741824	; 0x40000000
24007542:	2b00      	cmp	r3, #0
24007544:	d00d      	beq.n	24007562 <FLASH_OB_WaitForLastOperation+0x66>
  {
    /* Save the error code */
    pFlash.ErrorCode |= HAL_FLASH_ERROR_OB_CHANGE;
24007546:	4b0a      	ldr	r3, [pc, #40]	; (24007570 <FLASH_OB_WaitForLastOperation+0x74>)
24007548:	699b      	ldr	r3, [r3, #24]
2400754a:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
2400754e:	4a08      	ldr	r2, [pc, #32]	; (24007570 <FLASH_OB_WaitForLastOperation+0x74>)
24007550:	6193      	str	r3, [r2, #24]

    /* Clear the OB error flag */
    FLASH->OPTCCR |= FLASH_OPTCCR_CLR_OPTCHANGEERR;
24007552:	4b06      	ldr	r3, [pc, #24]	; (2400756c <FLASH_OB_WaitForLastOperation+0x70>)
24007554:	6a5b      	ldr	r3, [r3, #36]	; 0x24
24007556:	4a05      	ldr	r2, [pc, #20]	; (2400756c <FLASH_OB_WaitForLastOperation+0x70>)
24007558:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
2400755c:	6253      	str	r3, [r2, #36]	; 0x24

    return HAL_ERROR;
2400755e:	2301      	movs	r3, #1
24007560:	e000      	b.n	24007564 <FLASH_OB_WaitForLastOperation+0x68>
  }

  /* If there is no error flag set */
  return HAL_OK;
24007562:	2300      	movs	r3, #0
}
24007564:	4618      	mov	r0, r3
24007566:	3710      	adds	r7, #16
24007568:	46bd      	mov	sp, r7
2400756a:	bd80      	pop	{r7, pc}
2400756c:	52002000 	.word	0x52002000
24007570:	2400054c 	.word	0x2400054c

24007574 <FLASH_CRC_WaitForLastOperation>:
  * @param  Timeout maximum flash operation timeout
  * @param  Bank flash FLASH_BANK_1 or FLASH_BANK_2
  * @retval HAL_StatusTypeDef HAL Status
  */
HAL_StatusTypeDef FLASH_CRC_WaitForLastOperation(uint32_t Timeout, uint32_t Bank)
{
24007574:	b580      	push	{r7, lr}
24007576:	b084      	sub	sp, #16
24007578:	af00      	add	r7, sp, #0
2400757a:	6078      	str	r0, [r7, #4]
2400757c:	6039      	str	r1, [r7, #0]
  uint32_t bsyflag;
  uint32_t tickstart = HAL_GetTick();
2400757e:	f7f9 f969 	bl	24000854 <HAL_GetTick>
24007582:	60b8      	str	r0, [r7, #8]

  assert_param(IS_FLASH_BANK_EXCLUSIVE(Bank));

  /* Select bsyflag depending on Bank */
  if(Bank == FLASH_BANK_1)
24007584:	683b      	ldr	r3, [r7, #0]
24007586:	2b01      	cmp	r3, #1
24007588:	d102      	bne.n	24007590 <FLASH_CRC_WaitForLastOperation+0x1c>
  {
    bsyflag = FLASH_FLAG_CRC_BUSY_BANK1;
2400758a:	2308      	movs	r3, #8
2400758c:	60fb      	str	r3, [r7, #12]
2400758e:	e013      	b.n	240075b8 <FLASH_CRC_WaitForLastOperation+0x44>
  }
  else
  {
    bsyflag = FLASH_FLAG_CRC_BUSY_BANK2;
24007590:	4b31      	ldr	r3, [pc, #196]	; (24007658 <FLASH_CRC_WaitForLastOperation+0xe4>)
24007592:	60fb      	str	r3, [r7, #12]
  }

  /* Wait for the FLASH CRC computation to complete by polling on CRC_BUSY flag to be reset */
  while(__HAL_FLASH_GET_FLAG(bsyflag))
24007594:	e010      	b.n	240075b8 <FLASH_CRC_WaitForLastOperation+0x44>
  {
    if(Timeout != HAL_MAX_DELAY)
24007596:	687b      	ldr	r3, [r7, #4]
24007598:	f1b3 3fff 	cmp.w	r3, #4294967295
2400759c:	d00c      	beq.n	240075b8 <FLASH_CRC_WaitForLastOperation+0x44>
    {
      if(((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
2400759e:	f7f9 f959 	bl	24000854 <HAL_GetTick>
240075a2:	4602      	mov	r2, r0
240075a4:	68bb      	ldr	r3, [r7, #8]
240075a6:	1ad3      	subs	r3, r2, r3
240075a8:	687a      	ldr	r2, [r7, #4]
240075aa:	429a      	cmp	r2, r3
240075ac:	d302      	bcc.n	240075b4 <FLASH_CRC_WaitForLastOperation+0x40>
240075ae:	687b      	ldr	r3, [r7, #4]
240075b0:	2b00      	cmp	r3, #0
240075b2:	d101      	bne.n	240075b8 <FLASH_CRC_WaitForLastOperation+0x44>
      {
        return HAL_TIMEOUT;
240075b4:	2303      	movs	r3, #3
240075b6:	e04b      	b.n	24007650 <FLASH_CRC_WaitForLastOperation+0xdc>
  while(__HAL_FLASH_GET_FLAG(bsyflag))
240075b8:	68fa      	ldr	r2, [r7, #12]
240075ba:	4b28      	ldr	r3, [pc, #160]	; (2400765c <FLASH_CRC_WaitForLastOperation+0xe8>)
240075bc:	4013      	ands	r3, r2
240075be:	68fa      	ldr	r2, [r7, #12]
240075c0:	429a      	cmp	r2, r3
240075c2:	d10a      	bne.n	240075da <FLASH_CRC_WaitForLastOperation+0x66>
240075c4:	4b26      	ldr	r3, [pc, #152]	; (24007660 <FLASH_CRC_WaitForLastOperation+0xec>)
240075c6:	691a      	ldr	r2, [r3, #16]
240075c8:	68fb      	ldr	r3, [r7, #12]
240075ca:	4013      	ands	r3, r2
240075cc:	68fa      	ldr	r2, [r7, #12]
240075ce:	429a      	cmp	r2, r3
240075d0:	bf0c      	ite	eq
240075d2:	2301      	moveq	r3, #1
240075d4:	2300      	movne	r3, #0
240075d6:	b2db      	uxtb	r3, r3
240075d8:	e00c      	b.n	240075f4 <FLASH_CRC_WaitForLastOperation+0x80>
240075da:	4b21      	ldr	r3, [pc, #132]	; (24007660 <FLASH_CRC_WaitForLastOperation+0xec>)
240075dc:	f8d3 3110 	ldr.w	r3, [r3, #272]	; 0x110
240075e0:	43da      	mvns	r2, r3
240075e2:	68fb      	ldr	r3, [r7, #12]
240075e4:	4013      	ands	r3, r2
240075e6:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
240075ea:	2b00      	cmp	r3, #0
240075ec:	bf0c      	ite	eq
240075ee:	2301      	moveq	r3, #1
240075f0:	2300      	movne	r3, #0
240075f2:	b2db      	uxtb	r3, r3
240075f4:	2b00      	cmp	r3, #0
240075f6:	d1ce      	bne.n	24007596 <FLASH_CRC_WaitForLastOperation+0x22>
      }
    }
  }

  /* Check FLASH CRC read error flag  */
  if(Bank == FLASH_BANK_1)
240075f8:	683b      	ldr	r3, [r7, #0]
240075fa:	2b01      	cmp	r3, #1
240075fc:	d112      	bne.n	24007624 <FLASH_CRC_WaitForLastOperation+0xb0>
  {
    if (__HAL_FLASH_GET_FLAG_BANK1(FLASH_FLAG_CRCRDERR_BANK1))
240075fe:	4b18      	ldr	r3, [pc, #96]	; (24007660 <FLASH_CRC_WaitForLastOperation+0xec>)
24007600:	691b      	ldr	r3, [r3, #16]
24007602:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
24007606:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
2400760a:	d120      	bne.n	2400764e <FLASH_CRC_WaitForLastOperation+0xda>
    {
      /* Save the error code */
      pFlash.ErrorCode |= HAL_FLASH_ERROR_CRCRD_BANK1;
2400760c:	4b15      	ldr	r3, [pc, #84]	; (24007664 <FLASH_CRC_WaitForLastOperation+0xf0>)
2400760e:	699b      	ldr	r3, [r3, #24]
24007610:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
24007614:	4a13      	ldr	r2, [pc, #76]	; (24007664 <FLASH_CRC_WaitForLastOperation+0xf0>)
24007616:	6193      	str	r3, [r2, #24]

      /* Clear FLASH CRC read error pending bit */
      __HAL_FLASH_CLEAR_FLAG_BANK1(FLASH_FLAG_CRCRDERR_BANK1);
24007618:	4b11      	ldr	r3, [pc, #68]	; (24007660 <FLASH_CRC_WaitForLastOperation+0xec>)
2400761a:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
2400761e:	615a      	str	r2, [r3, #20]

      return HAL_ERROR;
24007620:	2301      	movs	r3, #1
24007622:	e015      	b.n	24007650 <FLASH_CRC_WaitForLastOperation+0xdc>
    }
  }
  else
  {
    if (__HAL_FLASH_GET_FLAG_BANK2(FLASH_FLAG_CRCRDERR_BANK2))
24007624:	4b0e      	ldr	r3, [pc, #56]	; (24007660 <FLASH_CRC_WaitForLastOperation+0xec>)
24007626:	f8d3 3110 	ldr.w	r3, [r3, #272]	; 0x110
2400762a:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
2400762e:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
24007632:	d10c      	bne.n	2400764e <FLASH_CRC_WaitForLastOperation+0xda>
    {
      /* Save the error code */
      pFlash.ErrorCode |= HAL_FLASH_ERROR_CRCRD_BANK2;
24007634:	4b0b      	ldr	r3, [pc, #44]	; (24007664 <FLASH_CRC_WaitForLastOperation+0xf0>)
24007636:	699b      	ldr	r3, [r3, #24]
24007638:	f043 4310 	orr.w	r3, r3, #2415919104	; 0x90000000
2400763c:	4a09      	ldr	r2, [pc, #36]	; (24007664 <FLASH_CRC_WaitForLastOperation+0xf0>)
2400763e:	6193      	str	r3, [r2, #24]

      /* Clear FLASH CRC read error pending bit */
      __HAL_FLASH_CLEAR_FLAG_BANK2(FLASH_FLAG_CRCRDERR_BANK2);
24007640:	4b07      	ldr	r3, [pc, #28]	; (24007660 <FLASH_CRC_WaitForLastOperation+0xec>)
24007642:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
24007646:	f8c3 2114 	str.w	r2, [r3, #276]	; 0x114

      return HAL_ERROR;
2400764a:	2301      	movs	r3, #1
2400764c:	e000      	b.n	24007650 <FLASH_CRC_WaitForLastOperation+0xdc>
    }
  }

  /* If there is no error flag set */
  return HAL_OK;
2400764e:	2300      	movs	r3, #0
}
24007650:	4618      	mov	r0, r3
24007652:	3710      	adds	r7, #16
24007654:	46bd      	mov	sp, r7
24007656:	bd80      	pop	{r7, pc}
24007658:	80000008 	.word	0x80000008
2400765c:	1fef000f 	.word	0x1fef000f
24007660:	52002000 	.word	0x52002000
24007664:	2400054c 	.word	0x2400054c

24007668 <HAL_FLASHEx_Erase>:
  *          the sectors have been correctly erased)
  *
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_FLASHEx_Erase(FLASH_EraseInitTypeDef *pEraseInit, uint32_t *SectorError)
{
24007668:	b580      	push	{r7, lr}
2400766a:	b084      	sub	sp, #16
2400766c:	af00      	add	r7, sp, #0
2400766e:	6078      	str	r0, [r7, #4]
24007670:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
24007672:	2300      	movs	r3, #0
24007674:	73fb      	strb	r3, [r7, #15]
  /* Check the parameters */
  assert_param(IS_FLASH_TYPEERASE(pEraseInit->TypeErase));
  assert_param(IS_FLASH_BANK(pEraseInit->Banks));

  /* Process Locked */
  __HAL_LOCK(&pFlash);
24007676:	4b5e      	ldr	r3, [pc, #376]	; (240077f0 <HAL_FLASHEx_Erase+0x188>)
24007678:	7d1b      	ldrb	r3, [r3, #20]
2400767a:	2b01      	cmp	r3, #1
2400767c:	d101      	bne.n	24007682 <HAL_FLASHEx_Erase+0x1a>
2400767e:	2302      	movs	r3, #2
24007680:	e0b2      	b.n	240077e8 <HAL_FLASHEx_Erase+0x180>
24007682:	4b5b      	ldr	r3, [pc, #364]	; (240077f0 <HAL_FLASHEx_Erase+0x188>)
24007684:	2201      	movs	r2, #1
24007686:	751a      	strb	r2, [r3, #20]

  /* Reset error code */
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
24007688:	4b59      	ldr	r3, [pc, #356]	; (240077f0 <HAL_FLASHEx_Erase+0x188>)
2400768a:	2200      	movs	r2, #0
2400768c:	619a      	str	r2, [r3, #24]

  /* Wait for last operation to be completed on Bank1 */
  if((pEraseInit->Banks & FLASH_BANK_1) == FLASH_BANK_1)
2400768e:	687b      	ldr	r3, [r7, #4]
24007690:	685b      	ldr	r3, [r3, #4]
24007692:	f003 0301 	and.w	r3, r3, #1
24007696:	2b00      	cmp	r3, #0
24007698:	d009      	beq.n	240076ae <HAL_FLASHEx_Erase+0x46>
  {
    if(FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_1) != HAL_OK)
2400769a:	2101      	movs	r1, #1
2400769c:	f24c 3050 	movw	r0, #50000	; 0xc350
240076a0:	f7ff fe90 	bl	240073c4 <FLASH_WaitForLastOperation>
240076a4:	4603      	mov	r3, r0
240076a6:	2b00      	cmp	r3, #0
240076a8:	d001      	beq.n	240076ae <HAL_FLASHEx_Erase+0x46>
    {
      status = HAL_ERROR;
240076aa:	2301      	movs	r3, #1
240076ac:	73fb      	strb	r3, [r7, #15]
    }
  }

  /* Wait for last operation to be completed on Bank2 */
  if((pEraseInit->Banks & FLASH_BANK_2) == FLASH_BANK_2)
240076ae:	687b      	ldr	r3, [r7, #4]
240076b0:	685b      	ldr	r3, [r3, #4]
240076b2:	f003 0302 	and.w	r3, r3, #2
240076b6:	2b00      	cmp	r3, #0
240076b8:	d009      	beq.n	240076ce <HAL_FLASHEx_Erase+0x66>
  {
    if(FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_2) != HAL_OK)
240076ba:	2102      	movs	r1, #2
240076bc:	f24c 3050 	movw	r0, #50000	; 0xc350
240076c0:	f7ff fe80 	bl	240073c4 <FLASH_WaitForLastOperation>
240076c4:	4603      	mov	r3, r0
240076c6:	2b00      	cmp	r3, #0
240076c8:	d001      	beq.n	240076ce <HAL_FLASHEx_Erase+0x66>
    {
      status = HAL_ERROR;
240076ca:	2301      	movs	r3, #1
240076cc:	73fb      	strb	r3, [r7, #15]
    }
  }

  if(status == HAL_OK)
240076ce:	7bfb      	ldrb	r3, [r7, #15]
240076d0:	2b00      	cmp	r3, #0
240076d2:	f040 8085 	bne.w	240077e0 <HAL_FLASHEx_Erase+0x178>
  {
    if(pEraseInit->TypeErase == FLASH_TYPEERASE_MASSERASE)
240076d6:	687b      	ldr	r3, [r7, #4]
240076d8:	681b      	ldr	r3, [r3, #0]
240076da:	2b01      	cmp	r3, #1
240076dc:	d136      	bne.n	2400774c <HAL_FLASHEx_Erase+0xe4>
    {
      /* Mass erase to be done */
      FLASH_MassErase(pEraseInit->VoltageRange, pEraseInit->Banks);
240076de:	687b      	ldr	r3, [r7, #4]
240076e0:	691a      	ldr	r2, [r3, #16]
240076e2:	687b      	ldr	r3, [r7, #4]
240076e4:	685b      	ldr	r3, [r3, #4]
240076e6:	4619      	mov	r1, r3
240076e8:	4610      	mov	r0, r2
240076ea:	f000 fb85 	bl	24007df8 <FLASH_MassErase>

      /* Wait for last operation to be completed */
      if((pEraseInit->Banks & FLASH_BANK_1) == FLASH_BANK_1)
240076ee:	687b      	ldr	r3, [r7, #4]
240076f0:	685b      	ldr	r3, [r3, #4]
240076f2:	f003 0301 	and.w	r3, r3, #1
240076f6:	2b00      	cmp	r3, #0
240076f8:	d00f      	beq.n	2400771a <HAL_FLASHEx_Erase+0xb2>
      {
        if(FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_1) != HAL_OK)
240076fa:	2101      	movs	r1, #1
240076fc:	f24c 3050 	movw	r0, #50000	; 0xc350
24007700:	f7ff fe60 	bl	240073c4 <FLASH_WaitForLastOperation>
24007704:	4603      	mov	r3, r0
24007706:	2b00      	cmp	r3, #0
24007708:	d001      	beq.n	2400770e <HAL_FLASHEx_Erase+0xa6>
        {
          status = HAL_ERROR;
2400770a:	2301      	movs	r3, #1
2400770c:	73fb      	strb	r3, [r7, #15]
        }
        /* if the erase operation is completed, disable the Bank1 BER Bit */
        FLASH->CR1 &= (~FLASH_CR_BER);
2400770e:	4b39      	ldr	r3, [pc, #228]	; (240077f4 <HAL_FLASHEx_Erase+0x18c>)
24007710:	68db      	ldr	r3, [r3, #12]
24007712:	4a38      	ldr	r2, [pc, #224]	; (240077f4 <HAL_FLASHEx_Erase+0x18c>)
24007714:	f023 0308 	bic.w	r3, r3, #8
24007718:	60d3      	str	r3, [r2, #12]
      }
      if((pEraseInit->Banks & FLASH_BANK_2) == FLASH_BANK_2)
2400771a:	687b      	ldr	r3, [r7, #4]
2400771c:	685b      	ldr	r3, [r3, #4]
2400771e:	f003 0302 	and.w	r3, r3, #2
24007722:	2b00      	cmp	r3, #0
24007724:	d05c      	beq.n	240077e0 <HAL_FLASHEx_Erase+0x178>
      {
        if(FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_2) != HAL_OK)
24007726:	2102      	movs	r1, #2
24007728:	f24c 3050 	movw	r0, #50000	; 0xc350
2400772c:	f7ff fe4a 	bl	240073c4 <FLASH_WaitForLastOperation>
24007730:	4603      	mov	r3, r0
24007732:	2b00      	cmp	r3, #0
24007734:	d001      	beq.n	2400773a <HAL_FLASHEx_Erase+0xd2>
        {
          status = HAL_ERROR;
24007736:	2301      	movs	r3, #1
24007738:	73fb      	strb	r3, [r7, #15]
        }
        /* if the erase operation is completed, disable the Bank2 BER Bit */
        FLASH->CR2 &= (~FLASH_CR_BER);
2400773a:	4b2e      	ldr	r3, [pc, #184]	; (240077f4 <HAL_FLASHEx_Erase+0x18c>)
2400773c:	f8d3 310c 	ldr.w	r3, [r3, #268]	; 0x10c
24007740:	4a2c      	ldr	r2, [pc, #176]	; (240077f4 <HAL_FLASHEx_Erase+0x18c>)
24007742:	f023 0308 	bic.w	r3, r3, #8
24007746:	f8c2 310c 	str.w	r3, [r2, #268]	; 0x10c
2400774a:	e049      	b.n	240077e0 <HAL_FLASHEx_Erase+0x178>
      }
    }
    else
    {
      /*Initialization of SectorError variable*/
      *SectorError = 0xFFFFFFFFU;
2400774c:	683b      	ldr	r3, [r7, #0]
2400774e:	f04f 32ff 	mov.w	r2, #4294967295
24007752:	601a      	str	r2, [r3, #0]

      /* Erase by sector by sector to be done*/
      for(sector_index = pEraseInit->Sector; sector_index < (pEraseInit->NbSectors + pEraseInit->Sector); sector_index++)
24007754:	687b      	ldr	r3, [r7, #4]
24007756:	689b      	ldr	r3, [r3, #8]
24007758:	60bb      	str	r3, [r7, #8]
2400775a:	e039      	b.n	240077d0 <HAL_FLASHEx_Erase+0x168>
      {
        FLASH_Erase_Sector(sector_index, pEraseInit->Banks, pEraseInit->VoltageRange);
2400775c:	687b      	ldr	r3, [r7, #4]
2400775e:	6859      	ldr	r1, [r3, #4]
24007760:	687b      	ldr	r3, [r7, #4]
24007762:	691b      	ldr	r3, [r3, #16]
24007764:	461a      	mov	r2, r3
24007766:	68b8      	ldr	r0, [r7, #8]
24007768:	f000 fbb0 	bl	24007ecc <FLASH_Erase_Sector>

        if((pEraseInit->Banks & FLASH_BANK_1) == FLASH_BANK_1)
2400776c:	687b      	ldr	r3, [r7, #4]
2400776e:	685b      	ldr	r3, [r3, #4]
24007770:	f003 0301 	and.w	r3, r3, #1
24007774:	2b00      	cmp	r3, #0
24007776:	d00c      	beq.n	24007792 <HAL_FLASHEx_Erase+0x12a>
        {
          /* Wait for last operation to be completed */
          status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_1);
24007778:	2101      	movs	r1, #1
2400777a:	f24c 3050 	movw	r0, #50000	; 0xc350
2400777e:	f7ff fe21 	bl	240073c4 <FLASH_WaitForLastOperation>
24007782:	4603      	mov	r3, r0
24007784:	73fb      	strb	r3, [r7, #15]

          /* If the erase operation is completed, disable the SER Bit */
          FLASH->CR1 &= (~(FLASH_CR_SER | FLASH_CR_SNB));
24007786:	4b1b      	ldr	r3, [pc, #108]	; (240077f4 <HAL_FLASHEx_Erase+0x18c>)
24007788:	68da      	ldr	r2, [r3, #12]
2400778a:	491a      	ldr	r1, [pc, #104]	; (240077f4 <HAL_FLASHEx_Erase+0x18c>)
2400778c:	4b1a      	ldr	r3, [pc, #104]	; (240077f8 <HAL_FLASHEx_Erase+0x190>)
2400778e:	4013      	ands	r3, r2
24007790:	60cb      	str	r3, [r1, #12]
        }
        if((pEraseInit->Banks & FLASH_BANK_2) == FLASH_BANK_2)
24007792:	687b      	ldr	r3, [r7, #4]
24007794:	685b      	ldr	r3, [r3, #4]
24007796:	f003 0302 	and.w	r3, r3, #2
2400779a:	2b00      	cmp	r3, #0
2400779c:	d00e      	beq.n	240077bc <HAL_FLASHEx_Erase+0x154>
        {
          /* Wait for last operation to be completed */
          status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_2);
2400779e:	2102      	movs	r1, #2
240077a0:	f24c 3050 	movw	r0, #50000	; 0xc350
240077a4:	f7ff fe0e 	bl	240073c4 <FLASH_WaitForLastOperation>
240077a8:	4603      	mov	r3, r0
240077aa:	73fb      	strb	r3, [r7, #15]

          /* If the erase operation is completed, disable the SER Bit */
          FLASH->CR2 &= (~(FLASH_CR_SER | FLASH_CR_SNB));
240077ac:	4b11      	ldr	r3, [pc, #68]	; (240077f4 <HAL_FLASHEx_Erase+0x18c>)
240077ae:	f8d3 210c 	ldr.w	r2, [r3, #268]	; 0x10c
240077b2:	4910      	ldr	r1, [pc, #64]	; (240077f4 <HAL_FLASHEx_Erase+0x18c>)
240077b4:	4b10      	ldr	r3, [pc, #64]	; (240077f8 <HAL_FLASHEx_Erase+0x190>)
240077b6:	4013      	ands	r3, r2
240077b8:	f8c1 310c 	str.w	r3, [r1, #268]	; 0x10c
        }

        if(status != HAL_OK)
240077bc:	7bfb      	ldrb	r3, [r7, #15]
240077be:	2b00      	cmp	r3, #0
240077c0:	d003      	beq.n	240077ca <HAL_FLASHEx_Erase+0x162>
        {
          /* In case of error, stop erase procedure and return the faulty sector */
          *SectorError = sector_index;
240077c2:	683b      	ldr	r3, [r7, #0]
240077c4:	68ba      	ldr	r2, [r7, #8]
240077c6:	601a      	str	r2, [r3, #0]
          break;
240077c8:	e00a      	b.n	240077e0 <HAL_FLASHEx_Erase+0x178>
      for(sector_index = pEraseInit->Sector; sector_index < (pEraseInit->NbSectors + pEraseInit->Sector); sector_index++)
240077ca:	68bb      	ldr	r3, [r7, #8]
240077cc:	3301      	adds	r3, #1
240077ce:	60bb      	str	r3, [r7, #8]
240077d0:	687b      	ldr	r3, [r7, #4]
240077d2:	68da      	ldr	r2, [r3, #12]
240077d4:	687b      	ldr	r3, [r7, #4]
240077d6:	689b      	ldr	r3, [r3, #8]
240077d8:	4413      	add	r3, r2
240077da:	68ba      	ldr	r2, [r7, #8]
240077dc:	429a      	cmp	r2, r3
240077de:	d3bd      	bcc.n	2400775c <HAL_FLASHEx_Erase+0xf4>
      }
    }
  }

  /* Process Unlocked */
  __HAL_UNLOCK(&pFlash);
240077e0:	4b03      	ldr	r3, [pc, #12]	; (240077f0 <HAL_FLASHEx_Erase+0x188>)
240077e2:	2200      	movs	r2, #0
240077e4:	751a      	strb	r2, [r3, #20]

  return status;
240077e6:	7bfb      	ldrb	r3, [r7, #15]
}
240077e8:	4618      	mov	r0, r3
240077ea:	3710      	adds	r7, #16
240077ec:	46bd      	mov	sp, r7
240077ee:	bd80      	pop	{r7, pc}
240077f0:	2400054c 	.word	0x2400054c
240077f4:	52002000 	.word	0x52002000
240077f8:	fffff8fb 	.word	0xfffff8fb

240077fc <HAL_FLASHEx_Erase_IT>:
  *         contains the configuration information for the erasing.
  *
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_FLASHEx_Erase_IT(FLASH_EraseInitTypeDef *pEraseInit)
{
240077fc:	b580      	push	{r7, lr}
240077fe:	b084      	sub	sp, #16
24007800:	af00      	add	r7, sp, #0
24007802:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
24007804:	2300      	movs	r3, #0
24007806:	73fb      	strb	r3, [r7, #15]
  /* Check the parameters */
  assert_param(IS_FLASH_TYPEERASE(pEraseInit->TypeErase));
  assert_param(IS_FLASH_BANK(pEraseInit->Banks));

  /* Process Locked */
  __HAL_LOCK(&pFlash);
24007808:	4b48      	ldr	r3, [pc, #288]	; (2400792c <HAL_FLASHEx_Erase_IT+0x130>)
2400780a:	7d1b      	ldrb	r3, [r3, #20]
2400780c:	2b01      	cmp	r3, #1
2400780e:	d101      	bne.n	24007814 <HAL_FLASHEx_Erase_IT+0x18>
24007810:	2302      	movs	r3, #2
24007812:	e087      	b.n	24007924 <HAL_FLASHEx_Erase_IT+0x128>
24007814:	4b45      	ldr	r3, [pc, #276]	; (2400792c <HAL_FLASHEx_Erase_IT+0x130>)
24007816:	2201      	movs	r2, #1
24007818:	751a      	strb	r2, [r3, #20]

  /* Reset error code */
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
2400781a:	4b44      	ldr	r3, [pc, #272]	; (2400792c <HAL_FLASHEx_Erase_IT+0x130>)
2400781c:	2200      	movs	r2, #0
2400781e:	619a      	str	r2, [r3, #24]

  /* Wait for last operation to be completed */
  if((pEraseInit->Banks & FLASH_BANK_1) == FLASH_BANK_1)
24007820:	687b      	ldr	r3, [r7, #4]
24007822:	685b      	ldr	r3, [r3, #4]
24007824:	f003 0301 	and.w	r3, r3, #1
24007828:	2b00      	cmp	r3, #0
2400782a:	d009      	beq.n	24007840 <HAL_FLASHEx_Erase_IT+0x44>
  {
    if(FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_1) != HAL_OK)
2400782c:	2101      	movs	r1, #1
2400782e:	f24c 3050 	movw	r0, #50000	; 0xc350
24007832:	f7ff fdc7 	bl	240073c4 <FLASH_WaitForLastOperation>
24007836:	4603      	mov	r3, r0
24007838:	2b00      	cmp	r3, #0
2400783a:	d001      	beq.n	24007840 <HAL_FLASHEx_Erase_IT+0x44>
    {
      status = HAL_ERROR;
2400783c:	2301      	movs	r3, #1
2400783e:	73fb      	strb	r3, [r7, #15]
    }
  }

  if((pEraseInit->Banks & FLASH_BANK_2) == FLASH_BANK_2)
24007840:	687b      	ldr	r3, [r7, #4]
24007842:	685b      	ldr	r3, [r3, #4]
24007844:	f003 0302 	and.w	r3, r3, #2
24007848:	2b00      	cmp	r3, #0
2400784a:	d009      	beq.n	24007860 <HAL_FLASHEx_Erase_IT+0x64>
  {
    if(FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_2) != HAL_OK)
2400784c:	2102      	movs	r1, #2
2400784e:	f24c 3050 	movw	r0, #50000	; 0xc350
24007852:	f7ff fdb7 	bl	240073c4 <FLASH_WaitForLastOperation>
24007856:	4603      	mov	r3, r0
24007858:	2b00      	cmp	r3, #0
2400785a:	d001      	beq.n	24007860 <HAL_FLASHEx_Erase_IT+0x64>
    {
      status = HAL_ERROR;
2400785c:	2301      	movs	r3, #1
2400785e:	73fb      	strb	r3, [r7, #15]
    }
  }

  if (status != HAL_OK)
24007860:	7bfb      	ldrb	r3, [r7, #15]
24007862:	2b00      	cmp	r3, #0
24007864:	d003      	beq.n	2400786e <HAL_FLASHEx_Erase_IT+0x72>
  {
    /* Process Unlocked */
    __HAL_UNLOCK(&pFlash);
24007866:	4b31      	ldr	r3, [pc, #196]	; (2400792c <HAL_FLASHEx_Erase_IT+0x130>)
24007868:	2200      	movs	r2, #0
2400786a:	751a      	strb	r2, [r3, #20]
2400786c:	e059      	b.n	24007922 <HAL_FLASHEx_Erase_IT+0x126>
  }
  else
  {
    if((pEraseInit->Banks & FLASH_BANK_1) == FLASH_BANK_1)
2400786e:	687b      	ldr	r3, [r7, #4]
24007870:	685b      	ldr	r3, [r3, #4]
24007872:	f003 0301 	and.w	r3, r3, #1
24007876:	2b00      	cmp	r3, #0
24007878:	d005      	beq.n	24007886 <HAL_FLASHEx_Erase_IT+0x8a>
    {
      /* Enable End of Operation and Error interrupts for Bank 1 */
#if defined (FLASH_CR_OPERRIE)
      __HAL_FLASH_ENABLE_IT_BANK1(FLASH_IT_EOP_BANK1     | FLASH_IT_WRPERR_BANK1 | FLASH_IT_PGSERR_BANK1 | \
2400787a:	4b2d      	ldr	r3, [pc, #180]	; (24007930 <HAL_FLASHEx_Erase_IT+0x134>)
2400787c:	68db      	ldr	r3, [r3, #12]
2400787e:	4a2c      	ldr	r2, [pc, #176]	; (24007930 <HAL_FLASHEx_Erase_IT+0x134>)
24007880:	f443 03de 	orr.w	r3, r3, #7274496	; 0x6f0000
24007884:	60d3      	str	r3, [r2, #12]
#else
      __HAL_FLASH_ENABLE_IT_BANK1(FLASH_IT_EOP_BANK1     | FLASH_IT_WRPERR_BANK1 | FLASH_IT_PGSERR_BANK1 | \
                                  FLASH_IT_STRBERR_BANK1 | FLASH_IT_INCERR_BANK1);
#endif /* FLASH_CR_OPERRIE */
    }
    if((pEraseInit->Banks & FLASH_BANK_2) == FLASH_BANK_2)
24007886:	687b      	ldr	r3, [r7, #4]
24007888:	685b      	ldr	r3, [r3, #4]
2400788a:	f003 0302 	and.w	r3, r3, #2
2400788e:	2b00      	cmp	r3, #0
24007890:	d007      	beq.n	240078a2 <HAL_FLASHEx_Erase_IT+0xa6>
    {
      /* Enable End of Operation and Error interrupts for Bank 2 */
#if defined (FLASH_CR_OPERRIE)
      __HAL_FLASH_ENABLE_IT_BANK2(FLASH_IT_EOP_BANK2     | FLASH_IT_WRPERR_BANK2 | FLASH_IT_PGSERR_BANK2 | \
24007892:	4b27      	ldr	r3, [pc, #156]	; (24007930 <HAL_FLASHEx_Erase_IT+0x134>)
24007894:	f8d3 310c 	ldr.w	r3, [r3, #268]	; 0x10c
24007898:	4a25      	ldr	r2, [pc, #148]	; (24007930 <HAL_FLASHEx_Erase_IT+0x134>)
2400789a:	f443 03de 	orr.w	r3, r3, #7274496	; 0x6f0000
2400789e:	f8c2 310c 	str.w	r3, [r2, #268]	; 0x10c
      __HAL_FLASH_ENABLE_IT_BANK2(FLASH_IT_EOP_BANK2     | FLASH_IT_WRPERR_BANK2 | FLASH_IT_PGSERR_BANK2 | \
                                  FLASH_IT_STRBERR_BANK2 | FLASH_IT_INCERR_BANK2);
#endif /* FLASH_CR_OPERRIE */
    }

    if(pEraseInit->TypeErase == FLASH_TYPEERASE_MASSERASE)
240078a2:	687b      	ldr	r3, [r7, #4]
240078a4:	681b      	ldr	r3, [r3, #0]
240078a6:	2b01      	cmp	r3, #1
240078a8:	d11b      	bne.n	240078e2 <HAL_FLASHEx_Erase_IT+0xe6>
    {
      /*Mass erase to be done*/
      if(pEraseInit->Banks == FLASH_BANK_1)
240078aa:	687b      	ldr	r3, [r7, #4]
240078ac:	685b      	ldr	r3, [r3, #4]
240078ae:	2b01      	cmp	r3, #1
240078b0:	d103      	bne.n	240078ba <HAL_FLASHEx_Erase_IT+0xbe>
      {
        pFlash.ProcedureOnGoing = FLASH_PROC_MASSERASE_BANK1;
240078b2:	4b1e      	ldr	r3, [pc, #120]	; (2400792c <HAL_FLASHEx_Erase_IT+0x130>)
240078b4:	2202      	movs	r2, #2
240078b6:	701a      	strb	r2, [r3, #0]
240078b8:	e00a      	b.n	240078d0 <HAL_FLASHEx_Erase_IT+0xd4>
      }
      else if(pEraseInit->Banks == FLASH_BANK_2)
240078ba:	687b      	ldr	r3, [r7, #4]
240078bc:	685b      	ldr	r3, [r3, #4]
240078be:	2b02      	cmp	r3, #2
240078c0:	d103      	bne.n	240078ca <HAL_FLASHEx_Erase_IT+0xce>
      {
        pFlash.ProcedureOnGoing = FLASH_PROC_MASSERASE_BANK2;
240078c2:	4b1a      	ldr	r3, [pc, #104]	; (2400792c <HAL_FLASHEx_Erase_IT+0x130>)
240078c4:	2205      	movs	r2, #5
240078c6:	701a      	strb	r2, [r3, #0]
240078c8:	e002      	b.n	240078d0 <HAL_FLASHEx_Erase_IT+0xd4>
      }
      else
      {
        pFlash.ProcedureOnGoing = FLASH_PROC_ALLBANK_MASSERASE;
240078ca:	4b18      	ldr	r3, [pc, #96]	; (2400792c <HAL_FLASHEx_Erase_IT+0x130>)
240078cc:	2207      	movs	r2, #7
240078ce:	701a      	strb	r2, [r3, #0]
      }

      FLASH_MassErase(pEraseInit->VoltageRange, pEraseInit->Banks);
240078d0:	687b      	ldr	r3, [r7, #4]
240078d2:	691a      	ldr	r2, [r3, #16]
240078d4:	687b      	ldr	r3, [r7, #4]
240078d6:	685b      	ldr	r3, [r3, #4]
240078d8:	4619      	mov	r1, r3
240078da:	4610      	mov	r0, r2
240078dc:	f000 fa8c 	bl	24007df8 <FLASH_MassErase>
240078e0:	e01f      	b.n	24007922 <HAL_FLASHEx_Erase_IT+0x126>
    }
    else
    {
      /* Erase by sector to be done */
      if(pEraseInit->Banks == FLASH_BANK_1)
240078e2:	687b      	ldr	r3, [r7, #4]
240078e4:	685b      	ldr	r3, [r3, #4]
240078e6:	2b01      	cmp	r3, #1
240078e8:	d103      	bne.n	240078f2 <HAL_FLASHEx_Erase_IT+0xf6>
      {
        pFlash.ProcedureOnGoing = FLASH_PROC_SECTERASE_BANK1;
240078ea:	4b10      	ldr	r3, [pc, #64]	; (2400792c <HAL_FLASHEx_Erase_IT+0x130>)
240078ec:	2201      	movs	r2, #1
240078ee:	701a      	strb	r2, [r3, #0]
240078f0:	e002      	b.n	240078f8 <HAL_FLASHEx_Erase_IT+0xfc>
      }
      else
      {
        pFlash.ProcedureOnGoing = FLASH_PROC_SECTERASE_BANK2;
240078f2:	4b0e      	ldr	r3, [pc, #56]	; (2400792c <HAL_FLASHEx_Erase_IT+0x130>)
240078f4:	2204      	movs	r2, #4
240078f6:	701a      	strb	r2, [r3, #0]
      }

      pFlash.NbSectorsToErase = pEraseInit->NbSectors;
240078f8:	687b      	ldr	r3, [r7, #4]
240078fa:	68db      	ldr	r3, [r3, #12]
240078fc:	4a0b      	ldr	r2, [pc, #44]	; (2400792c <HAL_FLASHEx_Erase_IT+0x130>)
240078fe:	6053      	str	r3, [r2, #4]
      pFlash.Sector = pEraseInit->Sector;
24007900:	687b      	ldr	r3, [r7, #4]
24007902:	689b      	ldr	r3, [r3, #8]
24007904:	4a09      	ldr	r2, [pc, #36]	; (2400792c <HAL_FLASHEx_Erase_IT+0x130>)
24007906:	60d3      	str	r3, [r2, #12]
      pFlash.VoltageForErase = pEraseInit->VoltageRange;
24007908:	687b      	ldr	r3, [r7, #4]
2400790a:	691b      	ldr	r3, [r3, #16]
2400790c:	4a07      	ldr	r2, [pc, #28]	; (2400792c <HAL_FLASHEx_Erase_IT+0x130>)
2400790e:	6093      	str	r3, [r2, #8]

      /* Erase first sector and wait for IT */
      FLASH_Erase_Sector(pEraseInit->Sector, pEraseInit->Banks, pEraseInit->VoltageRange);
24007910:	687b      	ldr	r3, [r7, #4]
24007912:	6898      	ldr	r0, [r3, #8]
24007914:	687b      	ldr	r3, [r7, #4]
24007916:	6859      	ldr	r1, [r3, #4]
24007918:	687b      	ldr	r3, [r7, #4]
2400791a:	691b      	ldr	r3, [r3, #16]
2400791c:	461a      	mov	r2, r3
2400791e:	f000 fad5 	bl	24007ecc <FLASH_Erase_Sector>
    }
  }

  return status;
24007922:	7bfb      	ldrb	r3, [r7, #15]
}
24007924:	4618      	mov	r0, r3
24007926:	3710      	adds	r7, #16
24007928:	46bd      	mov	sp, r7
2400792a:	bd80      	pop	{r7, pc}
2400792c:	2400054c 	.word	0x2400054c
24007930:	52002000 	.word	0x52002000

24007934 <HAL_FLASHEx_OBProgram>:
  *         contains the configuration information for the programming.
  *
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_FLASHEx_OBProgram(FLASH_OBProgramInitTypeDef *pOBInit)
{
24007934:	b580      	push	{r7, lr}
24007936:	b084      	sub	sp, #16
24007938:	af00      	add	r7, sp, #0
2400793a:	6078      	str	r0, [r7, #4]

  /* Check the parameters */
  assert_param(IS_OPTIONBYTE(pOBInit->OptionType));

  /* Process Locked */
  __HAL_LOCK(&pFlash);
2400793c:	4b4e      	ldr	r3, [pc, #312]	; (24007a78 <HAL_FLASHEx_OBProgram+0x144>)
2400793e:	7d1b      	ldrb	r3, [r3, #20]
24007940:	2b01      	cmp	r3, #1
24007942:	d101      	bne.n	24007948 <HAL_FLASHEx_OBProgram+0x14>
24007944:	2302      	movs	r3, #2
24007946:	e092      	b.n	24007a6e <HAL_FLASHEx_OBProgram+0x13a>
24007948:	4b4b      	ldr	r3, [pc, #300]	; (24007a78 <HAL_FLASHEx_OBProgram+0x144>)
2400794a:	2201      	movs	r2, #1
2400794c:	751a      	strb	r2, [r3, #20]

  /* Reset Error Code */
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
2400794e:	4b4a      	ldr	r3, [pc, #296]	; (24007a78 <HAL_FLASHEx_OBProgram+0x144>)
24007950:	2200      	movs	r2, #0
24007952:	619a      	str	r2, [r3, #24]

  /* Wait for last operation to be completed */
  if(FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_1) != HAL_OK)
24007954:	2101      	movs	r1, #1
24007956:	f24c 3050 	movw	r0, #50000	; 0xc350
2400795a:	f7ff fd33 	bl	240073c4 <FLASH_WaitForLastOperation>
2400795e:	4603      	mov	r3, r0
24007960:	2b00      	cmp	r3, #0
24007962:	d002      	beq.n	2400796a <HAL_FLASHEx_OBProgram+0x36>
  {
    status = HAL_ERROR;
24007964:	2301      	movs	r3, #1
24007966:	73fb      	strb	r3, [r7, #15]
24007968:	e00c      	b.n	24007984 <HAL_FLASHEx_OBProgram+0x50>
  }
  else if(FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_2) != HAL_OK)
2400796a:	2102      	movs	r1, #2
2400796c:	f24c 3050 	movw	r0, #50000	; 0xc350
24007970:	f7ff fd28 	bl	240073c4 <FLASH_WaitForLastOperation>
24007974:	4603      	mov	r3, r0
24007976:	2b00      	cmp	r3, #0
24007978:	d002      	beq.n	24007980 <HAL_FLASHEx_OBProgram+0x4c>
  {
    status = HAL_ERROR;
2400797a:	2301      	movs	r3, #1
2400797c:	73fb      	strb	r3, [r7, #15]
2400797e:	e001      	b.n	24007984 <HAL_FLASHEx_OBProgram+0x50>
  }
  else
  {
    status = HAL_OK;
24007980:	2300      	movs	r3, #0
24007982:	73fb      	strb	r3, [r7, #15]
  }

  if(status == HAL_OK)
24007984:	7bfb      	ldrb	r3, [r7, #15]
24007986:	2b00      	cmp	r3, #0
24007988:	d16d      	bne.n	24007a66 <HAL_FLASHEx_OBProgram+0x132>
  {
    /*Write protection configuration*/
    if((pOBInit->OptionType & OPTIONBYTE_WRP) == OPTIONBYTE_WRP)
2400798a:	687b      	ldr	r3, [r7, #4]
2400798c:	681b      	ldr	r3, [r3, #0]
2400798e:	f003 0301 	and.w	r3, r3, #1
24007992:	2b00      	cmp	r3, #0
24007994:	d014      	beq.n	240079c0 <HAL_FLASHEx_OBProgram+0x8c>
    {
      assert_param(IS_WRPSTATE(pOBInit->WRPState));

      if(pOBInit->WRPState == OB_WRPSTATE_ENABLE)
24007996:	687b      	ldr	r3, [r7, #4]
24007998:	685b      	ldr	r3, [r3, #4]
2400799a:	2b01      	cmp	r3, #1
2400799c:	d108      	bne.n	240079b0 <HAL_FLASHEx_OBProgram+0x7c>
      {
        /*Enable of Write protection on the selected Sector*/
        FLASH_OB_EnableWRP(pOBInit->WRPSector,pOBInit->Banks);
2400799e:	687b      	ldr	r3, [r7, #4]
240079a0:	689a      	ldr	r2, [r3, #8]
240079a2:	687b      	ldr	r3, [r7, #4]
240079a4:	69db      	ldr	r3, [r3, #28]
240079a6:	4619      	mov	r1, r3
240079a8:	4610      	mov	r0, r2
240079aa:	f000 facd 	bl	24007f48 <FLASH_OB_EnableWRP>
240079ae:	e007      	b.n	240079c0 <HAL_FLASHEx_OBProgram+0x8c>
      }
      else
      {
        /*Disable of Write protection on the selected Sector*/
        FLASH_OB_DisableWRP(pOBInit->WRPSector, pOBInit->Banks);
240079b0:	687b      	ldr	r3, [r7, #4]
240079b2:	689a      	ldr	r2, [r3, #8]
240079b4:	687b      	ldr	r3, [r7, #4]
240079b6:	69db      	ldr	r3, [r3, #28]
240079b8:	4619      	mov	r1, r3
240079ba:	4610      	mov	r0, r2
240079bc:	f000 faee 	bl	24007f9c <FLASH_OB_DisableWRP>
      }
    }

    /* Read protection configuration */
    if((pOBInit->OptionType & OPTIONBYTE_RDP) != 0U)
240079c0:	687b      	ldr	r3, [r7, #4]
240079c2:	681b      	ldr	r3, [r3, #0]
240079c4:	f003 0302 	and.w	r3, r3, #2
240079c8:	2b00      	cmp	r3, #0
240079ca:	d004      	beq.n	240079d6 <HAL_FLASHEx_OBProgram+0xa2>
    {
      /* Configure the Read protection level */
      FLASH_OB_RDPConfig(pOBInit->RDPLevel);
240079cc:	687b      	ldr	r3, [r7, #4]
240079ce:	68db      	ldr	r3, [r3, #12]
240079d0:	4618      	mov	r0, r3
240079d2:	f000 fb3d 	bl	24008050 <FLASH_OB_RDPConfig>
    }

    /* User Configuration */
    if((pOBInit->OptionType & OPTIONBYTE_USER) != 0U)
240079d6:	687b      	ldr	r3, [r7, #4]
240079d8:	681b      	ldr	r3, [r3, #0]
240079da:	f003 0304 	and.w	r3, r3, #4
240079de:	2b00      	cmp	r3, #0
240079e0:	d007      	beq.n	240079f2 <HAL_FLASHEx_OBProgram+0xbe>
    {
      /* Configure the user option bytes */
      FLASH_OB_UserConfig(pOBInit->USERType, pOBInit->USERConfig);
240079e2:	687b      	ldr	r3, [r7, #4]
240079e4:	695a      	ldr	r2, [r3, #20]
240079e6:	687b      	ldr	r3, [r7, #4]
240079e8:	699b      	ldr	r3, [r3, #24]
240079ea:	4619      	mov	r1, r3
240079ec:	4610      	mov	r0, r2
240079ee:	f000 fb5f 	bl	240080b0 <FLASH_OB_UserConfig>
    }

    /* PCROP Configuration */
    if((pOBInit->OptionType & OPTIONBYTE_PCROP) != 0U)
240079f2:	687b      	ldr	r3, [r7, #4]
240079f4:	681b      	ldr	r3, [r3, #0]
240079f6:	f003 0308 	and.w	r3, r3, #8
240079fa:	2b00      	cmp	r3, #0
240079fc:	d009      	beq.n	24007a12 <HAL_FLASHEx_OBProgram+0xde>
    {
      assert_param(IS_FLASH_BANK(pOBInit->Banks));

      /*Configure the Proprietary code readout protection */
      FLASH_OB_PCROPConfig(pOBInit->PCROPConfig, pOBInit->PCROPStartAddr, pOBInit->PCROPEndAddr, pOBInit->Banks);
240079fe:	687b      	ldr	r3, [r7, #4]
24007a00:	6a18      	ldr	r0, [r3, #32]
24007a02:	687b      	ldr	r3, [r7, #4]
24007a04:	6a59      	ldr	r1, [r3, #36]	; 0x24
24007a06:	687b      	ldr	r3, [r7, #4]
24007a08:	6a9a      	ldr	r2, [r3, #40]	; 0x28
24007a0a:	687b      	ldr	r3, [r7, #4]
24007a0c:	69db      	ldr	r3, [r3, #28]
24007a0e:	f000 fc07 	bl	24008220 <FLASH_OB_PCROPConfig>
    }

    /* BOR Level configuration */
    if((pOBInit->OptionType & OPTIONBYTE_BOR) == OPTIONBYTE_BOR)
24007a12:	687b      	ldr	r3, [r7, #4]
24007a14:	681b      	ldr	r3, [r3, #0]
24007a16:	f003 0310 	and.w	r3, r3, #16
24007a1a:	2b00      	cmp	r3, #0
24007a1c:	d004      	beq.n	24007a28 <HAL_FLASHEx_OBProgram+0xf4>
    {
      FLASH_OB_BOR_LevelConfig(pOBInit->BORLevel);
24007a1e:	687b      	ldr	r3, [r7, #4]
24007a20:	691b      	ldr	r3, [r3, #16]
24007a22:	4618      	mov	r0, r3
24007a24:	f000 fc78 	bl	24008318 <FLASH_OB_BOR_LevelConfig>
    {
      FLASH_OB_CM4BootAddConfig(pOBInit->CM4BootConfig, pOBInit->CM4BootAddr0, pOBInit->CM4BootAddr1);
    }
#else /* Single Core*/
    /* Boot Address  configuration */
    if((pOBInit->OptionType & OPTIONBYTE_BOOTADD) == OPTIONBYTE_BOOTADD)
24007a28:	687b      	ldr	r3, [r7, #4]
24007a2a:	681b      	ldr	r3, [r3, #0]
24007a2c:	f003 0340 	and.w	r3, r3, #64	; 0x40
24007a30:	2b00      	cmp	r3, #0
24007a32:	d008      	beq.n	24007a46 <HAL_FLASHEx_OBProgram+0x112>
    {
      FLASH_OB_BootAddConfig(pOBInit->BootConfig, pOBInit->BootAddr0, pOBInit->BootAddr1);
24007a34:	687b      	ldr	r3, [r7, #4]
24007a36:	6ad8      	ldr	r0, [r3, #44]	; 0x2c
24007a38:	687b      	ldr	r3, [r7, #4]
24007a3a:	6b19      	ldr	r1, [r3, #48]	; 0x30
24007a3c:	687b      	ldr	r3, [r7, #4]
24007a3e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
24007a40:	461a      	mov	r2, r3
24007a42:	f000 fc8b 	bl	2400835c <FLASH_OB_BootAddConfig>
    }
#endif /*DUAL_CORE*/

    /* Secure area configuration */
    if((pOBInit->OptionType & OPTIONBYTE_SECURE_AREA) == OPTIONBYTE_SECURE_AREA)
24007a46:	687b      	ldr	r3, [r7, #4]
24007a48:	681b      	ldr	r3, [r3, #0]
24007a4a:	f003 0320 	and.w	r3, r3, #32
24007a4e:	2b00      	cmp	r3, #0
24007a50:	d009      	beq.n	24007a66 <HAL_FLASHEx_OBProgram+0x132>
    {
      FLASH_OB_SecureAreaConfig(pOBInit->SecureAreaConfig, pOBInit->SecureAreaStartAddr, pOBInit->SecureAreaEndAddr,pOBInit->Banks);
24007a52:	687b      	ldr	r3, [r7, #4]
24007a54:	6b98      	ldr	r0, [r3, #56]	; 0x38
24007a56:	687b      	ldr	r3, [r7, #4]
24007a58:	6bd9      	ldr	r1, [r3, #60]	; 0x3c
24007a5a:	687b      	ldr	r3, [r7, #4]
24007a5c:	6c1a      	ldr	r2, [r3, #64]	; 0x40
24007a5e:	687b      	ldr	r3, [r7, #4]
24007a60:	69db      	ldr	r3, [r3, #28]
24007a62:	f000 fcc1 	bl	240083e8 <FLASH_OB_SecureAreaConfig>
    }
#endif /* FLASH_OTPBL_LOCKBL */
  }

  /* Process Unlocked */
  __HAL_UNLOCK(&pFlash);
24007a66:	4b04      	ldr	r3, [pc, #16]	; (24007a78 <HAL_FLASHEx_OBProgram+0x144>)
24007a68:	2200      	movs	r2, #0
24007a6a:	751a      	strb	r2, [r3, #20]

  return status;
24007a6c:	7bfb      	ldrb	r3, [r7, #15]
}
24007a6e:	4618      	mov	r0, r3
24007a70:	3710      	adds	r7, #16
24007a72:	46bd      	mov	sp, r7
24007a74:	bd80      	pop	{r7, pc}
24007a76:	bf00      	nop
24007a78:	2400054c 	.word	0x2400054c

24007a7c <HAL_FLASHEx_OBGetConfig>:
  *         as this parameter is use to get the given Bank WRP, PCROP and secured area configuration.
  *
  * @retval None
  */
void HAL_FLASHEx_OBGetConfig(FLASH_OBProgramInitTypeDef *pOBInit)
{
24007a7c:	b580      	push	{r7, lr}
24007a7e:	b082      	sub	sp, #8
24007a80:	af00      	add	r7, sp, #0
24007a82:	6078      	str	r0, [r7, #4]
  pOBInit->OptionType = (OPTIONBYTE_USER | OPTIONBYTE_RDP | OPTIONBYTE_BOR);
24007a84:	687b      	ldr	r3, [r7, #4]
24007a86:	2216      	movs	r2, #22
24007a88:	601a      	str	r2, [r3, #0]

  /* Get Read protection level */
  pOBInit->RDPLevel = FLASH_OB_GetRDP();
24007a8a:	f000 faf5 	bl	24008078 <FLASH_OB_GetRDP>
24007a8e:	4602      	mov	r2, r0
24007a90:	687b      	ldr	r3, [r7, #4]
24007a92:	60da      	str	r2, [r3, #12]

  /* Get the user option bytes */
  pOBInit->USERConfig = FLASH_OB_GetUser();
24007a94:	f000 fbae 	bl	240081f4 <FLASH_OB_GetUser>
24007a98:	4602      	mov	r2, r0
24007a9a:	687b      	ldr	r3, [r7, #4]
24007a9c:	619a      	str	r2, [r3, #24]

  /*Get BOR Level*/
  pOBInit->BORLevel = FLASH_OB_GetBOR();
24007a9e:	f000 fc4f 	bl	24008340 <FLASH_OB_GetBOR>
24007aa2:	4602      	mov	r2, r0
24007aa4:	687b      	ldr	r3, [r7, #4]
24007aa6:	611a      	str	r2, [r3, #16]

  if ((pOBInit->Banks == FLASH_BANK_1) || (pOBInit->Banks == FLASH_BANK_2))
24007aa8:	687b      	ldr	r3, [r7, #4]
24007aaa:	69db      	ldr	r3, [r3, #28]
24007aac:	2b01      	cmp	r3, #1
24007aae:	d003      	beq.n	24007ab8 <HAL_FLASHEx_OBGetConfig+0x3c>
24007ab0:	687b      	ldr	r3, [r7, #4]
24007ab2:	69db      	ldr	r3, [r3, #28]
24007ab4:	2b02      	cmp	r3, #2
24007ab6:	d129      	bne.n	24007b0c <HAL_FLASHEx_OBGetConfig+0x90>
  {
    pOBInit->OptionType |= (OPTIONBYTE_WRP | OPTIONBYTE_PCROP | OPTIONBYTE_SECURE_AREA);
24007ab8:	687b      	ldr	r3, [r7, #4]
24007aba:	681b      	ldr	r3, [r3, #0]
24007abc:	f043 0229 	orr.w	r2, r3, #41	; 0x29
24007ac0:	687b      	ldr	r3, [r7, #4]
24007ac2:	601a      	str	r2, [r3, #0]

    /* Get write protection on the selected area */
    FLASH_OB_GetWRP(&(pOBInit->WRPState), &(pOBInit->WRPSector), pOBInit->Banks);
24007ac4:	687b      	ldr	r3, [r7, #4]
24007ac6:	1d18      	adds	r0, r3, #4
24007ac8:	687b      	ldr	r3, [r7, #4]
24007aca:	f103 0108 	add.w	r1, r3, #8
24007ace:	687b      	ldr	r3, [r7, #4]
24007ad0:	69db      	ldr	r3, [r3, #28]
24007ad2:	461a      	mov	r2, r3
24007ad4:	f000 fa8a 	bl	24007fec <FLASH_OB_GetWRP>

    /* Get the Proprietary code readout protection */
    FLASH_OB_GetPCROP(&(pOBInit->PCROPConfig), &(pOBInit->PCROPStartAddr), &(pOBInit->PCROPEndAddr), pOBInit->Banks);
24007ad8:	687b      	ldr	r3, [r7, #4]
24007ada:	f103 0020 	add.w	r0, r3, #32
24007ade:	687b      	ldr	r3, [r7, #4]
24007ae0:	f103 0124 	add.w	r1, r3, #36	; 0x24
24007ae4:	687b      	ldr	r3, [r7, #4]
24007ae6:	f103 0228 	add.w	r2, r3, #40	; 0x28
24007aea:	687b      	ldr	r3, [r7, #4]
24007aec:	69db      	ldr	r3, [r3, #28]
24007aee:	f000 fbcd 	bl	2400828c <FLASH_OB_GetPCROP>

    /*Get Bank Secure area*/
    FLASH_OB_GetSecureArea(&(pOBInit->SecureAreaConfig), &(pOBInit->SecureAreaStartAddr), &(pOBInit->SecureAreaEndAddr), pOBInit->Banks);
24007af2:	687b      	ldr	r3, [r7, #4]
24007af4:	f103 0038 	add.w	r0, r3, #56	; 0x38
24007af8:	687b      	ldr	r3, [r7, #4]
24007afa:	f103 013c 	add.w	r1, r3, #60	; 0x3c
24007afe:	687b      	ldr	r3, [r7, #4]
24007b00:	f103 0240 	add.w	r2, r3, #64	; 0x40
24007b04:	687b      	ldr	r3, [r7, #4]
24007b06:	69db      	ldr	r3, [r3, #28]
24007b08:	f000 fca8 	bl	2400845c <FLASH_OB_GetSecureArea>
  }

  /*Get Boot Address*/
  FLASH_OB_GetBootAdd(&(pOBInit->BootAddr0), &(pOBInit->BootAddr1));
24007b0c:	687b      	ldr	r3, [r7, #4]
24007b0e:	f103 0230 	add.w	r2, r3, #48	; 0x30
24007b12:	687b      	ldr	r3, [r7, #4]
24007b14:	3334      	adds	r3, #52	; 0x34
24007b16:	4619      	mov	r1, r3
24007b18:	4610      	mov	r0, r2
24007b1a:	f000 fc49 	bl	240083b0 <FLASH_OB_GetBootAdd>
  pOBInit->OptionType |= OPTIONBYTE_CM7_BOOTADD | OPTIONBYTE_CM4_BOOTADD;

  /*Get CM4 Boot Address*/
  FLASH_OB_GetCM4BootAdd(&(pOBInit->CM4BootAddr0), &(pOBInit->CM4BootAddr1));
#else
  pOBInit->OptionType |= OPTIONBYTE_BOOTADD;
24007b1e:	687b      	ldr	r3, [r7, #4]
24007b20:	681b      	ldr	r3, [r3, #0]
24007b22:	f043 0240 	orr.w	r2, r3, #64	; 0x40
24007b26:	687b      	ldr	r3, [r7, #4]
24007b28:	601a      	str	r2, [r3, #0]
  pOBInit->OptionType |= OPTIONBYTE_OTP_LOCK;

  /* Get OTP Block Lock */
  pOBInit->OTPBlockLock = FLASH_OB_OTP_GetLock();
#endif /* FLASH_OTPBL_LOCKBL */
}
24007b2a:	bf00      	nop
24007b2c:	3708      	adds	r7, #8
24007b2e:	46bd      	mov	sp, r7
24007b30:	bd80      	pop	{r7, pc}
	...

24007b34 <HAL_FLASHEx_Unlock_Bank1>:
/**
  * @brief  Unlock the FLASH Bank1 control registers access
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_FLASHEx_Unlock_Bank1(void)
{
24007b34:	b480      	push	{r7}
24007b36:	af00      	add	r7, sp, #0
  if(READ_BIT(FLASH->CR1, FLASH_CR_LOCK) != 0U)
24007b38:	4b0c      	ldr	r3, [pc, #48]	; (24007b6c <HAL_FLASHEx_Unlock_Bank1+0x38>)
24007b3a:	68db      	ldr	r3, [r3, #12]
24007b3c:	f003 0301 	and.w	r3, r3, #1
24007b40:	2b00      	cmp	r3, #0
24007b42:	d00d      	beq.n	24007b60 <HAL_FLASHEx_Unlock_Bank1+0x2c>
  {
    /* Authorize the FLASH Bank1 Registers access */
    WRITE_REG(FLASH->KEYR1, FLASH_KEY1);
24007b44:	4b09      	ldr	r3, [pc, #36]	; (24007b6c <HAL_FLASHEx_Unlock_Bank1+0x38>)
24007b46:	4a0a      	ldr	r2, [pc, #40]	; (24007b70 <HAL_FLASHEx_Unlock_Bank1+0x3c>)
24007b48:	605a      	str	r2, [r3, #4]
    WRITE_REG(FLASH->KEYR1, FLASH_KEY2);
24007b4a:	4b08      	ldr	r3, [pc, #32]	; (24007b6c <HAL_FLASHEx_Unlock_Bank1+0x38>)
24007b4c:	4a09      	ldr	r2, [pc, #36]	; (24007b74 <HAL_FLASHEx_Unlock_Bank1+0x40>)
24007b4e:	605a      	str	r2, [r3, #4]

    /* Verify Flash Bank1 is unlocked */
    if (READ_BIT(FLASH->CR1, FLASH_CR_LOCK) != 0U)
24007b50:	4b06      	ldr	r3, [pc, #24]	; (24007b6c <HAL_FLASHEx_Unlock_Bank1+0x38>)
24007b52:	68db      	ldr	r3, [r3, #12]
24007b54:	f003 0301 	and.w	r3, r3, #1
24007b58:	2b00      	cmp	r3, #0
24007b5a:	d001      	beq.n	24007b60 <HAL_FLASHEx_Unlock_Bank1+0x2c>
    {
      return HAL_ERROR;
24007b5c:	2301      	movs	r3, #1
24007b5e:	e000      	b.n	24007b62 <HAL_FLASHEx_Unlock_Bank1+0x2e>
    }
  }

  return HAL_OK;
24007b60:	2300      	movs	r3, #0
}
24007b62:	4618      	mov	r0, r3
24007b64:	46bd      	mov	sp, r7
24007b66:	f85d 7b04 	ldr.w	r7, [sp], #4
24007b6a:	4770      	bx	lr
24007b6c:	52002000 	.word	0x52002000
24007b70:	45670123 	.word	0x45670123
24007b74:	cdef89ab 	.word	0xcdef89ab

24007b78 <HAL_FLASHEx_Lock_Bank1>:
/**
  * @brief  Locks the FLASH Bank1 control registers access
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_FLASHEx_Lock_Bank1(void)
{
24007b78:	b480      	push	{r7}
24007b7a:	af00      	add	r7, sp, #0
  /* Set the LOCK Bit to lock the FLASH Bank1 Registers access */
  SET_BIT(FLASH->CR1, FLASH_CR_LOCK);
24007b7c:	4b05      	ldr	r3, [pc, #20]	; (24007b94 <HAL_FLASHEx_Lock_Bank1+0x1c>)
24007b7e:	68db      	ldr	r3, [r3, #12]
24007b80:	4a04      	ldr	r2, [pc, #16]	; (24007b94 <HAL_FLASHEx_Lock_Bank1+0x1c>)
24007b82:	f043 0301 	orr.w	r3, r3, #1
24007b86:	60d3      	str	r3, [r2, #12]
  return HAL_OK;
24007b88:	2300      	movs	r3, #0
}
24007b8a:	4618      	mov	r0, r3
24007b8c:	46bd      	mov	sp, r7
24007b8e:	f85d 7b04 	ldr.w	r7, [sp], #4
24007b92:	4770      	bx	lr
24007b94:	52002000 	.word	0x52002000

24007b98 <HAL_FLASHEx_Unlock_Bank2>:
/**
  * @brief  Unlock the FLASH Bank2 control registers access
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_FLASHEx_Unlock_Bank2(void)
{
24007b98:	b480      	push	{r7}
24007b9a:	af00      	add	r7, sp, #0
  if(READ_BIT(FLASH->CR2, FLASH_CR_LOCK) != 0U)
24007b9c:	4b0e      	ldr	r3, [pc, #56]	; (24007bd8 <HAL_FLASHEx_Unlock_Bank2+0x40>)
24007b9e:	f8d3 310c 	ldr.w	r3, [r3, #268]	; 0x10c
24007ba2:	f003 0301 	and.w	r3, r3, #1
24007ba6:	2b00      	cmp	r3, #0
24007ba8:	d010      	beq.n	24007bcc <HAL_FLASHEx_Unlock_Bank2+0x34>
  {
    /* Authorize the FLASH Bank2 Registers access */
    WRITE_REG(FLASH->KEYR2, FLASH_KEY1);
24007baa:	4b0b      	ldr	r3, [pc, #44]	; (24007bd8 <HAL_FLASHEx_Unlock_Bank2+0x40>)
24007bac:	4a0b      	ldr	r2, [pc, #44]	; (24007bdc <HAL_FLASHEx_Unlock_Bank2+0x44>)
24007bae:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
    WRITE_REG(FLASH->KEYR2, FLASH_KEY2);
24007bb2:	4b09      	ldr	r3, [pc, #36]	; (24007bd8 <HAL_FLASHEx_Unlock_Bank2+0x40>)
24007bb4:	4a0a      	ldr	r2, [pc, #40]	; (24007be0 <HAL_FLASHEx_Unlock_Bank2+0x48>)
24007bb6:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104

    /* Verify Flash Bank1 is unlocked */
    if (READ_BIT(FLASH->CR2, FLASH_CR_LOCK) != 0U)
24007bba:	4b07      	ldr	r3, [pc, #28]	; (24007bd8 <HAL_FLASHEx_Unlock_Bank2+0x40>)
24007bbc:	f8d3 310c 	ldr.w	r3, [r3, #268]	; 0x10c
24007bc0:	f003 0301 	and.w	r3, r3, #1
24007bc4:	2b00      	cmp	r3, #0
24007bc6:	d001      	beq.n	24007bcc <HAL_FLASHEx_Unlock_Bank2+0x34>
    {
      return HAL_ERROR;
24007bc8:	2301      	movs	r3, #1
24007bca:	e000      	b.n	24007bce <HAL_FLASHEx_Unlock_Bank2+0x36>
    }
  }

  return HAL_OK;
24007bcc:	2300      	movs	r3, #0
}
24007bce:	4618      	mov	r0, r3
24007bd0:	46bd      	mov	sp, r7
24007bd2:	f85d 7b04 	ldr.w	r7, [sp], #4
24007bd6:	4770      	bx	lr
24007bd8:	52002000 	.word	0x52002000
24007bdc:	45670123 	.word	0x45670123
24007be0:	cdef89ab 	.word	0xcdef89ab

24007be4 <HAL_FLASHEx_Lock_Bank2>:
/**
  * @brief  Locks the FLASH Bank2 control registers access
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_FLASHEx_Lock_Bank2(void)
{
24007be4:	b480      	push	{r7}
24007be6:	af00      	add	r7, sp, #0
  /* Set the LOCK Bit to lock the FLASH Bank2 Registers access */
  SET_BIT(FLASH->CR2, FLASH_CR_LOCK);
24007be8:	4b06      	ldr	r3, [pc, #24]	; (24007c04 <HAL_FLASHEx_Lock_Bank2+0x20>)
24007bea:	f8d3 310c 	ldr.w	r3, [r3, #268]	; 0x10c
24007bee:	4a05      	ldr	r2, [pc, #20]	; (24007c04 <HAL_FLASHEx_Lock_Bank2+0x20>)
24007bf0:	f043 0301 	orr.w	r3, r3, #1
24007bf4:	f8c2 310c 	str.w	r3, [r2, #268]	; 0x10c
  return HAL_OK;
24007bf8:	2300      	movs	r3, #0
}
24007bfa:	4618      	mov	r0, r3
24007bfc:	46bd      	mov	sp, r7
24007bfe:	f85d 7b04 	ldr.w	r7, [sp], #4
24007c02:	4770      	bx	lr
24007c04:	52002000 	.word	0x52002000

24007c08 <HAL_FLASHEx_ComputeCRC>:
  *         A special error flag (CRC read error: CRCRDERR) can be used to
  *         detect such a case.
  * @retval HAL Status
*/
HAL_StatusTypeDef HAL_FLASHEx_ComputeCRC(FLASH_CRCInitTypeDef *pCRCInit, uint32_t *CRC_Result)
{
24007c08:	b580      	push	{r7, lr}
24007c0a:	b084      	sub	sp, #16
24007c0c:	af00      	add	r7, sp, #0
24007c0e:	6078      	str	r0, [r7, #4]
24007c10:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_FLASH_BANK_EXCLUSIVE(pCRCInit->Bank));
  assert_param(IS_FLASH_TYPECRC(pCRCInit->TypeCRC));

  /* Wait for OB change operation to be completed */
  status = FLASH_OB_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
24007c12:	f24c 3050 	movw	r0, #50000	; 0xc350
24007c16:	f7ff fc71 	bl	240074fc <FLASH_OB_WaitForLastOperation>
24007c1a:	4603      	mov	r3, r0
24007c1c:	73fb      	strb	r3, [r7, #15]

  if (status == HAL_OK)
24007c1e:	7bfb      	ldrb	r3, [r7, #15]
24007c20:	2b00      	cmp	r3, #0
24007c22:	f040 80e0 	bne.w	24007de6 <HAL_FLASHEx_ComputeCRC+0x1de>
  {
    if (pCRCInit->Bank == FLASH_BANK_1)
24007c26:	687b      	ldr	r3, [r7, #4]
24007c28:	689b      	ldr	r3, [r3, #8]
24007c2a:	2b01      	cmp	r3, #1
24007c2c:	d166      	bne.n	24007cfc <HAL_FLASHEx_ComputeCRC+0xf4>
    {
      /* Enable CRC feature */
      FLASH->CR1 |= FLASH_CR_CRC_EN;
24007c2e:	4b70      	ldr	r3, [pc, #448]	; (24007df0 <HAL_FLASHEx_ComputeCRC+0x1e8>)
24007c30:	68db      	ldr	r3, [r3, #12]
24007c32:	4a6f      	ldr	r2, [pc, #444]	; (24007df0 <HAL_FLASHEx_ComputeCRC+0x1e8>)
24007c34:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
24007c38:	60d3      	str	r3, [r2, #12]

      /* Clear CRC flags in Status Register: CRC end of calculation and CRC read error */
      FLASH->CCR1 |= (FLASH_CCR_CLR_CRCEND | FLASH_CCR_CLR_CRCRDERR);
24007c3a:	4b6d      	ldr	r3, [pc, #436]	; (24007df0 <HAL_FLASHEx_ComputeCRC+0x1e8>)
24007c3c:	695b      	ldr	r3, [r3, #20]
24007c3e:	4a6c      	ldr	r2, [pc, #432]	; (24007df0 <HAL_FLASHEx_ComputeCRC+0x1e8>)
24007c40:	f043 53c0 	orr.w	r3, r3, #402653184	; 0x18000000
24007c44:	6153      	str	r3, [r2, #20]

      /* Clear current CRC result, program burst size and define memory area on which CRC has to be computed */
      FLASH->CRCCR1 |= FLASH_CRCCR_CLEAN_CRC | pCRCInit->BurstSize | pCRCInit->TypeCRC;
24007c46:	4b6a      	ldr	r3, [pc, #424]	; (24007df0 <HAL_FLASHEx_ComputeCRC+0x1e8>)
24007c48:	6d1a      	ldr	r2, [r3, #80]	; 0x50
24007c4a:	687b      	ldr	r3, [r7, #4]
24007c4c:	6859      	ldr	r1, [r3, #4]
24007c4e:	687b      	ldr	r3, [r7, #4]
24007c50:	681b      	ldr	r3, [r3, #0]
24007c52:	430b      	orrs	r3, r1
24007c54:	4313      	orrs	r3, r2
24007c56:	4a66      	ldr	r2, [pc, #408]	; (24007df0 <HAL_FLASHEx_ComputeCRC+0x1e8>)
24007c58:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
24007c5c:	6513      	str	r3, [r2, #80]	; 0x50

      if (pCRCInit->TypeCRC == FLASH_CRC_SECTORS)
24007c5e:	687b      	ldr	r3, [r7, #4]
24007c60:	681b      	ldr	r3, [r3, #0]
24007c62:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
24007c66:	d119      	bne.n	24007c9c <HAL_FLASHEx_ComputeCRC+0x94>
      {
        /* Clear sectors list */
        FLASH->CRCCR1 |= FLASH_CRCCR_CLEAN_SECT;
24007c68:	4b61      	ldr	r3, [pc, #388]	; (24007df0 <HAL_FLASHEx_ComputeCRC+0x1e8>)
24007c6a:	6d1b      	ldr	r3, [r3, #80]	; 0x50
24007c6c:	4a60      	ldr	r2, [pc, #384]	; (24007df0 <HAL_FLASHEx_ComputeCRC+0x1e8>)
24007c6e:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
24007c72:	6513      	str	r3, [r2, #80]	; 0x50

        /* Select CRC sectors */
        for(sector_index = pCRCInit->Sector; sector_index < (pCRCInit->NbSectors + pCRCInit->Sector); sector_index++)
24007c74:	687b      	ldr	r3, [r7, #4]
24007c76:	68db      	ldr	r3, [r3, #12]
24007c78:	60bb      	str	r3, [r7, #8]
24007c7a:	e006      	b.n	24007c8a <HAL_FLASHEx_ComputeCRC+0x82>
        {
          FLASH_CRC_AddSector(sector_index, FLASH_BANK_1);
24007c7c:	2101      	movs	r1, #1
24007c7e:	68b8      	ldr	r0, [r7, #8]
24007c80:	f000 fc32 	bl	240084e8 <FLASH_CRC_AddSector>
        for(sector_index = pCRCInit->Sector; sector_index < (pCRCInit->NbSectors + pCRCInit->Sector); sector_index++)
24007c84:	68bb      	ldr	r3, [r7, #8]
24007c86:	3301      	adds	r3, #1
24007c88:	60bb      	str	r3, [r7, #8]
24007c8a:	687b      	ldr	r3, [r7, #4]
24007c8c:	691a      	ldr	r2, [r3, #16]
24007c8e:	687b      	ldr	r3, [r7, #4]
24007c90:	68db      	ldr	r3, [r3, #12]
24007c92:	4413      	add	r3, r2
24007c94:	68ba      	ldr	r2, [r7, #8]
24007c96:	429a      	cmp	r2, r3
24007c98:	d3f0      	bcc.n	24007c7c <HAL_FLASHEx_ComputeCRC+0x74>
24007c9a:	e013      	b.n	24007cc4 <HAL_FLASHEx_ComputeCRC+0xbc>
        }
      }
      else if (pCRCInit->TypeCRC == FLASH_CRC_BANK)
24007c9c:	687b      	ldr	r3, [r7, #4]
24007c9e:	681b      	ldr	r3, [r3, #0]
24007ca0:	4a54      	ldr	r2, [pc, #336]	; (24007df4 <HAL_FLASHEx_ComputeCRC+0x1ec>)
24007ca2:	4293      	cmp	r3, r2
24007ca4:	d106      	bne.n	24007cb4 <HAL_FLASHEx_ComputeCRC+0xac>
      {
        /* Enable Bank 1 CRC select bit */
        FLASH->CRCCR1 |= FLASH_CRCCR_ALL_BANK;
24007ca6:	4b52      	ldr	r3, [pc, #328]	; (24007df0 <HAL_FLASHEx_ComputeCRC+0x1e8>)
24007ca8:	6d1b      	ldr	r3, [r3, #80]	; 0x50
24007caa:	4a51      	ldr	r2, [pc, #324]	; (24007df0 <HAL_FLASHEx_ComputeCRC+0x1e8>)
24007cac:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
24007cb0:	6513      	str	r3, [r2, #80]	; 0x50
24007cb2:	e007      	b.n	24007cc4 <HAL_FLASHEx_ComputeCRC+0xbc>
      }
      else
      {
        /* Select CRC start and end addresses */
        FLASH_CRC_SelectAddress(pCRCInit->CRCStartAddr, pCRCInit->CRCEndAddr, FLASH_BANK_1);
24007cb4:	687b      	ldr	r3, [r7, #4]
24007cb6:	6958      	ldr	r0, [r3, #20]
24007cb8:	687b      	ldr	r3, [r7, #4]
24007cba:	699b      	ldr	r3, [r3, #24]
24007cbc:	2201      	movs	r2, #1
24007cbe:	4619      	mov	r1, r3
24007cc0:	f000 fc44 	bl	2400854c <FLASH_CRC_SelectAddress>
      }

      /* Start the CRC calculation */
      FLASH->CRCCR1 |= FLASH_CRCCR_START_CRC;
24007cc4:	4b4a      	ldr	r3, [pc, #296]	; (24007df0 <HAL_FLASHEx_ComputeCRC+0x1e8>)
24007cc6:	6d1b      	ldr	r3, [r3, #80]	; 0x50
24007cc8:	4a49      	ldr	r2, [pc, #292]	; (24007df0 <HAL_FLASHEx_ComputeCRC+0x1e8>)
24007cca:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
24007cce:	6513      	str	r3, [r2, #80]	; 0x50

      /* Wait on CRC busy flag */
      status = FLASH_CRC_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_1);
24007cd0:	2101      	movs	r1, #1
24007cd2:	f24c 3050 	movw	r0, #50000	; 0xc350
24007cd6:	f7ff fc4d 	bl	24007574 <FLASH_CRC_WaitForLastOperation>
24007cda:	4603      	mov	r3, r0
24007cdc:	73fb      	strb	r3, [r7, #15]

      /* Return CRC result */
      (*CRC_Result) = FLASH->CRCDATA;
24007cde:	4b44      	ldr	r3, [pc, #272]	; (24007df0 <HAL_FLASHEx_ComputeCRC+0x1e8>)
24007ce0:	6dda      	ldr	r2, [r3, #92]	; 0x5c
24007ce2:	683b      	ldr	r3, [r7, #0]
24007ce4:	601a      	str	r2, [r3, #0]

      /* Disable CRC feature */
      FLASH->CR1 &= (~FLASH_CR_CRC_EN);
24007ce6:	4b42      	ldr	r3, [pc, #264]	; (24007df0 <HAL_FLASHEx_ComputeCRC+0x1e8>)
24007ce8:	68db      	ldr	r3, [r3, #12]
24007cea:	4a41      	ldr	r2, [pc, #260]	; (24007df0 <HAL_FLASHEx_ComputeCRC+0x1e8>)
24007cec:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
24007cf0:	60d3      	str	r3, [r2, #12]

      /* Clear CRC flags */
      __HAL_FLASH_CLEAR_FLAG_BANK1(FLASH_FLAG_CRCEND_BANK1 | FLASH_FLAG_CRCRDERR_BANK1);
24007cf2:	4b3f      	ldr	r3, [pc, #252]	; (24007df0 <HAL_FLASHEx_ComputeCRC+0x1e8>)
24007cf4:	f04f 52c0 	mov.w	r2, #402653184	; 0x18000000
24007cf8:	615a      	str	r2, [r3, #20]
24007cfa:	e074      	b.n	24007de6 <HAL_FLASHEx_ComputeCRC+0x1de>
    }
    else
    {
      /* Enable CRC feature */
      FLASH->CR2 |= FLASH_CR_CRC_EN;
24007cfc:	4b3c      	ldr	r3, [pc, #240]	; (24007df0 <HAL_FLASHEx_ComputeCRC+0x1e8>)
24007cfe:	f8d3 310c 	ldr.w	r3, [r3, #268]	; 0x10c
24007d02:	4a3b      	ldr	r2, [pc, #236]	; (24007df0 <HAL_FLASHEx_ComputeCRC+0x1e8>)
24007d04:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
24007d08:	f8c2 310c 	str.w	r3, [r2, #268]	; 0x10c

      /* Clear CRC flags in Status Register: CRC end of calculation and CRC read error */
      FLASH->CCR2 |= (FLASH_CCR_CLR_CRCEND | FLASH_CCR_CLR_CRCRDERR);
24007d0c:	4b38      	ldr	r3, [pc, #224]	; (24007df0 <HAL_FLASHEx_ComputeCRC+0x1e8>)
24007d0e:	f8d3 3114 	ldr.w	r3, [r3, #276]	; 0x114
24007d12:	4a37      	ldr	r2, [pc, #220]	; (24007df0 <HAL_FLASHEx_ComputeCRC+0x1e8>)
24007d14:	f043 53c0 	orr.w	r3, r3, #402653184	; 0x18000000
24007d18:	f8c2 3114 	str.w	r3, [r2, #276]	; 0x114

      /* Clear current CRC result, program burst size and define memory area on which CRC has to be computed */
      FLASH->CRCCR2 |= FLASH_CRCCR_CLEAN_CRC | pCRCInit->BurstSize | pCRCInit->TypeCRC;
24007d1c:	4b34      	ldr	r3, [pc, #208]	; (24007df0 <HAL_FLASHEx_ComputeCRC+0x1e8>)
24007d1e:	f8d3 2150 	ldr.w	r2, [r3, #336]	; 0x150
24007d22:	687b      	ldr	r3, [r7, #4]
24007d24:	6859      	ldr	r1, [r3, #4]
24007d26:	687b      	ldr	r3, [r7, #4]
24007d28:	681b      	ldr	r3, [r3, #0]
24007d2a:	430b      	orrs	r3, r1
24007d2c:	4313      	orrs	r3, r2
24007d2e:	4a30      	ldr	r2, [pc, #192]	; (24007df0 <HAL_FLASHEx_ComputeCRC+0x1e8>)
24007d30:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
24007d34:	f8c2 3150 	str.w	r3, [r2, #336]	; 0x150

      if (pCRCInit->TypeCRC == FLASH_CRC_SECTORS)
24007d38:	687b      	ldr	r3, [r7, #4]
24007d3a:	681b      	ldr	r3, [r3, #0]
24007d3c:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
24007d40:	d11b      	bne.n	24007d7a <HAL_FLASHEx_ComputeCRC+0x172>
      {
        /* Clear sectors list */
        FLASH->CRCCR2 |= FLASH_CRCCR_CLEAN_SECT;
24007d42:	4b2b      	ldr	r3, [pc, #172]	; (24007df0 <HAL_FLASHEx_ComputeCRC+0x1e8>)
24007d44:	f8d3 3150 	ldr.w	r3, [r3, #336]	; 0x150
24007d48:	4a29      	ldr	r2, [pc, #164]	; (24007df0 <HAL_FLASHEx_ComputeCRC+0x1e8>)
24007d4a:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
24007d4e:	f8c2 3150 	str.w	r3, [r2, #336]	; 0x150

        /* Add CRC sectors */
        for(sector_index = pCRCInit->Sector; sector_index < (pCRCInit->NbSectors + pCRCInit->Sector); sector_index++)
24007d52:	687b      	ldr	r3, [r7, #4]
24007d54:	68db      	ldr	r3, [r3, #12]
24007d56:	60bb      	str	r3, [r7, #8]
24007d58:	e006      	b.n	24007d68 <HAL_FLASHEx_ComputeCRC+0x160>
        {
          FLASH_CRC_AddSector(sector_index, FLASH_BANK_2);
24007d5a:	2102      	movs	r1, #2
24007d5c:	68b8      	ldr	r0, [r7, #8]
24007d5e:	f000 fbc3 	bl	240084e8 <FLASH_CRC_AddSector>
        for(sector_index = pCRCInit->Sector; sector_index < (pCRCInit->NbSectors + pCRCInit->Sector); sector_index++)
24007d62:	68bb      	ldr	r3, [r7, #8]
24007d64:	3301      	adds	r3, #1
24007d66:	60bb      	str	r3, [r7, #8]
24007d68:	687b      	ldr	r3, [r7, #4]
24007d6a:	691a      	ldr	r2, [r3, #16]
24007d6c:	687b      	ldr	r3, [r7, #4]
24007d6e:	68db      	ldr	r3, [r3, #12]
24007d70:	4413      	add	r3, r2
24007d72:	68ba      	ldr	r2, [r7, #8]
24007d74:	429a      	cmp	r2, r3
24007d76:	d3f0      	bcc.n	24007d5a <HAL_FLASHEx_ComputeCRC+0x152>
24007d78:	e015      	b.n	24007da6 <HAL_FLASHEx_ComputeCRC+0x19e>
        }
      }
      else if (pCRCInit->TypeCRC == FLASH_CRC_BANK)
24007d7a:	687b      	ldr	r3, [r7, #4]
24007d7c:	681b      	ldr	r3, [r3, #0]
24007d7e:	4a1d      	ldr	r2, [pc, #116]	; (24007df4 <HAL_FLASHEx_ComputeCRC+0x1ec>)
24007d80:	4293      	cmp	r3, r2
24007d82:	d108      	bne.n	24007d96 <HAL_FLASHEx_ComputeCRC+0x18e>
      {
        /* Enable Bank 2 CRC select bit */
        FLASH->CRCCR2 |= FLASH_CRCCR_ALL_BANK;
24007d84:	4b1a      	ldr	r3, [pc, #104]	; (24007df0 <HAL_FLASHEx_ComputeCRC+0x1e8>)
24007d86:	f8d3 3150 	ldr.w	r3, [r3, #336]	; 0x150
24007d8a:	4a19      	ldr	r2, [pc, #100]	; (24007df0 <HAL_FLASHEx_ComputeCRC+0x1e8>)
24007d8c:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
24007d90:	f8c2 3150 	str.w	r3, [r2, #336]	; 0x150
24007d94:	e007      	b.n	24007da6 <HAL_FLASHEx_ComputeCRC+0x19e>
      }
      else
      {
        /* Select CRC start and end addresses */
        FLASH_CRC_SelectAddress(pCRCInit->CRCStartAddr, pCRCInit->CRCEndAddr, FLASH_BANK_2);
24007d96:	687b      	ldr	r3, [r7, #4]
24007d98:	6958      	ldr	r0, [r3, #20]
24007d9a:	687b      	ldr	r3, [r7, #4]
24007d9c:	699b      	ldr	r3, [r3, #24]
24007d9e:	2202      	movs	r2, #2
24007da0:	4619      	mov	r1, r3
24007da2:	f000 fbd3 	bl	2400854c <FLASH_CRC_SelectAddress>
      }

      /* Start the CRC calculation */
      FLASH->CRCCR2 |= FLASH_CRCCR_START_CRC;
24007da6:	4b12      	ldr	r3, [pc, #72]	; (24007df0 <HAL_FLASHEx_ComputeCRC+0x1e8>)
24007da8:	f8d3 3150 	ldr.w	r3, [r3, #336]	; 0x150
24007dac:	4a10      	ldr	r2, [pc, #64]	; (24007df0 <HAL_FLASHEx_ComputeCRC+0x1e8>)
24007dae:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
24007db2:	f8c2 3150 	str.w	r3, [r2, #336]	; 0x150

      /* Wait on CRC busy flag */
      status = FLASH_CRC_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_2);
24007db6:	2102      	movs	r1, #2
24007db8:	f24c 3050 	movw	r0, #50000	; 0xc350
24007dbc:	f7ff fbda 	bl	24007574 <FLASH_CRC_WaitForLastOperation>
24007dc0:	4603      	mov	r3, r0
24007dc2:	73fb      	strb	r3, [r7, #15]

      /* Return CRC result */
      (*CRC_Result) = FLASH->CRCDATA;
24007dc4:	4b0a      	ldr	r3, [pc, #40]	; (24007df0 <HAL_FLASHEx_ComputeCRC+0x1e8>)
24007dc6:	6dda      	ldr	r2, [r3, #92]	; 0x5c
24007dc8:	683b      	ldr	r3, [r7, #0]
24007dca:	601a      	str	r2, [r3, #0]

      /* Disable CRC feature */
      FLASH->CR2 &= (~FLASH_CR_CRC_EN);
24007dcc:	4b08      	ldr	r3, [pc, #32]	; (24007df0 <HAL_FLASHEx_ComputeCRC+0x1e8>)
24007dce:	f8d3 310c 	ldr.w	r3, [r3, #268]	; 0x10c
24007dd2:	4a07      	ldr	r2, [pc, #28]	; (24007df0 <HAL_FLASHEx_ComputeCRC+0x1e8>)
24007dd4:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
24007dd8:	f8c2 310c 	str.w	r3, [r2, #268]	; 0x10c

      /* Clear CRC flags */
      __HAL_FLASH_CLEAR_FLAG_BANK2(FLASH_FLAG_CRCEND_BANK2 | FLASH_FLAG_CRCRDERR_BANK2);
24007ddc:	4b04      	ldr	r3, [pc, #16]	; (24007df0 <HAL_FLASHEx_ComputeCRC+0x1e8>)
24007dde:	f04f 52c0 	mov.w	r2, #402653184	; 0x18000000
24007de2:	f8c3 2114 	str.w	r2, [r3, #276]	; 0x114
    }
  }

  return status;
24007de6:	7bfb      	ldrb	r3, [r7, #15]
}
24007de8:	4618      	mov	r0, r3
24007dea:	3710      	adds	r7, #16
24007dec:	46bd      	mov	sp, r7
24007dee:	bd80      	pop	{r7, pc}
24007df0:	52002000 	.word	0x52002000
24007df4:	00400100 	.word	0x00400100

24007df8 <FLASH_MassErase>:
  *            @arg FLASH_BANK_BOTH: Bank1 and Bank2 to be erased
  *
  * @retval HAL Status
  */
static void FLASH_MassErase(uint32_t VoltageRange, uint32_t Banks)
{
24007df8:	b480      	push	{r7}
24007dfa:	b083      	sub	sp, #12
24007dfc:	af00      	add	r7, sp, #0
24007dfe:	6078      	str	r0, [r7, #4]
24007e00:	6039      	str	r1, [r7, #0]
  UNUSED(VoltageRange);
#endif /* FLASH_CR_PSIZE */
  assert_param(IS_FLASH_BANK(Banks));

  /* Flash Mass Erase */
  if((Banks & FLASH_BANK_BOTH) == FLASH_BANK_BOTH)
24007e02:	683b      	ldr	r3, [r7, #0]
24007e04:	f003 0303 	and.w	r3, r3, #3
24007e08:	2b03      	cmp	r3, #3
24007e0a:	d122      	bne.n	24007e52 <FLASH_MassErase+0x5a>
  {
#if defined (FLASH_CR_PSIZE)
    /* Reset Program/erase VoltageRange for Bank1 and Bank2 */
    FLASH->CR1 &= (~FLASH_CR_PSIZE);
24007e0c:	4b2e      	ldr	r3, [pc, #184]	; (24007ec8 <FLASH_MassErase+0xd0>)
24007e0e:	68db      	ldr	r3, [r3, #12]
24007e10:	4a2d      	ldr	r2, [pc, #180]	; (24007ec8 <FLASH_MassErase+0xd0>)
24007e12:	f023 0330 	bic.w	r3, r3, #48	; 0x30
24007e16:	60d3      	str	r3, [r2, #12]
    FLASH->CR2 &= (~FLASH_CR_PSIZE);
24007e18:	4b2b      	ldr	r3, [pc, #172]	; (24007ec8 <FLASH_MassErase+0xd0>)
24007e1a:	f8d3 310c 	ldr.w	r3, [r3, #268]	; 0x10c
24007e1e:	4a2a      	ldr	r2, [pc, #168]	; (24007ec8 <FLASH_MassErase+0xd0>)
24007e20:	f023 0330 	bic.w	r3, r3, #48	; 0x30
24007e24:	f8c2 310c 	str.w	r3, [r2, #268]	; 0x10c

    /* Set voltage range */
    FLASH->CR1 |= VoltageRange;
24007e28:	4b27      	ldr	r3, [pc, #156]	; (24007ec8 <FLASH_MassErase+0xd0>)
24007e2a:	68da      	ldr	r2, [r3, #12]
24007e2c:	4926      	ldr	r1, [pc, #152]	; (24007ec8 <FLASH_MassErase+0xd0>)
24007e2e:	687b      	ldr	r3, [r7, #4]
24007e30:	4313      	orrs	r3, r2
24007e32:	60cb      	str	r3, [r1, #12]
    FLASH->CR2 |= VoltageRange;
24007e34:	4b24      	ldr	r3, [pc, #144]	; (24007ec8 <FLASH_MassErase+0xd0>)
24007e36:	f8d3 210c 	ldr.w	r2, [r3, #268]	; 0x10c
24007e3a:	4923      	ldr	r1, [pc, #140]	; (24007ec8 <FLASH_MassErase+0xd0>)
24007e3c:	687b      	ldr	r3, [r7, #4]
24007e3e:	4313      	orrs	r3, r2
24007e40:	f8c1 310c 	str.w	r3, [r1, #268]	; 0x10c
#endif /* FLASH_CR_PSIZE */

    /* Set Mass Erase Bit */
    FLASH->OPTCR |= FLASH_OPTCR_MER;
24007e44:	4b20      	ldr	r3, [pc, #128]	; (24007ec8 <FLASH_MassErase+0xd0>)
24007e46:	699b      	ldr	r3, [r3, #24]
24007e48:	4a1f      	ldr	r2, [pc, #124]	; (24007ec8 <FLASH_MassErase+0xd0>)
24007e4a:	f043 0310 	orr.w	r3, r3, #16
24007e4e:	6193      	str	r3, [r2, #24]

      /* Erase Bank2 */
      FLASH->CR2 |= (FLASH_CR_BER | FLASH_CR_START);
    }
  }
}
24007e50:	e033      	b.n	24007eba <FLASH_MassErase+0xc2>
    if((Banks & FLASH_BANK_1) == FLASH_BANK_1)
24007e52:	683b      	ldr	r3, [r7, #0]
24007e54:	f003 0301 	and.w	r3, r3, #1
24007e58:	2b00      	cmp	r3, #0
24007e5a:	d011      	beq.n	24007e80 <FLASH_MassErase+0x88>
      FLASH->CR1 &= (~FLASH_CR_PSIZE);
24007e5c:	4b1a      	ldr	r3, [pc, #104]	; (24007ec8 <FLASH_MassErase+0xd0>)
24007e5e:	68db      	ldr	r3, [r3, #12]
24007e60:	4a19      	ldr	r2, [pc, #100]	; (24007ec8 <FLASH_MassErase+0xd0>)
24007e62:	f023 0330 	bic.w	r3, r3, #48	; 0x30
24007e66:	60d3      	str	r3, [r2, #12]
      FLASH->CR1 |=  VoltageRange;
24007e68:	4b17      	ldr	r3, [pc, #92]	; (24007ec8 <FLASH_MassErase+0xd0>)
24007e6a:	68da      	ldr	r2, [r3, #12]
24007e6c:	4916      	ldr	r1, [pc, #88]	; (24007ec8 <FLASH_MassErase+0xd0>)
24007e6e:	687b      	ldr	r3, [r7, #4]
24007e70:	4313      	orrs	r3, r2
24007e72:	60cb      	str	r3, [r1, #12]
      FLASH->CR1 |= (FLASH_CR_BER | FLASH_CR_START);
24007e74:	4b14      	ldr	r3, [pc, #80]	; (24007ec8 <FLASH_MassErase+0xd0>)
24007e76:	68db      	ldr	r3, [r3, #12]
24007e78:	4a13      	ldr	r2, [pc, #76]	; (24007ec8 <FLASH_MassErase+0xd0>)
24007e7a:	f043 0388 	orr.w	r3, r3, #136	; 0x88
24007e7e:	60d3      	str	r3, [r2, #12]
    if((Banks & FLASH_BANK_2) == FLASH_BANK_2)
24007e80:	683b      	ldr	r3, [r7, #0]
24007e82:	f003 0302 	and.w	r3, r3, #2
24007e86:	2b00      	cmp	r3, #0
24007e88:	d017      	beq.n	24007eba <FLASH_MassErase+0xc2>
      FLASH->CR2 &= (~FLASH_CR_PSIZE);
24007e8a:	4b0f      	ldr	r3, [pc, #60]	; (24007ec8 <FLASH_MassErase+0xd0>)
24007e8c:	f8d3 310c 	ldr.w	r3, [r3, #268]	; 0x10c
24007e90:	4a0d      	ldr	r2, [pc, #52]	; (24007ec8 <FLASH_MassErase+0xd0>)
24007e92:	f023 0330 	bic.w	r3, r3, #48	; 0x30
24007e96:	f8c2 310c 	str.w	r3, [r2, #268]	; 0x10c
      FLASH->CR2 |= VoltageRange;
24007e9a:	4b0b      	ldr	r3, [pc, #44]	; (24007ec8 <FLASH_MassErase+0xd0>)
24007e9c:	f8d3 210c 	ldr.w	r2, [r3, #268]	; 0x10c
24007ea0:	4909      	ldr	r1, [pc, #36]	; (24007ec8 <FLASH_MassErase+0xd0>)
24007ea2:	687b      	ldr	r3, [r7, #4]
24007ea4:	4313      	orrs	r3, r2
24007ea6:	f8c1 310c 	str.w	r3, [r1, #268]	; 0x10c
      FLASH->CR2 |= (FLASH_CR_BER | FLASH_CR_START);
24007eaa:	4b07      	ldr	r3, [pc, #28]	; (24007ec8 <FLASH_MassErase+0xd0>)
24007eac:	f8d3 310c 	ldr.w	r3, [r3, #268]	; 0x10c
24007eb0:	4a05      	ldr	r2, [pc, #20]	; (24007ec8 <FLASH_MassErase+0xd0>)
24007eb2:	f043 0388 	orr.w	r3, r3, #136	; 0x88
24007eb6:	f8c2 310c 	str.w	r3, [r2, #268]	; 0x10c
}
24007eba:	bf00      	nop
24007ebc:	370c      	adds	r7, #12
24007ebe:	46bd      	mov	sp, r7
24007ec0:	f85d 7b04 	ldr.w	r7, [sp], #4
24007ec4:	4770      	bx	lr
24007ec6:	bf00      	nop
24007ec8:	52002000 	.word	0x52002000

24007ecc <FLASH_Erase_Sector>:
  *            @arg FLASH_VOLTAGE_RANGE_4 : Flash program/erase by 64 bits
  *
  * @retval None
  */
void FLASH_Erase_Sector(uint32_t Sector, uint32_t Banks, uint32_t VoltageRange)
{
24007ecc:	b480      	push	{r7}
24007ece:	b085      	sub	sp, #20
24007ed0:	af00      	add	r7, sp, #0
24007ed2:	60f8      	str	r0, [r7, #12]
24007ed4:	60b9      	str	r1, [r7, #8]
24007ed6:	607a      	str	r2, [r7, #4]
  assert_param(IS_VOLTAGERANGE(VoltageRange));
#else
  UNUSED(VoltageRange);
#endif /* FLASH_CR_PSIZE */

  if((Banks & FLASH_BANK_1) == FLASH_BANK_1)
24007ed8:	68bb      	ldr	r3, [r7, #8]
24007eda:	f003 0301 	and.w	r3, r3, #1
24007ede:	2b00      	cmp	r3, #0
24007ee0:	d010      	beq.n	24007f04 <FLASH_Erase_Sector+0x38>
  {
#if defined (FLASH_CR_PSIZE)
    /* Reset Program/erase VoltageRange and Sector Number for Bank1 */
    FLASH->CR1 &= ~(FLASH_CR_PSIZE | FLASH_CR_SNB);
24007ee2:	4b18      	ldr	r3, [pc, #96]	; (24007f44 <FLASH_Erase_Sector+0x78>)
24007ee4:	68db      	ldr	r3, [r3, #12]
24007ee6:	4a17      	ldr	r2, [pc, #92]	; (24007f44 <FLASH_Erase_Sector+0x78>)
24007ee8:	f423 63e6 	bic.w	r3, r3, #1840	; 0x730
24007eec:	60d3      	str	r3, [r2, #12]

    FLASH->CR1 |= (FLASH_CR_SER | VoltageRange | (Sector << FLASH_CR_SNB_Pos) | FLASH_CR_START);
24007eee:	4b15      	ldr	r3, [pc, #84]	; (24007f44 <FLASH_Erase_Sector+0x78>)
24007ef0:	68da      	ldr	r2, [r3, #12]
24007ef2:	68fb      	ldr	r3, [r7, #12]
24007ef4:	0219      	lsls	r1, r3, #8
24007ef6:	687b      	ldr	r3, [r7, #4]
24007ef8:	430b      	orrs	r3, r1
24007efa:	4313      	orrs	r3, r2
24007efc:	4a11      	ldr	r2, [pc, #68]	; (24007f44 <FLASH_Erase_Sector+0x78>)
24007efe:	f043 0384 	orr.w	r3, r3, #132	; 0x84
24007f02:	60d3      	str	r3, [r2, #12]

    FLASH->CR1 |= (FLASH_CR_SER | (Sector << FLASH_CR_SNB_Pos) | FLASH_CR_START);
#endif /* FLASH_CR_PSIZE */
  }

  if((Banks & FLASH_BANK_2) == FLASH_BANK_2)
24007f04:	68bb      	ldr	r3, [r7, #8]
24007f06:	f003 0302 	and.w	r3, r3, #2
24007f0a:	2b00      	cmp	r3, #0
24007f0c:	d014      	beq.n	24007f38 <FLASH_Erase_Sector+0x6c>
  {
#if defined (FLASH_CR_PSIZE)
    /* Reset Program/erase VoltageRange and Sector Number for Bank2 */
    FLASH->CR2 &= ~(FLASH_CR_PSIZE | FLASH_CR_SNB);
24007f0e:	4b0d      	ldr	r3, [pc, #52]	; (24007f44 <FLASH_Erase_Sector+0x78>)
24007f10:	f8d3 310c 	ldr.w	r3, [r3, #268]	; 0x10c
24007f14:	4a0b      	ldr	r2, [pc, #44]	; (24007f44 <FLASH_Erase_Sector+0x78>)
24007f16:	f423 63e6 	bic.w	r3, r3, #1840	; 0x730
24007f1a:	f8c2 310c 	str.w	r3, [r2, #268]	; 0x10c

    FLASH->CR2 |= (FLASH_CR_SER | VoltageRange  | (Sector << FLASH_CR_SNB_Pos) | FLASH_CR_START);
24007f1e:	4b09      	ldr	r3, [pc, #36]	; (24007f44 <FLASH_Erase_Sector+0x78>)
24007f20:	f8d3 210c 	ldr.w	r2, [r3, #268]	; 0x10c
24007f24:	68fb      	ldr	r3, [r7, #12]
24007f26:	0219      	lsls	r1, r3, #8
24007f28:	687b      	ldr	r3, [r7, #4]
24007f2a:	430b      	orrs	r3, r1
24007f2c:	4313      	orrs	r3, r2
24007f2e:	4a05      	ldr	r2, [pc, #20]	; (24007f44 <FLASH_Erase_Sector+0x78>)
24007f30:	f043 0384 	orr.w	r3, r3, #132	; 0x84
24007f34:	f8c2 310c 	str.w	r3, [r2, #268]	; 0x10c
    FLASH->CR2 &= ~(FLASH_CR_SNB);

    FLASH->CR2 |= (FLASH_CR_SER | (Sector << FLASH_CR_SNB_Pos) | FLASH_CR_START);
#endif /* FLASH_CR_PSIZE */
  }
}
24007f38:	bf00      	nop
24007f3a:	3714      	adds	r7, #20
24007f3c:	46bd      	mov	sp, r7
24007f3e:	f85d 7b04 	ldr.w	r7, [sp], #4
24007f42:	4770      	bx	lr
24007f44:	52002000 	.word	0x52002000

24007f48 <FLASH_OB_EnableWRP>:
  *            @arg FLASH_BANK_BOTH: enable WRP on both bank1 and bank2 specified sectors
  *
  * @retval HAL FLASH State
  */
static void FLASH_OB_EnableWRP(uint32_t WRPSector, uint32_t Banks)
{
24007f48:	b480      	push	{r7}
24007f4a:	b083      	sub	sp, #12
24007f4c:	af00      	add	r7, sp, #0
24007f4e:	6078      	str	r0, [r7, #4]
24007f50:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_OB_WRP_SECTOR(WRPSector));
  assert_param(IS_FLASH_BANK(Banks));

  if((Banks & FLASH_BANK_1) == FLASH_BANK_1)
24007f52:	683b      	ldr	r3, [r7, #0]
24007f54:	f003 0301 	and.w	r3, r3, #1
24007f58:	2b00      	cmp	r3, #0
24007f5a:	d007      	beq.n	24007f6c <FLASH_OB_EnableWRP+0x24>
  {
    /* Enable Write Protection for bank 1 */
    FLASH->WPSN_PRG1 &= (~(WRPSector & FLASH_WPSN_WRPSN));
24007f5c:	4b0e      	ldr	r3, [pc, #56]	; (24007f98 <FLASH_OB_EnableWRP+0x50>)
24007f5e:	6bda      	ldr	r2, [r3, #60]	; 0x3c
24007f60:	687b      	ldr	r3, [r7, #4]
24007f62:	b2db      	uxtb	r3, r3
24007f64:	43db      	mvns	r3, r3
24007f66:	490c      	ldr	r1, [pc, #48]	; (24007f98 <FLASH_OB_EnableWRP+0x50>)
24007f68:	4013      	ands	r3, r2
24007f6a:	63cb      	str	r3, [r1, #60]	; 0x3c
  }

  if((Banks & FLASH_BANK_2) == FLASH_BANK_2)
24007f6c:	683b      	ldr	r3, [r7, #0]
24007f6e:	f003 0302 	and.w	r3, r3, #2
24007f72:	2b00      	cmp	r3, #0
24007f74:	d009      	beq.n	24007f8a <FLASH_OB_EnableWRP+0x42>
  {
    /* Enable Write Protection for bank 2 */
    FLASH->WPSN_PRG2 &= (~(WRPSector & FLASH_WPSN_WRPSN));
24007f76:	4b08      	ldr	r3, [pc, #32]	; (24007f98 <FLASH_OB_EnableWRP+0x50>)
24007f78:	f8d3 213c 	ldr.w	r2, [r3, #316]	; 0x13c
24007f7c:	687b      	ldr	r3, [r7, #4]
24007f7e:	b2db      	uxtb	r3, r3
24007f80:	43db      	mvns	r3, r3
24007f82:	4905      	ldr	r1, [pc, #20]	; (24007f98 <FLASH_OB_EnableWRP+0x50>)
24007f84:	4013      	ands	r3, r2
24007f86:	f8c1 313c 	str.w	r3, [r1, #316]	; 0x13c
  }
}
24007f8a:	bf00      	nop
24007f8c:	370c      	adds	r7, #12
24007f8e:	46bd      	mov	sp, r7
24007f90:	f85d 7b04 	ldr.w	r7, [sp], #4
24007f94:	4770      	bx	lr
24007f96:	bf00      	nop
24007f98:	52002000 	.word	0x52002000

24007f9c <FLASH_OB_DisableWRP>:
  *            @arg FLASH_BANK_BOTH: disable WRP on both bank1 and bank2 specified sectors
  *
  * @retval HAL FLASH State
  */
static void FLASH_OB_DisableWRP(uint32_t WRPSector, uint32_t Banks)
{
24007f9c:	b480      	push	{r7}
24007f9e:	b083      	sub	sp, #12
24007fa0:	af00      	add	r7, sp, #0
24007fa2:	6078      	str	r0, [r7, #4]
24007fa4:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_OB_WRP_SECTOR(WRPSector));
  assert_param(IS_FLASH_BANK(Banks));

  if((Banks & FLASH_BANK_1) == FLASH_BANK_1)
24007fa6:	683b      	ldr	r3, [r7, #0]
24007fa8:	f003 0301 	and.w	r3, r3, #1
24007fac:	2b00      	cmp	r3, #0
24007fae:	d006      	beq.n	24007fbe <FLASH_OB_DisableWRP+0x22>
  {
    /* Disable Write Protection for bank 1 */
    FLASH->WPSN_PRG1 |= (WRPSector & FLASH_WPSN_WRPSN);
24007fb0:	4b0d      	ldr	r3, [pc, #52]	; (24007fe8 <FLASH_OB_DisableWRP+0x4c>)
24007fb2:	6bda      	ldr	r2, [r3, #60]	; 0x3c
24007fb4:	687b      	ldr	r3, [r7, #4]
24007fb6:	b2db      	uxtb	r3, r3
24007fb8:	490b      	ldr	r1, [pc, #44]	; (24007fe8 <FLASH_OB_DisableWRP+0x4c>)
24007fba:	4313      	orrs	r3, r2
24007fbc:	63cb      	str	r3, [r1, #60]	; 0x3c
  }

  if((Banks & FLASH_BANK_2) == FLASH_BANK_2)
24007fbe:	683b      	ldr	r3, [r7, #0]
24007fc0:	f003 0302 	and.w	r3, r3, #2
24007fc4:	2b00      	cmp	r3, #0
24007fc6:	d008      	beq.n	24007fda <FLASH_OB_DisableWRP+0x3e>
  {
    /* Disable Write Protection for bank 2 */
    FLASH->WPSN_PRG2 |= (WRPSector & FLASH_WPSN_WRPSN);
24007fc8:	4b07      	ldr	r3, [pc, #28]	; (24007fe8 <FLASH_OB_DisableWRP+0x4c>)
24007fca:	f8d3 213c 	ldr.w	r2, [r3, #316]	; 0x13c
24007fce:	687b      	ldr	r3, [r7, #4]
24007fd0:	b2db      	uxtb	r3, r3
24007fd2:	4905      	ldr	r1, [pc, #20]	; (24007fe8 <FLASH_OB_DisableWRP+0x4c>)
24007fd4:	4313      	orrs	r3, r2
24007fd6:	f8c1 313c 	str.w	r3, [r1, #316]	; 0x13c
  }
}
24007fda:	bf00      	nop
24007fdc:	370c      	adds	r7, #12
24007fde:	46bd      	mov	sp, r7
24007fe0:	f85d 7b04 	ldr.w	r7, [sp], #4
24007fe4:	4770      	bx	lr
24007fe6:	bf00      	nop
24007fe8:	52002000 	.word	0x52002000

24007fec <FLASH_OB_GetWRP>:
  *            @arg FLASH_BANK_BOTH: note allowed in this functions
  *
  * @retval HAL FLASH State
  */
static void FLASH_OB_GetWRP(uint32_t *WRPState, uint32_t *WRPSector, uint32_t Bank)
{
24007fec:	b480      	push	{r7}
24007fee:	b087      	sub	sp, #28
24007ff0:	af00      	add	r7, sp, #0
24007ff2:	60f8      	str	r0, [r7, #12]
24007ff4:	60b9      	str	r1, [r7, #8]
24007ff6:	607a      	str	r2, [r7, #4]
  uint32_t regvalue = 0U;
24007ff8:	2300      	movs	r3, #0
24007ffa:	617b      	str	r3, [r7, #20]

  if((Bank & FLASH_BANK_BOTH) == FLASH_BANK_1)
24007ffc:	687b      	ldr	r3, [r7, #4]
24007ffe:	f003 0303 	and.w	r3, r3, #3
24008002:	2b01      	cmp	r3, #1
24008004:	d102      	bne.n	2400800c <FLASH_OB_GetWRP+0x20>
  {
    regvalue = FLASH->WPSN_CUR1;
24008006:	4b11      	ldr	r3, [pc, #68]	; (2400804c <FLASH_OB_GetWRP+0x60>)
24008008:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400800a:	617b      	str	r3, [r7, #20]
  }

  if((Bank & FLASH_BANK_BOTH) == FLASH_BANK_2)
2400800c:	687b      	ldr	r3, [r7, #4]
2400800e:	f003 0303 	and.w	r3, r3, #3
24008012:	2b02      	cmp	r3, #2
24008014:	d103      	bne.n	2400801e <FLASH_OB_GetWRP+0x32>
  {
    regvalue = FLASH->WPSN_CUR2;
24008016:	4b0d      	ldr	r3, [pc, #52]	; (2400804c <FLASH_OB_GetWRP+0x60>)
24008018:	f8d3 3138 	ldr.w	r3, [r3, #312]	; 0x138
2400801c:	617b      	str	r3, [r7, #20]
  }

  (*WRPSector) = (~regvalue) & FLASH_WPSN_WRPSN;
2400801e:	697b      	ldr	r3, [r7, #20]
24008020:	43db      	mvns	r3, r3
24008022:	b2da      	uxtb	r2, r3
24008024:	68bb      	ldr	r3, [r7, #8]
24008026:	601a      	str	r2, [r3, #0]

  if(*WRPSector == 0U)
24008028:	68bb      	ldr	r3, [r7, #8]
2400802a:	681b      	ldr	r3, [r3, #0]
2400802c:	2b00      	cmp	r3, #0
2400802e:	d103      	bne.n	24008038 <FLASH_OB_GetWRP+0x4c>
  {
    (*WRPState) = OB_WRPSTATE_DISABLE;
24008030:	68fb      	ldr	r3, [r7, #12]
24008032:	2200      	movs	r2, #0
24008034:	601a      	str	r2, [r3, #0]
  }
  else
  {
    (*WRPState) = OB_WRPSTATE_ENABLE;
  }
}
24008036:	e002      	b.n	2400803e <FLASH_OB_GetWRP+0x52>
    (*WRPState) = OB_WRPSTATE_ENABLE;
24008038:	68fb      	ldr	r3, [r7, #12]
2400803a:	2201      	movs	r2, #1
2400803c:	601a      	str	r2, [r3, #0]
}
2400803e:	bf00      	nop
24008040:	371c      	adds	r7, #28
24008042:	46bd      	mov	sp, r7
24008044:	f85d 7b04 	ldr.w	r7, [sp], #4
24008048:	4770      	bx	lr
2400804a:	bf00      	nop
2400804c:	52002000 	.word	0x52002000

24008050 <FLASH_OB_RDPConfig>:
  *            @arg OB_RDP_LEVEL_2: Full chip protection
  *
  * @retval HAL status
  */
static void FLASH_OB_RDPConfig(uint32_t RDPLevel)
{
24008050:	b480      	push	{r7}
24008052:	b083      	sub	sp, #12
24008054:	af00      	add	r7, sp, #0
24008056:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_OB_RDP_LEVEL(RDPLevel));

  /* Configure the RDP level in the option bytes register */
  MODIFY_REG(FLASH->OPTSR_PRG, FLASH_OPTSR_RDP, RDPLevel);
24008058:	4b06      	ldr	r3, [pc, #24]	; (24008074 <FLASH_OB_RDPConfig+0x24>)
2400805a:	6a1b      	ldr	r3, [r3, #32]
2400805c:	f423 427f 	bic.w	r2, r3, #65280	; 0xff00
24008060:	4904      	ldr	r1, [pc, #16]	; (24008074 <FLASH_OB_RDPConfig+0x24>)
24008062:	687b      	ldr	r3, [r7, #4]
24008064:	4313      	orrs	r3, r2
24008066:	620b      	str	r3, [r1, #32]
}
24008068:	bf00      	nop
2400806a:	370c      	adds	r7, #12
2400806c:	46bd      	mov	sp, r7
2400806e:	f85d 7b04 	ldr.w	r7, [sp], #4
24008072:	4770      	bx	lr
24008074:	52002000 	.word	0x52002000

24008078 <FLASH_OB_GetRDP>:
  *            @arg OB_RDP_LEVEL_0: No protection
  *            @arg OB_RDP_LEVEL_1: Read protection of the memory
  *            @arg OB_RDP_LEVEL_2: Full chip protection
  */
static uint32_t FLASH_OB_GetRDP(void)
{
24008078:	b480      	push	{r7}
2400807a:	b083      	sub	sp, #12
2400807c:	af00      	add	r7, sp, #0
  uint32_t rdp_level = READ_BIT(FLASH->OPTSR_CUR, FLASH_OPTSR_RDP);
2400807e:	4b0b      	ldr	r3, [pc, #44]	; (240080ac <FLASH_OB_GetRDP+0x34>)
24008080:	69db      	ldr	r3, [r3, #28]
24008082:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
24008086:	607b      	str	r3, [r7, #4]
  
  if ((rdp_level != OB_RDP_LEVEL_0) && (rdp_level != OB_RDP_LEVEL_2))
24008088:	687b      	ldr	r3, [r7, #4]
2400808a:	f5b3 4f2a 	cmp.w	r3, #43520	; 0xaa00
2400808e:	d006      	beq.n	2400809e <FLASH_OB_GetRDP+0x26>
24008090:	687b      	ldr	r3, [r7, #4]
24008092:	f5b3 4f4c 	cmp.w	r3, #52224	; 0xcc00
24008096:	d002      	beq.n	2400809e <FLASH_OB_GetRDP+0x26>
  {
    return (OB_RDP_LEVEL_1);
24008098:	f44f 43aa 	mov.w	r3, #21760	; 0x5500
2400809c:	e000      	b.n	240080a0 <FLASH_OB_GetRDP+0x28>
  }
  else
  {
    return rdp_level;
2400809e:	687b      	ldr	r3, [r7, #4]
  }
}
240080a0:	4618      	mov	r0, r3
240080a2:	370c      	adds	r7, #12
240080a4:	46bd      	mov	sp, r7
240080a6:	f85d 7b04 	ldr.w	r7, [sp], #4
240080aa:	4770      	bx	lr
240080ac:	52002000 	.word	0x52002000

240080b0 <FLASH_OB_UserConfig>:
  *
  * @retval HAL status
  */
#endif /*DUAL_CORE*/
static void FLASH_OB_UserConfig(uint32_t UserType, uint32_t UserConfig)
{
240080b0:	b480      	push	{r7}
240080b2:	b085      	sub	sp, #20
240080b4:	af00      	add	r7, sp, #0
240080b6:	6078      	str	r0, [r7, #4]
240080b8:	6039      	str	r1, [r7, #0]
  uint32_t optr_reg_val = 0;
240080ba:	2300      	movs	r3, #0
240080bc:	60fb      	str	r3, [r7, #12]
  uint32_t optr_reg_mask = 0;
240080be:	2300      	movs	r3, #0
240080c0:	60bb      	str	r3, [r7, #8]

  /* Check the parameters */
  assert_param(IS_OB_USER_TYPE(UserType));

  if((UserType & OB_USER_IWDG1_SW) != 0U)
240080c2:	687b      	ldr	r3, [r7, #4]
240080c4:	f003 0301 	and.w	r3, r3, #1
240080c8:	2b00      	cmp	r3, #0
240080ca:	d009      	beq.n	240080e0 <FLASH_OB_UserConfig+0x30>
  {
    /* IWDG_HW option byte should be modified */
    assert_param(IS_OB_IWDG1_SOURCE(UserConfig & FLASH_OPTSR_IWDG1_SW));

    /* Set value and mask for IWDG_HW option byte */
    optr_reg_val |= (UserConfig & FLASH_OPTSR_IWDG1_SW);
240080cc:	683b      	ldr	r3, [r7, #0]
240080ce:	f003 0310 	and.w	r3, r3, #16
240080d2:	68fa      	ldr	r2, [r7, #12]
240080d4:	4313      	orrs	r3, r2
240080d6:	60fb      	str	r3, [r7, #12]
    optr_reg_mask |= FLASH_OPTSR_IWDG1_SW;
240080d8:	68bb      	ldr	r3, [r7, #8]
240080da:	f043 0310 	orr.w	r3, r3, #16
240080de:	60bb      	str	r3, [r7, #8]
    /* Set value and mask for IWDG2_SW option byte */
    optr_reg_val |= (UserConfig & FLASH_OPTSR_IWDG2_SW);
    optr_reg_mask |= FLASH_OPTSR_IWDG2_SW;
  }
#endif /*DUAL_CORE*/
  if((UserType & OB_USER_NRST_STOP_D1) != 0U)
240080e0:	687b      	ldr	r3, [r7, #4]
240080e2:	f003 0302 	and.w	r3, r3, #2
240080e6:	2b00      	cmp	r3, #0
240080e8:	d009      	beq.n	240080fe <FLASH_OB_UserConfig+0x4e>
  {
    /* NRST_STOP option byte should be modified */
    assert_param(IS_OB_STOP_D1_RESET(UserConfig & FLASH_OPTSR_NRST_STOP_D1));

    /* Set value and mask for NRST_STOP option byte */
    optr_reg_val |= (UserConfig & FLASH_OPTSR_NRST_STOP_D1);
240080ea:	683b      	ldr	r3, [r7, #0]
240080ec:	f003 0340 	and.w	r3, r3, #64	; 0x40
240080f0:	68fa      	ldr	r2, [r7, #12]
240080f2:	4313      	orrs	r3, r2
240080f4:	60fb      	str	r3, [r7, #12]
    optr_reg_mask |= FLASH_OPTSR_NRST_STOP_D1;
240080f6:	68bb      	ldr	r3, [r7, #8]
240080f8:	f043 0340 	orr.w	r3, r3, #64	; 0x40
240080fc:	60bb      	str	r3, [r7, #8]
  }

  if((UserType & OB_USER_NRST_STDBY_D1) != 0U)
240080fe:	687b      	ldr	r3, [r7, #4]
24008100:	f003 0304 	and.w	r3, r3, #4
24008104:	2b00      	cmp	r3, #0
24008106:	d009      	beq.n	2400811c <FLASH_OB_UserConfig+0x6c>
  {
    /* NRST_STDBY option byte should be modified */
    assert_param(IS_OB_STDBY_D1_RESET(UserConfig & FLASH_OPTSR_NRST_STBY_D1));

    /* Set value and mask for NRST_STDBY option byte */
    optr_reg_val |= (UserConfig & FLASH_OPTSR_NRST_STBY_D1);
24008108:	683b      	ldr	r3, [r7, #0]
2400810a:	f003 0380 	and.w	r3, r3, #128	; 0x80
2400810e:	68fa      	ldr	r2, [r7, #12]
24008110:	4313      	orrs	r3, r2
24008112:	60fb      	str	r3, [r7, #12]
    optr_reg_mask |= FLASH_OPTSR_NRST_STBY_D1;
24008114:	68bb      	ldr	r3, [r7, #8]
24008116:	f043 0380 	orr.w	r3, r3, #128	; 0x80
2400811a:	60bb      	str	r3, [r7, #8]
  }

  if((UserType & OB_USER_IWDG_STOP) != 0U)
2400811c:	687b      	ldr	r3, [r7, #4]
2400811e:	f003 0308 	and.w	r3, r3, #8
24008122:	2b00      	cmp	r3, #0
24008124:	d009      	beq.n	2400813a <FLASH_OB_UserConfig+0x8a>
  {
    /* IWDG_STOP option byte should be modified */
    assert_param(IS_OB_USER_IWDG_STOP(UserConfig & FLASH_OPTSR_FZ_IWDG_STOP));

    /* Set value and mask for IWDG_STOP option byte */
    optr_reg_val |= (UserConfig & FLASH_OPTSR_FZ_IWDG_STOP);
24008126:	683b      	ldr	r3, [r7, #0]
24008128:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
2400812c:	68fa      	ldr	r2, [r7, #12]
2400812e:	4313      	orrs	r3, r2
24008130:	60fb      	str	r3, [r7, #12]
    optr_reg_mask |= FLASH_OPTSR_FZ_IWDG_STOP;
24008132:	68bb      	ldr	r3, [r7, #8]
24008134:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
24008138:	60bb      	str	r3, [r7, #8]
  }

  if((UserType & OB_USER_IWDG_STDBY) != 0U)
2400813a:	687b      	ldr	r3, [r7, #4]
2400813c:	f003 0310 	and.w	r3, r3, #16
24008140:	2b00      	cmp	r3, #0
24008142:	d009      	beq.n	24008158 <FLASH_OB_UserConfig+0xa8>
  {
    /* IWDG_STDBY option byte should be modified */
    assert_param(IS_OB_USER_IWDG_STDBY(UserConfig & FLASH_OPTSR_FZ_IWDG_SDBY));

    /* Set value and mask for IWDG_STDBY option byte */
    optr_reg_val |= (UserConfig & FLASH_OPTSR_FZ_IWDG_SDBY);
24008144:	683b      	ldr	r3, [r7, #0]
24008146:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
2400814a:	68fa      	ldr	r2, [r7, #12]
2400814c:	4313      	orrs	r3, r2
2400814e:	60fb      	str	r3, [r7, #12]
    optr_reg_mask |= FLASH_OPTSR_FZ_IWDG_SDBY;
24008150:	68bb      	ldr	r3, [r7, #8]
24008152:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
24008156:	60bb      	str	r3, [r7, #8]
  }

  if((UserType & OB_USER_ST_RAM_SIZE) != 0U)
24008158:	687b      	ldr	r3, [r7, #4]
2400815a:	f003 0320 	and.w	r3, r3, #32
2400815e:	2b00      	cmp	r3, #0
24008160:	d009      	beq.n	24008176 <FLASH_OB_UserConfig+0xc6>
  {
    /* ST_RAM_SIZE option byte should be modified */
    assert_param(IS_OB_USER_ST_RAM_SIZE(UserConfig & FLASH_OPTSR_ST_RAM_SIZE));

    /* Set value and mask for ST_RAM_SIZE option byte */
    optr_reg_val |= (UserConfig & FLASH_OPTSR_ST_RAM_SIZE);
24008162:	683b      	ldr	r3, [r7, #0]
24008164:	f403 13c0 	and.w	r3, r3, #1572864	; 0x180000
24008168:	68fa      	ldr	r2, [r7, #12]
2400816a:	4313      	orrs	r3, r2
2400816c:	60fb      	str	r3, [r7, #12]
    optr_reg_mask |= FLASH_OPTSR_ST_RAM_SIZE;
2400816e:	68bb      	ldr	r3, [r7, #8]
24008170:	f443 13c0 	orr.w	r3, r3, #1572864	; 0x180000
24008174:	60bb      	str	r3, [r7, #8]
  }

  if((UserType & OB_USER_SECURITY) != 0U)
24008176:	687b      	ldr	r3, [r7, #4]
24008178:	f003 0340 	and.w	r3, r3, #64	; 0x40
2400817c:	2b00      	cmp	r3, #0
2400817e:	d009      	beq.n	24008194 <FLASH_OB_UserConfig+0xe4>
  {
    /* SECURITY option byte should be modified */
    assert_param(IS_OB_USER_SECURITY(UserConfig & FLASH_OPTSR_SECURITY));

    /* Set value and mask for SECURITY option byte */
    optr_reg_val |= (UserConfig & FLASH_OPTSR_SECURITY);
24008180:	683b      	ldr	r3, [r7, #0]
24008182:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
24008186:	68fa      	ldr	r2, [r7, #12]
24008188:	4313      	orrs	r3, r2
2400818a:	60fb      	str	r3, [r7, #12]
    optr_reg_mask |= FLASH_OPTSR_SECURITY;
2400818c:	68bb      	ldr	r3, [r7, #8]
2400818e:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
24008192:	60bb      	str	r3, [r7, #8]
    /* Set value and mask for NRST_STDBY option byte */
    optr_reg_val |= (UserConfig & FLASH_OPTSR_NRST_STBY_D2);
    optr_reg_mask |= FLASH_OPTSR_NRST_STBY_D2;
  }
#endif /* DUAL_CORE */
  if((UserType & OB_USER_SWAP_BANK) != 0U)
24008194:	687b      	ldr	r3, [r7, #4]
24008196:	f403 7380 	and.w	r3, r3, #256	; 0x100
2400819a:	2b00      	cmp	r3, #0
2400819c:	d009      	beq.n	240081b2 <FLASH_OB_UserConfig+0x102>
  {
    /* SWAP_BANK_OPT option byte should be modified */
    assert_param(IS_OB_USER_SWAP_BANK(UserConfig & FLASH_OPTSR_SWAP_BANK_OPT));

    /* Set value and mask for SWAP_BANK_OPT option byte */
    optr_reg_val |= (UserConfig & FLASH_OPTSR_SWAP_BANK_OPT);
2400819e:	683b      	ldr	r3, [r7, #0]
240081a0:	f003 4300 	and.w	r3, r3, #2147483648	; 0x80000000
240081a4:	68fa      	ldr	r2, [r7, #12]
240081a6:	4313      	orrs	r3, r2
240081a8:	60fb      	str	r3, [r7, #12]
    optr_reg_mask |= FLASH_OPTSR_SWAP_BANK_OPT;
240081aa:	68bb      	ldr	r3, [r7, #8]
240081ac:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
240081b0:	60bb      	str	r3, [r7, #8]
  }

  if((UserType & OB_USER_IOHSLV) != 0U)
240081b2:	687b      	ldr	r3, [r7, #4]
240081b4:	f003 0380 	and.w	r3, r3, #128	; 0x80
240081b8:	2b00      	cmp	r3, #0
240081ba:	d009      	beq.n	240081d0 <FLASH_OB_UserConfig+0x120>
  {
    /* IOHSLV_OPT option byte should be modified */
    assert_param(IS_OB_USER_IOHSLV(UserConfig & FLASH_OPTSR_IO_HSLV));

    /* Set value and mask for IOHSLV_OPT option byte */
    optr_reg_val |= (UserConfig & FLASH_OPTSR_IO_HSLV);
240081bc:	683b      	ldr	r3, [r7, #0]
240081be:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
240081c2:	68fa      	ldr	r2, [r7, #12]
240081c4:	4313      	orrs	r3, r2
240081c6:	60fb      	str	r3, [r7, #12]
    optr_reg_mask |= FLASH_OPTSR_IO_HSLV;
240081c8:	68bb      	ldr	r3, [r7, #8]
240081ca:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
240081ce:	60bb      	str	r3, [r7, #8]
    optr_reg_mask |= FLASH_OPTSR_VDDMMC_HSLV;
  }
#endif /* FLASH_OPTSR_VDDMMC_HSLV */

  /* Configure the option bytes register */
  MODIFY_REG(FLASH->OPTSR_PRG, optr_reg_mask, optr_reg_val);
240081d0:	4b07      	ldr	r3, [pc, #28]	; (240081f0 <FLASH_OB_UserConfig+0x140>)
240081d2:	6a1a      	ldr	r2, [r3, #32]
240081d4:	68bb      	ldr	r3, [r7, #8]
240081d6:	43db      	mvns	r3, r3
240081d8:	401a      	ands	r2, r3
240081da:	4905      	ldr	r1, [pc, #20]	; (240081f0 <FLASH_OB_UserConfig+0x140>)
240081dc:	68fb      	ldr	r3, [r7, #12]
240081de:	4313      	orrs	r3, r2
240081e0:	620b      	str	r3, [r1, #32]
}
240081e2:	bf00      	nop
240081e4:	3714      	adds	r7, #20
240081e6:	46bd      	mov	sp, r7
240081e8:	f85d 7b04 	ldr.w	r7, [sp], #4
240081ec:	4770      	bx	lr
240081ee:	bf00      	nop
240081f0:	52002000 	.word	0x52002000

240081f4 <FLASH_OB_GetUser>:
  *         FZ_IWDG_STOP(Bit 17), FZ_IWDG_SDBY(Bit 18), ST_RAM_SIZE(Bit[19:20]),
  *         SECURITY(Bit 21), IO_HSLV (Bit 29) and SWAP_BANK_OPT(Bit 31).
  */
#endif /*DUAL_CORE*/
static uint32_t FLASH_OB_GetUser(void)
{
240081f4:	b480      	push	{r7}
240081f6:	b083      	sub	sp, #12
240081f8:	af00      	add	r7, sp, #0
  uint32_t userConfig = READ_REG(FLASH->OPTSR_CUR);
240081fa:	4b07      	ldr	r3, [pc, #28]	; (24008218 <FLASH_OB_GetUser+0x24>)
240081fc:	69db      	ldr	r3, [r3, #28]
240081fe:	607b      	str	r3, [r7, #4]
  userConfig &= (~(FLASH_OPTSR_BOR_LEV | FLASH_OPTSR_RDP));
24008200:	687a      	ldr	r2, [r7, #4]
24008202:	4b06      	ldr	r3, [pc, #24]	; (2400821c <FLASH_OB_GetUser+0x28>)
24008204:	4013      	ands	r3, r2
24008206:	607b      	str	r3, [r7, #4]

  return userConfig;
24008208:	687b      	ldr	r3, [r7, #4]
}
2400820a:	4618      	mov	r0, r3
2400820c:	370c      	adds	r7, #12
2400820e:	46bd      	mov	sp, r7
24008210:	f85d 7b04 	ldr.w	r7, [sp], #4
24008214:	4770      	bx	lr
24008216:	bf00      	nop
24008218:	52002000 	.word	0x52002000
2400821c:	ffff00f3 	.word	0xffff00f3

24008220 <FLASH_OB_PCROPConfig>:
  *            @arg FLASH_BANK_BOTH: PCROP on specified bank1 and bank2 area (same config will be applied on both banks)
  *
  * @retval None
  */
static void FLASH_OB_PCROPConfig(uint32_t PCROPConfig, uint32_t PCROPStartAddr, uint32_t PCROPEndAddr, uint32_t Banks)
{
24008220:	b480      	push	{r7}
24008222:	b085      	sub	sp, #20
24008224:	af00      	add	r7, sp, #0
24008226:	60f8      	str	r0, [r7, #12]
24008228:	60b9      	str	r1, [r7, #8]
2400822a:	607a      	str	r2, [r7, #4]
2400822c:	603b      	str	r3, [r7, #0]
  /* Check the parameters */
  assert_param(IS_FLASH_BANK(Banks));
  assert_param(IS_OB_PCROP_RDP(PCROPConfig));

  if((Banks & FLASH_BANK_1) == FLASH_BANK_1)
2400822e:	683b      	ldr	r3, [r7, #0]
24008230:	f003 0301 	and.w	r3, r3, #1
24008234:	2b00      	cmp	r3, #0
24008236:	d00d      	beq.n	24008254 <FLASH_OB_PCROPConfig+0x34>
  {
    assert_param(IS_FLASH_PROGRAM_ADDRESS_BANK1(PCROPStartAddr));
    assert_param(IS_FLASH_PROGRAM_ADDRESS_BANK1(PCROPEndAddr));

    /* Configure the Proprietary code readout protection */
    FLASH->PRAR_PRG1 = ((PCROPStartAddr - FLASH_BANK1_BASE) >> 8)                                 | \
24008238:	68bb      	ldr	r3, [r7, #8]
2400823a:	f103 4378 	add.w	r3, r3, #4160749568	; 0xf8000000
2400823e:	0a1a      	lsrs	r2, r3, #8
                       (((PCROPEndAddr - FLASH_BANK1_BASE) >> 8) << FLASH_PRAR_PROT_AREA_END_Pos) | \
24008240:	687b      	ldr	r3, [r7, #4]
24008242:	f103 4378 	add.w	r3, r3, #4160749568	; 0xf8000000
24008246:	0a1b      	lsrs	r3, r3, #8
24008248:	041b      	lsls	r3, r3, #16
    FLASH->PRAR_PRG1 = ((PCROPStartAddr - FLASH_BANK1_BASE) >> 8)                                 | \
2400824a:	431a      	orrs	r2, r3
2400824c:	490e      	ldr	r1, [pc, #56]	; (24008288 <FLASH_OB_PCROPConfig+0x68>)
                       (((PCROPEndAddr - FLASH_BANK1_BASE) >> 8) << FLASH_PRAR_PROT_AREA_END_Pos) | \
2400824e:	68fb      	ldr	r3, [r7, #12]
24008250:	4313      	orrs	r3, r2
    FLASH->PRAR_PRG1 = ((PCROPStartAddr - FLASH_BANK1_BASE) >> 8)                                 | \
24008252:	62cb      	str	r3, [r1, #44]	; 0x2c
                       PCROPConfig;
  }

  if((Banks & FLASH_BANK_2) == FLASH_BANK_2)
24008254:	683b      	ldr	r3, [r7, #0]
24008256:	f003 0302 	and.w	r3, r3, #2
2400825a:	2b00      	cmp	r3, #0
2400825c:	d00e      	beq.n	2400827c <FLASH_OB_PCROPConfig+0x5c>
  {
    assert_param(IS_FLASH_PROGRAM_ADDRESS_BANK2(PCROPStartAddr));
    assert_param(IS_FLASH_PROGRAM_ADDRESS_BANK2(PCROPEndAddr));

    /* Configure the Proprietary code readout protection */
    FLASH->PRAR_PRG2 = ((PCROPStartAddr - FLASH_BANK2_BASE) >> 8)                                 | \
2400825e:	68bb      	ldr	r3, [r7, #8]
24008260:	f1a3 6301 	sub.w	r3, r3, #135266304	; 0x8100000
24008264:	0a1a      	lsrs	r2, r3, #8
                       (((PCROPEndAddr - FLASH_BANK2_BASE) >> 8) << FLASH_PRAR_PROT_AREA_END_Pos) | \
24008266:	687b      	ldr	r3, [r7, #4]
24008268:	f1a3 6301 	sub.w	r3, r3, #135266304	; 0x8100000
2400826c:	0a1b      	lsrs	r3, r3, #8
2400826e:	041b      	lsls	r3, r3, #16
    FLASH->PRAR_PRG2 = ((PCROPStartAddr - FLASH_BANK2_BASE) >> 8)                                 | \
24008270:	431a      	orrs	r2, r3
24008272:	4905      	ldr	r1, [pc, #20]	; (24008288 <FLASH_OB_PCROPConfig+0x68>)
                       (((PCROPEndAddr - FLASH_BANK2_BASE) >> 8) << FLASH_PRAR_PROT_AREA_END_Pos) | \
24008274:	68fb      	ldr	r3, [r7, #12]
24008276:	4313      	orrs	r3, r2
    FLASH->PRAR_PRG2 = ((PCROPStartAddr - FLASH_BANK2_BASE) >> 8)                                 | \
24008278:	f8c1 312c 	str.w	r3, [r1, #300]	; 0x12c
                       PCROPConfig;
  }
}
2400827c:	bf00      	nop
2400827e:	3714      	adds	r7, #20
24008280:	46bd      	mov	sp, r7
24008282:	f85d 7b04 	ldr.w	r7, [sp], #4
24008286:	4770      	bx	lr
24008288:	52002000 	.word	0x52002000

2400828c <FLASH_OB_GetPCROP>:
  *            @arg FLASH_BANK_BOTH: is  not allowed here
  *
  * @retval None
  */
static void FLASH_OB_GetPCROP(uint32_t *PCROPConfig, uint32_t *PCROPStartAddr, uint32_t *PCROPEndAddr, uint32_t Bank)
{
2400828c:	b480      	push	{r7}
2400828e:	b087      	sub	sp, #28
24008290:	af00      	add	r7, sp, #0
24008292:	60f8      	str	r0, [r7, #12]
24008294:	60b9      	str	r1, [r7, #8]
24008296:	607a      	str	r2, [r7, #4]
24008298:	603b      	str	r3, [r7, #0]
  uint32_t regvalue = 0;
2400829a:	2300      	movs	r3, #0
2400829c:	617b      	str	r3, [r7, #20]
  uint32_t bankBase = 0;
2400829e:	2300      	movs	r3, #0
240082a0:	613b      	str	r3, [r7, #16]

  if((Bank & FLASH_BANK_BOTH) == FLASH_BANK_1)
240082a2:	683b      	ldr	r3, [r7, #0]
240082a4:	f003 0303 	and.w	r3, r3, #3
240082a8:	2b01      	cmp	r3, #1
240082aa:	d105      	bne.n	240082b8 <FLASH_OB_GetPCROP+0x2c>
  {
    regvalue = FLASH->PRAR_CUR1;
240082ac:	4b18      	ldr	r3, [pc, #96]	; (24008310 <FLASH_OB_GetPCROP+0x84>)
240082ae:	6a9b      	ldr	r3, [r3, #40]	; 0x28
240082b0:	617b      	str	r3, [r7, #20]
    bankBase = FLASH_BANK1_BASE;
240082b2:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
240082b6:	613b      	str	r3, [r7, #16]
  }

  if((Bank & FLASH_BANK_BOTH) == FLASH_BANK_2)
240082b8:	683b      	ldr	r3, [r7, #0]
240082ba:	f003 0303 	and.w	r3, r3, #3
240082be:	2b02      	cmp	r3, #2
240082c0:	d106      	bne.n	240082d0 <FLASH_OB_GetPCROP+0x44>
  {
    regvalue = FLASH->PRAR_CUR2;
240082c2:	4b13      	ldr	r3, [pc, #76]	; (24008310 <FLASH_OB_GetPCROP+0x84>)
240082c4:	f8d3 3128 	ldr.w	r3, [r3, #296]	; 0x128
240082c8:	617b      	str	r3, [r7, #20]
    bankBase = FLASH_BANK2_BASE;
240082ca:	f04f 6301 	mov.w	r3, #135266304	; 0x8100000
240082ce:	613b      	str	r3, [r7, #16]
  }

  (*PCROPConfig) =  (regvalue & FLASH_PRAR_DMEP);
240082d0:	697b      	ldr	r3, [r7, #20]
240082d2:	f003 4200 	and.w	r2, r3, #2147483648	; 0x80000000
240082d6:	68fb      	ldr	r3, [r7, #12]
240082d8:	601a      	str	r2, [r3, #0]

  (*PCROPStartAddr) = ((regvalue & FLASH_PRAR_PROT_AREA_START) << 8) + bankBase;
240082da:	697b      	ldr	r3, [r7, #20]
240082dc:	021a      	lsls	r2, r3, #8
240082de:	4b0d      	ldr	r3, [pc, #52]	; (24008314 <FLASH_OB_GetPCROP+0x88>)
240082e0:	4013      	ands	r3, r2
240082e2:	693a      	ldr	r2, [r7, #16]
240082e4:	441a      	add	r2, r3
240082e6:	68bb      	ldr	r3, [r7, #8]
240082e8:	601a      	str	r2, [r3, #0]
  (*PCROPEndAddr) = (regvalue & FLASH_PRAR_PROT_AREA_END) >> FLASH_PRAR_PROT_AREA_END_Pos;
240082ea:	697b      	ldr	r3, [r7, #20]
240082ec:	0c1b      	lsrs	r3, r3, #16
240082ee:	f3c3 020b 	ubfx	r2, r3, #0, #12
240082f2:	687b      	ldr	r3, [r7, #4]
240082f4:	601a      	str	r2, [r3, #0]
  (*PCROPEndAddr) = ((*PCROPEndAddr) << 8) + bankBase;
240082f6:	687b      	ldr	r3, [r7, #4]
240082f8:	681b      	ldr	r3, [r3, #0]
240082fa:	021a      	lsls	r2, r3, #8
240082fc:	693b      	ldr	r3, [r7, #16]
240082fe:	441a      	add	r2, r3
24008300:	687b      	ldr	r3, [r7, #4]
24008302:	601a      	str	r2, [r3, #0]
}
24008304:	bf00      	nop
24008306:	371c      	adds	r7, #28
24008308:	46bd      	mov	sp, r7
2400830a:	f85d 7b04 	ldr.w	r7, [sp], #4
2400830e:	4770      	bx	lr
24008310:	52002000 	.word	0x52002000
24008314:	000fff00 	.word	0x000fff00

24008318 <FLASH_OB_BOR_LevelConfig>:
  *            @arg OB_BOR_LEVEL2: Reset level threshold is set to 2.4V
  *            @arg OB_BOR_LEVEL3: Reset level threshold is set to 2.7V
  * @retval None
  */
static void FLASH_OB_BOR_LevelConfig(uint32_t Level)
{
24008318:	b480      	push	{r7}
2400831a:	b083      	sub	sp, #12
2400831c:	af00      	add	r7, sp, #0
2400831e:	6078      	str	r0, [r7, #4]
  assert_param(IS_OB_BOR_LEVEL(Level));

  /* Configure BOR_LEV option byte */
  MODIFY_REG(FLASH->OPTSR_PRG, FLASH_OPTSR_BOR_LEV, Level);
24008320:	4b06      	ldr	r3, [pc, #24]	; (2400833c <FLASH_OB_BOR_LevelConfig+0x24>)
24008322:	6a1b      	ldr	r3, [r3, #32]
24008324:	f023 020c 	bic.w	r2, r3, #12
24008328:	4904      	ldr	r1, [pc, #16]	; (2400833c <FLASH_OB_BOR_LevelConfig+0x24>)
2400832a:	687b      	ldr	r3, [r7, #4]
2400832c:	4313      	orrs	r3, r2
2400832e:	620b      	str	r3, [r1, #32]
}
24008330:	bf00      	nop
24008332:	370c      	adds	r7, #12
24008334:	46bd      	mov	sp, r7
24008336:	f85d 7b04 	ldr.w	r7, [sp], #4
2400833a:	4770      	bx	lr
2400833c:	52002000 	.word	0x52002000

24008340 <FLASH_OB_GetBOR>:
  *            @arg OB_BOR_LEVEL1: Reset level threshold is set to 2.1V
  *            @arg OB_BOR_LEVEL2: Reset level threshold is set to 2.4V
  *            @arg OB_BOR_LEVEL3: Reset level threshold is set to 2.7V
  */
static uint32_t FLASH_OB_GetBOR(void)
{
24008340:	b480      	push	{r7}
24008342:	af00      	add	r7, sp, #0
  return (FLASH->OPTSR_CUR & FLASH_OPTSR_BOR_LEV);
24008344:	4b04      	ldr	r3, [pc, #16]	; (24008358 <FLASH_OB_GetBOR+0x18>)
24008346:	69db      	ldr	r3, [r3, #28]
24008348:	f003 030c 	and.w	r3, r3, #12
}
2400834c:	4618      	mov	r0, r3
2400834e:	46bd      	mov	sp, r7
24008350:	f85d 7b04 	ldr.w	r7, [sp], #4
24008354:	4770      	bx	lr
24008356:	bf00      	nop
24008358:	52002000 	.word	0x52002000

2400835c <FLASH_OB_BootAddConfig>:
  * @param  BootAddress0 Specifies the Boot Address 0
  * @param  BootAddress1 Specifies the Boot Address 1
  * @retval HAL Status
  */
static void FLASH_OB_BootAddConfig(uint32_t BootOption, uint32_t BootAddress0, uint32_t BootAddress1)
{
2400835c:	b480      	push	{r7}
2400835e:	b085      	sub	sp, #20
24008360:	af00      	add	r7, sp, #0
24008362:	60f8      	str	r0, [r7, #12]
24008364:	60b9      	str	r1, [r7, #8]
24008366:	607a      	str	r2, [r7, #4]
  /* Check the parameters */
  assert_param(IS_OB_BOOT_ADD_OPTION(BootOption));

  if((BootOption & OB_BOOT_ADD0) == OB_BOOT_ADD0)
24008368:	68fb      	ldr	r3, [r7, #12]
2400836a:	f003 0301 	and.w	r3, r3, #1
2400836e:	2b00      	cmp	r3, #0
24008370:	d008      	beq.n	24008384 <FLASH_OB_BootAddConfig+0x28>

    /* Configure CM7 BOOT ADD0 */
#if defined(DUAL_CORE)
    MODIFY_REG(FLASH->BOOT7_PRG, FLASH_BOOT7_BCM7_ADD0, (BootAddress0 >> 16));
#else /* Single Core*/
    MODIFY_REG(FLASH->BOOT_PRG, FLASH_BOOT_ADD0, (BootAddress0 >> 16));
24008372:	4b0d      	ldr	r3, [pc, #52]	; (240083a8 <FLASH_OB_BootAddConfig+0x4c>)
24008374:	6c5a      	ldr	r2, [r3, #68]	; 0x44
24008376:	4b0d      	ldr	r3, [pc, #52]	; (240083ac <FLASH_OB_BootAddConfig+0x50>)
24008378:	4013      	ands	r3, r2
2400837a:	68ba      	ldr	r2, [r7, #8]
2400837c:	0c12      	lsrs	r2, r2, #16
2400837e:	490a      	ldr	r1, [pc, #40]	; (240083a8 <FLASH_OB_BootAddConfig+0x4c>)
24008380:	4313      	orrs	r3, r2
24008382:	644b      	str	r3, [r1, #68]	; 0x44
#endif /* DUAL_CORE */
  }

  if((BootOption & OB_BOOT_ADD1) == OB_BOOT_ADD1)
24008384:	68fb      	ldr	r3, [r7, #12]
24008386:	f003 0302 	and.w	r3, r3, #2
2400838a:	2b00      	cmp	r3, #0
2400838c:	d006      	beq.n	2400839c <FLASH_OB_BootAddConfig+0x40>

    /* Configure CM7 BOOT ADD1 */
#if defined(DUAL_CORE)
    MODIFY_REG(FLASH->BOOT7_PRG, FLASH_BOOT7_BCM7_ADD1, BootAddress1);
#else /* Single Core*/
    MODIFY_REG(FLASH->BOOT_PRG, FLASH_BOOT_ADD1, BootAddress1);
2400838e:	4b06      	ldr	r3, [pc, #24]	; (240083a8 <FLASH_OB_BootAddConfig+0x4c>)
24008390:	6c5b      	ldr	r3, [r3, #68]	; 0x44
24008392:	b29a      	uxth	r2, r3
24008394:	4904      	ldr	r1, [pc, #16]	; (240083a8 <FLASH_OB_BootAddConfig+0x4c>)
24008396:	687b      	ldr	r3, [r7, #4]
24008398:	4313      	orrs	r3, r2
2400839a:	644b      	str	r3, [r1, #68]	; 0x44
#endif /* DUAL_CORE */
  }
}
2400839c:	bf00      	nop
2400839e:	3714      	adds	r7, #20
240083a0:	46bd      	mov	sp, r7
240083a2:	f85d 7b04 	ldr.w	r7, [sp], #4
240083a6:	4770      	bx	lr
240083a8:	52002000 	.word	0x52002000
240083ac:	ffff0000 	.word	0xffff0000

240083b0 <FLASH_OB_GetBootAdd>:
  * @param  BootAddress0 Specifies the Boot Address 0.
  * @param  BootAddress1 Specifies the Boot Address 1.
  * @retval HAL Status
  */
static void FLASH_OB_GetBootAdd(uint32_t *BootAddress0, uint32_t *BootAddress1)
{
240083b0:	b480      	push	{r7}
240083b2:	b085      	sub	sp, #20
240083b4:	af00      	add	r7, sp, #0
240083b6:	6078      	str	r0, [r7, #4]
240083b8:	6039      	str	r1, [r7, #0]
  regvalue = FLASH->BOOT7_CUR;

  (*BootAddress0) = (regvalue & FLASH_BOOT7_BCM7_ADD0) << 16;
  (*BootAddress1) = (regvalue & FLASH_BOOT7_BCM7_ADD1);
#else /* Single Core */
  regvalue = FLASH->BOOT_CUR;
240083ba:	4b09      	ldr	r3, [pc, #36]	; (240083e0 <FLASH_OB_GetBootAdd+0x30>)
240083bc:	6c1b      	ldr	r3, [r3, #64]	; 0x40
240083be:	60fb      	str	r3, [r7, #12]

  (*BootAddress0) = (regvalue & FLASH_BOOT_ADD0) << 16;
240083c0:	68fb      	ldr	r3, [r7, #12]
240083c2:	041a      	lsls	r2, r3, #16
240083c4:	687b      	ldr	r3, [r7, #4]
240083c6:	601a      	str	r2, [r3, #0]
  (*BootAddress1) = (regvalue & FLASH_BOOT_ADD1);
240083c8:	68fa      	ldr	r2, [r7, #12]
240083ca:	4b06      	ldr	r3, [pc, #24]	; (240083e4 <FLASH_OB_GetBootAdd+0x34>)
240083cc:	4013      	ands	r3, r2
240083ce:	683a      	ldr	r2, [r7, #0]
240083d0:	6013      	str	r3, [r2, #0]
#endif /* DUAL_CORE */
}
240083d2:	bf00      	nop
240083d4:	3714      	adds	r7, #20
240083d6:	46bd      	mov	sp, r7
240083d8:	f85d 7b04 	ldr.w	r7, [sp], #4
240083dc:	4770      	bx	lr
240083de:	bf00      	nop
240083e0:	52002000 	.word	0x52002000
240083e4:	ffff0000 	.word	0xffff0000

240083e8 <FLASH_OB_SecureAreaConfig>:
  *            @arg FLASH_BANK_2: Secure area on specified bank2 area
  *            @arg FLASH_BANK_BOTH: Secure area on specified bank1 and bank2 area (same config will be applied on both banks)
  * @retval None
  */
static void FLASH_OB_SecureAreaConfig(uint32_t SecureAreaConfig, uint32_t SecureAreaStartAddr, uint32_t SecureAreaEndAddr, uint32_t Banks)
{
240083e8:	b480      	push	{r7}
240083ea:	b085      	sub	sp, #20
240083ec:	af00      	add	r7, sp, #0
240083ee:	60f8      	str	r0, [r7, #12]
240083f0:	60b9      	str	r1, [r7, #8]
240083f2:	607a      	str	r2, [r7, #4]
240083f4:	603b      	str	r3, [r7, #0]
  /* Check the parameters */
  assert_param(IS_FLASH_BANK(Banks));
  assert_param(IS_OB_SECURE_RDP(SecureAreaConfig));

  if((Banks & FLASH_BANK_1) == FLASH_BANK_1)
240083f6:	683b      	ldr	r3, [r7, #0]
240083f8:	f003 0301 	and.w	r3, r3, #1
240083fc:	2b00      	cmp	r3, #0
240083fe:	d00f      	beq.n	24008420 <FLASH_OB_SecureAreaConfig+0x38>
    /* Check the parameters */
    assert_param(IS_FLASH_PROGRAM_ADDRESS_BANK1(SecureAreaStartAddr));
    assert_param(IS_FLASH_PROGRAM_ADDRESS_BANK1(SecureAreaEndAddr));

    /* Configure the secure area */
    FLASH->SCAR_PRG1 = ((SecureAreaStartAddr - FLASH_BANK1_BASE) >> 8)                                | \
24008400:	68bb      	ldr	r3, [r7, #8]
24008402:	f103 4378 	add.w	r3, r3, #4160749568	; 0xf8000000
24008406:	0a1a      	lsrs	r2, r3, #8
                       (((SecureAreaEndAddr - FLASH_BANK1_BASE) >> 8) << FLASH_SCAR_SEC_AREA_END_Pos) | \
24008408:	687b      	ldr	r3, [r7, #4]
2400840a:	f103 4378 	add.w	r3, r3, #4160749568	; 0xf8000000
2400840e:	0a1b      	lsrs	r3, r3, #8
24008410:	041b      	lsls	r3, r3, #16
    FLASH->SCAR_PRG1 = ((SecureAreaStartAddr - FLASH_BANK1_BASE) >> 8)                                | \
24008412:	431a      	orrs	r2, r3
                       (SecureAreaConfig & FLASH_SCAR_DMES);
24008414:	68fb      	ldr	r3, [r7, #12]
24008416:	f003 4300 	and.w	r3, r3, #2147483648	; 0x80000000
    FLASH->SCAR_PRG1 = ((SecureAreaStartAddr - FLASH_BANK1_BASE) >> 8)                                | \
2400841a:	490f      	ldr	r1, [pc, #60]	; (24008458 <FLASH_OB_SecureAreaConfig+0x70>)
                       (((SecureAreaEndAddr - FLASH_BANK1_BASE) >> 8) << FLASH_SCAR_SEC_AREA_END_Pos) | \
2400841c:	4313      	orrs	r3, r2
    FLASH->SCAR_PRG1 = ((SecureAreaStartAddr - FLASH_BANK1_BASE) >> 8)                                | \
2400841e:	634b      	str	r3, [r1, #52]	; 0x34
  }

  if((Banks & FLASH_BANK_2) == FLASH_BANK_2)
24008420:	683b      	ldr	r3, [r7, #0]
24008422:	f003 0302 	and.w	r3, r3, #2
24008426:	2b00      	cmp	r3, #0
24008428:	d010      	beq.n	2400844c <FLASH_OB_SecureAreaConfig+0x64>
    /* Check the parameters */
    assert_param(IS_FLASH_PROGRAM_ADDRESS_BANK2(SecureAreaStartAddr));
    assert_param(IS_FLASH_PROGRAM_ADDRESS_BANK2(SecureAreaEndAddr));

    /* Configure the secure area */
    FLASH->SCAR_PRG2 = ((SecureAreaStartAddr - FLASH_BANK2_BASE) >> 8)                                | \
2400842a:	68bb      	ldr	r3, [r7, #8]
2400842c:	f1a3 6301 	sub.w	r3, r3, #135266304	; 0x8100000
24008430:	0a1a      	lsrs	r2, r3, #8
                       (((SecureAreaEndAddr - FLASH_BANK2_BASE) >> 8) << FLASH_SCAR_SEC_AREA_END_Pos) | \
24008432:	687b      	ldr	r3, [r7, #4]
24008434:	f1a3 6301 	sub.w	r3, r3, #135266304	; 0x8100000
24008438:	0a1b      	lsrs	r3, r3, #8
2400843a:	041b      	lsls	r3, r3, #16
    FLASH->SCAR_PRG2 = ((SecureAreaStartAddr - FLASH_BANK2_BASE) >> 8)                                | \
2400843c:	431a      	orrs	r2, r3
                       (SecureAreaConfig & FLASH_SCAR_DMES);
2400843e:	68fb      	ldr	r3, [r7, #12]
24008440:	f003 4300 	and.w	r3, r3, #2147483648	; 0x80000000
    FLASH->SCAR_PRG2 = ((SecureAreaStartAddr - FLASH_BANK2_BASE) >> 8)                                | \
24008444:	4904      	ldr	r1, [pc, #16]	; (24008458 <FLASH_OB_SecureAreaConfig+0x70>)
                       (((SecureAreaEndAddr - FLASH_BANK2_BASE) >> 8) << FLASH_SCAR_SEC_AREA_END_Pos) | \
24008446:	4313      	orrs	r3, r2
    FLASH->SCAR_PRG2 = ((SecureAreaStartAddr - FLASH_BANK2_BASE) >> 8)                                | \
24008448:	f8c1 3134 	str.w	r3, [r1, #308]	; 0x134
  }
}
2400844c:	bf00      	nop
2400844e:	3714      	adds	r7, #20
24008450:	46bd      	mov	sp, r7
24008452:	f85d 7b04 	ldr.w	r7, [sp], #4
24008456:	4770      	bx	lr
24008458:	52002000 	.word	0x52002000

2400845c <FLASH_OB_GetSecureArea>:
  * @param  SecureAreaEndAddr gives the secure area end address
  * @param  Bank Specifies the Bank
  * @retval None
  */
static void FLASH_OB_GetSecureArea(uint32_t *SecureAreaConfig, uint32_t *SecureAreaStartAddr, uint32_t *SecureAreaEndAddr, uint32_t Bank)
{
2400845c:	b480      	push	{r7}
2400845e:	b087      	sub	sp, #28
24008460:	af00      	add	r7, sp, #0
24008462:	60f8      	str	r0, [r7, #12]
24008464:	60b9      	str	r1, [r7, #8]
24008466:	607a      	str	r2, [r7, #4]
24008468:	603b      	str	r3, [r7, #0]
  uint32_t regvalue = 0;
2400846a:	2300      	movs	r3, #0
2400846c:	617b      	str	r3, [r7, #20]
  uint32_t bankBase = 0;
2400846e:	2300      	movs	r3, #0
24008470:	613b      	str	r3, [r7, #16]

  /* Check Bank parameter value */
  if((Bank & FLASH_BANK_BOTH) == FLASH_BANK_1)
24008472:	683b      	ldr	r3, [r7, #0]
24008474:	f003 0303 	and.w	r3, r3, #3
24008478:	2b01      	cmp	r3, #1
2400847a:	d105      	bne.n	24008488 <FLASH_OB_GetSecureArea+0x2c>
  {
    regvalue = FLASH->SCAR_CUR1;
2400847c:	4b18      	ldr	r3, [pc, #96]	; (240084e0 <FLASH_OB_GetSecureArea+0x84>)
2400847e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
24008480:	617b      	str	r3, [r7, #20]
    bankBase = FLASH_BANK1_BASE;
24008482:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
24008486:	613b      	str	r3, [r7, #16]
  }

  if((Bank & FLASH_BANK_BOTH) == FLASH_BANK_2)
24008488:	683b      	ldr	r3, [r7, #0]
2400848a:	f003 0303 	and.w	r3, r3, #3
2400848e:	2b02      	cmp	r3, #2
24008490:	d106      	bne.n	240084a0 <FLASH_OB_GetSecureArea+0x44>
  {
    regvalue = FLASH->SCAR_CUR2;
24008492:	4b13      	ldr	r3, [pc, #76]	; (240084e0 <FLASH_OB_GetSecureArea+0x84>)
24008494:	f8d3 3130 	ldr.w	r3, [r3, #304]	; 0x130
24008498:	617b      	str	r3, [r7, #20]
    bankBase = FLASH_BANK2_BASE;
2400849a:	f04f 6301 	mov.w	r3, #135266304	; 0x8100000
2400849e:	613b      	str	r3, [r7, #16]
  }

  /* Get the secure area settings */
  (*SecureAreaConfig) = (regvalue & FLASH_SCAR_DMES);
240084a0:	697b      	ldr	r3, [r7, #20]
240084a2:	f003 4200 	and.w	r2, r3, #2147483648	; 0x80000000
240084a6:	68fb      	ldr	r3, [r7, #12]
240084a8:	601a      	str	r2, [r3, #0]
  (*SecureAreaStartAddr) = ((regvalue & FLASH_SCAR_SEC_AREA_START) << 8) + bankBase;
240084aa:	697b      	ldr	r3, [r7, #20]
240084ac:	021a      	lsls	r2, r3, #8
240084ae:	4b0d      	ldr	r3, [pc, #52]	; (240084e4 <FLASH_OB_GetSecureArea+0x88>)
240084b0:	4013      	ands	r3, r2
240084b2:	693a      	ldr	r2, [r7, #16]
240084b4:	441a      	add	r2, r3
240084b6:	68bb      	ldr	r3, [r7, #8]
240084b8:	601a      	str	r2, [r3, #0]
  (*SecureAreaEndAddr) = (regvalue & FLASH_SCAR_SEC_AREA_END) >> FLASH_SCAR_SEC_AREA_END_Pos;
240084ba:	697b      	ldr	r3, [r7, #20]
240084bc:	0c1b      	lsrs	r3, r3, #16
240084be:	f3c3 020b 	ubfx	r2, r3, #0, #12
240084c2:	687b      	ldr	r3, [r7, #4]
240084c4:	601a      	str	r2, [r3, #0]
  (*SecureAreaEndAddr) = ((*SecureAreaEndAddr) << 8) + bankBase;
240084c6:	687b      	ldr	r3, [r7, #4]
240084c8:	681b      	ldr	r3, [r3, #0]
240084ca:	021a      	lsls	r2, r3, #8
240084cc:	693b      	ldr	r3, [r7, #16]
240084ce:	441a      	add	r2, r3
240084d0:	687b      	ldr	r3, [r7, #4]
240084d2:	601a      	str	r2, [r3, #0]
}
240084d4:	bf00      	nop
240084d6:	371c      	adds	r7, #28
240084d8:	46bd      	mov	sp, r7
240084da:	f85d 7b04 	ldr.w	r7, [sp], #4
240084de:	4770      	bx	lr
240084e0:	52002000 	.word	0x52002000
240084e4:	000fff00 	.word	0x000fff00

240084e8 <FLASH_CRC_AddSector>:
  * @param  Sector Specifies the CRC sector number
  * @param  Bank Specifies the Bank
  * @retval None
  */
static void FLASH_CRC_AddSector(uint32_t Sector, uint32_t Bank)
{
240084e8:	b480      	push	{r7}
240084ea:	b083      	sub	sp, #12
240084ec:	af00      	add	r7, sp, #0
240084ee:	6078      	str	r0, [r7, #4]
240084f0:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_FLASH_SECTOR(Sector));

  if (Bank == FLASH_BANK_1)
240084f2:	683b      	ldr	r3, [r7, #0]
240084f4:	2b01      	cmp	r3, #1
240084f6:	d10e      	bne.n	24008516 <FLASH_CRC_AddSector+0x2e>
  {
    /* Clear CRC sector */
    FLASH->CRCCR1 &= (~FLASH_CRCCR_CRC_SECT);
240084f8:	4b13      	ldr	r3, [pc, #76]	; (24008548 <FLASH_CRC_AddSector+0x60>)
240084fa:	6d1b      	ldr	r3, [r3, #80]	; 0x50
240084fc:	4a12      	ldr	r2, [pc, #72]	; (24008548 <FLASH_CRC_AddSector+0x60>)
240084fe:	f023 0307 	bic.w	r3, r3, #7
24008502:	6513      	str	r3, [r2, #80]	; 0x50

    /* Select CRC Sector and activate ADD_SECT bit */
    FLASH->CRCCR1 |= Sector | FLASH_CRCCR_ADD_SECT;
24008504:	4b10      	ldr	r3, [pc, #64]	; (24008548 <FLASH_CRC_AddSector+0x60>)
24008506:	6d1a      	ldr	r2, [r3, #80]	; 0x50
24008508:	687b      	ldr	r3, [r7, #4]
2400850a:	4313      	orrs	r3, r2
2400850c:	4a0e      	ldr	r2, [pc, #56]	; (24008548 <FLASH_CRC_AddSector+0x60>)
2400850e:	f443 7300 	orr.w	r3, r3, #512	; 0x200
24008512:	6513      	str	r3, [r2, #80]	; 0x50
    FLASH->CRCCR2 &= (~FLASH_CRCCR_CRC_SECT);

    /* Select CRC Sector and activate ADD_SECT bit */
    FLASH->CRCCR2 |= Sector | FLASH_CRCCR_ADD_SECT;
  }
}
24008514:	e011      	b.n	2400853a <FLASH_CRC_AddSector+0x52>
    FLASH->CRCCR2 &= (~FLASH_CRCCR_CRC_SECT);
24008516:	4b0c      	ldr	r3, [pc, #48]	; (24008548 <FLASH_CRC_AddSector+0x60>)
24008518:	f8d3 3150 	ldr.w	r3, [r3, #336]	; 0x150
2400851c:	4a0a      	ldr	r2, [pc, #40]	; (24008548 <FLASH_CRC_AddSector+0x60>)
2400851e:	f023 0307 	bic.w	r3, r3, #7
24008522:	f8c2 3150 	str.w	r3, [r2, #336]	; 0x150
    FLASH->CRCCR2 |= Sector | FLASH_CRCCR_ADD_SECT;
24008526:	4b08      	ldr	r3, [pc, #32]	; (24008548 <FLASH_CRC_AddSector+0x60>)
24008528:	f8d3 2150 	ldr.w	r2, [r3, #336]	; 0x150
2400852c:	687b      	ldr	r3, [r7, #4]
2400852e:	4313      	orrs	r3, r2
24008530:	4a05      	ldr	r2, [pc, #20]	; (24008548 <FLASH_CRC_AddSector+0x60>)
24008532:	f443 7300 	orr.w	r3, r3, #512	; 0x200
24008536:	f8c2 3150 	str.w	r3, [r2, #336]	; 0x150
}
2400853a:	bf00      	nop
2400853c:	370c      	adds	r7, #12
2400853e:	46bd      	mov	sp, r7
24008540:	f85d 7b04 	ldr.w	r7, [sp], #4
24008544:	4770      	bx	lr
24008546:	bf00      	nop
24008548:	52002000 	.word	0x52002000

2400854c <FLASH_CRC_SelectAddress>:
  * @param  CRCEndAddr Specifies the CRC end address
  * @param  Bank Specifies the Bank
  * @retval None
  */
static void FLASH_CRC_SelectAddress(uint32_t CRCStartAddr, uint32_t CRCEndAddr, uint32_t Bank)
{
2400854c:	b480      	push	{r7}
2400854e:	b085      	sub	sp, #20
24008550:	af00      	add	r7, sp, #0
24008552:	60f8      	str	r0, [r7, #12]
24008554:	60b9      	str	r1, [r7, #8]
24008556:	607a      	str	r2, [r7, #4]
  if (Bank == FLASH_BANK_1)
24008558:	687b      	ldr	r3, [r7, #4]
2400855a:	2b01      	cmp	r3, #1
2400855c:	d106      	bne.n	2400856c <FLASH_CRC_SelectAddress+0x20>
  {
    assert_param(IS_FLASH_PROGRAM_ADDRESS_BANK1(CRCStartAddr));
    assert_param(IS_FLASH_PROGRAM_ADDRESS_BANK1(CRCEndAddr));

    /* Write CRC Start and End addresses */
    FLASH->CRCSADD1 = CRCStartAddr;
2400855e:	4a0a      	ldr	r2, [pc, #40]	; (24008588 <FLASH_CRC_SelectAddress+0x3c>)
24008560:	68fb      	ldr	r3, [r7, #12]
24008562:	6553      	str	r3, [r2, #84]	; 0x54
    FLASH->CRCEADD1 = CRCEndAddr;
24008564:	4a08      	ldr	r2, [pc, #32]	; (24008588 <FLASH_CRC_SelectAddress+0x3c>)
24008566:	68bb      	ldr	r3, [r7, #8]
24008568:	6593      	str	r3, [r2, #88]	; 0x58

    /* Write CRC Start and End addresses */
    FLASH->CRCSADD2 = CRCStartAddr;
    FLASH->CRCEADD2 = CRCEndAddr;
  }
}
2400856a:	e007      	b.n	2400857c <FLASH_CRC_SelectAddress+0x30>
    FLASH->CRCSADD2 = CRCStartAddr;
2400856c:	4a06      	ldr	r2, [pc, #24]	; (24008588 <FLASH_CRC_SelectAddress+0x3c>)
2400856e:	68fb      	ldr	r3, [r7, #12]
24008570:	f8c2 3154 	str.w	r3, [r2, #340]	; 0x154
    FLASH->CRCEADD2 = CRCEndAddr;
24008574:	4a04      	ldr	r2, [pc, #16]	; (24008588 <FLASH_CRC_SelectAddress+0x3c>)
24008576:	68bb      	ldr	r3, [r7, #8]
24008578:	f8c2 3158 	str.w	r3, [r2, #344]	; 0x158
}
2400857c:	bf00      	nop
2400857e:	3714      	adds	r7, #20
24008580:	46bd      	mov	sp, r7
24008582:	f85d 7b04 	ldr.w	r7, [sp], #4
24008586:	4770      	bx	lr
24008588:	52002000 	.word	0x52002000

2400858c <HAL_GPIO_Init>:
  * @param  GPIO_Init: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
2400858c:	b480      	push	{r7}
2400858e:	b089      	sub	sp, #36	; 0x24
24008590:	af00      	add	r7, sp, #0
24008592:	6078      	str	r0, [r7, #4]
24008594:	6039      	str	r1, [r7, #0]
  uint32_t position = 0x00U;
24008596:	2300      	movs	r3, #0
24008598:	61fb      	str	r3, [r7, #28]
  EXTI_Core_TypeDef *EXTI_CurrentCPU;

#if defined(DUAL_CORE) && defined(CORE_CM4)
  EXTI_CurrentCPU = EXTI_D2; /* EXTI for CM4 CPU */
#else
  EXTI_CurrentCPU = EXTI_D1; /* EXTI for CM7 CPU */
2400859a:	4b89      	ldr	r3, [pc, #548]	; (240087c0 <HAL_GPIO_Init+0x234>)
2400859c:	617b      	str	r3, [r7, #20]
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != 0x00U)
2400859e:	e194      	b.n	240088ca <HAL_GPIO_Init+0x33e>
  {
    /* Get current io position */
    iocurrent = (GPIO_Init->Pin) & (1UL << position);
240085a0:	683b      	ldr	r3, [r7, #0]
240085a2:	681a      	ldr	r2, [r3, #0]
240085a4:	2101      	movs	r1, #1
240085a6:	69fb      	ldr	r3, [r7, #28]
240085a8:	fa01 f303 	lsl.w	r3, r1, r3
240085ac:	4013      	ands	r3, r2
240085ae:	613b      	str	r3, [r7, #16]

    if (iocurrent != 0x00U)
240085b0:	693b      	ldr	r3, [r7, #16]
240085b2:	2b00      	cmp	r3, #0
240085b4:	f000 8186 	beq.w	240088c4 <HAL_GPIO_Init+0x338>
    {
      /*--------------------- GPIO Mode Configuration ------------------------*/
      /* In case of Output or Alternate function mode selection */
      if ((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
240085b8:	683b      	ldr	r3, [r7, #0]
240085ba:	685b      	ldr	r3, [r3, #4]
240085bc:	2b01      	cmp	r3, #1
240085be:	d00b      	beq.n	240085d8 <HAL_GPIO_Init+0x4c>
240085c0:	683b      	ldr	r3, [r7, #0]
240085c2:	685b      	ldr	r3, [r3, #4]
240085c4:	2b02      	cmp	r3, #2
240085c6:	d007      	beq.n	240085d8 <HAL_GPIO_Init+0x4c>
          (GPIO_Init->Mode == GPIO_MODE_OUTPUT_OD) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
240085c8:	683b      	ldr	r3, [r7, #0]
240085ca:	685b      	ldr	r3, [r3, #4]
      if ((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
240085cc:	2b11      	cmp	r3, #17
240085ce:	d003      	beq.n	240085d8 <HAL_GPIO_Init+0x4c>
          (GPIO_Init->Mode == GPIO_MODE_OUTPUT_OD) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
240085d0:	683b      	ldr	r3, [r7, #0]
240085d2:	685b      	ldr	r3, [r3, #4]
240085d4:	2b12      	cmp	r3, #18
240085d6:	d130      	bne.n	2400863a <HAL_GPIO_Init+0xae>
      {
        /* Check the Speed parameter */
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
        /* Configure the IO Speed */
        temp = GPIOx->OSPEEDR;
240085d8:	687b      	ldr	r3, [r7, #4]
240085da:	689b      	ldr	r3, [r3, #8]
240085dc:	61bb      	str	r3, [r7, #24]
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2U));
240085de:	69fb      	ldr	r3, [r7, #28]
240085e0:	005b      	lsls	r3, r3, #1
240085e2:	2203      	movs	r2, #3
240085e4:	fa02 f303 	lsl.w	r3, r2, r3
240085e8:	43db      	mvns	r3, r3
240085ea:	69ba      	ldr	r2, [r7, #24]
240085ec:	4013      	ands	r3, r2
240085ee:	61bb      	str	r3, [r7, #24]
        temp |= (GPIO_Init->Speed << (position * 2U));
240085f0:	683b      	ldr	r3, [r7, #0]
240085f2:	68da      	ldr	r2, [r3, #12]
240085f4:	69fb      	ldr	r3, [r7, #28]
240085f6:	005b      	lsls	r3, r3, #1
240085f8:	fa02 f303 	lsl.w	r3, r2, r3
240085fc:	69ba      	ldr	r2, [r7, #24]
240085fe:	4313      	orrs	r3, r2
24008600:	61bb      	str	r3, [r7, #24]
        GPIOx->OSPEEDR = temp;
24008602:	687b      	ldr	r3, [r7, #4]
24008604:	69ba      	ldr	r2, [r7, #24]
24008606:	609a      	str	r2, [r3, #8]

        /* Configure the IO Output Type */
        temp = GPIOx->OTYPER;
24008608:	687b      	ldr	r3, [r7, #4]
2400860a:	685b      	ldr	r3, [r3, #4]
2400860c:	61bb      	str	r3, [r7, #24]
        temp &= ~(GPIO_OTYPER_OT0 << position) ;
2400860e:	2201      	movs	r2, #1
24008610:	69fb      	ldr	r3, [r7, #28]
24008612:	fa02 f303 	lsl.w	r3, r2, r3
24008616:	43db      	mvns	r3, r3
24008618:	69ba      	ldr	r2, [r7, #24]
2400861a:	4013      	ands	r3, r2
2400861c:	61bb      	str	r3, [r7, #24]
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4U) << position);
2400861e:	683b      	ldr	r3, [r7, #0]
24008620:	685b      	ldr	r3, [r3, #4]
24008622:	091b      	lsrs	r3, r3, #4
24008624:	f003 0201 	and.w	r2, r3, #1
24008628:	69fb      	ldr	r3, [r7, #28]
2400862a:	fa02 f303 	lsl.w	r3, r2, r3
2400862e:	69ba      	ldr	r2, [r7, #24]
24008630:	4313      	orrs	r3, r2
24008632:	61bb      	str	r3, [r7, #24]
        GPIOx->OTYPER = temp;
24008634:	687b      	ldr	r3, [r7, #4]
24008636:	69ba      	ldr	r2, [r7, #24]
24008638:	605a      	str	r2, [r3, #4]
      }

      /* Activate the Pull-up or Pull down resistor for the current IO */
      temp = GPIOx->PUPDR;
2400863a:	687b      	ldr	r3, [r7, #4]
2400863c:	68db      	ldr	r3, [r3, #12]
2400863e:	61bb      	str	r3, [r7, #24]
      temp &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
24008640:	69fb      	ldr	r3, [r7, #28]
24008642:	005b      	lsls	r3, r3, #1
24008644:	2203      	movs	r2, #3
24008646:	fa02 f303 	lsl.w	r3, r2, r3
2400864a:	43db      	mvns	r3, r3
2400864c:	69ba      	ldr	r2, [r7, #24]
2400864e:	4013      	ands	r3, r2
24008650:	61bb      	str	r3, [r7, #24]
      temp |= ((GPIO_Init->Pull) << (position * 2U));
24008652:	683b      	ldr	r3, [r7, #0]
24008654:	689a      	ldr	r2, [r3, #8]
24008656:	69fb      	ldr	r3, [r7, #28]
24008658:	005b      	lsls	r3, r3, #1
2400865a:	fa02 f303 	lsl.w	r3, r2, r3
2400865e:	69ba      	ldr	r2, [r7, #24]
24008660:	4313      	orrs	r3, r2
24008662:	61bb      	str	r3, [r7, #24]
      GPIOx->PUPDR = temp;
24008664:	687b      	ldr	r3, [r7, #4]
24008666:	69ba      	ldr	r2, [r7, #24]
24008668:	60da      	str	r2, [r3, #12]

      /* In case of Alternate function mode selection */
      if ((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
2400866a:	683b      	ldr	r3, [r7, #0]
2400866c:	685b      	ldr	r3, [r3, #4]
2400866e:	2b02      	cmp	r3, #2
24008670:	d003      	beq.n	2400867a <HAL_GPIO_Init+0xee>
24008672:	683b      	ldr	r3, [r7, #0]
24008674:	685b      	ldr	r3, [r3, #4]
24008676:	2b12      	cmp	r3, #18
24008678:	d123      	bne.n	240086c2 <HAL_GPIO_Init+0x136>
        /* Check the Alternate function parameters */
        assert_param(IS_GPIO_AF_INSTANCE(GPIOx));
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));

        /* Configure Alternate function mapped with the current IO */
        temp = GPIOx->AFR[position >> 3U];
2400867a:	69fb      	ldr	r3, [r7, #28]
2400867c:	08da      	lsrs	r2, r3, #3
2400867e:	687b      	ldr	r3, [r7, #4]
24008680:	3208      	adds	r2, #8
24008682:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
24008686:	61bb      	str	r3, [r7, #24]
        temp &= ~(0xFU << ((position & 0x07U) * 4U));
24008688:	69fb      	ldr	r3, [r7, #28]
2400868a:	f003 0307 	and.w	r3, r3, #7
2400868e:	009b      	lsls	r3, r3, #2
24008690:	220f      	movs	r2, #15
24008692:	fa02 f303 	lsl.w	r3, r2, r3
24008696:	43db      	mvns	r3, r3
24008698:	69ba      	ldr	r2, [r7, #24]
2400869a:	4013      	ands	r3, r2
2400869c:	61bb      	str	r3, [r7, #24]
        temp |= ((GPIO_Init->Alternate) << ((position & 0x07U) * 4U));
2400869e:	683b      	ldr	r3, [r7, #0]
240086a0:	691a      	ldr	r2, [r3, #16]
240086a2:	69fb      	ldr	r3, [r7, #28]
240086a4:	f003 0307 	and.w	r3, r3, #7
240086a8:	009b      	lsls	r3, r3, #2
240086aa:	fa02 f303 	lsl.w	r3, r2, r3
240086ae:	69ba      	ldr	r2, [r7, #24]
240086b0:	4313      	orrs	r3, r2
240086b2:	61bb      	str	r3, [r7, #24]
        GPIOx->AFR[position >> 3U] = temp;
240086b4:	69fb      	ldr	r3, [r7, #28]
240086b6:	08da      	lsrs	r2, r3, #3
240086b8:	687b      	ldr	r3, [r7, #4]
240086ba:	3208      	adds	r2, #8
240086bc:	69b9      	ldr	r1, [r7, #24]
240086be:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
240086c2:	687b      	ldr	r3, [r7, #4]
240086c4:	681b      	ldr	r3, [r3, #0]
240086c6:	61bb      	str	r3, [r7, #24]
      temp &= ~(GPIO_MODER_MODE0 << (position * 2U));
240086c8:	69fb      	ldr	r3, [r7, #28]
240086ca:	005b      	lsls	r3, r3, #1
240086cc:	2203      	movs	r2, #3
240086ce:	fa02 f303 	lsl.w	r3, r2, r3
240086d2:	43db      	mvns	r3, r3
240086d4:	69ba      	ldr	r2, [r7, #24]
240086d6:	4013      	ands	r3, r2
240086d8:	61bb      	str	r3, [r7, #24]
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
240086da:	683b      	ldr	r3, [r7, #0]
240086dc:	685b      	ldr	r3, [r3, #4]
240086de:	f003 0203 	and.w	r2, r3, #3
240086e2:	69fb      	ldr	r3, [r7, #28]
240086e4:	005b      	lsls	r3, r3, #1
240086e6:	fa02 f303 	lsl.w	r3, r2, r3
240086ea:	69ba      	ldr	r2, [r7, #24]
240086ec:	4313      	orrs	r3, r2
240086ee:	61bb      	str	r3, [r7, #24]
      GPIOx->MODER = temp;
240086f0:	687b      	ldr	r3, [r7, #4]
240086f2:	69ba      	ldr	r2, [r7, #24]
240086f4:	601a      	str	r2, [r3, #0]

      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if ((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
240086f6:	683b      	ldr	r3, [r7, #0]
240086f8:	685b      	ldr	r3, [r3, #4]
240086fa:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
240086fe:	2b00      	cmp	r3, #0
24008700:	f000 80e0 	beq.w	240088c4 <HAL_GPIO_Init+0x338>
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
24008704:	4b2f      	ldr	r3, [pc, #188]	; (240087c4 <HAL_GPIO_Init+0x238>)
24008706:	f8d3 30f4 	ldr.w	r3, [r3, #244]	; 0xf4
2400870a:	4a2e      	ldr	r2, [pc, #184]	; (240087c4 <HAL_GPIO_Init+0x238>)
2400870c:	f043 0302 	orr.w	r3, r3, #2
24008710:	f8c2 30f4 	str.w	r3, [r2, #244]	; 0xf4
24008714:	4b2b      	ldr	r3, [pc, #172]	; (240087c4 <HAL_GPIO_Init+0x238>)
24008716:	f8d3 30f4 	ldr.w	r3, [r3, #244]	; 0xf4
2400871a:	f003 0302 	and.w	r3, r3, #2
2400871e:	60fb      	str	r3, [r7, #12]
24008720:	68fb      	ldr	r3, [r7, #12]

        temp = SYSCFG->EXTICR[position >> 2U];
24008722:	4a29      	ldr	r2, [pc, #164]	; (240087c8 <HAL_GPIO_Init+0x23c>)
24008724:	69fb      	ldr	r3, [r7, #28]
24008726:	089b      	lsrs	r3, r3, #2
24008728:	3302      	adds	r3, #2
2400872a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
2400872e:	61bb      	str	r3, [r7, #24]
        temp &= ~(0x0FUL << (4U * (position & 0x03U)));
24008730:	69fb      	ldr	r3, [r7, #28]
24008732:	f003 0303 	and.w	r3, r3, #3
24008736:	009b      	lsls	r3, r3, #2
24008738:	220f      	movs	r2, #15
2400873a:	fa02 f303 	lsl.w	r3, r2, r3
2400873e:	43db      	mvns	r3, r3
24008740:	69ba      	ldr	r2, [r7, #24]
24008742:	4013      	ands	r3, r2
24008744:	61bb      	str	r3, [r7, #24]
        temp |= (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U)));
24008746:	687b      	ldr	r3, [r7, #4]
24008748:	4a20      	ldr	r2, [pc, #128]	; (240087cc <HAL_GPIO_Init+0x240>)
2400874a:	4293      	cmp	r3, r2
2400874c:	d052      	beq.n	240087f4 <HAL_GPIO_Init+0x268>
2400874e:	687b      	ldr	r3, [r7, #4]
24008750:	4a1f      	ldr	r2, [pc, #124]	; (240087d0 <HAL_GPIO_Init+0x244>)
24008752:	4293      	cmp	r3, r2
24008754:	d031      	beq.n	240087ba <HAL_GPIO_Init+0x22e>
24008756:	687b      	ldr	r3, [r7, #4]
24008758:	4a1e      	ldr	r2, [pc, #120]	; (240087d4 <HAL_GPIO_Init+0x248>)
2400875a:	4293      	cmp	r3, r2
2400875c:	d02b      	beq.n	240087b6 <HAL_GPIO_Init+0x22a>
2400875e:	687b      	ldr	r3, [r7, #4]
24008760:	4a1d      	ldr	r2, [pc, #116]	; (240087d8 <HAL_GPIO_Init+0x24c>)
24008762:	4293      	cmp	r3, r2
24008764:	d025      	beq.n	240087b2 <HAL_GPIO_Init+0x226>
24008766:	687b      	ldr	r3, [r7, #4]
24008768:	4a1c      	ldr	r2, [pc, #112]	; (240087dc <HAL_GPIO_Init+0x250>)
2400876a:	4293      	cmp	r3, r2
2400876c:	d01f      	beq.n	240087ae <HAL_GPIO_Init+0x222>
2400876e:	687b      	ldr	r3, [r7, #4]
24008770:	4a1b      	ldr	r2, [pc, #108]	; (240087e0 <HAL_GPIO_Init+0x254>)
24008772:	4293      	cmp	r3, r2
24008774:	d019      	beq.n	240087aa <HAL_GPIO_Init+0x21e>
24008776:	687b      	ldr	r3, [r7, #4]
24008778:	4a1a      	ldr	r2, [pc, #104]	; (240087e4 <HAL_GPIO_Init+0x258>)
2400877a:	4293      	cmp	r3, r2
2400877c:	d013      	beq.n	240087a6 <HAL_GPIO_Init+0x21a>
2400877e:	687b      	ldr	r3, [r7, #4]
24008780:	4a19      	ldr	r2, [pc, #100]	; (240087e8 <HAL_GPIO_Init+0x25c>)
24008782:	4293      	cmp	r3, r2
24008784:	d00d      	beq.n	240087a2 <HAL_GPIO_Init+0x216>
24008786:	687b      	ldr	r3, [r7, #4]
24008788:	4a18      	ldr	r2, [pc, #96]	; (240087ec <HAL_GPIO_Init+0x260>)
2400878a:	4293      	cmp	r3, r2
2400878c:	d007      	beq.n	2400879e <HAL_GPIO_Init+0x212>
2400878e:	687b      	ldr	r3, [r7, #4]
24008790:	4a17      	ldr	r2, [pc, #92]	; (240087f0 <HAL_GPIO_Init+0x264>)
24008792:	4293      	cmp	r3, r2
24008794:	d101      	bne.n	2400879a <HAL_GPIO_Init+0x20e>
24008796:	2309      	movs	r3, #9
24008798:	e02d      	b.n	240087f6 <HAL_GPIO_Init+0x26a>
2400879a:	230a      	movs	r3, #10
2400879c:	e02b      	b.n	240087f6 <HAL_GPIO_Init+0x26a>
2400879e:	2308      	movs	r3, #8
240087a0:	e029      	b.n	240087f6 <HAL_GPIO_Init+0x26a>
240087a2:	2307      	movs	r3, #7
240087a4:	e027      	b.n	240087f6 <HAL_GPIO_Init+0x26a>
240087a6:	2306      	movs	r3, #6
240087a8:	e025      	b.n	240087f6 <HAL_GPIO_Init+0x26a>
240087aa:	2305      	movs	r3, #5
240087ac:	e023      	b.n	240087f6 <HAL_GPIO_Init+0x26a>
240087ae:	2304      	movs	r3, #4
240087b0:	e021      	b.n	240087f6 <HAL_GPIO_Init+0x26a>
240087b2:	2303      	movs	r3, #3
240087b4:	e01f      	b.n	240087f6 <HAL_GPIO_Init+0x26a>
240087b6:	2302      	movs	r3, #2
240087b8:	e01d      	b.n	240087f6 <HAL_GPIO_Init+0x26a>
240087ba:	2301      	movs	r3, #1
240087bc:	e01b      	b.n	240087f6 <HAL_GPIO_Init+0x26a>
240087be:	bf00      	nop
240087c0:	58000080 	.word	0x58000080
240087c4:	58024400 	.word	0x58024400
240087c8:	58000400 	.word	0x58000400
240087cc:	58020000 	.word	0x58020000
240087d0:	58020400 	.word	0x58020400
240087d4:	58020800 	.word	0x58020800
240087d8:	58020c00 	.word	0x58020c00
240087dc:	58021000 	.word	0x58021000
240087e0:	58021400 	.word	0x58021400
240087e4:	58021800 	.word	0x58021800
240087e8:	58021c00 	.word	0x58021c00
240087ec:	58022000 	.word	0x58022000
240087f0:	58022400 	.word	0x58022400
240087f4:	2300      	movs	r3, #0
240087f6:	69fa      	ldr	r2, [r7, #28]
240087f8:	f002 0203 	and.w	r2, r2, #3
240087fc:	0092      	lsls	r2, r2, #2
240087fe:	4093      	lsls	r3, r2
24008800:	69ba      	ldr	r2, [r7, #24]
24008802:	4313      	orrs	r3, r2
24008804:	61bb      	str	r3, [r7, #24]
        SYSCFG->EXTICR[position >> 2U] = temp;
24008806:	4938      	ldr	r1, [pc, #224]	; (240088e8 <HAL_GPIO_Init+0x35c>)
24008808:	69fb      	ldr	r3, [r7, #28]
2400880a:	089b      	lsrs	r3, r3, #2
2400880c:	3302      	adds	r3, #2
2400880e:	69ba      	ldr	r2, [r7, #24]
24008810:	f841 2023 	str.w	r2, [r1, r3, lsl #2]

        /* Clear EXTI line configuration */
        temp = EXTI_CurrentCPU->IMR1;
24008814:	697b      	ldr	r3, [r7, #20]
24008816:	681b      	ldr	r3, [r3, #0]
24008818:	61bb      	str	r3, [r7, #24]
        temp &= ~(iocurrent);
2400881a:	693b      	ldr	r3, [r7, #16]
2400881c:	43db      	mvns	r3, r3
2400881e:	69ba      	ldr	r2, [r7, #24]
24008820:	4013      	ands	r3, r2
24008822:	61bb      	str	r3, [r7, #24]
        if ((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
24008824:	683b      	ldr	r3, [r7, #0]
24008826:	685b      	ldr	r3, [r3, #4]
24008828:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
2400882c:	2b00      	cmp	r3, #0
2400882e:	d003      	beq.n	24008838 <HAL_GPIO_Init+0x2ac>
        {
          temp |= iocurrent;
24008830:	69ba      	ldr	r2, [r7, #24]
24008832:	693b      	ldr	r3, [r7, #16]
24008834:	4313      	orrs	r3, r2
24008836:	61bb      	str	r3, [r7, #24]
        }
        EXTI_CurrentCPU->IMR1 = temp;
24008838:	697b      	ldr	r3, [r7, #20]
2400883a:	69ba      	ldr	r2, [r7, #24]
2400883c:	601a      	str	r2, [r3, #0]

        temp = EXTI_CurrentCPU->EMR1;
2400883e:	697b      	ldr	r3, [r7, #20]
24008840:	685b      	ldr	r3, [r3, #4]
24008842:	61bb      	str	r3, [r7, #24]
        temp &= ~(iocurrent);
24008844:	693b      	ldr	r3, [r7, #16]
24008846:	43db      	mvns	r3, r3
24008848:	69ba      	ldr	r2, [r7, #24]
2400884a:	4013      	ands	r3, r2
2400884c:	61bb      	str	r3, [r7, #24]
        if ((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
2400884e:	683b      	ldr	r3, [r7, #0]
24008850:	685b      	ldr	r3, [r3, #4]
24008852:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
24008856:	2b00      	cmp	r3, #0
24008858:	d003      	beq.n	24008862 <HAL_GPIO_Init+0x2d6>
        {
          temp |= iocurrent;
2400885a:	69ba      	ldr	r2, [r7, #24]
2400885c:	693b      	ldr	r3, [r7, #16]
2400885e:	4313      	orrs	r3, r2
24008860:	61bb      	str	r3, [r7, #24]
        }
        EXTI_CurrentCPU->EMR1 = temp;
24008862:	697b      	ldr	r3, [r7, #20]
24008864:	69ba      	ldr	r2, [r7, #24]
24008866:	605a      	str	r2, [r3, #4]

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR1;
24008868:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
2400886c:	681b      	ldr	r3, [r3, #0]
2400886e:	61bb      	str	r3, [r7, #24]
        temp &= ~(iocurrent);
24008870:	693b      	ldr	r3, [r7, #16]
24008872:	43db      	mvns	r3, r3
24008874:	69ba      	ldr	r2, [r7, #24]
24008876:	4013      	ands	r3, r2
24008878:	61bb      	str	r3, [r7, #24]
        if ((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
2400887a:	683b      	ldr	r3, [r7, #0]
2400887c:	685b      	ldr	r3, [r3, #4]
2400887e:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
24008882:	2b00      	cmp	r3, #0
24008884:	d003      	beq.n	2400888e <HAL_GPIO_Init+0x302>
        {
          temp |= iocurrent;
24008886:	69ba      	ldr	r2, [r7, #24]
24008888:	693b      	ldr	r3, [r7, #16]
2400888a:	4313      	orrs	r3, r2
2400888c:	61bb      	str	r3, [r7, #24]
        }
        EXTI->RTSR1 = temp;
2400888e:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
24008892:	69bb      	ldr	r3, [r7, #24]
24008894:	6013      	str	r3, [r2, #0]

        temp = EXTI->FTSR1;
24008896:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
2400889a:	685b      	ldr	r3, [r3, #4]
2400889c:	61bb      	str	r3, [r7, #24]
        temp &= ~(iocurrent);
2400889e:	693b      	ldr	r3, [r7, #16]
240088a0:	43db      	mvns	r3, r3
240088a2:	69ba      	ldr	r2, [r7, #24]
240088a4:	4013      	ands	r3, r2
240088a6:	61bb      	str	r3, [r7, #24]
        if ((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
240088a8:	683b      	ldr	r3, [r7, #0]
240088aa:	685b      	ldr	r3, [r3, #4]
240088ac:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
240088b0:	2b00      	cmp	r3, #0
240088b2:	d003      	beq.n	240088bc <HAL_GPIO_Init+0x330>
        {
          temp |= iocurrent;
240088b4:	69ba      	ldr	r2, [r7, #24]
240088b6:	693b      	ldr	r3, [r7, #16]
240088b8:	4313      	orrs	r3, r2
240088ba:	61bb      	str	r3, [r7, #24]
        }
        EXTI->FTSR1 = temp;
240088bc:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
240088c0:	69bb      	ldr	r3, [r7, #24]
240088c2:	6053      	str	r3, [r2, #4]
      }
    }

    position++;
240088c4:	69fb      	ldr	r3, [r7, #28]
240088c6:	3301      	adds	r3, #1
240088c8:	61fb      	str	r3, [r7, #28]
  while (((GPIO_Init->Pin) >> position) != 0x00U)
240088ca:	683b      	ldr	r3, [r7, #0]
240088cc:	681a      	ldr	r2, [r3, #0]
240088ce:	69fb      	ldr	r3, [r7, #28]
240088d0:	fa22 f303 	lsr.w	r3, r2, r3
240088d4:	2b00      	cmp	r3, #0
240088d6:	f47f ae63 	bne.w	240085a0 <HAL_GPIO_Init+0x14>
  }
}
240088da:	bf00      	nop
240088dc:	3724      	adds	r7, #36	; 0x24
240088de:	46bd      	mov	sp, r7
240088e0:	f85d 7b04 	ldr.w	r7, [sp], #4
240088e4:	4770      	bx	lr
240088e6:	bf00      	nop
240088e8:	58000400 	.word	0x58000400

240088ec <HAL_GPIO_DeInit>:
  * @param  GPIO_Pin: specifies the port bit to be written.
  *          This parameter can be one of GPIO_PIN_x where x can be (0..15).
  * @retval None
  */
void HAL_GPIO_DeInit(GPIO_TypeDef  *GPIOx, uint32_t GPIO_Pin)
{
240088ec:	b480      	push	{r7}
240088ee:	b087      	sub	sp, #28
240088f0:	af00      	add	r7, sp, #0
240088f2:	6078      	str	r0, [r7, #4]
240088f4:	6039      	str	r1, [r7, #0]
  uint32_t position = 0x00U;
240088f6:	2300      	movs	r3, #0
240088f8:	617b      	str	r3, [r7, #20]
  EXTI_Core_TypeDef *EXTI_CurrentCPU;

#if defined(DUAL_CORE) && defined(CORE_CM4)
  EXTI_CurrentCPU = EXTI_D2; /* EXTI for CM4 CPU */
#else
  EXTI_CurrentCPU = EXTI_D1; /* EXTI for CM7 CPU */
240088fa:	4b75      	ldr	r3, [pc, #468]	; (24008ad0 <HAL_GPIO_DeInit+0x1e4>)
240088fc:	613b      	str	r3, [r7, #16]
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  /* Configure the port pins */
  while ((GPIO_Pin >> position) != 0x00U)
240088fe:	e0d9      	b.n	24008ab4 <HAL_GPIO_DeInit+0x1c8>
  {
    /* Get current io position */
    iocurrent = GPIO_Pin & (1UL << position) ;
24008900:	2201      	movs	r2, #1
24008902:	697b      	ldr	r3, [r7, #20]
24008904:	fa02 f303 	lsl.w	r3, r2, r3
24008908:	683a      	ldr	r2, [r7, #0]
2400890a:	4013      	ands	r3, r2
2400890c:	60fb      	str	r3, [r7, #12]

    if (iocurrent != 0x00U)
2400890e:	68fb      	ldr	r3, [r7, #12]
24008910:	2b00      	cmp	r3, #0
24008912:	f000 80cc 	beq.w	24008aae <HAL_GPIO_DeInit+0x1c2>
    {
      /*------------------------- EXTI Mode Configuration --------------------*/
      /* Clear the External Interrupt or Event for the current IO */
      tmp = SYSCFG->EXTICR[position >> 2U];
24008916:	4a6f      	ldr	r2, [pc, #444]	; (24008ad4 <HAL_GPIO_DeInit+0x1e8>)
24008918:	697b      	ldr	r3, [r7, #20]
2400891a:	089b      	lsrs	r3, r3, #2
2400891c:	3302      	adds	r3, #2
2400891e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
24008922:	60bb      	str	r3, [r7, #8]
      tmp &= (0x0FUL << (4U * (position & 0x03U)));
24008924:	697b      	ldr	r3, [r7, #20]
24008926:	f003 0303 	and.w	r3, r3, #3
2400892a:	009b      	lsls	r3, r3, #2
2400892c:	220f      	movs	r2, #15
2400892e:	fa02 f303 	lsl.w	r3, r2, r3
24008932:	68ba      	ldr	r2, [r7, #8]
24008934:	4013      	ands	r3, r2
24008936:	60bb      	str	r3, [r7, #8]
      if (tmp == (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U))))
24008938:	687b      	ldr	r3, [r7, #4]
2400893a:	4a67      	ldr	r2, [pc, #412]	; (24008ad8 <HAL_GPIO_DeInit+0x1ec>)
2400893c:	4293      	cmp	r3, r2
2400893e:	d037      	beq.n	240089b0 <HAL_GPIO_DeInit+0xc4>
24008940:	687b      	ldr	r3, [r7, #4]
24008942:	4a66      	ldr	r2, [pc, #408]	; (24008adc <HAL_GPIO_DeInit+0x1f0>)
24008944:	4293      	cmp	r3, r2
24008946:	d031      	beq.n	240089ac <HAL_GPIO_DeInit+0xc0>
24008948:	687b      	ldr	r3, [r7, #4]
2400894a:	4a65      	ldr	r2, [pc, #404]	; (24008ae0 <HAL_GPIO_DeInit+0x1f4>)
2400894c:	4293      	cmp	r3, r2
2400894e:	d02b      	beq.n	240089a8 <HAL_GPIO_DeInit+0xbc>
24008950:	687b      	ldr	r3, [r7, #4]
24008952:	4a64      	ldr	r2, [pc, #400]	; (24008ae4 <HAL_GPIO_DeInit+0x1f8>)
24008954:	4293      	cmp	r3, r2
24008956:	d025      	beq.n	240089a4 <HAL_GPIO_DeInit+0xb8>
24008958:	687b      	ldr	r3, [r7, #4]
2400895a:	4a63      	ldr	r2, [pc, #396]	; (24008ae8 <HAL_GPIO_DeInit+0x1fc>)
2400895c:	4293      	cmp	r3, r2
2400895e:	d01f      	beq.n	240089a0 <HAL_GPIO_DeInit+0xb4>
24008960:	687b      	ldr	r3, [r7, #4]
24008962:	4a62      	ldr	r2, [pc, #392]	; (24008aec <HAL_GPIO_DeInit+0x200>)
24008964:	4293      	cmp	r3, r2
24008966:	d019      	beq.n	2400899c <HAL_GPIO_DeInit+0xb0>
24008968:	687b      	ldr	r3, [r7, #4]
2400896a:	4a61      	ldr	r2, [pc, #388]	; (24008af0 <HAL_GPIO_DeInit+0x204>)
2400896c:	4293      	cmp	r3, r2
2400896e:	d013      	beq.n	24008998 <HAL_GPIO_DeInit+0xac>
24008970:	687b      	ldr	r3, [r7, #4]
24008972:	4a60      	ldr	r2, [pc, #384]	; (24008af4 <HAL_GPIO_DeInit+0x208>)
24008974:	4293      	cmp	r3, r2
24008976:	d00d      	beq.n	24008994 <HAL_GPIO_DeInit+0xa8>
24008978:	687b      	ldr	r3, [r7, #4]
2400897a:	4a5f      	ldr	r2, [pc, #380]	; (24008af8 <HAL_GPIO_DeInit+0x20c>)
2400897c:	4293      	cmp	r3, r2
2400897e:	d007      	beq.n	24008990 <HAL_GPIO_DeInit+0xa4>
24008980:	687b      	ldr	r3, [r7, #4]
24008982:	4a5e      	ldr	r2, [pc, #376]	; (24008afc <HAL_GPIO_DeInit+0x210>)
24008984:	4293      	cmp	r3, r2
24008986:	d101      	bne.n	2400898c <HAL_GPIO_DeInit+0xa0>
24008988:	2309      	movs	r3, #9
2400898a:	e012      	b.n	240089b2 <HAL_GPIO_DeInit+0xc6>
2400898c:	230a      	movs	r3, #10
2400898e:	e010      	b.n	240089b2 <HAL_GPIO_DeInit+0xc6>
24008990:	2308      	movs	r3, #8
24008992:	e00e      	b.n	240089b2 <HAL_GPIO_DeInit+0xc6>
24008994:	2307      	movs	r3, #7
24008996:	e00c      	b.n	240089b2 <HAL_GPIO_DeInit+0xc6>
24008998:	2306      	movs	r3, #6
2400899a:	e00a      	b.n	240089b2 <HAL_GPIO_DeInit+0xc6>
2400899c:	2305      	movs	r3, #5
2400899e:	e008      	b.n	240089b2 <HAL_GPIO_DeInit+0xc6>
240089a0:	2304      	movs	r3, #4
240089a2:	e006      	b.n	240089b2 <HAL_GPIO_DeInit+0xc6>
240089a4:	2303      	movs	r3, #3
240089a6:	e004      	b.n	240089b2 <HAL_GPIO_DeInit+0xc6>
240089a8:	2302      	movs	r3, #2
240089aa:	e002      	b.n	240089b2 <HAL_GPIO_DeInit+0xc6>
240089ac:	2301      	movs	r3, #1
240089ae:	e000      	b.n	240089b2 <HAL_GPIO_DeInit+0xc6>
240089b0:	2300      	movs	r3, #0
240089b2:	697a      	ldr	r2, [r7, #20]
240089b4:	f002 0203 	and.w	r2, r2, #3
240089b8:	0092      	lsls	r2, r2, #2
240089ba:	4093      	lsls	r3, r2
240089bc:	68ba      	ldr	r2, [r7, #8]
240089be:	429a      	cmp	r2, r3
240089c0:	d136      	bne.n	24008a30 <HAL_GPIO_DeInit+0x144>
      {
        /* Clear EXTI line configuration for Current CPU */
        EXTI_CurrentCPU->IMR1 &= ~(iocurrent);
240089c2:	693b      	ldr	r3, [r7, #16]
240089c4:	681a      	ldr	r2, [r3, #0]
240089c6:	68fb      	ldr	r3, [r7, #12]
240089c8:	43db      	mvns	r3, r3
240089ca:	401a      	ands	r2, r3
240089cc:	693b      	ldr	r3, [r7, #16]
240089ce:	601a      	str	r2, [r3, #0]
        EXTI_CurrentCPU->EMR1 &= ~(iocurrent);
240089d0:	693b      	ldr	r3, [r7, #16]
240089d2:	685a      	ldr	r2, [r3, #4]
240089d4:	68fb      	ldr	r3, [r7, #12]
240089d6:	43db      	mvns	r3, r3
240089d8:	401a      	ands	r2, r3
240089da:	693b      	ldr	r3, [r7, #16]
240089dc:	605a      	str	r2, [r3, #4]

        /* Clear Rising Falling edge configuration */
        EXTI->RTSR1 &= ~(iocurrent);
240089de:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
240089e2:	681a      	ldr	r2, [r3, #0]
240089e4:	68fb      	ldr	r3, [r7, #12]
240089e6:	43db      	mvns	r3, r3
240089e8:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
240089ec:	4013      	ands	r3, r2
240089ee:	600b      	str	r3, [r1, #0]
        EXTI->FTSR1 &= ~(iocurrent);
240089f0:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
240089f4:	685a      	ldr	r2, [r3, #4]
240089f6:	68fb      	ldr	r3, [r7, #12]
240089f8:	43db      	mvns	r3, r3
240089fa:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
240089fe:	4013      	ands	r3, r2
24008a00:	604b      	str	r3, [r1, #4]

        tmp = 0x0FUL << (4U * (position & 0x03U));
24008a02:	697b      	ldr	r3, [r7, #20]
24008a04:	f003 0303 	and.w	r3, r3, #3
24008a08:	009b      	lsls	r3, r3, #2
24008a0a:	220f      	movs	r2, #15
24008a0c:	fa02 f303 	lsl.w	r3, r2, r3
24008a10:	60bb      	str	r3, [r7, #8]
        SYSCFG->EXTICR[position >> 2U] &= ~tmp;
24008a12:	4a30      	ldr	r2, [pc, #192]	; (24008ad4 <HAL_GPIO_DeInit+0x1e8>)
24008a14:	697b      	ldr	r3, [r7, #20]
24008a16:	089b      	lsrs	r3, r3, #2
24008a18:	3302      	adds	r3, #2
24008a1a:	f852 1023 	ldr.w	r1, [r2, r3, lsl #2]
24008a1e:	68bb      	ldr	r3, [r7, #8]
24008a20:	43da      	mvns	r2, r3
24008a22:	482c      	ldr	r0, [pc, #176]	; (24008ad4 <HAL_GPIO_DeInit+0x1e8>)
24008a24:	697b      	ldr	r3, [r7, #20]
24008a26:	089b      	lsrs	r3, r3, #2
24008a28:	400a      	ands	r2, r1
24008a2a:	3302      	adds	r3, #2
24008a2c:	f840 2023 	str.w	r2, [r0, r3, lsl #2]
      }

      /*------------------------- GPIO Mode Configuration --------------------*/
      /* Configure IO in Analog Mode */
      GPIOx->MODER |= (GPIO_MODER_MODE0 << (position * 2U));
24008a30:	687b      	ldr	r3, [r7, #4]
24008a32:	681a      	ldr	r2, [r3, #0]
24008a34:	697b      	ldr	r3, [r7, #20]
24008a36:	005b      	lsls	r3, r3, #1
24008a38:	2103      	movs	r1, #3
24008a3a:	fa01 f303 	lsl.w	r3, r1, r3
24008a3e:	431a      	orrs	r2, r3
24008a40:	687b      	ldr	r3, [r7, #4]
24008a42:	601a      	str	r2, [r3, #0]

      /* Configure the default Alternate Function in current IO */
      GPIOx->AFR[position >> 3U] &= ~(0xFU << ((position & 0x07U) * 4U)) ;
24008a44:	697b      	ldr	r3, [r7, #20]
24008a46:	08da      	lsrs	r2, r3, #3
24008a48:	687b      	ldr	r3, [r7, #4]
24008a4a:	3208      	adds	r2, #8
24008a4c:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
24008a50:	697b      	ldr	r3, [r7, #20]
24008a52:	f003 0307 	and.w	r3, r3, #7
24008a56:	009b      	lsls	r3, r3, #2
24008a58:	220f      	movs	r2, #15
24008a5a:	fa02 f303 	lsl.w	r3, r2, r3
24008a5e:	43db      	mvns	r3, r3
24008a60:	697a      	ldr	r2, [r7, #20]
24008a62:	08d2      	lsrs	r2, r2, #3
24008a64:	4019      	ands	r1, r3
24008a66:	687b      	ldr	r3, [r7, #4]
24008a68:	3208      	adds	r2, #8
24008a6a:	f843 1022 	str.w	r1, [r3, r2, lsl #2]

      /* Deactivate the Pull-up and Pull-down resistor for the current IO */
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
24008a6e:	687b      	ldr	r3, [r7, #4]
24008a70:	68da      	ldr	r2, [r3, #12]
24008a72:	697b      	ldr	r3, [r7, #20]
24008a74:	005b      	lsls	r3, r3, #1
24008a76:	2103      	movs	r1, #3
24008a78:	fa01 f303 	lsl.w	r3, r1, r3
24008a7c:	43db      	mvns	r3, r3
24008a7e:	401a      	ands	r2, r3
24008a80:	687b      	ldr	r3, [r7, #4]
24008a82:	60da      	str	r2, [r3, #12]

      /* Configure the default value IO Output Type */
      GPIOx->OTYPER  &= ~(GPIO_OTYPER_OT0 << position) ;
24008a84:	687b      	ldr	r3, [r7, #4]
24008a86:	685a      	ldr	r2, [r3, #4]
24008a88:	2101      	movs	r1, #1
24008a8a:	697b      	ldr	r3, [r7, #20]
24008a8c:	fa01 f303 	lsl.w	r3, r1, r3
24008a90:	43db      	mvns	r3, r3
24008a92:	401a      	ands	r2, r3
24008a94:	687b      	ldr	r3, [r7, #4]
24008a96:	605a      	str	r2, [r3, #4]

      /* Configure the default value for IO Speed */
      GPIOx->OSPEEDR &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2U));
24008a98:	687b      	ldr	r3, [r7, #4]
24008a9a:	689a      	ldr	r2, [r3, #8]
24008a9c:	697b      	ldr	r3, [r7, #20]
24008a9e:	005b      	lsls	r3, r3, #1
24008aa0:	2103      	movs	r1, #3
24008aa2:	fa01 f303 	lsl.w	r3, r1, r3
24008aa6:	43db      	mvns	r3, r3
24008aa8:	401a      	ands	r2, r3
24008aaa:	687b      	ldr	r3, [r7, #4]
24008aac:	609a      	str	r2, [r3, #8]
    }

    position++;
24008aae:	697b      	ldr	r3, [r7, #20]
24008ab0:	3301      	adds	r3, #1
24008ab2:	617b      	str	r3, [r7, #20]
  while ((GPIO_Pin >> position) != 0x00U)
24008ab4:	683a      	ldr	r2, [r7, #0]
24008ab6:	697b      	ldr	r3, [r7, #20]
24008ab8:	fa22 f303 	lsr.w	r3, r2, r3
24008abc:	2b00      	cmp	r3, #0
24008abe:	f47f af1f 	bne.w	24008900 <HAL_GPIO_DeInit+0x14>
  }
}
24008ac2:	bf00      	nop
24008ac4:	371c      	adds	r7, #28
24008ac6:	46bd      	mov	sp, r7
24008ac8:	f85d 7b04 	ldr.w	r7, [sp], #4
24008acc:	4770      	bx	lr
24008ace:	bf00      	nop
24008ad0:	58000080 	.word	0x58000080
24008ad4:	58000400 	.word	0x58000400
24008ad8:	58020000 	.word	0x58020000
24008adc:	58020400 	.word	0x58020400
24008ae0:	58020800 	.word	0x58020800
24008ae4:	58020c00 	.word	0x58020c00
24008ae8:	58021000 	.word	0x58021000
24008aec:	58021400 	.word	0x58021400
24008af0:	58021800 	.word	0x58021800
24008af4:	58021c00 	.word	0x58021c00
24008af8:	58022000 	.word	0x58022000
24008afc:	58022400 	.word	0x58022400

24008b00 <HAL_GPIO_ReadPin>:
  * @param  GPIO_Pin: specifies the port bit to read.
  *         This parameter can be GPIO_PIN_x where x can be (0..15).
  * @retval The input port pin value.
  */
GPIO_PinState HAL_GPIO_ReadPin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin)
{
24008b00:	b480      	push	{r7}
24008b02:	b085      	sub	sp, #20
24008b04:	af00      	add	r7, sp, #0
24008b06:	6078      	str	r0, [r7, #4]
24008b08:	460b      	mov	r3, r1
24008b0a:	807b      	strh	r3, [r7, #2]
  GPIO_PinState bitstatus;

  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  if ((GPIOx->IDR & GPIO_Pin) != 0x00U)
24008b0c:	687b      	ldr	r3, [r7, #4]
24008b0e:	691a      	ldr	r2, [r3, #16]
24008b10:	887b      	ldrh	r3, [r7, #2]
24008b12:	4013      	ands	r3, r2
24008b14:	2b00      	cmp	r3, #0
24008b16:	d002      	beq.n	24008b1e <HAL_GPIO_ReadPin+0x1e>
  {
    bitstatus = GPIO_PIN_SET;
24008b18:	2301      	movs	r3, #1
24008b1a:	73fb      	strb	r3, [r7, #15]
24008b1c:	e001      	b.n	24008b22 <HAL_GPIO_ReadPin+0x22>
  }
  else
  {
    bitstatus = GPIO_PIN_RESET;
24008b1e:	2300      	movs	r3, #0
24008b20:	73fb      	strb	r3, [r7, #15]
  }
  return bitstatus;
24008b22:	7bfb      	ldrb	r3, [r7, #15]
}
24008b24:	4618      	mov	r0, r3
24008b26:	3714      	adds	r7, #20
24008b28:	46bd      	mov	sp, r7
24008b2a:	f85d 7b04 	ldr.w	r7, [sp], #4
24008b2e:	4770      	bx	lr

24008b30 <HAL_GPIO_WritePin>:
  *            @arg GPIO_PIN_RESET: to clear the port pin
  *            @arg GPIO_PIN_SET: to set the port pin
  * @retval None
  */
void HAL_GPIO_WritePin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState)
{
24008b30:	b480      	push	{r7}
24008b32:	b083      	sub	sp, #12
24008b34:	af00      	add	r7, sp, #0
24008b36:	6078      	str	r0, [r7, #4]
24008b38:	460b      	mov	r3, r1
24008b3a:	807b      	strh	r3, [r7, #2]
24008b3c:	4613      	mov	r3, r2
24008b3e:	707b      	strb	r3, [r7, #1]
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if (PinState != GPIO_PIN_RESET)
24008b40:	787b      	ldrb	r3, [r7, #1]
24008b42:	2b00      	cmp	r3, #0
24008b44:	d003      	beq.n	24008b4e <HAL_GPIO_WritePin+0x1e>
  {
    GPIOx->BSRR = GPIO_Pin;
24008b46:	887a      	ldrh	r2, [r7, #2]
24008b48:	687b      	ldr	r3, [r7, #4]
24008b4a:	619a      	str	r2, [r3, #24]
  }
  else
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin << GPIO_NUMBER;
  }
}
24008b4c:	e003      	b.n	24008b56 <HAL_GPIO_WritePin+0x26>
    GPIOx->BSRR = (uint32_t)GPIO_Pin << GPIO_NUMBER;
24008b4e:	887b      	ldrh	r3, [r7, #2]
24008b50:	041a      	lsls	r2, r3, #16
24008b52:	687b      	ldr	r3, [r7, #4]
24008b54:	619a      	str	r2, [r3, #24]
}
24008b56:	bf00      	nop
24008b58:	370c      	adds	r7, #12
24008b5a:	46bd      	mov	sp, r7
24008b5c:	f85d 7b04 	ldr.w	r7, [sp], #4
24008b60:	4770      	bx	lr

24008b62 <HAL_GPIO_TogglePin>:
  * @param  GPIOx: Where x can be (A..K) to select the GPIO peripheral.
  * @param  GPIO_Pin: Specifies the pins to be toggled.
  * @retval None
  */
void HAL_GPIO_TogglePin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin)
{
24008b62:	b480      	push	{r7}
24008b64:	b083      	sub	sp, #12
24008b66:	af00      	add	r7, sp, #0
24008b68:	6078      	str	r0, [r7, #4]
24008b6a:	460b      	mov	r3, r1
24008b6c:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  if ((GPIOx->ODR & GPIO_Pin) == GPIO_Pin)
24008b6e:	687b      	ldr	r3, [r7, #4]
24008b70:	695a      	ldr	r2, [r3, #20]
24008b72:	887b      	ldrh	r3, [r7, #2]
24008b74:	401a      	ands	r2, r3
24008b76:	887b      	ldrh	r3, [r7, #2]
24008b78:	429a      	cmp	r2, r3
24008b7a:	d104      	bne.n	24008b86 <HAL_GPIO_TogglePin+0x24>
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin << GPIO_NUMBER;
24008b7c:	887b      	ldrh	r3, [r7, #2]
24008b7e:	041a      	lsls	r2, r3, #16
24008b80:	687b      	ldr	r3, [r7, #4]
24008b82:	619a      	str	r2, [r3, #24]
  }
  else
  {
    GPIOx->BSRR = GPIO_Pin;
  }
}
24008b84:	e002      	b.n	24008b8c <HAL_GPIO_TogglePin+0x2a>
    GPIOx->BSRR = GPIO_Pin;
24008b86:	887a      	ldrh	r2, [r7, #2]
24008b88:	687b      	ldr	r3, [r7, #4]
24008b8a:	619a      	str	r2, [r3, #24]
}
24008b8c:	bf00      	nop
24008b8e:	370c      	adds	r7, #12
24008b90:	46bd      	mov	sp, r7
24008b92:	f85d 7b04 	ldr.w	r7, [sp], #4
24008b96:	4770      	bx	lr

24008b98 <HAL_GPIO_LockPin>:
  * @param  GPIO_Pin: specifies the port bit to be locked.
  *         This parameter can be any combination of GPIO_PIN_x where x can be (0..15).
  * @retval None
  */
HAL_StatusTypeDef HAL_GPIO_LockPin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin)
{
24008b98:	b480      	push	{r7}
24008b9a:	b085      	sub	sp, #20
24008b9c:	af00      	add	r7, sp, #0
24008b9e:	6078      	str	r0, [r7, #4]
24008ba0:	460b      	mov	r3, r1
24008ba2:	807b      	strh	r3, [r7, #2]
  __IO uint32_t tmp = GPIO_LCKR_LCKK;
24008ba4:	f44f 3380 	mov.w	r3, #65536	; 0x10000
24008ba8:	60fb      	str	r3, [r7, #12]
  /* Check the parameters */
  assert_param(IS_GPIO_LOCK_INSTANCE(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  /* Apply lock key write sequence */
  tmp |= GPIO_Pin;
24008baa:	887a      	ldrh	r2, [r7, #2]
24008bac:	68fb      	ldr	r3, [r7, #12]
24008bae:	4313      	orrs	r3, r2
24008bb0:	60fb      	str	r3, [r7, #12]
  /* Set LCKx bit(s): LCKK='1' + LCK[15-0] */
  GPIOx->LCKR = tmp;
24008bb2:	68fa      	ldr	r2, [r7, #12]
24008bb4:	687b      	ldr	r3, [r7, #4]
24008bb6:	61da      	str	r2, [r3, #28]
  /* Reset LCKx bit(s): LCKK='0' + LCK[15-0] */
  GPIOx->LCKR = GPIO_Pin;
24008bb8:	887a      	ldrh	r2, [r7, #2]
24008bba:	687b      	ldr	r3, [r7, #4]
24008bbc:	61da      	str	r2, [r3, #28]
  /* Set LCKx bit(s): LCKK='1' + LCK[15-0] */
  GPIOx->LCKR = tmp;
24008bbe:	68fa      	ldr	r2, [r7, #12]
24008bc0:	687b      	ldr	r3, [r7, #4]
24008bc2:	61da      	str	r2, [r3, #28]
  /* Read LCKK register. This read is mandatory to complete key lock sequence*/
  tmp = GPIOx->LCKR;
24008bc4:	687b      	ldr	r3, [r7, #4]
24008bc6:	69db      	ldr	r3, [r3, #28]
24008bc8:	60fb      	str	r3, [r7, #12]

  /* read again in order to confirm lock is active */
  if ((GPIOx->LCKR & GPIO_LCKR_LCKK) != 0x00U)
24008bca:	687b      	ldr	r3, [r7, #4]
24008bcc:	69db      	ldr	r3, [r3, #28]
24008bce:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
24008bd2:	2b00      	cmp	r3, #0
24008bd4:	d001      	beq.n	24008bda <HAL_GPIO_LockPin+0x42>
  {
    return HAL_OK;
24008bd6:	2300      	movs	r3, #0
24008bd8:	e000      	b.n	24008bdc <HAL_GPIO_LockPin+0x44>
  }
  else
  {
    return HAL_ERROR;
24008bda:	2301      	movs	r3, #1
  }
}
24008bdc:	4618      	mov	r0, r3
24008bde:	3714      	adds	r7, #20
24008be0:	46bd      	mov	sp, r7
24008be2:	f85d 7b04 	ldr.w	r7, [sp], #4
24008be6:	4770      	bx	lr

24008be8 <HAL_GPIO_EXTI_IRQHandler>:
  * @brief  Handle EXTI interrupt request.
  * @param  GPIO_Pin: Specifies the port pin connected to corresponding EXTI line.
  * @retval None
  */
void HAL_GPIO_EXTI_IRQHandler(uint16_t GPIO_Pin)
{
24008be8:	b580      	push	{r7, lr}
24008bea:	b082      	sub	sp, #8
24008bec:	af00      	add	r7, sp, #0
24008bee:	4603      	mov	r3, r0
24008bf0:	80fb      	strh	r3, [r7, #6]
    __HAL_GPIO_EXTID2_CLEAR_IT(GPIO_Pin);
    HAL_GPIO_EXTI_Callback(GPIO_Pin);
  }
#else
  /* EXTI line interrupt detected */
  if (__HAL_GPIO_EXTI_GET_IT(GPIO_Pin) != 0x00U)
24008bf2:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
24008bf6:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
24008bfa:	88fb      	ldrh	r3, [r7, #6]
24008bfc:	4013      	ands	r3, r2
24008bfe:	2b00      	cmp	r3, #0
24008c00:	d008      	beq.n	24008c14 <HAL_GPIO_EXTI_IRQHandler+0x2c>
  {
    __HAL_GPIO_EXTI_CLEAR_IT(GPIO_Pin);
24008c02:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
24008c06:	88fb      	ldrh	r3, [r7, #6]
24008c08:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
    HAL_GPIO_EXTI_Callback(GPIO_Pin);
24008c0c:	88fb      	ldrh	r3, [r7, #6]
24008c0e:	4618      	mov	r0, r3
24008c10:	f000 f804 	bl	24008c1c <HAL_GPIO_EXTI_Callback>
  }
#endif
}
24008c14:	bf00      	nop
24008c16:	3708      	adds	r7, #8
24008c18:	46bd      	mov	sp, r7
24008c1a:	bd80      	pop	{r7, pc}

24008c1c <HAL_GPIO_EXTI_Callback>:
  * @brief  EXTI line detection callback.
  * @param  GPIO_Pin: Specifies the port pin connected to corresponding EXTI line.
  * @retval None
  */
__weak void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
{
24008c1c:	b480      	push	{r7}
24008c1e:	b083      	sub	sp, #12
24008c20:	af00      	add	r7, sp, #0
24008c22:	4603      	mov	r3, r0
24008c24:	80fb      	strh	r3, [r7, #6]
  UNUSED(GPIO_Pin);

  /* NOTE: This function Should not be modified, when the callback is needed,
           the HAL_GPIO_EXTI_Callback could be implemented in the user file
   */
}
24008c26:	bf00      	nop
24008c28:	370c      	adds	r7, #12
24008c2a:	46bd      	mov	sp, r7
24008c2c:	f85d 7b04 	ldr.w	r7, [sp], #4
24008c30:	4770      	bx	lr
	...

24008c34 <HAL_HSEM_Take>:
  * @param  SemID: semaphore ID from 0 to 31
  * @param  ProcessID: Process ID from 0 to 255
  * @retval HAL status
  */
HAL_StatusTypeDef  HAL_HSEM_Take(uint32_t SemID, uint32_t ProcessID)
{
24008c34:	b480      	push	{r7}
24008c36:	b083      	sub	sp, #12
24008c38:	af00      	add	r7, sp, #0
24008c3a:	6078      	str	r0, [r7, #4]
24008c3c:	6039      	str	r1, [r7, #0]
    /*take success when MasterID and ProcessID match and take bit set*/
    return HAL_OK;
  }
#else
  /* First step  write R register with MasterID, processID and take bit=1*/
  HSEM->R[SemID] = (ProcessID | HSEM_CR_COREID_CURRENT | HSEM_R_LOCK);
24008c3e:	490c      	ldr	r1, [pc, #48]	; (24008c70 <HAL_HSEM_Take+0x3c>)
24008c40:	683a      	ldr	r2, [r7, #0]
24008c42:	4b0c      	ldr	r3, [pc, #48]	; (24008c74 <HAL_HSEM_Take+0x40>)
24008c44:	4313      	orrs	r3, r2
24008c46:	687a      	ldr	r2, [r7, #4]
24008c48:	f841 3022 	str.w	r3, [r1, r2, lsl #2]

  /* second step : read the R register . Take achieved if MasterID and processID match and take bit set to 1 */
  if (HSEM->R[SemID] == (ProcessID | HSEM_CR_COREID_CURRENT | HSEM_R_LOCK))
24008c4c:	4a08      	ldr	r2, [pc, #32]	; (24008c70 <HAL_HSEM_Take+0x3c>)
24008c4e:	687b      	ldr	r3, [r7, #4]
24008c50:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
24008c54:	6839      	ldr	r1, [r7, #0]
24008c56:	4b07      	ldr	r3, [pc, #28]	; (24008c74 <HAL_HSEM_Take+0x40>)
24008c58:	430b      	orrs	r3, r1
24008c5a:	429a      	cmp	r2, r3
24008c5c:	d101      	bne.n	24008c62 <HAL_HSEM_Take+0x2e>
  {
    /*take success when MasterID and ProcessID match and take bit set*/
    return HAL_OK;
24008c5e:	2300      	movs	r3, #0
24008c60:	e000      	b.n	24008c64 <HAL_HSEM_Take+0x30>
  }
#endif

  /* Semaphore take fails*/
  return HAL_ERROR;
24008c62:	2301      	movs	r3, #1
}
24008c64:	4618      	mov	r0, r3
24008c66:	370c      	adds	r7, #12
24008c68:	46bd      	mov	sp, r7
24008c6a:	f85d 7b04 	ldr.w	r7, [sp], #4
24008c6e:	4770      	bx	lr
24008c70:	58026400 	.word	0x58026400
24008c74:	80000300 	.word	0x80000300

24008c78 <HAL_HSEM_FastTake>:
  * @brief  Fast Take a semaphore with 1 Step mode.
  * @param  SemID: semaphore ID from 0 to 31
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_HSEM_FastTake(uint32_t SemID)
{
24008c78:	b480      	push	{r7}
24008c7a:	b083      	sub	sp, #12
24008c7c:	af00      	add	r7, sp, #0
24008c7e:	6078      	str	r0, [r7, #4]
    /*take success when MasterID match and take bit set*/
    return HAL_OK;
  }
#else
  /* Read the RLR register to take the semaphore */
  if (HSEM->RLR[SemID] == (HSEM_CR_COREID_CURRENT | HSEM_RLR_LOCK))
24008c80:	4a08      	ldr	r2, [pc, #32]	; (24008ca4 <HAL_HSEM_FastTake+0x2c>)
24008c82:	687b      	ldr	r3, [r7, #4]
24008c84:	3320      	adds	r3, #32
24008c86:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
24008c8a:	4a07      	ldr	r2, [pc, #28]	; (24008ca8 <HAL_HSEM_FastTake+0x30>)
24008c8c:	4293      	cmp	r3, r2
24008c8e:	d101      	bne.n	24008c94 <HAL_HSEM_FastTake+0x1c>
  {
    /*take success when MasterID match and take bit set*/
    return HAL_OK;
24008c90:	2300      	movs	r3, #0
24008c92:	e000      	b.n	24008c96 <HAL_HSEM_FastTake+0x1e>
  }
#endif

  /* Semaphore take fails */
  return HAL_ERROR;
24008c94:	2301      	movs	r3, #1
}
24008c96:	4618      	mov	r0, r3
24008c98:	370c      	adds	r7, #12
24008c9a:	46bd      	mov	sp, r7
24008c9c:	f85d 7b04 	ldr.w	r7, [sp], #4
24008ca0:	4770      	bx	lr
24008ca2:	bf00      	nop
24008ca4:	58026400 	.word	0x58026400
24008ca8:	80000300 	.word	0x80000300

24008cac <HAL_HSEM_IsSemTaken>:
  * @brief  Check semaphore state Taken or not.
  * @param  SemID: semaphore ID
  * @retval HAL HSEM state
  */
uint32_t HAL_HSEM_IsSemTaken(uint32_t SemID)
{
24008cac:	b480      	push	{r7}
24008cae:	b083      	sub	sp, #12
24008cb0:	af00      	add	r7, sp, #0
24008cb2:	6078      	str	r0, [r7, #4]
  return (((HSEM->R[SemID] & HSEM_R_LOCK) != 0U) ? 1UL : 0UL);
24008cb4:	4a07      	ldr	r2, [pc, #28]	; (24008cd4 <HAL_HSEM_IsSemTaken+0x28>)
24008cb6:	687b      	ldr	r3, [r7, #4]
24008cb8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
24008cbc:	2b00      	cmp	r3, #0
24008cbe:	da01      	bge.n	24008cc4 <HAL_HSEM_IsSemTaken+0x18>
24008cc0:	2301      	movs	r3, #1
24008cc2:	e000      	b.n	24008cc6 <HAL_HSEM_IsSemTaken+0x1a>
24008cc4:	2300      	movs	r3, #0
}
24008cc6:	4618      	mov	r0, r3
24008cc8:	370c      	adds	r7, #12
24008cca:	46bd      	mov	sp, r7
24008ccc:	f85d 7b04 	ldr.w	r7, [sp], #4
24008cd0:	4770      	bx	lr
24008cd2:	bf00      	nop
24008cd4:	58026400 	.word	0x58026400

24008cd8 <HAL_HSEM_Release>:
  * @param  SemID: semaphore ID from 0 to 31
  * @param  ProcessID: Process ID from 0 to 255
  * @retval None
  */
void  HAL_HSEM_Release(uint32_t SemID, uint32_t ProcessID)
{
24008cd8:	b480      	push	{r7}
24008cda:	b083      	sub	sp, #12
24008cdc:	af00      	add	r7, sp, #0
24008cde:	6078      	str	r0, [r7, #4]
24008ce0:	6039      	str	r1, [r7, #0]

  /* Clear the semaphore by writing to the R register : the MasterID , the processID and take bit = 0  */
#if  USE_MULTI_CORE_SHARED_CODE != 0U
  HSEM->R[SemID] = (ProcessID | ((HAL_GetCurrentCPUID() << POSITION_VAL(HSEM_R_MASTERID)) & HSEM_R_MASTERID));
#else
  HSEM->R[SemID] = (ProcessID | HSEM_CR_COREID_CURRENT);
24008ce2:	4906      	ldr	r1, [pc, #24]	; (24008cfc <HAL_HSEM_Release+0x24>)
24008ce4:	683b      	ldr	r3, [r7, #0]
24008ce6:	f443 7240 	orr.w	r2, r3, #768	; 0x300
24008cea:	687b      	ldr	r3, [r7, #4]
24008cec:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
#endif

}
24008cf0:	bf00      	nop
24008cf2:	370c      	adds	r7, #12
24008cf4:	46bd      	mov	sp, r7
24008cf6:	f85d 7b04 	ldr.w	r7, [sp], #4
24008cfa:	4770      	bx	lr
24008cfc:	58026400 	.word	0x58026400

24008d00 <HAL_HSEM_ReleaseAll>:
  * @param  Key: Semaphore Key , value from 0 to 0xFFFF
  * @param  CoreID: CoreID of the CPU that is using semaphores to be released
  * @retval None
  */
void HAL_HSEM_ReleaseAll(uint32_t Key, uint32_t CoreID)
{
24008d00:	b480      	push	{r7}
24008d02:	b083      	sub	sp, #12
24008d04:	af00      	add	r7, sp, #0
24008d06:	6078      	str	r0, [r7, #4]
24008d08:	6039      	str	r1, [r7, #0]
  assert_param(IS_HSEM_KEY(Key));
  assert_param(IS_HSEM_COREID(CoreID));

  HSEM->CR = ((Key << HSEM_CR_KEY_Pos) | (CoreID << HSEM_CR_COREID_Pos));
24008d0a:	687b      	ldr	r3, [r7, #4]
24008d0c:	041a      	lsls	r2, r3, #16
24008d0e:	683b      	ldr	r3, [r7, #0]
24008d10:	021b      	lsls	r3, r3, #8
24008d12:	4905      	ldr	r1, [pc, #20]	; (24008d28 <HAL_HSEM_ReleaseAll+0x28>)
24008d14:	4313      	orrs	r3, r2
24008d16:	f8c1 3140 	str.w	r3, [r1, #320]	; 0x140
}
24008d1a:	bf00      	nop
24008d1c:	370c      	adds	r7, #12
24008d1e:	46bd      	mov	sp, r7
24008d20:	f85d 7b04 	ldr.w	r7, [sp], #4
24008d24:	4770      	bx	lr
24008d26:	bf00      	nop
24008d28:	58026400 	.word	0x58026400

24008d2c <HAL_HSEM_SetClearKey>:
  * @brief  Set semaphore Key .
  * @param  Key: Semaphore Key , value from 0 to 0xFFFF
  * @retval None
  */
void  HAL_HSEM_SetClearKey(uint32_t Key)
{
24008d2c:	b480      	push	{r7}
24008d2e:	b083      	sub	sp, #12
24008d30:	af00      	add	r7, sp, #0
24008d32:	6078      	str	r0, [r7, #4]
  assert_param(IS_HSEM_KEY(Key));

  MODIFY_REG(HSEM->KEYR, HSEM_KEYR_KEY, (Key << HSEM_KEYR_KEY_Pos));
24008d34:	4b07      	ldr	r3, [pc, #28]	; (24008d54 <HAL_HSEM_SetClearKey+0x28>)
24008d36:	f8d3 3144 	ldr.w	r3, [r3, #324]	; 0x144
24008d3a:	b29a      	uxth	r2, r3
24008d3c:	687b      	ldr	r3, [r7, #4]
24008d3e:	041b      	lsls	r3, r3, #16
24008d40:	4904      	ldr	r1, [pc, #16]	; (24008d54 <HAL_HSEM_SetClearKey+0x28>)
24008d42:	4313      	orrs	r3, r2
24008d44:	f8c1 3144 	str.w	r3, [r1, #324]	; 0x144

}
24008d48:	bf00      	nop
24008d4a:	370c      	adds	r7, #12
24008d4c:	46bd      	mov	sp, r7
24008d4e:	f85d 7b04 	ldr.w	r7, [sp], #4
24008d52:	4770      	bx	lr
24008d54:	58026400 	.word	0x58026400

24008d58 <HAL_HSEM_GetClearKey>:
/**
  * @brief  Get semaphore Key .
  * @retval Semaphore Key , value from 0 to 0xFFFF
  */
uint32_t HAL_HSEM_GetClearKey(void)
{
24008d58:	b480      	push	{r7}
24008d5a:	af00      	add	r7, sp, #0
  return (HSEM->KEYR >> HSEM_KEYR_KEY_Pos);
24008d5c:	4b04      	ldr	r3, [pc, #16]	; (24008d70 <HAL_HSEM_GetClearKey+0x18>)
24008d5e:	f8d3 3144 	ldr.w	r3, [r3, #324]	; 0x144
24008d62:	0c1b      	lsrs	r3, r3, #16
}
24008d64:	4618      	mov	r0, r3
24008d66:	46bd      	mov	sp, r7
24008d68:	f85d 7b04 	ldr.w	r7, [sp], #4
24008d6c:	4770      	bx	lr
24008d6e:	bf00      	nop
24008d70:	58026400 	.word	0x58026400

24008d74 <HAL_HSEM_ActivateNotification>:
  * @brief  Activate Semaphore release Notification for a given Semaphores Mask .
  * @param  SemMask: Mask of Released semaphores
  * @retval Semaphore Key
  */
void HAL_HSEM_ActivateNotification(uint32_t SemMask)
{
24008d74:	b480      	push	{r7}
24008d76:	b083      	sub	sp, #12
24008d78:	af00      	add	r7, sp, #0
24008d7a:	6078      	str	r0, [r7, #4]
  {
    /*Use interrupt line 1 for CPU2 Master*/
    HSEM->C2IER |= SemMask;
  }
#else
  HSEM_COMMON->IER |= SemMask;
24008d7c:	4b05      	ldr	r3, [pc, #20]	; (24008d94 <HAL_HSEM_ActivateNotification+0x20>)
24008d7e:	681a      	ldr	r2, [r3, #0]
24008d80:	4904      	ldr	r1, [pc, #16]	; (24008d94 <HAL_HSEM_ActivateNotification+0x20>)
24008d82:	687b      	ldr	r3, [r7, #4]
24008d84:	4313      	orrs	r3, r2
24008d86:	600b      	str	r3, [r1, #0]
#endif
}
24008d88:	bf00      	nop
24008d8a:	370c      	adds	r7, #12
24008d8c:	46bd      	mov	sp, r7
24008d8e:	f85d 7b04 	ldr.w	r7, [sp], #4
24008d92:	4770      	bx	lr
24008d94:	58026500 	.word	0x58026500

24008d98 <HAL_HSEM_DeactivateNotification>:
  * @brief  Deactivate Semaphore release Notification for a given Semaphores Mask .
  * @param  SemMask: Mask of Released semaphores
  * @retval Semaphore Key
  */
void HAL_HSEM_DeactivateNotification(uint32_t SemMask)
{
24008d98:	b480      	push	{r7}
24008d9a:	b083      	sub	sp, #12
24008d9c:	af00      	add	r7, sp, #0
24008d9e:	6078      	str	r0, [r7, #4]
  {
    /*Use interrupt line 1 for CPU2 Master*/
    HSEM->C2IER &= ~SemMask;
  }
#else
  HSEM_COMMON->IER &= ~SemMask;
24008da0:	4b06      	ldr	r3, [pc, #24]	; (24008dbc <HAL_HSEM_DeactivateNotification+0x24>)
24008da2:	681a      	ldr	r2, [r3, #0]
24008da4:	687b      	ldr	r3, [r7, #4]
24008da6:	43db      	mvns	r3, r3
24008da8:	4904      	ldr	r1, [pc, #16]	; (24008dbc <HAL_HSEM_DeactivateNotification+0x24>)
24008daa:	4013      	ands	r3, r2
24008dac:	600b      	str	r3, [r1, #0]
#endif
}
24008dae:	bf00      	nop
24008db0:	370c      	adds	r7, #12
24008db2:	46bd      	mov	sp, r7
24008db4:	f85d 7b04 	ldr.w	r7, [sp], #4
24008db8:	4770      	bx	lr
24008dba:	bf00      	nop
24008dbc:	58026500 	.word	0x58026500

24008dc0 <HAL_HSEM_IRQHandler>:
/**
  * @brief  This function handles HSEM interrupt request
  * @retval None
  */
void HAL_HSEM_IRQHandler(void)
{
24008dc0:	b580      	push	{r7, lr}
24008dc2:	b082      	sub	sp, #8
24008dc4:	af00      	add	r7, sp, #0
    /*Clear Flags*/
    HSEM->C2ICR = ((uint32_t)statusreg);
  }
#else
  /* Get the list of masked freed semaphores*/
  statusreg = HSEM_COMMON->MISR;
24008dc6:	4b0a      	ldr	r3, [pc, #40]	; (24008df0 <HAL_HSEM_IRQHandler+0x30>)
24008dc8:	68db      	ldr	r3, [r3, #12]
24008dca:	607b      	str	r3, [r7, #4]

  /*Disable Interrupts*/
  HSEM_COMMON->IER &= ~((uint32_t)statusreg);
24008dcc:	4b08      	ldr	r3, [pc, #32]	; (24008df0 <HAL_HSEM_IRQHandler+0x30>)
24008dce:	681a      	ldr	r2, [r3, #0]
24008dd0:	687b      	ldr	r3, [r7, #4]
24008dd2:	43db      	mvns	r3, r3
24008dd4:	4906      	ldr	r1, [pc, #24]	; (24008df0 <HAL_HSEM_IRQHandler+0x30>)
24008dd6:	4013      	ands	r3, r2
24008dd8:	600b      	str	r3, [r1, #0]

  /*Clear Flags*/
  HSEM_COMMON->ICR = ((uint32_t)statusreg);
24008dda:	4a05      	ldr	r2, [pc, #20]	; (24008df0 <HAL_HSEM_IRQHandler+0x30>)
24008ddc:	687b      	ldr	r3, [r7, #4]
24008dde:	6053      	str	r3, [r2, #4]

#endif
  /* Call FreeCallback */
  HAL_HSEM_FreeCallback(statusreg);
24008de0:	6878      	ldr	r0, [r7, #4]
24008de2:	f000 f807 	bl	24008df4 <HAL_HSEM_FreeCallback>
}
24008de6:	bf00      	nop
24008de8:	3708      	adds	r7, #8
24008dea:	46bd      	mov	sp, r7
24008dec:	bd80      	pop	{r7, pc}
24008dee:	bf00      	nop
24008df0:	58026500 	.word	0x58026500

24008df4 <HAL_HSEM_FreeCallback>:
  * @brief Semaphore Released Callback.
  * @param SemMask: Mask of Released semaphores
  * @retval None
  */
__weak void HAL_HSEM_FreeCallback(uint32_t SemMask)
{
24008df4:	b480      	push	{r7}
24008df6:	b083      	sub	sp, #12
24008df8:	af00      	add	r7, sp, #0
24008dfa:	6078      	str	r0, [r7, #4]
  UNUSED(SemMask);

  /* NOTE : This function should not be modified, when the callback is needed,
  the HAL_HSEM_FreeCallback can be implemented in the user file
    */
}
24008dfc:	bf00      	nop
24008dfe:	370c      	adds	r7, #12
24008e00:	46bd      	mov	sp, r7
24008e02:	f85d 7b04 	ldr.w	r7, [sp], #4
24008e06:	4770      	bx	lr

24008e08 <HAL_I2C_Init>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Init(I2C_HandleTypeDef *hi2c)
{
24008e08:	b580      	push	{r7, lr}
24008e0a:	b082      	sub	sp, #8
24008e0c:	af00      	add	r7, sp, #0
24008e0e:	6078      	str	r0, [r7, #4]
  /* Check the I2C handle allocation */
  if (hi2c == NULL)
24008e10:	687b      	ldr	r3, [r7, #4]
24008e12:	2b00      	cmp	r3, #0
24008e14:	d101      	bne.n	24008e1a <HAL_I2C_Init+0x12>
  {
    return HAL_ERROR;
24008e16:	2301      	movs	r3, #1
24008e18:	e07f      	b.n	24008f1a <HAL_I2C_Init+0x112>
  assert_param(IS_I2C_OWN_ADDRESS2(hi2c->Init.OwnAddress2));
  assert_param(IS_I2C_OWN_ADDRESS2_MASK(hi2c->Init.OwnAddress2Masks));
  assert_param(IS_I2C_GENERAL_CALL(hi2c->Init.GeneralCallMode));
  assert_param(IS_I2C_NO_STRETCH(hi2c->Init.NoStretchMode));

  if (hi2c->State == HAL_I2C_STATE_RESET)
24008e1a:	687b      	ldr	r3, [r7, #4]
24008e1c:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
24008e20:	b2db      	uxtb	r3, r3
24008e22:	2b00      	cmp	r3, #0
24008e24:	d106      	bne.n	24008e34 <HAL_I2C_Init+0x2c>
  {
    /* Allocate lock resource and initialize it */
    hi2c->Lock = HAL_UNLOCKED;
24008e26:	687b      	ldr	r3, [r7, #4]
24008e28:	2200      	movs	r2, #0
24008e2a:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Init the low level hardware : GPIO, CLOCK, CORTEX...etc */
    hi2c->MspInitCallback(hi2c);
#else
    /* Init the low level hardware : GPIO, CLOCK, CORTEX...etc */
    HAL_I2C_MspInit(hi2c);
24008e2e:	6878      	ldr	r0, [r7, #4]
24008e30:	f000 f8a9 	bl	24008f86 <HAL_I2C_MspInit>
#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
  }

  hi2c->State = HAL_I2C_STATE_BUSY;
24008e34:	687b      	ldr	r3, [r7, #4]
24008e36:	2224      	movs	r2, #36	; 0x24
24008e38:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

  /* Disable the selected I2C peripheral */
  __HAL_I2C_DISABLE(hi2c);
24008e3c:	687b      	ldr	r3, [r7, #4]
24008e3e:	681b      	ldr	r3, [r3, #0]
24008e40:	681a      	ldr	r2, [r3, #0]
24008e42:	687b      	ldr	r3, [r7, #4]
24008e44:	681b      	ldr	r3, [r3, #0]
24008e46:	f022 0201 	bic.w	r2, r2, #1
24008e4a:	601a      	str	r2, [r3, #0]

  /*---------------------------- I2Cx TIMINGR Configuration ------------------*/
  /* Configure I2Cx: Frequency range */
  hi2c->Instance->TIMINGR = hi2c->Init.Timing & TIMING_CLEAR_MASK;
24008e4c:	687b      	ldr	r3, [r7, #4]
24008e4e:	685a      	ldr	r2, [r3, #4]
24008e50:	687b      	ldr	r3, [r7, #4]
24008e52:	681b      	ldr	r3, [r3, #0]
24008e54:	f022 6270 	bic.w	r2, r2, #251658240	; 0xf000000
24008e58:	611a      	str	r2, [r3, #16]

  /*---------------------------- I2Cx OAR1 Configuration ---------------------*/
  /* Disable Own Address1 before set the Own Address1 configuration */
  hi2c->Instance->OAR1 &= ~I2C_OAR1_OA1EN;
24008e5a:	687b      	ldr	r3, [r7, #4]
24008e5c:	681b      	ldr	r3, [r3, #0]
24008e5e:	689a      	ldr	r2, [r3, #8]
24008e60:	687b      	ldr	r3, [r7, #4]
24008e62:	681b      	ldr	r3, [r3, #0]
24008e64:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
24008e68:	609a      	str	r2, [r3, #8]

  /* Configure I2Cx: Own Address1 and ack own address1 mode */
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
24008e6a:	687b      	ldr	r3, [r7, #4]
24008e6c:	68db      	ldr	r3, [r3, #12]
24008e6e:	2b01      	cmp	r3, #1
24008e70:	d107      	bne.n	24008e82 <HAL_I2C_Init+0x7a>
  {
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | hi2c->Init.OwnAddress1);
24008e72:	687b      	ldr	r3, [r7, #4]
24008e74:	689a      	ldr	r2, [r3, #8]
24008e76:	687b      	ldr	r3, [r7, #4]
24008e78:	681b      	ldr	r3, [r3, #0]
24008e7a:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
24008e7e:	609a      	str	r2, [r3, #8]
24008e80:	e006      	b.n	24008e90 <HAL_I2C_Init+0x88>
  }
  else /* I2C_ADDRESSINGMODE_10BIT */
  {
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | I2C_OAR1_OA1MODE | hi2c->Init.OwnAddress1);
24008e82:	687b      	ldr	r3, [r7, #4]
24008e84:	689a      	ldr	r2, [r3, #8]
24008e86:	687b      	ldr	r3, [r7, #4]
24008e88:	681b      	ldr	r3, [r3, #0]
24008e8a:	f442 4204 	orr.w	r2, r2, #33792	; 0x8400
24008e8e:	609a      	str	r2, [r3, #8]
  }

  /*---------------------------- I2Cx CR2 Configuration ----------------------*/
  /* Configure I2Cx: Addressing Master mode */
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
24008e90:	687b      	ldr	r3, [r7, #4]
24008e92:	68db      	ldr	r3, [r3, #12]
24008e94:	2b02      	cmp	r3, #2
24008e96:	d104      	bne.n	24008ea2 <HAL_I2C_Init+0x9a>
  {
    hi2c->Instance->CR2 = (I2C_CR2_ADD10);
24008e98:	687b      	ldr	r3, [r7, #4]
24008e9a:	681b      	ldr	r3, [r3, #0]
24008e9c:	f44f 6200 	mov.w	r2, #2048	; 0x800
24008ea0:	605a      	str	r2, [r3, #4]
  }
  /* Enable the AUTOEND by default, and enable NACK (should be disable only during Slave process */
  hi2c->Instance->CR2 |= (I2C_CR2_AUTOEND | I2C_CR2_NACK);
24008ea2:	687b      	ldr	r3, [r7, #4]
24008ea4:	681b      	ldr	r3, [r3, #0]
24008ea6:	6859      	ldr	r1, [r3, #4]
24008ea8:	687b      	ldr	r3, [r7, #4]
24008eaa:	681a      	ldr	r2, [r3, #0]
24008eac:	4b1d      	ldr	r3, [pc, #116]	; (24008f24 <HAL_I2C_Init+0x11c>)
24008eae:	430b      	orrs	r3, r1
24008eb0:	6053      	str	r3, [r2, #4]

  /*---------------------------- I2Cx OAR2 Configuration ---------------------*/
  /* Disable Own Address2 before set the Own Address2 configuration */
  hi2c->Instance->OAR2 &= ~I2C_DUALADDRESS_ENABLE;
24008eb2:	687b      	ldr	r3, [r7, #4]
24008eb4:	681b      	ldr	r3, [r3, #0]
24008eb6:	68da      	ldr	r2, [r3, #12]
24008eb8:	687b      	ldr	r3, [r7, #4]
24008eba:	681b      	ldr	r3, [r3, #0]
24008ebc:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
24008ec0:	60da      	str	r2, [r3, #12]

  /* Configure I2Cx: Dual mode and Own Address2 */
  hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2 | (hi2c->Init.OwnAddress2Masks << 8));
24008ec2:	687b      	ldr	r3, [r7, #4]
24008ec4:	691a      	ldr	r2, [r3, #16]
24008ec6:	687b      	ldr	r3, [r7, #4]
24008ec8:	695b      	ldr	r3, [r3, #20]
24008eca:	ea42 0103 	orr.w	r1, r2, r3
24008ece:	687b      	ldr	r3, [r7, #4]
24008ed0:	699b      	ldr	r3, [r3, #24]
24008ed2:	021a      	lsls	r2, r3, #8
24008ed4:	687b      	ldr	r3, [r7, #4]
24008ed6:	681b      	ldr	r3, [r3, #0]
24008ed8:	430a      	orrs	r2, r1
24008eda:	60da      	str	r2, [r3, #12]

  /*---------------------------- I2Cx CR1 Configuration ----------------------*/
  /* Configure I2Cx: Generalcall and NoStretch mode */
  hi2c->Instance->CR1 = (hi2c->Init.GeneralCallMode | hi2c->Init.NoStretchMode);
24008edc:	687b      	ldr	r3, [r7, #4]
24008ede:	69d9      	ldr	r1, [r3, #28]
24008ee0:	687b      	ldr	r3, [r7, #4]
24008ee2:	6a1a      	ldr	r2, [r3, #32]
24008ee4:	687b      	ldr	r3, [r7, #4]
24008ee6:	681b      	ldr	r3, [r3, #0]
24008ee8:	430a      	orrs	r2, r1
24008eea:	601a      	str	r2, [r3, #0]

  /* Enable the selected I2C peripheral */
  __HAL_I2C_ENABLE(hi2c);
24008eec:	687b      	ldr	r3, [r7, #4]
24008eee:	681b      	ldr	r3, [r3, #0]
24008ef0:	681a      	ldr	r2, [r3, #0]
24008ef2:	687b      	ldr	r3, [r7, #4]
24008ef4:	681b      	ldr	r3, [r3, #0]
24008ef6:	f042 0201 	orr.w	r2, r2, #1
24008efa:	601a      	str	r2, [r3, #0]

  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
24008efc:	687b      	ldr	r3, [r7, #4]
24008efe:	2200      	movs	r2, #0
24008f00:	645a      	str	r2, [r3, #68]	; 0x44
  hi2c->State = HAL_I2C_STATE_READY;
24008f02:	687b      	ldr	r3, [r7, #4]
24008f04:	2220      	movs	r2, #32
24008f06:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
  hi2c->PreviousState = I2C_STATE_NONE;
24008f0a:	687b      	ldr	r3, [r7, #4]
24008f0c:	2200      	movs	r2, #0
24008f0e:	631a      	str	r2, [r3, #48]	; 0x30
  hi2c->Mode = HAL_I2C_MODE_NONE;
24008f10:	687b      	ldr	r3, [r7, #4]
24008f12:	2200      	movs	r2, #0
24008f14:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

  return HAL_OK;
24008f18:	2300      	movs	r3, #0
}
24008f1a:	4618      	mov	r0, r3
24008f1c:	3708      	adds	r7, #8
24008f1e:	46bd      	mov	sp, r7
24008f20:	bd80      	pop	{r7, pc}
24008f22:	bf00      	nop
24008f24:	02008000 	.word	0x02008000

24008f28 <HAL_I2C_DeInit>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_DeInit(I2C_HandleTypeDef *hi2c)
{
24008f28:	b580      	push	{r7, lr}
24008f2a:	b082      	sub	sp, #8
24008f2c:	af00      	add	r7, sp, #0
24008f2e:	6078      	str	r0, [r7, #4]
  /* Check the I2C handle allocation */
  if (hi2c == NULL)
24008f30:	687b      	ldr	r3, [r7, #4]
24008f32:	2b00      	cmp	r3, #0
24008f34:	d101      	bne.n	24008f3a <HAL_I2C_DeInit+0x12>
  {
    return HAL_ERROR;
24008f36:	2301      	movs	r3, #1
24008f38:	e021      	b.n	24008f7e <HAL_I2C_DeInit+0x56>
  }

  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));

  hi2c->State = HAL_I2C_STATE_BUSY;
24008f3a:	687b      	ldr	r3, [r7, #4]
24008f3c:	2224      	movs	r2, #36	; 0x24
24008f3e:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

  /* Disable the I2C Peripheral Clock */
  __HAL_I2C_DISABLE(hi2c);
24008f42:	687b      	ldr	r3, [r7, #4]
24008f44:	681b      	ldr	r3, [r3, #0]
24008f46:	681a      	ldr	r2, [r3, #0]
24008f48:	687b      	ldr	r3, [r7, #4]
24008f4a:	681b      	ldr	r3, [r3, #0]
24008f4c:	f022 0201 	bic.w	r2, r2, #1
24008f50:	601a      	str	r2, [r3, #0]

  /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
  hi2c->MspDeInitCallback(hi2c);
#else
  /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
  HAL_I2C_MspDeInit(hi2c);
24008f52:	6878      	ldr	r0, [r7, #4]
24008f54:	f000 f821 	bl	24008f9a <HAL_I2C_MspDeInit>
#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */

  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
24008f58:	687b      	ldr	r3, [r7, #4]
24008f5a:	2200      	movs	r2, #0
24008f5c:	645a      	str	r2, [r3, #68]	; 0x44
  hi2c->State = HAL_I2C_STATE_RESET;
24008f5e:	687b      	ldr	r3, [r7, #4]
24008f60:	2200      	movs	r2, #0
24008f62:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
  hi2c->PreviousState = I2C_STATE_NONE;
24008f66:	687b      	ldr	r3, [r7, #4]
24008f68:	2200      	movs	r2, #0
24008f6a:	631a      	str	r2, [r3, #48]	; 0x30
  hi2c->Mode = HAL_I2C_MODE_NONE;
24008f6c:	687b      	ldr	r3, [r7, #4]
24008f6e:	2200      	movs	r2, #0
24008f70:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

  /* Release Lock */
  __HAL_UNLOCK(hi2c);
24008f74:	687b      	ldr	r3, [r7, #4]
24008f76:	2200      	movs	r2, #0
24008f78:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  return HAL_OK;
24008f7c:	2300      	movs	r3, #0
}
24008f7e:	4618      	mov	r0, r3
24008f80:	3708      	adds	r7, #8
24008f82:	46bd      	mov	sp, r7
24008f84:	bd80      	pop	{r7, pc}

24008f86 <HAL_I2C_MspInit>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
__weak void HAL_I2C_MspInit(I2C_HandleTypeDef *hi2c)
{
24008f86:	b480      	push	{r7}
24008f88:	b083      	sub	sp, #12
24008f8a:	af00      	add	r7, sp, #0
24008f8c:	6078      	str	r0, [r7, #4]
  UNUSED(hi2c);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_MspInit could be implemented in the user file
   */
}
24008f8e:	bf00      	nop
24008f90:	370c      	adds	r7, #12
24008f92:	46bd      	mov	sp, r7
24008f94:	f85d 7b04 	ldr.w	r7, [sp], #4
24008f98:	4770      	bx	lr

24008f9a <HAL_I2C_MspDeInit>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
__weak void HAL_I2C_MspDeInit(I2C_HandleTypeDef *hi2c)
{
24008f9a:	b480      	push	{r7}
24008f9c:	b083      	sub	sp, #12
24008f9e:	af00      	add	r7, sp, #0
24008fa0:	6078      	str	r0, [r7, #4]
  UNUSED(hi2c);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_MspDeInit could be implemented in the user file
   */
}
24008fa2:	bf00      	nop
24008fa4:	370c      	adds	r7, #12
24008fa6:	46bd      	mov	sp, r7
24008fa8:	f85d 7b04 	ldr.w	r7, [sp], #4
24008fac:	4770      	bx	lr
	...

24008fb0 <HAL_I2C_Master_Transmit>:
  * @param  Size Amount of data to be sent
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Master_Transmit(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
24008fb0:	b580      	push	{r7, lr}
24008fb2:	b088      	sub	sp, #32
24008fb4:	af02      	add	r7, sp, #8
24008fb6:	60f8      	str	r0, [r7, #12]
24008fb8:	607a      	str	r2, [r7, #4]
24008fba:	461a      	mov	r2, r3
24008fbc:	460b      	mov	r3, r1
24008fbe:	817b      	strh	r3, [r7, #10]
24008fc0:	4613      	mov	r3, r2
24008fc2:	813b      	strh	r3, [r7, #8]
  uint32_t tickstart;

  if (hi2c->State == HAL_I2C_STATE_READY)
24008fc4:	68fb      	ldr	r3, [r7, #12]
24008fc6:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
24008fca:	b2db      	uxtb	r3, r3
24008fcc:	2b20      	cmp	r3, #32
24008fce:	f040 80da 	bne.w	24009186 <HAL_I2C_Master_Transmit+0x1d6>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
24008fd2:	68fb      	ldr	r3, [r7, #12]
24008fd4:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
24008fd8:	2b01      	cmp	r3, #1
24008fda:	d101      	bne.n	24008fe0 <HAL_I2C_Master_Transmit+0x30>
24008fdc:	2302      	movs	r3, #2
24008fde:	e0d3      	b.n	24009188 <HAL_I2C_Master_Transmit+0x1d8>
24008fe0:	68fb      	ldr	r3, [r7, #12]
24008fe2:	2201      	movs	r2, #1
24008fe4:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Init tickstart for timeout management*/
    tickstart = HAL_GetTick();
24008fe8:	f7f7 fc34 	bl	24000854 <HAL_GetTick>
24008fec:	6178      	str	r0, [r7, #20]

    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
24008fee:	697b      	ldr	r3, [r7, #20]
24008ff0:	9300      	str	r3, [sp, #0]
24008ff2:	2319      	movs	r3, #25
24008ff4:	2201      	movs	r2, #1
24008ff6:	f44f 4100 	mov.w	r1, #32768	; 0x8000
24008ffa:	68f8      	ldr	r0, [r7, #12]
24008ffc:	f004 fd10 	bl	2400da20 <I2C_WaitOnFlagUntilTimeout>
24009000:	4603      	mov	r3, r0
24009002:	2b00      	cmp	r3, #0
24009004:	d001      	beq.n	2400900a <HAL_I2C_Master_Transmit+0x5a>
    {
      return HAL_ERROR;
24009006:	2301      	movs	r3, #1
24009008:	e0be      	b.n	24009188 <HAL_I2C_Master_Transmit+0x1d8>
    }

    hi2c->State     = HAL_I2C_STATE_BUSY_TX;
2400900a:	68fb      	ldr	r3, [r7, #12]
2400900c:	2221      	movs	r2, #33	; 0x21
2400900e:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode      = HAL_I2C_MODE_MASTER;
24009012:	68fb      	ldr	r3, [r7, #12]
24009014:	2210      	movs	r2, #16
24009016:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
2400901a:	68fb      	ldr	r3, [r7, #12]
2400901c:	2200      	movs	r2, #0
2400901e:	645a      	str	r2, [r3, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr  = pData;
24009020:	68fb      	ldr	r3, [r7, #12]
24009022:	687a      	ldr	r2, [r7, #4]
24009024:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount = Size;
24009026:	68fb      	ldr	r3, [r7, #12]
24009028:	893a      	ldrh	r2, [r7, #8]
2400902a:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferISR   = NULL;
2400902c:	68fb      	ldr	r3, [r7, #12]
2400902e:	2200      	movs	r2, #0
24009030:	635a      	str	r2, [r3, #52]	; 0x34

    /* Send Slave Address */
    /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE and generate RESTART */
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
24009032:	68fb      	ldr	r3, [r7, #12]
24009034:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
24009036:	b29b      	uxth	r3, r3
24009038:	2bff      	cmp	r3, #255	; 0xff
2400903a:	d90e      	bls.n	2400905a <HAL_I2C_Master_Transmit+0xaa>
    {
      hi2c->XferSize = MAX_NBYTE_SIZE;
2400903c:	68fb      	ldr	r3, [r7, #12]
2400903e:	22ff      	movs	r2, #255	; 0xff
24009040:	851a      	strh	r2, [r3, #40]	; 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_GENERATE_START_WRITE);
24009042:	68fb      	ldr	r3, [r7, #12]
24009044:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
24009046:	b2da      	uxtb	r2, r3
24009048:	8979      	ldrh	r1, [r7, #10]
2400904a:	4b51      	ldr	r3, [pc, #324]	; (24009190 <HAL_I2C_Master_Transmit+0x1e0>)
2400904c:	9300      	str	r3, [sp, #0]
2400904e:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
24009052:	68f8      	ldr	r0, [r7, #12]
24009054:	f004 fe72 	bl	2400dd3c <I2C_TransferConfig>
24009058:	e06c      	b.n	24009134 <HAL_I2C_Master_Transmit+0x184>
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
2400905a:	68fb      	ldr	r3, [r7, #12]
2400905c:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400905e:	b29a      	uxth	r2, r3
24009060:	68fb      	ldr	r3, [r7, #12]
24009062:	851a      	strh	r2, [r3, #40]	; 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_GENERATE_START_WRITE);
24009064:	68fb      	ldr	r3, [r7, #12]
24009066:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
24009068:	b2da      	uxtb	r2, r3
2400906a:	8979      	ldrh	r1, [r7, #10]
2400906c:	4b48      	ldr	r3, [pc, #288]	; (24009190 <HAL_I2C_Master_Transmit+0x1e0>)
2400906e:	9300      	str	r3, [sp, #0]
24009070:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
24009074:	68f8      	ldr	r0, [r7, #12]
24009076:	f004 fe61 	bl	2400dd3c <I2C_TransferConfig>
    }

    while (hi2c->XferCount > 0U)
2400907a:	e05b      	b.n	24009134 <HAL_I2C_Master_Transmit+0x184>
    {
      /* Wait until TXIS flag is set */
      if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
2400907c:	697a      	ldr	r2, [r7, #20]
2400907e:	6a39      	ldr	r1, [r7, #32]
24009080:	68f8      	ldr	r0, [r7, #12]
24009082:	f004 fd0d 	bl	2400daa0 <I2C_WaitOnTXISFlagUntilTimeout>
24009086:	4603      	mov	r3, r0
24009088:	2b00      	cmp	r3, #0
2400908a:	d001      	beq.n	24009090 <HAL_I2C_Master_Transmit+0xe0>
      {
        return HAL_ERROR;
2400908c:	2301      	movs	r3, #1
2400908e:	e07b      	b.n	24009188 <HAL_I2C_Master_Transmit+0x1d8>
      }
      /* Write data to TXDR */
      hi2c->Instance->TXDR = *hi2c->pBuffPtr;
24009090:	68fb      	ldr	r3, [r7, #12]
24009092:	6a5b      	ldr	r3, [r3, #36]	; 0x24
24009094:	781a      	ldrb	r2, [r3, #0]
24009096:	68fb      	ldr	r3, [r7, #12]
24009098:	681b      	ldr	r3, [r3, #0]
2400909a:	629a      	str	r2, [r3, #40]	; 0x28

      /* Increment Buffer pointer */
      hi2c->pBuffPtr++;
2400909c:	68fb      	ldr	r3, [r7, #12]
2400909e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
240090a0:	1c5a      	adds	r2, r3, #1
240090a2:	68fb      	ldr	r3, [r7, #12]
240090a4:	625a      	str	r2, [r3, #36]	; 0x24

      hi2c->XferCount--;
240090a6:	68fb      	ldr	r3, [r7, #12]
240090a8:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
240090aa:	b29b      	uxth	r3, r3
240090ac:	3b01      	subs	r3, #1
240090ae:	b29a      	uxth	r2, r3
240090b0:	68fb      	ldr	r3, [r7, #12]
240090b2:	855a      	strh	r2, [r3, #42]	; 0x2a
      hi2c->XferSize--;
240090b4:	68fb      	ldr	r3, [r7, #12]
240090b6:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
240090b8:	3b01      	subs	r3, #1
240090ba:	b29a      	uxth	r2, r3
240090bc:	68fb      	ldr	r3, [r7, #12]
240090be:	851a      	strh	r2, [r3, #40]	; 0x28

      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
240090c0:	68fb      	ldr	r3, [r7, #12]
240090c2:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
240090c4:	b29b      	uxth	r3, r3
240090c6:	2b00      	cmp	r3, #0
240090c8:	d034      	beq.n	24009134 <HAL_I2C_Master_Transmit+0x184>
240090ca:	68fb      	ldr	r3, [r7, #12]
240090cc:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
240090ce:	2b00      	cmp	r3, #0
240090d0:	d130      	bne.n	24009134 <HAL_I2C_Master_Transmit+0x184>
      {
        /* Wait until TCR flag is set */
        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, tickstart) != HAL_OK)
240090d2:	697b      	ldr	r3, [r7, #20]
240090d4:	9300      	str	r3, [sp, #0]
240090d6:	6a3b      	ldr	r3, [r7, #32]
240090d8:	2200      	movs	r2, #0
240090da:	2180      	movs	r1, #128	; 0x80
240090dc:	68f8      	ldr	r0, [r7, #12]
240090de:	f004 fc9f 	bl	2400da20 <I2C_WaitOnFlagUntilTimeout>
240090e2:	4603      	mov	r3, r0
240090e4:	2b00      	cmp	r3, #0
240090e6:	d001      	beq.n	240090ec <HAL_I2C_Master_Transmit+0x13c>
        {
          return HAL_ERROR;
240090e8:	2301      	movs	r3, #1
240090ea:	e04d      	b.n	24009188 <HAL_I2C_Master_Transmit+0x1d8>
        }

        if (hi2c->XferCount > MAX_NBYTE_SIZE)
240090ec:	68fb      	ldr	r3, [r7, #12]
240090ee:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
240090f0:	b29b      	uxth	r3, r3
240090f2:	2bff      	cmp	r3, #255	; 0xff
240090f4:	d90e      	bls.n	24009114 <HAL_I2C_Master_Transmit+0x164>
        {
          hi2c->XferSize = MAX_NBYTE_SIZE;
240090f6:	68fb      	ldr	r3, [r7, #12]
240090f8:	22ff      	movs	r2, #255	; 0xff
240090fa:	851a      	strh	r2, [r3, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
240090fc:	68fb      	ldr	r3, [r7, #12]
240090fe:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
24009100:	b2da      	uxtb	r2, r3
24009102:	8979      	ldrh	r1, [r7, #10]
24009104:	2300      	movs	r3, #0
24009106:	9300      	str	r3, [sp, #0]
24009108:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
2400910c:	68f8      	ldr	r0, [r7, #12]
2400910e:	f004 fe15 	bl	2400dd3c <I2C_TransferConfig>
24009112:	e00f      	b.n	24009134 <HAL_I2C_Master_Transmit+0x184>
        }
        else
        {
          hi2c->XferSize = hi2c->XferCount;
24009114:	68fb      	ldr	r3, [r7, #12]
24009116:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
24009118:	b29a      	uxth	r2, r3
2400911a:	68fb      	ldr	r3, [r7, #12]
2400911c:	851a      	strh	r2, [r3, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
2400911e:	68fb      	ldr	r3, [r7, #12]
24009120:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
24009122:	b2da      	uxtb	r2, r3
24009124:	8979      	ldrh	r1, [r7, #10]
24009126:	2300      	movs	r3, #0
24009128:	9300      	str	r3, [sp, #0]
2400912a:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
2400912e:	68f8      	ldr	r0, [r7, #12]
24009130:	f004 fe04 	bl	2400dd3c <I2C_TransferConfig>
    while (hi2c->XferCount > 0U)
24009134:	68fb      	ldr	r3, [r7, #12]
24009136:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
24009138:	b29b      	uxth	r3, r3
2400913a:	2b00      	cmp	r3, #0
2400913c:	d19e      	bne.n	2400907c <HAL_I2C_Master_Transmit+0xcc>
      }
    }

    /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
    /* Wait until STOPF flag is set */
    if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
2400913e:	697a      	ldr	r2, [r7, #20]
24009140:	6a39      	ldr	r1, [r7, #32]
24009142:	68f8      	ldr	r0, [r7, #12]
24009144:	f004 fcec 	bl	2400db20 <I2C_WaitOnSTOPFlagUntilTimeout>
24009148:	4603      	mov	r3, r0
2400914a:	2b00      	cmp	r3, #0
2400914c:	d001      	beq.n	24009152 <HAL_I2C_Master_Transmit+0x1a2>
    {
      return HAL_ERROR;
2400914e:	2301      	movs	r3, #1
24009150:	e01a      	b.n	24009188 <HAL_I2C_Master_Transmit+0x1d8>
    }

    /* Clear STOP Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
24009152:	68fb      	ldr	r3, [r7, #12]
24009154:	681b      	ldr	r3, [r3, #0]
24009156:	2220      	movs	r2, #32
24009158:	61da      	str	r2, [r3, #28]

    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);
2400915a:	68fb      	ldr	r3, [r7, #12]
2400915c:	681b      	ldr	r3, [r3, #0]
2400915e:	6859      	ldr	r1, [r3, #4]
24009160:	68fb      	ldr	r3, [r7, #12]
24009162:	681a      	ldr	r2, [r3, #0]
24009164:	4b0b      	ldr	r3, [pc, #44]	; (24009194 <HAL_I2C_Master_Transmit+0x1e4>)
24009166:	400b      	ands	r3, r1
24009168:	6053      	str	r3, [r2, #4]

    hi2c->State = HAL_I2C_STATE_READY;
2400916a:	68fb      	ldr	r3, [r7, #12]
2400916c:	2220      	movs	r2, #32
2400916e:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode  = HAL_I2C_MODE_NONE;
24009172:	68fb      	ldr	r3, [r7, #12]
24009174:	2200      	movs	r2, #0
24009176:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
2400917a:	68fb      	ldr	r3, [r7, #12]
2400917c:	2200      	movs	r2, #0
2400917e:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    return HAL_OK;
24009182:	2300      	movs	r3, #0
24009184:	e000      	b.n	24009188 <HAL_I2C_Master_Transmit+0x1d8>
  }
  else
  {
    return HAL_BUSY;
24009186:	2302      	movs	r3, #2
  }
}
24009188:	4618      	mov	r0, r3
2400918a:	3718      	adds	r7, #24
2400918c:	46bd      	mov	sp, r7
2400918e:	bd80      	pop	{r7, pc}
24009190:	80002000 	.word	0x80002000
24009194:	fe00e800 	.word	0xfe00e800

24009198 <HAL_I2C_Master_Receive>:
  * @param  Size Amount of data to be sent
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Master_Receive(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
24009198:	b580      	push	{r7, lr}
2400919a:	b088      	sub	sp, #32
2400919c:	af02      	add	r7, sp, #8
2400919e:	60f8      	str	r0, [r7, #12]
240091a0:	607a      	str	r2, [r7, #4]
240091a2:	461a      	mov	r2, r3
240091a4:	460b      	mov	r3, r1
240091a6:	817b      	strh	r3, [r7, #10]
240091a8:	4613      	mov	r3, r2
240091aa:	813b      	strh	r3, [r7, #8]
  uint32_t tickstart;

  if (hi2c->State == HAL_I2C_STATE_READY)
240091ac:	68fb      	ldr	r3, [r7, #12]
240091ae:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
240091b2:	b2db      	uxtb	r3, r3
240091b4:	2b20      	cmp	r3, #32
240091b6:	f040 80db 	bne.w	24009370 <HAL_I2C_Master_Receive+0x1d8>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
240091ba:	68fb      	ldr	r3, [r7, #12]
240091bc:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
240091c0:	2b01      	cmp	r3, #1
240091c2:	d101      	bne.n	240091c8 <HAL_I2C_Master_Receive+0x30>
240091c4:	2302      	movs	r3, #2
240091c6:	e0d4      	b.n	24009372 <HAL_I2C_Master_Receive+0x1da>
240091c8:	68fb      	ldr	r3, [r7, #12]
240091ca:	2201      	movs	r2, #1
240091cc:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Init tickstart for timeout management*/
    tickstart = HAL_GetTick();
240091d0:	f7f7 fb40 	bl	24000854 <HAL_GetTick>
240091d4:	6178      	str	r0, [r7, #20]

    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
240091d6:	697b      	ldr	r3, [r7, #20]
240091d8:	9300      	str	r3, [sp, #0]
240091da:	2319      	movs	r3, #25
240091dc:	2201      	movs	r2, #1
240091de:	f44f 4100 	mov.w	r1, #32768	; 0x8000
240091e2:	68f8      	ldr	r0, [r7, #12]
240091e4:	f004 fc1c 	bl	2400da20 <I2C_WaitOnFlagUntilTimeout>
240091e8:	4603      	mov	r3, r0
240091ea:	2b00      	cmp	r3, #0
240091ec:	d001      	beq.n	240091f2 <HAL_I2C_Master_Receive+0x5a>
    {
      return HAL_ERROR;
240091ee:	2301      	movs	r3, #1
240091f0:	e0bf      	b.n	24009372 <HAL_I2C_Master_Receive+0x1da>
    }

    hi2c->State     = HAL_I2C_STATE_BUSY_RX;
240091f2:	68fb      	ldr	r3, [r7, #12]
240091f4:	2222      	movs	r2, #34	; 0x22
240091f6:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode      = HAL_I2C_MODE_MASTER;
240091fa:	68fb      	ldr	r3, [r7, #12]
240091fc:	2210      	movs	r2, #16
240091fe:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
24009202:	68fb      	ldr	r3, [r7, #12]
24009204:	2200      	movs	r2, #0
24009206:	645a      	str	r2, [r3, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr  = pData;
24009208:	68fb      	ldr	r3, [r7, #12]
2400920a:	687a      	ldr	r2, [r7, #4]
2400920c:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount = Size;
2400920e:	68fb      	ldr	r3, [r7, #12]
24009210:	893a      	ldrh	r2, [r7, #8]
24009212:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferISR   = NULL;
24009214:	68fb      	ldr	r3, [r7, #12]
24009216:	2200      	movs	r2, #0
24009218:	635a      	str	r2, [r3, #52]	; 0x34

    /* Send Slave Address */
    /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE and generate RESTART */
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
2400921a:	68fb      	ldr	r3, [r7, #12]
2400921c:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400921e:	b29b      	uxth	r3, r3
24009220:	2bff      	cmp	r3, #255	; 0xff
24009222:	d90e      	bls.n	24009242 <HAL_I2C_Master_Receive+0xaa>
    {
      hi2c->XferSize = MAX_NBYTE_SIZE;
24009224:	68fb      	ldr	r3, [r7, #12]
24009226:	22ff      	movs	r2, #255	; 0xff
24009228:	851a      	strh	r2, [r3, #40]	; 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_GENERATE_START_READ);
2400922a:	68fb      	ldr	r3, [r7, #12]
2400922c:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400922e:	b2da      	uxtb	r2, r3
24009230:	8979      	ldrh	r1, [r7, #10]
24009232:	4b52      	ldr	r3, [pc, #328]	; (2400937c <HAL_I2C_Master_Receive+0x1e4>)
24009234:	9300      	str	r3, [sp, #0]
24009236:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
2400923a:	68f8      	ldr	r0, [r7, #12]
2400923c:	f004 fd7e 	bl	2400dd3c <I2C_TransferConfig>
24009240:	e06d      	b.n	2400931e <HAL_I2C_Master_Receive+0x186>
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
24009242:	68fb      	ldr	r3, [r7, #12]
24009244:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
24009246:	b29a      	uxth	r2, r3
24009248:	68fb      	ldr	r3, [r7, #12]
2400924a:	851a      	strh	r2, [r3, #40]	; 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_GENERATE_START_READ);
2400924c:	68fb      	ldr	r3, [r7, #12]
2400924e:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
24009250:	b2da      	uxtb	r2, r3
24009252:	8979      	ldrh	r1, [r7, #10]
24009254:	4b49      	ldr	r3, [pc, #292]	; (2400937c <HAL_I2C_Master_Receive+0x1e4>)
24009256:	9300      	str	r3, [sp, #0]
24009258:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
2400925c:	68f8      	ldr	r0, [r7, #12]
2400925e:	f004 fd6d 	bl	2400dd3c <I2C_TransferConfig>
    }

    while (hi2c->XferCount > 0U)
24009262:	e05c      	b.n	2400931e <HAL_I2C_Master_Receive+0x186>
    {
      /* Wait until RXNE flag is set */
      if (I2C_WaitOnRXNEFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
24009264:	697a      	ldr	r2, [r7, #20]
24009266:	6a39      	ldr	r1, [r7, #32]
24009268:	68f8      	ldr	r0, [r7, #12]
2400926a:	f004 fc95 	bl	2400db98 <I2C_WaitOnRXNEFlagUntilTimeout>
2400926e:	4603      	mov	r3, r0
24009270:	2b00      	cmp	r3, #0
24009272:	d001      	beq.n	24009278 <HAL_I2C_Master_Receive+0xe0>
      {
        return HAL_ERROR;
24009274:	2301      	movs	r3, #1
24009276:	e07c      	b.n	24009372 <HAL_I2C_Master_Receive+0x1da>
      }

      /* Read data from RXDR */
      *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
24009278:	68fb      	ldr	r3, [r7, #12]
2400927a:	681b      	ldr	r3, [r3, #0]
2400927c:	6a5a      	ldr	r2, [r3, #36]	; 0x24
2400927e:	68fb      	ldr	r3, [r7, #12]
24009280:	6a5b      	ldr	r3, [r3, #36]	; 0x24
24009282:	b2d2      	uxtb	r2, r2
24009284:	701a      	strb	r2, [r3, #0]

      /* Increment Buffer pointer */
      hi2c->pBuffPtr++;
24009286:	68fb      	ldr	r3, [r7, #12]
24009288:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2400928a:	1c5a      	adds	r2, r3, #1
2400928c:	68fb      	ldr	r3, [r7, #12]
2400928e:	625a      	str	r2, [r3, #36]	; 0x24

      hi2c->XferSize--;
24009290:	68fb      	ldr	r3, [r7, #12]
24009292:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
24009294:	3b01      	subs	r3, #1
24009296:	b29a      	uxth	r2, r3
24009298:	68fb      	ldr	r3, [r7, #12]
2400929a:	851a      	strh	r2, [r3, #40]	; 0x28
      hi2c->XferCount--;
2400929c:	68fb      	ldr	r3, [r7, #12]
2400929e:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
240092a0:	b29b      	uxth	r3, r3
240092a2:	3b01      	subs	r3, #1
240092a4:	b29a      	uxth	r2, r3
240092a6:	68fb      	ldr	r3, [r7, #12]
240092a8:	855a      	strh	r2, [r3, #42]	; 0x2a

      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
240092aa:	68fb      	ldr	r3, [r7, #12]
240092ac:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
240092ae:	b29b      	uxth	r3, r3
240092b0:	2b00      	cmp	r3, #0
240092b2:	d034      	beq.n	2400931e <HAL_I2C_Master_Receive+0x186>
240092b4:	68fb      	ldr	r3, [r7, #12]
240092b6:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
240092b8:	2b00      	cmp	r3, #0
240092ba:	d130      	bne.n	2400931e <HAL_I2C_Master_Receive+0x186>
      {
        /* Wait until TCR flag is set */
        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, tickstart) != HAL_OK)
240092bc:	697b      	ldr	r3, [r7, #20]
240092be:	9300      	str	r3, [sp, #0]
240092c0:	6a3b      	ldr	r3, [r7, #32]
240092c2:	2200      	movs	r2, #0
240092c4:	2180      	movs	r1, #128	; 0x80
240092c6:	68f8      	ldr	r0, [r7, #12]
240092c8:	f004 fbaa 	bl	2400da20 <I2C_WaitOnFlagUntilTimeout>
240092cc:	4603      	mov	r3, r0
240092ce:	2b00      	cmp	r3, #0
240092d0:	d001      	beq.n	240092d6 <HAL_I2C_Master_Receive+0x13e>
        {
          return HAL_ERROR;
240092d2:	2301      	movs	r3, #1
240092d4:	e04d      	b.n	24009372 <HAL_I2C_Master_Receive+0x1da>
        }

        if (hi2c->XferCount > MAX_NBYTE_SIZE)
240092d6:	68fb      	ldr	r3, [r7, #12]
240092d8:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
240092da:	b29b      	uxth	r3, r3
240092dc:	2bff      	cmp	r3, #255	; 0xff
240092de:	d90e      	bls.n	240092fe <HAL_I2C_Master_Receive+0x166>
        {
          hi2c->XferSize = MAX_NBYTE_SIZE;
240092e0:	68fb      	ldr	r3, [r7, #12]
240092e2:	22ff      	movs	r2, #255	; 0xff
240092e4:	851a      	strh	r2, [r3, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
240092e6:	68fb      	ldr	r3, [r7, #12]
240092e8:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
240092ea:	b2da      	uxtb	r2, r3
240092ec:	8979      	ldrh	r1, [r7, #10]
240092ee:	2300      	movs	r3, #0
240092f0:	9300      	str	r3, [sp, #0]
240092f2:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
240092f6:	68f8      	ldr	r0, [r7, #12]
240092f8:	f004 fd20 	bl	2400dd3c <I2C_TransferConfig>
240092fc:	e00f      	b.n	2400931e <HAL_I2C_Master_Receive+0x186>
        }
        else
        {
          hi2c->XferSize = hi2c->XferCount;
240092fe:	68fb      	ldr	r3, [r7, #12]
24009300:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
24009302:	b29a      	uxth	r2, r3
24009304:	68fb      	ldr	r3, [r7, #12]
24009306:	851a      	strh	r2, [r3, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
24009308:	68fb      	ldr	r3, [r7, #12]
2400930a:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400930c:	b2da      	uxtb	r2, r3
2400930e:	8979      	ldrh	r1, [r7, #10]
24009310:	2300      	movs	r3, #0
24009312:	9300      	str	r3, [sp, #0]
24009314:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
24009318:	68f8      	ldr	r0, [r7, #12]
2400931a:	f004 fd0f 	bl	2400dd3c <I2C_TransferConfig>
    while (hi2c->XferCount > 0U)
2400931e:	68fb      	ldr	r3, [r7, #12]
24009320:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
24009322:	b29b      	uxth	r3, r3
24009324:	2b00      	cmp	r3, #0
24009326:	d19d      	bne.n	24009264 <HAL_I2C_Master_Receive+0xcc>
      }
    }

    /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
    /* Wait until STOPF flag is set */
    if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
24009328:	697a      	ldr	r2, [r7, #20]
2400932a:	6a39      	ldr	r1, [r7, #32]
2400932c:	68f8      	ldr	r0, [r7, #12]
2400932e:	f004 fbf7 	bl	2400db20 <I2C_WaitOnSTOPFlagUntilTimeout>
24009332:	4603      	mov	r3, r0
24009334:	2b00      	cmp	r3, #0
24009336:	d001      	beq.n	2400933c <HAL_I2C_Master_Receive+0x1a4>
    {
      return HAL_ERROR;
24009338:	2301      	movs	r3, #1
2400933a:	e01a      	b.n	24009372 <HAL_I2C_Master_Receive+0x1da>
    }

    /* Clear STOP Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
2400933c:	68fb      	ldr	r3, [r7, #12]
2400933e:	681b      	ldr	r3, [r3, #0]
24009340:	2220      	movs	r2, #32
24009342:	61da      	str	r2, [r3, #28]

    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);
24009344:	68fb      	ldr	r3, [r7, #12]
24009346:	681b      	ldr	r3, [r3, #0]
24009348:	6859      	ldr	r1, [r3, #4]
2400934a:	68fb      	ldr	r3, [r7, #12]
2400934c:	681a      	ldr	r2, [r3, #0]
2400934e:	4b0c      	ldr	r3, [pc, #48]	; (24009380 <HAL_I2C_Master_Receive+0x1e8>)
24009350:	400b      	ands	r3, r1
24009352:	6053      	str	r3, [r2, #4]

    hi2c->State = HAL_I2C_STATE_READY;
24009354:	68fb      	ldr	r3, [r7, #12]
24009356:	2220      	movs	r2, #32
24009358:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode  = HAL_I2C_MODE_NONE;
2400935c:	68fb      	ldr	r3, [r7, #12]
2400935e:	2200      	movs	r2, #0
24009360:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
24009364:	68fb      	ldr	r3, [r7, #12]
24009366:	2200      	movs	r2, #0
24009368:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    return HAL_OK;
2400936c:	2300      	movs	r3, #0
2400936e:	e000      	b.n	24009372 <HAL_I2C_Master_Receive+0x1da>
  }
  else
  {
    return HAL_BUSY;
24009370:	2302      	movs	r3, #2
  }
}
24009372:	4618      	mov	r0, r3
24009374:	3718      	adds	r7, #24
24009376:	46bd      	mov	sp, r7
24009378:	bd80      	pop	{r7, pc}
2400937a:	bf00      	nop
2400937c:	80002400 	.word	0x80002400
24009380:	fe00e800 	.word	0xfe00e800

24009384 <HAL_I2C_Slave_Transmit>:
  * @param  Size Amount of data to be sent
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Slave_Transmit(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
24009384:	b580      	push	{r7, lr}
24009386:	b088      	sub	sp, #32
24009388:	af02      	add	r7, sp, #8
2400938a:	60f8      	str	r0, [r7, #12]
2400938c:	60b9      	str	r1, [r7, #8]
2400938e:	603b      	str	r3, [r7, #0]
24009390:	4613      	mov	r3, r2
24009392:	80fb      	strh	r3, [r7, #6]
  uint32_t tickstart;

  if (hi2c->State == HAL_I2C_STATE_READY)
24009394:	68fb      	ldr	r3, [r7, #12]
24009396:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400939a:	b2db      	uxtb	r3, r3
2400939c:	2b20      	cmp	r3, #32
2400939e:	f040 80f5 	bne.w	2400958c <HAL_I2C_Slave_Transmit+0x208>
  {
    if ((pData == NULL) || (Size == 0U))
240093a2:	68bb      	ldr	r3, [r7, #8]
240093a4:	2b00      	cmp	r3, #0
240093a6:	d002      	beq.n	240093ae <HAL_I2C_Slave_Transmit+0x2a>
240093a8:	88fb      	ldrh	r3, [r7, #6]
240093aa:	2b00      	cmp	r3, #0
240093ac:	d105      	bne.n	240093ba <HAL_I2C_Slave_Transmit+0x36>
    {
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
240093ae:	68fb      	ldr	r3, [r7, #12]
240093b0:	f44f 7200 	mov.w	r2, #512	; 0x200
240093b4:	645a      	str	r2, [r3, #68]	; 0x44
      return  HAL_ERROR;
240093b6:	2301      	movs	r3, #1
240093b8:	e0e9      	b.n	2400958e <HAL_I2C_Slave_Transmit+0x20a>
    }
    /* Process Locked */
    __HAL_LOCK(hi2c);
240093ba:	68fb      	ldr	r3, [r7, #12]
240093bc:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
240093c0:	2b01      	cmp	r3, #1
240093c2:	d101      	bne.n	240093c8 <HAL_I2C_Slave_Transmit+0x44>
240093c4:	2302      	movs	r3, #2
240093c6:	e0e2      	b.n	2400958e <HAL_I2C_Slave_Transmit+0x20a>
240093c8:	68fb      	ldr	r3, [r7, #12]
240093ca:	2201      	movs	r2, #1
240093cc:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Init tickstart for timeout management*/
    tickstart = HAL_GetTick();
240093d0:	f7f7 fa40 	bl	24000854 <HAL_GetTick>
240093d4:	6178      	str	r0, [r7, #20]

    hi2c->State     = HAL_I2C_STATE_BUSY_TX;
240093d6:	68fb      	ldr	r3, [r7, #12]
240093d8:	2221      	movs	r2, #33	; 0x21
240093da:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode      = HAL_I2C_MODE_SLAVE;
240093de:	68fb      	ldr	r3, [r7, #12]
240093e0:	2220      	movs	r2, #32
240093e2:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
240093e6:	68fb      	ldr	r3, [r7, #12]
240093e8:	2200      	movs	r2, #0
240093ea:	645a      	str	r2, [r3, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr  = pData;
240093ec:	68fb      	ldr	r3, [r7, #12]
240093ee:	68ba      	ldr	r2, [r7, #8]
240093f0:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount = Size;
240093f2:	68fb      	ldr	r3, [r7, #12]
240093f4:	88fa      	ldrh	r2, [r7, #6]
240093f6:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferISR   = NULL;
240093f8:	68fb      	ldr	r3, [r7, #12]
240093fa:	2200      	movs	r2, #0
240093fc:	635a      	str	r2, [r3, #52]	; 0x34

    /* Enable Address Acknowledge */
    hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
240093fe:	68fb      	ldr	r3, [r7, #12]
24009400:	681b      	ldr	r3, [r3, #0]
24009402:	685a      	ldr	r2, [r3, #4]
24009404:	68fb      	ldr	r3, [r7, #12]
24009406:	681b      	ldr	r3, [r3, #0]
24009408:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
2400940c:	605a      	str	r2, [r3, #4]

    /* Wait until ADDR flag is set */
    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, RESET, Timeout, tickstart) != HAL_OK)
2400940e:	697b      	ldr	r3, [r7, #20]
24009410:	9300      	str	r3, [sp, #0]
24009412:	683b      	ldr	r3, [r7, #0]
24009414:	2200      	movs	r2, #0
24009416:	2108      	movs	r1, #8
24009418:	68f8      	ldr	r0, [r7, #12]
2400941a:	f004 fb01 	bl	2400da20 <I2C_WaitOnFlagUntilTimeout>
2400941e:	4603      	mov	r3, r0
24009420:	2b00      	cmp	r3, #0
24009422:	d009      	beq.n	24009438 <HAL_I2C_Slave_Transmit+0xb4>
    {
      /* Disable Address Acknowledge */
      hi2c->Instance->CR2 |= I2C_CR2_NACK;
24009424:	68fb      	ldr	r3, [r7, #12]
24009426:	681b      	ldr	r3, [r3, #0]
24009428:	685a      	ldr	r2, [r3, #4]
2400942a:	68fb      	ldr	r3, [r7, #12]
2400942c:	681b      	ldr	r3, [r3, #0]
2400942e:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
24009432:	605a      	str	r2, [r3, #4]
      return HAL_ERROR;
24009434:	2301      	movs	r3, #1
24009436:	e0aa      	b.n	2400958e <HAL_I2C_Slave_Transmit+0x20a>
    }

    /* Clear ADDR flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
24009438:	68fb      	ldr	r3, [r7, #12]
2400943a:	681b      	ldr	r3, [r3, #0]
2400943c:	2208      	movs	r2, #8
2400943e:	61da      	str	r2, [r3, #28]

    /* If 10bit addressing mode is selected */
    if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
24009440:	68fb      	ldr	r3, [r7, #12]
24009442:	68db      	ldr	r3, [r3, #12]
24009444:	2b02      	cmp	r3, #2
24009446:	d118      	bne.n	2400947a <HAL_I2C_Slave_Transmit+0xf6>
    {
      /* Wait until ADDR flag is set */
      if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, RESET, Timeout, tickstart) != HAL_OK)
24009448:	697b      	ldr	r3, [r7, #20]
2400944a:	9300      	str	r3, [sp, #0]
2400944c:	683b      	ldr	r3, [r7, #0]
2400944e:	2200      	movs	r2, #0
24009450:	2108      	movs	r1, #8
24009452:	68f8      	ldr	r0, [r7, #12]
24009454:	f004 fae4 	bl	2400da20 <I2C_WaitOnFlagUntilTimeout>
24009458:	4603      	mov	r3, r0
2400945a:	2b00      	cmp	r3, #0
2400945c:	d009      	beq.n	24009472 <HAL_I2C_Slave_Transmit+0xee>
      {
        /* Disable Address Acknowledge */
        hi2c->Instance->CR2 |= I2C_CR2_NACK;
2400945e:	68fb      	ldr	r3, [r7, #12]
24009460:	681b      	ldr	r3, [r3, #0]
24009462:	685a      	ldr	r2, [r3, #4]
24009464:	68fb      	ldr	r3, [r7, #12]
24009466:	681b      	ldr	r3, [r3, #0]
24009468:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
2400946c:	605a      	str	r2, [r3, #4]
        return HAL_ERROR;
2400946e:	2301      	movs	r3, #1
24009470:	e08d      	b.n	2400958e <HAL_I2C_Slave_Transmit+0x20a>
      }

      /* Clear ADDR flag */
      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
24009472:	68fb      	ldr	r3, [r7, #12]
24009474:	681b      	ldr	r3, [r3, #0]
24009476:	2208      	movs	r2, #8
24009478:	61da      	str	r2, [r3, #28]
    }

    /* Wait until DIR flag is set Transmitter mode */
    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_DIR, RESET, Timeout, tickstart) != HAL_OK)
2400947a:	697b      	ldr	r3, [r7, #20]
2400947c:	9300      	str	r3, [sp, #0]
2400947e:	683b      	ldr	r3, [r7, #0]
24009480:	2200      	movs	r2, #0
24009482:	f44f 3180 	mov.w	r1, #65536	; 0x10000
24009486:	68f8      	ldr	r0, [r7, #12]
24009488:	f004 faca 	bl	2400da20 <I2C_WaitOnFlagUntilTimeout>
2400948c:	4603      	mov	r3, r0
2400948e:	2b00      	cmp	r3, #0
24009490:	d02d      	beq.n	240094ee <HAL_I2C_Slave_Transmit+0x16a>
    {
      /* Disable Address Acknowledge */
      hi2c->Instance->CR2 |= I2C_CR2_NACK;
24009492:	68fb      	ldr	r3, [r7, #12]
24009494:	681b      	ldr	r3, [r3, #0]
24009496:	685a      	ldr	r2, [r3, #4]
24009498:	68fb      	ldr	r3, [r7, #12]
2400949a:	681b      	ldr	r3, [r3, #0]
2400949c:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
240094a0:	605a      	str	r2, [r3, #4]
      return HAL_ERROR;
240094a2:	2301      	movs	r3, #1
240094a4:	e073      	b.n	2400958e <HAL_I2C_Slave_Transmit+0x20a>
    }

    while (hi2c->XferCount > 0U)
    {
      /* Wait until TXIS flag is set */
      if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
240094a6:	697a      	ldr	r2, [r7, #20]
240094a8:	6839      	ldr	r1, [r7, #0]
240094aa:	68f8      	ldr	r0, [r7, #12]
240094ac:	f004 faf8 	bl	2400daa0 <I2C_WaitOnTXISFlagUntilTimeout>
240094b0:	4603      	mov	r3, r0
240094b2:	2b00      	cmp	r3, #0
240094b4:	d009      	beq.n	240094ca <HAL_I2C_Slave_Transmit+0x146>
      {
        /* Disable Address Acknowledge */
        hi2c->Instance->CR2 |= I2C_CR2_NACK;
240094b6:	68fb      	ldr	r3, [r7, #12]
240094b8:	681b      	ldr	r3, [r3, #0]
240094ba:	685a      	ldr	r2, [r3, #4]
240094bc:	68fb      	ldr	r3, [r7, #12]
240094be:	681b      	ldr	r3, [r3, #0]
240094c0:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
240094c4:	605a      	str	r2, [r3, #4]
        return HAL_ERROR;
240094c6:	2301      	movs	r3, #1
240094c8:	e061      	b.n	2400958e <HAL_I2C_Slave_Transmit+0x20a>
      }

      /* Write data to TXDR */
      hi2c->Instance->TXDR = *hi2c->pBuffPtr;
240094ca:	68fb      	ldr	r3, [r7, #12]
240094cc:	6a5b      	ldr	r3, [r3, #36]	; 0x24
240094ce:	781a      	ldrb	r2, [r3, #0]
240094d0:	68fb      	ldr	r3, [r7, #12]
240094d2:	681b      	ldr	r3, [r3, #0]
240094d4:	629a      	str	r2, [r3, #40]	; 0x28

      /* Increment Buffer pointer */
      hi2c->pBuffPtr++;
240094d6:	68fb      	ldr	r3, [r7, #12]
240094d8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
240094da:	1c5a      	adds	r2, r3, #1
240094dc:	68fb      	ldr	r3, [r7, #12]
240094de:	625a      	str	r2, [r3, #36]	; 0x24

      hi2c->XferCount--;
240094e0:	68fb      	ldr	r3, [r7, #12]
240094e2:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
240094e4:	b29b      	uxth	r3, r3
240094e6:	3b01      	subs	r3, #1
240094e8:	b29a      	uxth	r2, r3
240094ea:	68fb      	ldr	r3, [r7, #12]
240094ec:	855a      	strh	r2, [r3, #42]	; 0x2a
    while (hi2c->XferCount > 0U)
240094ee:	68fb      	ldr	r3, [r7, #12]
240094f0:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
240094f2:	b29b      	uxth	r3, r3
240094f4:	2b00      	cmp	r3, #0
240094f6:	d1d6      	bne.n	240094a6 <HAL_I2C_Slave_Transmit+0x122>
    }

    /* Wait until STOP flag is set */
    if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
240094f8:	697a      	ldr	r2, [r7, #20]
240094fa:	6839      	ldr	r1, [r7, #0]
240094fc:	68f8      	ldr	r0, [r7, #12]
240094fe:	f004 fb0f 	bl	2400db20 <I2C_WaitOnSTOPFlagUntilTimeout>
24009502:	4603      	mov	r3, r0
24009504:	2b00      	cmp	r3, #0
24009506:	d011      	beq.n	2400952c <HAL_I2C_Slave_Transmit+0x1a8>
    {
      /* Disable Address Acknowledge */
      hi2c->Instance->CR2 |= I2C_CR2_NACK;
24009508:	68fb      	ldr	r3, [r7, #12]
2400950a:	681b      	ldr	r3, [r3, #0]
2400950c:	685a      	ldr	r2, [r3, #4]
2400950e:	68fb      	ldr	r3, [r7, #12]
24009510:	681b      	ldr	r3, [r3, #0]
24009512:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
24009516:	605a      	str	r2, [r3, #4]

      if (hi2c->ErrorCode == HAL_I2C_ERROR_AF)
24009518:	68fb      	ldr	r3, [r7, #12]
2400951a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400951c:	2b04      	cmp	r3, #4
2400951e:	d103      	bne.n	24009528 <HAL_I2C_Slave_Transmit+0x1a4>
      {
        /* Normal use case for Transmitter mode */
        /* A NACK is generated to confirm the end of transfer */
        hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
24009520:	68fb      	ldr	r3, [r7, #12]
24009522:	2200      	movs	r2, #0
24009524:	645a      	str	r2, [r3, #68]	; 0x44
24009526:	e001      	b.n	2400952c <HAL_I2C_Slave_Transmit+0x1a8>
      }
      else
      {
        return HAL_ERROR;
24009528:	2301      	movs	r3, #1
2400952a:	e030      	b.n	2400958e <HAL_I2C_Slave_Transmit+0x20a>
      }
    }

    /* Clear STOP flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
2400952c:	68fb      	ldr	r3, [r7, #12]
2400952e:	681b      	ldr	r3, [r3, #0]
24009530:	2220      	movs	r2, #32
24009532:	61da      	str	r2, [r3, #28]

    /* Wait until BUSY flag is reset */
    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, Timeout, tickstart) != HAL_OK)
24009534:	697b      	ldr	r3, [r7, #20]
24009536:	9300      	str	r3, [sp, #0]
24009538:	683b      	ldr	r3, [r7, #0]
2400953a:	2201      	movs	r2, #1
2400953c:	f44f 4100 	mov.w	r1, #32768	; 0x8000
24009540:	68f8      	ldr	r0, [r7, #12]
24009542:	f004 fa6d 	bl	2400da20 <I2C_WaitOnFlagUntilTimeout>
24009546:	4603      	mov	r3, r0
24009548:	2b00      	cmp	r3, #0
2400954a:	d009      	beq.n	24009560 <HAL_I2C_Slave_Transmit+0x1dc>
    {
      /* Disable Address Acknowledge */
      hi2c->Instance->CR2 |= I2C_CR2_NACK;
2400954c:	68fb      	ldr	r3, [r7, #12]
2400954e:	681b      	ldr	r3, [r3, #0]
24009550:	685a      	ldr	r2, [r3, #4]
24009552:	68fb      	ldr	r3, [r7, #12]
24009554:	681b      	ldr	r3, [r3, #0]
24009556:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
2400955a:	605a      	str	r2, [r3, #4]
      return HAL_ERROR;
2400955c:	2301      	movs	r3, #1
2400955e:	e016      	b.n	2400958e <HAL_I2C_Slave_Transmit+0x20a>
    }

    /* Disable Address Acknowledge */
    hi2c->Instance->CR2 |= I2C_CR2_NACK;
24009560:	68fb      	ldr	r3, [r7, #12]
24009562:	681b      	ldr	r3, [r3, #0]
24009564:	685a      	ldr	r2, [r3, #4]
24009566:	68fb      	ldr	r3, [r7, #12]
24009568:	681b      	ldr	r3, [r3, #0]
2400956a:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
2400956e:	605a      	str	r2, [r3, #4]

    hi2c->State = HAL_I2C_STATE_READY;
24009570:	68fb      	ldr	r3, [r7, #12]
24009572:	2220      	movs	r2, #32
24009574:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode  = HAL_I2C_MODE_NONE;
24009578:	68fb      	ldr	r3, [r7, #12]
2400957a:	2200      	movs	r2, #0
2400957c:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
24009580:	68fb      	ldr	r3, [r7, #12]
24009582:	2200      	movs	r2, #0
24009584:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    return HAL_OK;
24009588:	2300      	movs	r3, #0
2400958a:	e000      	b.n	2400958e <HAL_I2C_Slave_Transmit+0x20a>
  }
  else
  {
    return HAL_BUSY;
2400958c:	2302      	movs	r3, #2
  }
}
2400958e:	4618      	mov	r0, r3
24009590:	3718      	adds	r7, #24
24009592:	46bd      	mov	sp, r7
24009594:	bd80      	pop	{r7, pc}

24009596 <HAL_I2C_Slave_Receive>:
  * @param  Size Amount of data to be sent
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Slave_Receive(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
24009596:	b580      	push	{r7, lr}
24009598:	b088      	sub	sp, #32
2400959a:	af02      	add	r7, sp, #8
2400959c:	60f8      	str	r0, [r7, #12]
2400959e:	60b9      	str	r1, [r7, #8]
240095a0:	603b      	str	r3, [r7, #0]
240095a2:	4613      	mov	r3, r2
240095a4:	80fb      	strh	r3, [r7, #6]
  uint32_t tickstart;

  if (hi2c->State == HAL_I2C_STATE_READY)
240095a6:	68fb      	ldr	r3, [r7, #12]
240095a8:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
240095ac:	b2db      	uxtb	r3, r3
240095ae:	2b20      	cmp	r3, #32
240095b0:	f040 80eb 	bne.w	2400978a <HAL_I2C_Slave_Receive+0x1f4>
  {
    if ((pData == NULL) || (Size == 0U))
240095b4:	68bb      	ldr	r3, [r7, #8]
240095b6:	2b00      	cmp	r3, #0
240095b8:	d002      	beq.n	240095c0 <HAL_I2C_Slave_Receive+0x2a>
240095ba:	88fb      	ldrh	r3, [r7, #6]
240095bc:	2b00      	cmp	r3, #0
240095be:	d105      	bne.n	240095cc <HAL_I2C_Slave_Receive+0x36>
    {
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
240095c0:	68fb      	ldr	r3, [r7, #12]
240095c2:	f44f 7200 	mov.w	r2, #512	; 0x200
240095c6:	645a      	str	r2, [r3, #68]	; 0x44
      return  HAL_ERROR;
240095c8:	2301      	movs	r3, #1
240095ca:	e0df      	b.n	2400978c <HAL_I2C_Slave_Receive+0x1f6>
    }
    /* Process Locked */
    __HAL_LOCK(hi2c);
240095cc:	68fb      	ldr	r3, [r7, #12]
240095ce:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
240095d2:	2b01      	cmp	r3, #1
240095d4:	d101      	bne.n	240095da <HAL_I2C_Slave_Receive+0x44>
240095d6:	2302      	movs	r3, #2
240095d8:	e0d8      	b.n	2400978c <HAL_I2C_Slave_Receive+0x1f6>
240095da:	68fb      	ldr	r3, [r7, #12]
240095dc:	2201      	movs	r2, #1
240095de:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Init tickstart for timeout management*/
    tickstart = HAL_GetTick();
240095e2:	f7f7 f937 	bl	24000854 <HAL_GetTick>
240095e6:	6178      	str	r0, [r7, #20]

    hi2c->State     = HAL_I2C_STATE_BUSY_RX;
240095e8:	68fb      	ldr	r3, [r7, #12]
240095ea:	2222      	movs	r2, #34	; 0x22
240095ec:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode      = HAL_I2C_MODE_SLAVE;
240095f0:	68fb      	ldr	r3, [r7, #12]
240095f2:	2220      	movs	r2, #32
240095f4:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
240095f8:	68fb      	ldr	r3, [r7, #12]
240095fa:	2200      	movs	r2, #0
240095fc:	645a      	str	r2, [r3, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr  = pData;
240095fe:	68fb      	ldr	r3, [r7, #12]
24009600:	68ba      	ldr	r2, [r7, #8]
24009602:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount = Size;
24009604:	68fb      	ldr	r3, [r7, #12]
24009606:	88fa      	ldrh	r2, [r7, #6]
24009608:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferISR   = NULL;
2400960a:	68fb      	ldr	r3, [r7, #12]
2400960c:	2200      	movs	r2, #0
2400960e:	635a      	str	r2, [r3, #52]	; 0x34

    /* Enable Address Acknowledge */
    hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
24009610:	68fb      	ldr	r3, [r7, #12]
24009612:	681b      	ldr	r3, [r3, #0]
24009614:	685a      	ldr	r2, [r3, #4]
24009616:	68fb      	ldr	r3, [r7, #12]
24009618:	681b      	ldr	r3, [r3, #0]
2400961a:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
2400961e:	605a      	str	r2, [r3, #4]

    /* Wait until ADDR flag is set */
    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, RESET, Timeout, tickstart) != HAL_OK)
24009620:	697b      	ldr	r3, [r7, #20]
24009622:	9300      	str	r3, [sp, #0]
24009624:	683b      	ldr	r3, [r7, #0]
24009626:	2200      	movs	r2, #0
24009628:	2108      	movs	r1, #8
2400962a:	68f8      	ldr	r0, [r7, #12]
2400962c:	f004 f9f8 	bl	2400da20 <I2C_WaitOnFlagUntilTimeout>
24009630:	4603      	mov	r3, r0
24009632:	2b00      	cmp	r3, #0
24009634:	d009      	beq.n	2400964a <HAL_I2C_Slave_Receive+0xb4>
    {
      /* Disable Address Acknowledge */
      hi2c->Instance->CR2 |= I2C_CR2_NACK;
24009636:	68fb      	ldr	r3, [r7, #12]
24009638:	681b      	ldr	r3, [r3, #0]
2400963a:	685a      	ldr	r2, [r3, #4]
2400963c:	68fb      	ldr	r3, [r7, #12]
2400963e:	681b      	ldr	r3, [r3, #0]
24009640:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
24009644:	605a      	str	r2, [r3, #4]
      return HAL_ERROR;
24009646:	2301      	movs	r3, #1
24009648:	e0a0      	b.n	2400978c <HAL_I2C_Slave_Receive+0x1f6>
    }

    /* Clear ADDR flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
2400964a:	68fb      	ldr	r3, [r7, #12]
2400964c:	681b      	ldr	r3, [r3, #0]
2400964e:	2208      	movs	r2, #8
24009650:	61da      	str	r2, [r3, #28]

    /* Wait until DIR flag is reset Receiver mode */
    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_DIR, SET, Timeout, tickstart) != HAL_OK)
24009652:	697b      	ldr	r3, [r7, #20]
24009654:	9300      	str	r3, [sp, #0]
24009656:	683b      	ldr	r3, [r7, #0]
24009658:	2201      	movs	r2, #1
2400965a:	f44f 3180 	mov.w	r1, #65536	; 0x10000
2400965e:	68f8      	ldr	r0, [r7, #12]
24009660:	f004 f9de 	bl	2400da20 <I2C_WaitOnFlagUntilTimeout>
24009664:	4603      	mov	r3, r0
24009666:	2b00      	cmp	r3, #0
24009668:	d048      	beq.n	240096fc <HAL_I2C_Slave_Receive+0x166>
    {
      /* Disable Address Acknowledge */
      hi2c->Instance->CR2 |= I2C_CR2_NACK;
2400966a:	68fb      	ldr	r3, [r7, #12]
2400966c:	681b      	ldr	r3, [r3, #0]
2400966e:	685a      	ldr	r2, [r3, #4]
24009670:	68fb      	ldr	r3, [r7, #12]
24009672:	681b      	ldr	r3, [r3, #0]
24009674:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
24009678:	605a      	str	r2, [r3, #4]
      return HAL_ERROR;
2400967a:	2301      	movs	r3, #1
2400967c:	e086      	b.n	2400978c <HAL_I2C_Slave_Receive+0x1f6>
    }

    while (hi2c->XferCount > 0U)
    {
      /* Wait until RXNE flag is set */
      if (I2C_WaitOnRXNEFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
2400967e:	697a      	ldr	r2, [r7, #20]
24009680:	6839      	ldr	r1, [r7, #0]
24009682:	68f8      	ldr	r0, [r7, #12]
24009684:	f004 fa88 	bl	2400db98 <I2C_WaitOnRXNEFlagUntilTimeout>
24009688:	4603      	mov	r3, r0
2400968a:	2b00      	cmp	r3, #0
2400968c:	d023      	beq.n	240096d6 <HAL_I2C_Slave_Receive+0x140>
      {
        /* Disable Address Acknowledge */
        hi2c->Instance->CR2 |= I2C_CR2_NACK;
2400968e:	68fb      	ldr	r3, [r7, #12]
24009690:	681b      	ldr	r3, [r3, #0]
24009692:	685a      	ldr	r2, [r3, #4]
24009694:	68fb      	ldr	r3, [r7, #12]
24009696:	681b      	ldr	r3, [r3, #0]
24009698:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
2400969c:	605a      	str	r2, [r3, #4]

        /* Store Last receive data if any */
        if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == SET)
2400969e:	68fb      	ldr	r3, [r7, #12]
240096a0:	681b      	ldr	r3, [r3, #0]
240096a2:	699b      	ldr	r3, [r3, #24]
240096a4:	f003 0304 	and.w	r3, r3, #4
240096a8:	2b04      	cmp	r3, #4
240096aa:	d112      	bne.n	240096d2 <HAL_I2C_Slave_Receive+0x13c>
        {
          /* Read data from RXDR */
          *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
240096ac:	68fb      	ldr	r3, [r7, #12]
240096ae:	681b      	ldr	r3, [r3, #0]
240096b0:	6a5a      	ldr	r2, [r3, #36]	; 0x24
240096b2:	68fb      	ldr	r3, [r7, #12]
240096b4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
240096b6:	b2d2      	uxtb	r2, r2
240096b8:	701a      	strb	r2, [r3, #0]

          /* Increment Buffer pointer */
          hi2c->pBuffPtr++;
240096ba:	68fb      	ldr	r3, [r7, #12]
240096bc:	6a5b      	ldr	r3, [r3, #36]	; 0x24
240096be:	1c5a      	adds	r2, r3, #1
240096c0:	68fb      	ldr	r3, [r7, #12]
240096c2:	625a      	str	r2, [r3, #36]	; 0x24

          hi2c->XferCount--;
240096c4:	68fb      	ldr	r3, [r7, #12]
240096c6:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
240096c8:	b29b      	uxth	r3, r3
240096ca:	3b01      	subs	r3, #1
240096cc:	b29a      	uxth	r2, r3
240096ce:	68fb      	ldr	r3, [r7, #12]
240096d0:	855a      	strh	r2, [r3, #42]	; 0x2a
        }

        return HAL_ERROR;
240096d2:	2301      	movs	r3, #1
240096d4:	e05a      	b.n	2400978c <HAL_I2C_Slave_Receive+0x1f6>
      }

      /* Read data from RXDR */
      *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
240096d6:	68fb      	ldr	r3, [r7, #12]
240096d8:	681b      	ldr	r3, [r3, #0]
240096da:	6a5a      	ldr	r2, [r3, #36]	; 0x24
240096dc:	68fb      	ldr	r3, [r7, #12]
240096de:	6a5b      	ldr	r3, [r3, #36]	; 0x24
240096e0:	b2d2      	uxtb	r2, r2
240096e2:	701a      	strb	r2, [r3, #0]

      /* Increment Buffer pointer */
      hi2c->pBuffPtr++;
240096e4:	68fb      	ldr	r3, [r7, #12]
240096e6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
240096e8:	1c5a      	adds	r2, r3, #1
240096ea:	68fb      	ldr	r3, [r7, #12]
240096ec:	625a      	str	r2, [r3, #36]	; 0x24

      hi2c->XferCount--;
240096ee:	68fb      	ldr	r3, [r7, #12]
240096f0:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
240096f2:	b29b      	uxth	r3, r3
240096f4:	3b01      	subs	r3, #1
240096f6:	b29a      	uxth	r2, r3
240096f8:	68fb      	ldr	r3, [r7, #12]
240096fa:	855a      	strh	r2, [r3, #42]	; 0x2a
    while (hi2c->XferCount > 0U)
240096fc:	68fb      	ldr	r3, [r7, #12]
240096fe:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
24009700:	b29b      	uxth	r3, r3
24009702:	2b00      	cmp	r3, #0
24009704:	d1bb      	bne.n	2400967e <HAL_I2C_Slave_Receive+0xe8>
    }

    /* Wait until STOP flag is set */
    if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
24009706:	697a      	ldr	r2, [r7, #20]
24009708:	6839      	ldr	r1, [r7, #0]
2400970a:	68f8      	ldr	r0, [r7, #12]
2400970c:	f004 fa08 	bl	2400db20 <I2C_WaitOnSTOPFlagUntilTimeout>
24009710:	4603      	mov	r3, r0
24009712:	2b00      	cmp	r3, #0
24009714:	d009      	beq.n	2400972a <HAL_I2C_Slave_Receive+0x194>
    {
      /* Disable Address Acknowledge */
      hi2c->Instance->CR2 |= I2C_CR2_NACK;
24009716:	68fb      	ldr	r3, [r7, #12]
24009718:	681b      	ldr	r3, [r3, #0]
2400971a:	685a      	ldr	r2, [r3, #4]
2400971c:	68fb      	ldr	r3, [r7, #12]
2400971e:	681b      	ldr	r3, [r3, #0]
24009720:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
24009724:	605a      	str	r2, [r3, #4]
      return HAL_ERROR;
24009726:	2301      	movs	r3, #1
24009728:	e030      	b.n	2400978c <HAL_I2C_Slave_Receive+0x1f6>
    }

    /* Clear STOP flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
2400972a:	68fb      	ldr	r3, [r7, #12]
2400972c:	681b      	ldr	r3, [r3, #0]
2400972e:	2220      	movs	r2, #32
24009730:	61da      	str	r2, [r3, #28]

    /* Wait until BUSY flag is reset */
    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, Timeout, tickstart) != HAL_OK)
24009732:	697b      	ldr	r3, [r7, #20]
24009734:	9300      	str	r3, [sp, #0]
24009736:	683b      	ldr	r3, [r7, #0]
24009738:	2201      	movs	r2, #1
2400973a:	f44f 4100 	mov.w	r1, #32768	; 0x8000
2400973e:	68f8      	ldr	r0, [r7, #12]
24009740:	f004 f96e 	bl	2400da20 <I2C_WaitOnFlagUntilTimeout>
24009744:	4603      	mov	r3, r0
24009746:	2b00      	cmp	r3, #0
24009748:	d009      	beq.n	2400975e <HAL_I2C_Slave_Receive+0x1c8>
    {
      /* Disable Address Acknowledge */
      hi2c->Instance->CR2 |= I2C_CR2_NACK;
2400974a:	68fb      	ldr	r3, [r7, #12]
2400974c:	681b      	ldr	r3, [r3, #0]
2400974e:	685a      	ldr	r2, [r3, #4]
24009750:	68fb      	ldr	r3, [r7, #12]
24009752:	681b      	ldr	r3, [r3, #0]
24009754:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
24009758:	605a      	str	r2, [r3, #4]
      return HAL_ERROR;
2400975a:	2301      	movs	r3, #1
2400975c:	e016      	b.n	2400978c <HAL_I2C_Slave_Receive+0x1f6>
    }

    /* Disable Address Acknowledge */
    hi2c->Instance->CR2 |= I2C_CR2_NACK;
2400975e:	68fb      	ldr	r3, [r7, #12]
24009760:	681b      	ldr	r3, [r3, #0]
24009762:	685a      	ldr	r2, [r3, #4]
24009764:	68fb      	ldr	r3, [r7, #12]
24009766:	681b      	ldr	r3, [r3, #0]
24009768:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
2400976c:	605a      	str	r2, [r3, #4]

    hi2c->State = HAL_I2C_STATE_READY;
2400976e:	68fb      	ldr	r3, [r7, #12]
24009770:	2220      	movs	r2, #32
24009772:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode  = HAL_I2C_MODE_NONE;
24009776:	68fb      	ldr	r3, [r7, #12]
24009778:	2200      	movs	r2, #0
2400977a:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
2400977e:	68fb      	ldr	r3, [r7, #12]
24009780:	2200      	movs	r2, #0
24009782:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    return HAL_OK;
24009786:	2300      	movs	r3, #0
24009788:	e000      	b.n	2400978c <HAL_I2C_Slave_Receive+0x1f6>
  }
  else
  {
    return HAL_BUSY;
2400978a:	2302      	movs	r3, #2
  }
}
2400978c:	4618      	mov	r0, r3
2400978e:	3718      	adds	r7, #24
24009790:	46bd      	mov	sp, r7
24009792:	bd80      	pop	{r7, pc}

24009794 <HAL_I2C_Master_Transmit_IT>:
  * @param  pData Pointer to data buffer
  * @param  Size Amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Master_Transmit_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size)
{
24009794:	b580      	push	{r7, lr}
24009796:	b088      	sub	sp, #32
24009798:	af02      	add	r7, sp, #8
2400979a:	60f8      	str	r0, [r7, #12]
2400979c:	607a      	str	r2, [r7, #4]
2400979e:	461a      	mov	r2, r3
240097a0:	460b      	mov	r3, r1
240097a2:	817b      	strh	r3, [r7, #10]
240097a4:	4613      	mov	r3, r2
240097a6:	813b      	strh	r3, [r7, #8]
  uint32_t xfermode;

  if (hi2c->State == HAL_I2C_STATE_READY)
240097a8:	68fb      	ldr	r3, [r7, #12]
240097aa:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
240097ae:	b2db      	uxtb	r3, r3
240097b0:	2b20      	cmp	r3, #32
240097b2:	d153      	bne.n	2400985c <HAL_I2C_Master_Transmit_IT+0xc8>
  {
    if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
240097b4:	68fb      	ldr	r3, [r7, #12]
240097b6:	681b      	ldr	r3, [r3, #0]
240097b8:	699b      	ldr	r3, [r3, #24]
240097ba:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
240097be:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
240097c2:	d101      	bne.n	240097c8 <HAL_I2C_Master_Transmit_IT+0x34>
    {
      return HAL_BUSY;
240097c4:	2302      	movs	r3, #2
240097c6:	e04a      	b.n	2400985e <HAL_I2C_Master_Transmit_IT+0xca>
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
240097c8:	68fb      	ldr	r3, [r7, #12]
240097ca:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
240097ce:	2b01      	cmp	r3, #1
240097d0:	d101      	bne.n	240097d6 <HAL_I2C_Master_Transmit_IT+0x42>
240097d2:	2302      	movs	r3, #2
240097d4:	e043      	b.n	2400985e <HAL_I2C_Master_Transmit_IT+0xca>
240097d6:	68fb      	ldr	r3, [r7, #12]
240097d8:	2201      	movs	r2, #1
240097da:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    hi2c->State       = HAL_I2C_STATE_BUSY_TX;
240097de:	68fb      	ldr	r3, [r7, #12]
240097e0:	2221      	movs	r2, #33	; 0x21
240097e2:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode        = HAL_I2C_MODE_MASTER;
240097e6:	68fb      	ldr	r3, [r7, #12]
240097e8:	2210      	movs	r2, #16
240097ea:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
240097ee:	68fb      	ldr	r3, [r7, #12]
240097f0:	2200      	movs	r2, #0
240097f2:	645a      	str	r2, [r3, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr    = pData;
240097f4:	68fb      	ldr	r3, [r7, #12]
240097f6:	687a      	ldr	r2, [r7, #4]
240097f8:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount   = Size;
240097fa:	68fb      	ldr	r3, [r7, #12]
240097fc:	893a      	ldrh	r2, [r7, #8]
240097fe:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
24009800:	68fb      	ldr	r3, [r7, #12]
24009802:	4a19      	ldr	r2, [pc, #100]	; (24009868 <HAL_I2C_Master_Transmit_IT+0xd4>)
24009804:	62da      	str	r2, [r3, #44]	; 0x2c
    hi2c->XferISR     = I2C_Master_ISR_IT;
24009806:	68fb      	ldr	r3, [r7, #12]
24009808:	4a18      	ldr	r2, [pc, #96]	; (2400986c <HAL_I2C_Master_Transmit_IT+0xd8>)
2400980a:	635a      	str	r2, [r3, #52]	; 0x34

    if (hi2c->XferCount > MAX_NBYTE_SIZE)
2400980c:	68fb      	ldr	r3, [r7, #12]
2400980e:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
24009810:	b29b      	uxth	r3, r3
24009812:	2bff      	cmp	r3, #255	; 0xff
24009814:	d906      	bls.n	24009824 <HAL_I2C_Master_Transmit_IT+0x90>
    {
      hi2c->XferSize = MAX_NBYTE_SIZE;
24009816:	68fb      	ldr	r3, [r7, #12]
24009818:	22ff      	movs	r2, #255	; 0xff
2400981a:	851a      	strh	r2, [r3, #40]	; 0x28
      xfermode = I2C_RELOAD_MODE;
2400981c:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
24009820:	617b      	str	r3, [r7, #20]
24009822:	e007      	b.n	24009834 <HAL_I2C_Master_Transmit_IT+0xa0>
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
24009824:	68fb      	ldr	r3, [r7, #12]
24009826:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
24009828:	b29a      	uxth	r2, r3
2400982a:	68fb      	ldr	r3, [r7, #12]
2400982c:	851a      	strh	r2, [r3, #40]	; 0x28
      xfermode = I2C_AUTOEND_MODE;
2400982e:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
24009832:	617b      	str	r3, [r7, #20]
    }

    /* Send Slave Address */
    /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE */
    I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, I2C_GENERATE_START_WRITE);
24009834:	68fb      	ldr	r3, [r7, #12]
24009836:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
24009838:	b2da      	uxtb	r2, r3
2400983a:	8979      	ldrh	r1, [r7, #10]
2400983c:	4b0c      	ldr	r3, [pc, #48]	; (24009870 <HAL_I2C_Master_Transmit_IT+0xdc>)
2400983e:	9300      	str	r3, [sp, #0]
24009840:	697b      	ldr	r3, [r7, #20]
24009842:	68f8      	ldr	r0, [r7, #12]
24009844:	f004 fa7a 	bl	2400dd3c <I2C_TransferConfig>

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
24009848:	68fb      	ldr	r3, [r7, #12]
2400984a:	2200      	movs	r2, #0
2400984c:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
              process unlock */

    /* Enable ERR, TC, STOP, NACK, TXI interrupt */
    /* possible to enable all of these */
    /* I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */
    I2C_Enable_IRQ(hi2c, I2C_XFER_TX_IT);
24009850:	2101      	movs	r1, #1
24009852:	68f8      	ldr	r0, [r7, #12]
24009854:	f004 faa0 	bl	2400dd98 <I2C_Enable_IRQ>

    return HAL_OK;
24009858:	2300      	movs	r3, #0
2400985a:	e000      	b.n	2400985e <HAL_I2C_Master_Transmit_IT+0xca>
  }
  else
  {
    return HAL_BUSY;
2400985c:	2302      	movs	r3, #2
  }
}
2400985e:	4618      	mov	r0, r3
24009860:	3718      	adds	r7, #24
24009862:	46bd      	mov	sp, r7
24009864:	bd80      	pop	{r7, pc}
24009866:	bf00      	nop
24009868:	ffff0000 	.word	0xffff0000
2400986c:	2400beb3 	.word	0x2400beb3
24009870:	80002000 	.word	0x80002000

24009874 <HAL_I2C_Master_Receive_IT>:
  * @param  pData Pointer to data buffer
  * @param  Size Amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Master_Receive_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size)
{
24009874:	b580      	push	{r7, lr}
24009876:	b088      	sub	sp, #32
24009878:	af02      	add	r7, sp, #8
2400987a:	60f8      	str	r0, [r7, #12]
2400987c:	607a      	str	r2, [r7, #4]
2400987e:	461a      	mov	r2, r3
24009880:	460b      	mov	r3, r1
24009882:	817b      	strh	r3, [r7, #10]
24009884:	4613      	mov	r3, r2
24009886:	813b      	strh	r3, [r7, #8]
  uint32_t xfermode;

  if (hi2c->State == HAL_I2C_STATE_READY)
24009888:	68fb      	ldr	r3, [r7, #12]
2400988a:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400988e:	b2db      	uxtb	r3, r3
24009890:	2b20      	cmp	r3, #32
24009892:	d153      	bne.n	2400993c <HAL_I2C_Master_Receive_IT+0xc8>
  {
    if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
24009894:	68fb      	ldr	r3, [r7, #12]
24009896:	681b      	ldr	r3, [r3, #0]
24009898:	699b      	ldr	r3, [r3, #24]
2400989a:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
2400989e:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
240098a2:	d101      	bne.n	240098a8 <HAL_I2C_Master_Receive_IT+0x34>
    {
      return HAL_BUSY;
240098a4:	2302      	movs	r3, #2
240098a6:	e04a      	b.n	2400993e <HAL_I2C_Master_Receive_IT+0xca>
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
240098a8:	68fb      	ldr	r3, [r7, #12]
240098aa:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
240098ae:	2b01      	cmp	r3, #1
240098b0:	d101      	bne.n	240098b6 <HAL_I2C_Master_Receive_IT+0x42>
240098b2:	2302      	movs	r3, #2
240098b4:	e043      	b.n	2400993e <HAL_I2C_Master_Receive_IT+0xca>
240098b6:	68fb      	ldr	r3, [r7, #12]
240098b8:	2201      	movs	r2, #1
240098ba:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    hi2c->State       = HAL_I2C_STATE_BUSY_RX;
240098be:	68fb      	ldr	r3, [r7, #12]
240098c0:	2222      	movs	r2, #34	; 0x22
240098c2:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode        = HAL_I2C_MODE_MASTER;
240098c6:	68fb      	ldr	r3, [r7, #12]
240098c8:	2210      	movs	r2, #16
240098ca:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
240098ce:	68fb      	ldr	r3, [r7, #12]
240098d0:	2200      	movs	r2, #0
240098d2:	645a      	str	r2, [r3, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr    = pData;
240098d4:	68fb      	ldr	r3, [r7, #12]
240098d6:	687a      	ldr	r2, [r7, #4]
240098d8:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount   = Size;
240098da:	68fb      	ldr	r3, [r7, #12]
240098dc:	893a      	ldrh	r2, [r7, #8]
240098de:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
240098e0:	68fb      	ldr	r3, [r7, #12]
240098e2:	4a19      	ldr	r2, [pc, #100]	; (24009948 <HAL_I2C_Master_Receive_IT+0xd4>)
240098e4:	62da      	str	r2, [r3, #44]	; 0x2c
    hi2c->XferISR     = I2C_Master_ISR_IT;
240098e6:	68fb      	ldr	r3, [r7, #12]
240098e8:	4a18      	ldr	r2, [pc, #96]	; (2400994c <HAL_I2C_Master_Receive_IT+0xd8>)
240098ea:	635a      	str	r2, [r3, #52]	; 0x34

    if (hi2c->XferCount > MAX_NBYTE_SIZE)
240098ec:	68fb      	ldr	r3, [r7, #12]
240098ee:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
240098f0:	b29b      	uxth	r3, r3
240098f2:	2bff      	cmp	r3, #255	; 0xff
240098f4:	d906      	bls.n	24009904 <HAL_I2C_Master_Receive_IT+0x90>
    {
      hi2c->XferSize = MAX_NBYTE_SIZE;
240098f6:	68fb      	ldr	r3, [r7, #12]
240098f8:	22ff      	movs	r2, #255	; 0xff
240098fa:	851a      	strh	r2, [r3, #40]	; 0x28
      xfermode = I2C_RELOAD_MODE;
240098fc:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
24009900:	617b      	str	r3, [r7, #20]
24009902:	e007      	b.n	24009914 <HAL_I2C_Master_Receive_IT+0xa0>
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
24009904:	68fb      	ldr	r3, [r7, #12]
24009906:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
24009908:	b29a      	uxth	r2, r3
2400990a:	68fb      	ldr	r3, [r7, #12]
2400990c:	851a      	strh	r2, [r3, #40]	; 0x28
      xfermode = I2C_AUTOEND_MODE;
2400990e:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
24009912:	617b      	str	r3, [r7, #20]
    }

    /* Send Slave Address */
    /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE */
    I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, I2C_GENERATE_START_READ);
24009914:	68fb      	ldr	r3, [r7, #12]
24009916:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
24009918:	b2da      	uxtb	r2, r3
2400991a:	8979      	ldrh	r1, [r7, #10]
2400991c:	4b0c      	ldr	r3, [pc, #48]	; (24009950 <HAL_I2C_Master_Receive_IT+0xdc>)
2400991e:	9300      	str	r3, [sp, #0]
24009920:	697b      	ldr	r3, [r7, #20]
24009922:	68f8      	ldr	r0, [r7, #12]
24009924:	f004 fa0a 	bl	2400dd3c <I2C_TransferConfig>

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
24009928:	68fb      	ldr	r3, [r7, #12]
2400992a:	2200      	movs	r2, #0
2400992c:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
              process unlock */

    /* Enable ERR, TC, STOP, NACK, RXI interrupt */
    /* possible to enable all of these */
    /* I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */
    I2C_Enable_IRQ(hi2c, I2C_XFER_RX_IT);
24009930:	2102      	movs	r1, #2
24009932:	68f8      	ldr	r0, [r7, #12]
24009934:	f004 fa30 	bl	2400dd98 <I2C_Enable_IRQ>

    return HAL_OK;
24009938:	2300      	movs	r3, #0
2400993a:	e000      	b.n	2400993e <HAL_I2C_Master_Receive_IT+0xca>
  }
  else
  {
    return HAL_BUSY;
2400993c:	2302      	movs	r3, #2
  }
}
2400993e:	4618      	mov	r0, r3
24009940:	3718      	adds	r7, #24
24009942:	46bd      	mov	sp, r7
24009944:	bd80      	pop	{r7, pc}
24009946:	bf00      	nop
24009948:	ffff0000 	.word	0xffff0000
2400994c:	2400beb3 	.word	0x2400beb3
24009950:	80002400 	.word	0x80002400

24009954 <HAL_I2C_Slave_Transmit_IT>:
  * @param  pData Pointer to data buffer
  * @param  Size Amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Slave_Transmit_IT(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size)
{
24009954:	b580      	push	{r7, lr}
24009956:	b084      	sub	sp, #16
24009958:	af00      	add	r7, sp, #0
2400995a:	60f8      	str	r0, [r7, #12]
2400995c:	60b9      	str	r1, [r7, #8]
2400995e:	4613      	mov	r3, r2
24009960:	80fb      	strh	r3, [r7, #6]
  if (hi2c->State == HAL_I2C_STATE_READY)
24009962:	68fb      	ldr	r3, [r7, #12]
24009964:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
24009968:	b2db      	uxtb	r3, r3
2400996a:	2b20      	cmp	r3, #32
2400996c:	d139      	bne.n	240099e2 <HAL_I2C_Slave_Transmit_IT+0x8e>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
2400996e:	68fb      	ldr	r3, [r7, #12]
24009970:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
24009974:	2b01      	cmp	r3, #1
24009976:	d101      	bne.n	2400997c <HAL_I2C_Slave_Transmit_IT+0x28>
24009978:	2302      	movs	r3, #2
2400997a:	e033      	b.n	240099e4 <HAL_I2C_Slave_Transmit_IT+0x90>
2400997c:	68fb      	ldr	r3, [r7, #12]
2400997e:	2201      	movs	r2, #1
24009980:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    hi2c->State       = HAL_I2C_STATE_BUSY_TX;
24009984:	68fb      	ldr	r3, [r7, #12]
24009986:	2221      	movs	r2, #33	; 0x21
24009988:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode        = HAL_I2C_MODE_SLAVE;
2400998c:	68fb      	ldr	r3, [r7, #12]
2400998e:	2220      	movs	r2, #32
24009990:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
24009994:	68fb      	ldr	r3, [r7, #12]
24009996:	2200      	movs	r2, #0
24009998:	645a      	str	r2, [r3, #68]	; 0x44

    /* Enable Address Acknowledge */
    hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
2400999a:	68fb      	ldr	r3, [r7, #12]
2400999c:	681b      	ldr	r3, [r3, #0]
2400999e:	685a      	ldr	r2, [r3, #4]
240099a0:	68fb      	ldr	r3, [r7, #12]
240099a2:	681b      	ldr	r3, [r3, #0]
240099a4:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
240099a8:	605a      	str	r2, [r3, #4]

    /* Prepare transfer parameters */
    hi2c->pBuffPtr    = pData;
240099aa:	68fb      	ldr	r3, [r7, #12]
240099ac:	68ba      	ldr	r2, [r7, #8]
240099ae:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount   = Size;
240099b0:	68fb      	ldr	r3, [r7, #12]
240099b2:	88fa      	ldrh	r2, [r7, #6]
240099b4:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferSize    = hi2c->XferCount;
240099b6:	68fb      	ldr	r3, [r7, #12]
240099b8:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
240099ba:	b29a      	uxth	r2, r3
240099bc:	68fb      	ldr	r3, [r7, #12]
240099be:	851a      	strh	r2, [r3, #40]	; 0x28
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
240099c0:	68fb      	ldr	r3, [r7, #12]
240099c2:	4a0a      	ldr	r2, [pc, #40]	; (240099ec <HAL_I2C_Slave_Transmit_IT+0x98>)
240099c4:	62da      	str	r2, [r3, #44]	; 0x2c
    hi2c->XferISR     = I2C_Slave_ISR_IT;
240099c6:	68fb      	ldr	r3, [r7, #12]
240099c8:	4a09      	ldr	r2, [pc, #36]	; (240099f0 <HAL_I2C_Slave_Transmit_IT+0x9c>)
240099ca:	635a      	str	r2, [r3, #52]	; 0x34

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
240099cc:	68fb      	ldr	r3, [r7, #12]
240099ce:	2200      	movs	r2, #0
240099d0:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
              process unlock */

    /* Enable ERR, TC, STOP, NACK, TXI interrupt */
    /* possible to enable all of these */
    /* I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */
    I2C_Enable_IRQ(hi2c, I2C_XFER_TX_IT | I2C_XFER_LISTEN_IT);
240099d4:	f248 0101 	movw	r1, #32769	; 0x8001
240099d8:	68f8      	ldr	r0, [r7, #12]
240099da:	f004 f9dd 	bl	2400dd98 <I2C_Enable_IRQ>

    return HAL_OK;
240099de:	2300      	movs	r3, #0
240099e0:	e000      	b.n	240099e4 <HAL_I2C_Slave_Transmit_IT+0x90>
  }
  else
  {
    return HAL_BUSY;
240099e2:	2302      	movs	r3, #2
  }
}
240099e4:	4618      	mov	r0, r3
240099e6:	3710      	adds	r7, #16
240099e8:	46bd      	mov	sp, r7
240099ea:	bd80      	pop	{r7, pc}
240099ec:	ffff0000 	.word	0xffff0000
240099f0:	2400c105 	.word	0x2400c105

240099f4 <HAL_I2C_Slave_Receive_IT>:
  * @param  pData Pointer to data buffer
  * @param  Size Amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Slave_Receive_IT(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size)
{
240099f4:	b580      	push	{r7, lr}
240099f6:	b084      	sub	sp, #16
240099f8:	af00      	add	r7, sp, #0
240099fa:	60f8      	str	r0, [r7, #12]
240099fc:	60b9      	str	r1, [r7, #8]
240099fe:	4613      	mov	r3, r2
24009a00:	80fb      	strh	r3, [r7, #6]
  if (hi2c->State == HAL_I2C_STATE_READY)
24009a02:	68fb      	ldr	r3, [r7, #12]
24009a04:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
24009a08:	b2db      	uxtb	r3, r3
24009a0a:	2b20      	cmp	r3, #32
24009a0c:	d139      	bne.n	24009a82 <HAL_I2C_Slave_Receive_IT+0x8e>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
24009a0e:	68fb      	ldr	r3, [r7, #12]
24009a10:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
24009a14:	2b01      	cmp	r3, #1
24009a16:	d101      	bne.n	24009a1c <HAL_I2C_Slave_Receive_IT+0x28>
24009a18:	2302      	movs	r3, #2
24009a1a:	e033      	b.n	24009a84 <HAL_I2C_Slave_Receive_IT+0x90>
24009a1c:	68fb      	ldr	r3, [r7, #12]
24009a1e:	2201      	movs	r2, #1
24009a20:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    hi2c->State       = HAL_I2C_STATE_BUSY_RX;
24009a24:	68fb      	ldr	r3, [r7, #12]
24009a26:	2222      	movs	r2, #34	; 0x22
24009a28:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode        = HAL_I2C_MODE_SLAVE;
24009a2c:	68fb      	ldr	r3, [r7, #12]
24009a2e:	2220      	movs	r2, #32
24009a30:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
24009a34:	68fb      	ldr	r3, [r7, #12]
24009a36:	2200      	movs	r2, #0
24009a38:	645a      	str	r2, [r3, #68]	; 0x44

    /* Enable Address Acknowledge */
    hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
24009a3a:	68fb      	ldr	r3, [r7, #12]
24009a3c:	681b      	ldr	r3, [r3, #0]
24009a3e:	685a      	ldr	r2, [r3, #4]
24009a40:	68fb      	ldr	r3, [r7, #12]
24009a42:	681b      	ldr	r3, [r3, #0]
24009a44:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
24009a48:	605a      	str	r2, [r3, #4]

    /* Prepare transfer parameters */
    hi2c->pBuffPtr    = pData;
24009a4a:	68fb      	ldr	r3, [r7, #12]
24009a4c:	68ba      	ldr	r2, [r7, #8]
24009a4e:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount   = Size;
24009a50:	68fb      	ldr	r3, [r7, #12]
24009a52:	88fa      	ldrh	r2, [r7, #6]
24009a54:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferSize    = hi2c->XferCount;
24009a56:	68fb      	ldr	r3, [r7, #12]
24009a58:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
24009a5a:	b29a      	uxth	r2, r3
24009a5c:	68fb      	ldr	r3, [r7, #12]
24009a5e:	851a      	strh	r2, [r3, #40]	; 0x28
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
24009a60:	68fb      	ldr	r3, [r7, #12]
24009a62:	4a0a      	ldr	r2, [pc, #40]	; (24009a8c <HAL_I2C_Slave_Receive_IT+0x98>)
24009a64:	62da      	str	r2, [r3, #44]	; 0x2c
    hi2c->XferISR     = I2C_Slave_ISR_IT;
24009a66:	68fb      	ldr	r3, [r7, #12]
24009a68:	4a09      	ldr	r2, [pc, #36]	; (24009a90 <HAL_I2C_Slave_Receive_IT+0x9c>)
24009a6a:	635a      	str	r2, [r3, #52]	; 0x34

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
24009a6c:	68fb      	ldr	r3, [r7, #12]
24009a6e:	2200      	movs	r2, #0
24009a70:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
              process unlock */

    /* Enable ERR, TC, STOP, NACK, RXI interrupt */
    /* possible to enable all of these */
    /* I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */
    I2C_Enable_IRQ(hi2c, I2C_XFER_RX_IT | I2C_XFER_LISTEN_IT);
24009a74:	f248 0102 	movw	r1, #32770	; 0x8002
24009a78:	68f8      	ldr	r0, [r7, #12]
24009a7a:	f004 f98d 	bl	2400dd98 <I2C_Enable_IRQ>

    return HAL_OK;
24009a7e:	2300      	movs	r3, #0
24009a80:	e000      	b.n	24009a84 <HAL_I2C_Slave_Receive_IT+0x90>
  }
  else
  {
    return HAL_BUSY;
24009a82:	2302      	movs	r3, #2
  }
}
24009a84:	4618      	mov	r0, r3
24009a86:	3710      	adds	r7, #16
24009a88:	46bd      	mov	sp, r7
24009a8a:	bd80      	pop	{r7, pc}
24009a8c:	ffff0000 	.word	0xffff0000
24009a90:	2400c105 	.word	0x2400c105

24009a94 <HAL_I2C_Master_Transmit_DMA>:
  * @param  pData Pointer to data buffer
  * @param  Size Amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Master_Transmit_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size)
{
24009a94:	b580      	push	{r7, lr}
24009a96:	b088      	sub	sp, #32
24009a98:	af02      	add	r7, sp, #8
24009a9a:	60f8      	str	r0, [r7, #12]
24009a9c:	607a      	str	r2, [r7, #4]
24009a9e:	461a      	mov	r2, r3
24009aa0:	460b      	mov	r3, r1
24009aa2:	817b      	strh	r3, [r7, #10]
24009aa4:	4613      	mov	r3, r2
24009aa6:	813b      	strh	r3, [r7, #8]
  uint32_t xfermode;
  HAL_StatusTypeDef dmaxferstatus;

  if (hi2c->State == HAL_I2C_STATE_READY)
24009aa8:	68fb      	ldr	r3, [r7, #12]
24009aaa:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
24009aae:	b2db      	uxtb	r3, r3
24009ab0:	2b20      	cmp	r3, #32
24009ab2:	f040 80cd 	bne.w	24009c50 <HAL_I2C_Master_Transmit_DMA+0x1bc>
  {
    if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
24009ab6:	68fb      	ldr	r3, [r7, #12]
24009ab8:	681b      	ldr	r3, [r3, #0]
24009aba:	699b      	ldr	r3, [r3, #24]
24009abc:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
24009ac0:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
24009ac4:	d101      	bne.n	24009aca <HAL_I2C_Master_Transmit_DMA+0x36>
    {
      return HAL_BUSY;
24009ac6:	2302      	movs	r3, #2
24009ac8:	e0c3      	b.n	24009c52 <HAL_I2C_Master_Transmit_DMA+0x1be>
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
24009aca:	68fb      	ldr	r3, [r7, #12]
24009acc:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
24009ad0:	2b01      	cmp	r3, #1
24009ad2:	d101      	bne.n	24009ad8 <HAL_I2C_Master_Transmit_DMA+0x44>
24009ad4:	2302      	movs	r3, #2
24009ad6:	e0bc      	b.n	24009c52 <HAL_I2C_Master_Transmit_DMA+0x1be>
24009ad8:	68fb      	ldr	r3, [r7, #12]
24009ada:	2201      	movs	r2, #1
24009adc:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    hi2c->State       = HAL_I2C_STATE_BUSY_TX;
24009ae0:	68fb      	ldr	r3, [r7, #12]
24009ae2:	2221      	movs	r2, #33	; 0x21
24009ae4:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode        = HAL_I2C_MODE_MASTER;
24009ae8:	68fb      	ldr	r3, [r7, #12]
24009aea:	2210      	movs	r2, #16
24009aec:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
24009af0:	68fb      	ldr	r3, [r7, #12]
24009af2:	2200      	movs	r2, #0
24009af4:	645a      	str	r2, [r3, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr    = pData;
24009af6:	68fb      	ldr	r3, [r7, #12]
24009af8:	687a      	ldr	r2, [r7, #4]
24009afa:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount   = Size;
24009afc:	68fb      	ldr	r3, [r7, #12]
24009afe:	893a      	ldrh	r2, [r7, #8]
24009b00:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
24009b02:	68fb      	ldr	r3, [r7, #12]
24009b04:	4a55      	ldr	r2, [pc, #340]	; (24009c5c <HAL_I2C_Master_Transmit_DMA+0x1c8>)
24009b06:	62da      	str	r2, [r3, #44]	; 0x2c
    hi2c->XferISR     = I2C_Master_ISR_DMA;
24009b08:	68fb      	ldr	r3, [r7, #12]
24009b0a:	4a55      	ldr	r2, [pc, #340]	; (24009c60 <HAL_I2C_Master_Transmit_DMA+0x1cc>)
24009b0c:	635a      	str	r2, [r3, #52]	; 0x34

    if (hi2c->XferCount > MAX_NBYTE_SIZE)
24009b0e:	68fb      	ldr	r3, [r7, #12]
24009b10:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
24009b12:	b29b      	uxth	r3, r3
24009b14:	2bff      	cmp	r3, #255	; 0xff
24009b16:	d906      	bls.n	24009b26 <HAL_I2C_Master_Transmit_DMA+0x92>
    {
      hi2c->XferSize = MAX_NBYTE_SIZE;
24009b18:	68fb      	ldr	r3, [r7, #12]
24009b1a:	22ff      	movs	r2, #255	; 0xff
24009b1c:	851a      	strh	r2, [r3, #40]	; 0x28
      xfermode = I2C_RELOAD_MODE;
24009b1e:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
24009b22:	617b      	str	r3, [r7, #20]
24009b24:	e007      	b.n	24009b36 <HAL_I2C_Master_Transmit_DMA+0xa2>
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
24009b26:	68fb      	ldr	r3, [r7, #12]
24009b28:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
24009b2a:	b29a      	uxth	r2, r3
24009b2c:	68fb      	ldr	r3, [r7, #12]
24009b2e:	851a      	strh	r2, [r3, #40]	; 0x28
      xfermode = I2C_AUTOEND_MODE;
24009b30:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
24009b34:	617b      	str	r3, [r7, #20]
    }

    if (hi2c->XferSize > 0U)
24009b36:	68fb      	ldr	r3, [r7, #12]
24009b38:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
24009b3a:	2b00      	cmp	r3, #0
24009b3c:	d070      	beq.n	24009c20 <HAL_I2C_Master_Transmit_DMA+0x18c>
    {
      if (hi2c->hdmatx != NULL)
24009b3e:	68fb      	ldr	r3, [r7, #12]
24009b40:	6b9b      	ldr	r3, [r3, #56]	; 0x38
24009b42:	2b00      	cmp	r3, #0
24009b44:	d020      	beq.n	24009b88 <HAL_I2C_Master_Transmit_DMA+0xf4>
      {
        /* Set the I2C DMA transfer complete callback */
        hi2c->hdmatx->XferCpltCallback = I2C_DMAMasterTransmitCplt;
24009b46:	68fb      	ldr	r3, [r7, #12]
24009b48:	6b9b      	ldr	r3, [r3, #56]	; 0x38
24009b4a:	4a46      	ldr	r2, [pc, #280]	; (24009c64 <HAL_I2C_Master_Transmit_DMA+0x1d0>)
24009b4c:	63da      	str	r2, [r3, #60]	; 0x3c

        /* Set the DMA error callback */
        hi2c->hdmatx->XferErrorCallback = I2C_DMAError;
24009b4e:	68fb      	ldr	r3, [r7, #12]
24009b50:	6b9b      	ldr	r3, [r3, #56]	; 0x38
24009b52:	4a45      	ldr	r2, [pc, #276]	; (24009c68 <HAL_I2C_Master_Transmit_DMA+0x1d4>)
24009b54:	64da      	str	r2, [r3, #76]	; 0x4c

        /* Set the unused DMA callbacks to NULL */
        hi2c->hdmatx->XferHalfCpltCallback = NULL;
24009b56:	68fb      	ldr	r3, [r7, #12]
24009b58:	6b9b      	ldr	r3, [r3, #56]	; 0x38
24009b5a:	2200      	movs	r2, #0
24009b5c:	641a      	str	r2, [r3, #64]	; 0x40
        hi2c->hdmatx->XferAbortCallback = NULL;
24009b5e:	68fb      	ldr	r3, [r7, #12]
24009b60:	6b9b      	ldr	r3, [r3, #56]	; 0x38
24009b62:	2200      	movs	r2, #0
24009b64:	651a      	str	r2, [r3, #80]	; 0x50

        /* Enable the DMA stream or channel depends on Instance */
        dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)pData, (uint32_t)&hi2c->Instance->TXDR, hi2c->XferSize);
24009b66:	68fb      	ldr	r3, [r7, #12]
24009b68:	6b98      	ldr	r0, [r3, #56]	; 0x38
24009b6a:	6879      	ldr	r1, [r7, #4]
24009b6c:	68fb      	ldr	r3, [r7, #12]
24009b6e:	681b      	ldr	r3, [r3, #0]
24009b70:	3328      	adds	r3, #40	; 0x28
24009b72:	461a      	mov	r2, r3
24009b74:	68fb      	ldr	r3, [r7, #12]
24009b76:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
24009b78:	f7f8 fcea 	bl	24002550 <HAL_DMA_Start_IT>
24009b7c:	4603      	mov	r3, r0
24009b7e:	74fb      	strb	r3, [r7, #19]
        __HAL_UNLOCK(hi2c);

        return HAL_ERROR;
      }

      if (dmaxferstatus == HAL_OK)
24009b80:	7cfb      	ldrb	r3, [r7, #19]
24009b82:	2b00      	cmp	r3, #0
24009b84:	d138      	bne.n	24009bf8 <HAL_I2C_Master_Transmit_DMA+0x164>
24009b86:	e013      	b.n	24009bb0 <HAL_I2C_Master_Transmit_DMA+0x11c>
        hi2c->State     = HAL_I2C_STATE_READY;
24009b88:	68fb      	ldr	r3, [r7, #12]
24009b8a:	2220      	movs	r2, #32
24009b8c:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
        hi2c->Mode      = HAL_I2C_MODE_NONE;
24009b90:	68fb      	ldr	r3, [r7, #12]
24009b92:	2200      	movs	r2, #0
24009b94:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
        hi2c->ErrorCode |= HAL_I2C_ERROR_DMA_PARAM;
24009b98:	68fb      	ldr	r3, [r7, #12]
24009b9a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
24009b9c:	f043 0280 	orr.w	r2, r3, #128	; 0x80
24009ba0:	68fb      	ldr	r3, [r7, #12]
24009ba2:	645a      	str	r2, [r3, #68]	; 0x44
        __HAL_UNLOCK(hi2c);
24009ba4:	68fb      	ldr	r3, [r7, #12]
24009ba6:	2200      	movs	r2, #0
24009ba8:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
        return HAL_ERROR;
24009bac:	2301      	movs	r3, #1
24009bae:	e050      	b.n	24009c52 <HAL_I2C_Master_Transmit_DMA+0x1be>
      {
        /* Send Slave Address */
        /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE and generate RESTART */
        I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, I2C_GENERATE_START_WRITE);
24009bb0:	68fb      	ldr	r3, [r7, #12]
24009bb2:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
24009bb4:	b2da      	uxtb	r2, r3
24009bb6:	8979      	ldrh	r1, [r7, #10]
24009bb8:	4b2c      	ldr	r3, [pc, #176]	; (24009c6c <HAL_I2C_Master_Transmit_DMA+0x1d8>)
24009bba:	9300      	str	r3, [sp, #0]
24009bbc:	697b      	ldr	r3, [r7, #20]
24009bbe:	68f8      	ldr	r0, [r7, #12]
24009bc0:	f004 f8bc 	bl	2400dd3c <I2C_TransferConfig>

        /* Update XferCount value */
        hi2c->XferCount -= hi2c->XferSize;
24009bc4:	68fb      	ldr	r3, [r7, #12]
24009bc6:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
24009bc8:	b29a      	uxth	r2, r3
24009bca:	68fb      	ldr	r3, [r7, #12]
24009bcc:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
24009bce:	1ad3      	subs	r3, r2, r3
24009bd0:	b29a      	uxth	r2, r3
24009bd2:	68fb      	ldr	r3, [r7, #12]
24009bd4:	855a      	strh	r2, [r3, #42]	; 0x2a

        /* Process Unlocked */
        __HAL_UNLOCK(hi2c);
24009bd6:	68fb      	ldr	r3, [r7, #12]
24009bd8:	2200      	movs	r2, #0
24009bda:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

        /* Note : The I2C interrupts must be enabled after unlocking current process
                  to avoid the risk of I2C interrupt handle execution before current
                  process unlock */
        /* Enable ERR and NACK interrupts */
        I2C_Enable_IRQ(hi2c, I2C_XFER_ERROR_IT);
24009bde:	2110      	movs	r1, #16
24009be0:	68f8      	ldr	r0, [r7, #12]
24009be2:	f004 f8d9 	bl	2400dd98 <I2C_Enable_IRQ>

        /* Enable DMA Request */
        hi2c->Instance->CR1 |= I2C_CR1_TXDMAEN;
24009be6:	68fb      	ldr	r3, [r7, #12]
24009be8:	681b      	ldr	r3, [r3, #0]
24009bea:	681a      	ldr	r2, [r3, #0]
24009bec:	68fb      	ldr	r3, [r7, #12]
24009bee:	681b      	ldr	r3, [r3, #0]
24009bf0:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
24009bf4:	601a      	str	r2, [r3, #0]
24009bf6:	e029      	b.n	24009c4c <HAL_I2C_Master_Transmit_DMA+0x1b8>
      }
      else
      {
        /* Update I2C state */
        hi2c->State     = HAL_I2C_STATE_READY;
24009bf8:	68fb      	ldr	r3, [r7, #12]
24009bfa:	2220      	movs	r2, #32
24009bfc:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
        hi2c->Mode      = HAL_I2C_MODE_NONE;
24009c00:	68fb      	ldr	r3, [r7, #12]
24009c02:	2200      	movs	r2, #0
24009c04:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

        /* Update I2C error code */
        hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
24009c08:	68fb      	ldr	r3, [r7, #12]
24009c0a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
24009c0c:	f043 0210 	orr.w	r2, r3, #16
24009c10:	68fb      	ldr	r3, [r7, #12]
24009c12:	645a      	str	r2, [r3, #68]	; 0x44

        /* Process Unlocked */
        __HAL_UNLOCK(hi2c);
24009c14:	68fb      	ldr	r3, [r7, #12]
24009c16:	2200      	movs	r2, #0
24009c18:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

        return HAL_ERROR;
24009c1c:	2301      	movs	r3, #1
24009c1e:	e018      	b.n	24009c52 <HAL_I2C_Master_Transmit_DMA+0x1be>
      }
    }
    else
    {
      /* Update Transfer ISR function pointer */
      hi2c->XferISR = I2C_Master_ISR_IT;
24009c20:	68fb      	ldr	r3, [r7, #12]
24009c22:	4a13      	ldr	r2, [pc, #76]	; (24009c70 <HAL_I2C_Master_Transmit_DMA+0x1dc>)
24009c24:	635a      	str	r2, [r3, #52]	; 0x34

      /* Send Slave Address */
      /* Set NBYTES to write and generate START condition */
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_GENERATE_START_WRITE);
24009c26:	68fb      	ldr	r3, [r7, #12]
24009c28:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
24009c2a:	b2da      	uxtb	r2, r3
24009c2c:	8979      	ldrh	r1, [r7, #10]
24009c2e:	4b0f      	ldr	r3, [pc, #60]	; (24009c6c <HAL_I2C_Master_Transmit_DMA+0x1d8>)
24009c30:	9300      	str	r3, [sp, #0]
24009c32:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
24009c36:	68f8      	ldr	r0, [r7, #12]
24009c38:	f004 f880 	bl	2400dd3c <I2C_TransferConfig>

      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
24009c3c:	68fb      	ldr	r3, [r7, #12]
24009c3e:	2200      	movs	r2, #0
24009c40:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
                to avoid the risk of I2C interrupt handle execution before current
                process unlock */
      /* Enable ERR, TC, STOP, NACK, TXI interrupt */
      /* possible to enable all of these */
      /* I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */
      I2C_Enable_IRQ(hi2c, I2C_XFER_TX_IT);
24009c44:	2101      	movs	r1, #1
24009c46:	68f8      	ldr	r0, [r7, #12]
24009c48:	f004 f8a6 	bl	2400dd98 <I2C_Enable_IRQ>
    }

    return HAL_OK;
24009c4c:	2300      	movs	r3, #0
24009c4e:	e000      	b.n	24009c52 <HAL_I2C_Master_Transmit_DMA+0x1be>
  }
  else
  {
    return HAL_BUSY;
24009c50:	2302      	movs	r3, #2
  }
}
24009c52:	4618      	mov	r0, r3
24009c54:	3718      	adds	r7, #24
24009c56:	46bd      	mov	sp, r7
24009c58:	bd80      	pop	{r7, pc}
24009c5a:	bf00      	nop
24009c5c:	ffff0000 	.word	0xffff0000
24009c60:	2400c30b 	.word	0x2400c30b
24009c64:	2400d4a3 	.word	0x2400d4a3
24009c68:	2400d775 	.word	0x2400d775
24009c6c:	80002000 	.word	0x80002000
24009c70:	2400beb3 	.word	0x2400beb3

24009c74 <HAL_I2C_Master_Receive_DMA>:
  * @param  pData Pointer to data buffer
  * @param  Size Amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Master_Receive_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size)
{
24009c74:	b580      	push	{r7, lr}
24009c76:	b088      	sub	sp, #32
24009c78:	af02      	add	r7, sp, #8
24009c7a:	60f8      	str	r0, [r7, #12]
24009c7c:	607a      	str	r2, [r7, #4]
24009c7e:	461a      	mov	r2, r3
24009c80:	460b      	mov	r3, r1
24009c82:	817b      	strh	r3, [r7, #10]
24009c84:	4613      	mov	r3, r2
24009c86:	813b      	strh	r3, [r7, #8]
  uint32_t xfermode;
  HAL_StatusTypeDef dmaxferstatus;

  if (hi2c->State == HAL_I2C_STATE_READY)
24009c88:	68fb      	ldr	r3, [r7, #12]
24009c8a:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
24009c8e:	b2db      	uxtb	r3, r3
24009c90:	2b20      	cmp	r3, #32
24009c92:	f040 80cd 	bne.w	24009e30 <HAL_I2C_Master_Receive_DMA+0x1bc>
  {
    if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
24009c96:	68fb      	ldr	r3, [r7, #12]
24009c98:	681b      	ldr	r3, [r3, #0]
24009c9a:	699b      	ldr	r3, [r3, #24]
24009c9c:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
24009ca0:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
24009ca4:	d101      	bne.n	24009caa <HAL_I2C_Master_Receive_DMA+0x36>
    {
      return HAL_BUSY;
24009ca6:	2302      	movs	r3, #2
24009ca8:	e0c3      	b.n	24009e32 <HAL_I2C_Master_Receive_DMA+0x1be>
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
24009caa:	68fb      	ldr	r3, [r7, #12]
24009cac:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
24009cb0:	2b01      	cmp	r3, #1
24009cb2:	d101      	bne.n	24009cb8 <HAL_I2C_Master_Receive_DMA+0x44>
24009cb4:	2302      	movs	r3, #2
24009cb6:	e0bc      	b.n	24009e32 <HAL_I2C_Master_Receive_DMA+0x1be>
24009cb8:	68fb      	ldr	r3, [r7, #12]
24009cba:	2201      	movs	r2, #1
24009cbc:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    hi2c->State       = HAL_I2C_STATE_BUSY_RX;
24009cc0:	68fb      	ldr	r3, [r7, #12]
24009cc2:	2222      	movs	r2, #34	; 0x22
24009cc4:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode        = HAL_I2C_MODE_MASTER;
24009cc8:	68fb      	ldr	r3, [r7, #12]
24009cca:	2210      	movs	r2, #16
24009ccc:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
24009cd0:	68fb      	ldr	r3, [r7, #12]
24009cd2:	2200      	movs	r2, #0
24009cd4:	645a      	str	r2, [r3, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr    = pData;
24009cd6:	68fb      	ldr	r3, [r7, #12]
24009cd8:	687a      	ldr	r2, [r7, #4]
24009cda:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount   = Size;
24009cdc:	68fb      	ldr	r3, [r7, #12]
24009cde:	893a      	ldrh	r2, [r7, #8]
24009ce0:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
24009ce2:	68fb      	ldr	r3, [r7, #12]
24009ce4:	4a55      	ldr	r2, [pc, #340]	; (24009e3c <HAL_I2C_Master_Receive_DMA+0x1c8>)
24009ce6:	62da      	str	r2, [r3, #44]	; 0x2c
    hi2c->XferISR     = I2C_Master_ISR_DMA;
24009ce8:	68fb      	ldr	r3, [r7, #12]
24009cea:	4a55      	ldr	r2, [pc, #340]	; (24009e40 <HAL_I2C_Master_Receive_DMA+0x1cc>)
24009cec:	635a      	str	r2, [r3, #52]	; 0x34

    if (hi2c->XferCount > MAX_NBYTE_SIZE)
24009cee:	68fb      	ldr	r3, [r7, #12]
24009cf0:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
24009cf2:	b29b      	uxth	r3, r3
24009cf4:	2bff      	cmp	r3, #255	; 0xff
24009cf6:	d906      	bls.n	24009d06 <HAL_I2C_Master_Receive_DMA+0x92>
    {
      hi2c->XferSize = MAX_NBYTE_SIZE;
24009cf8:	68fb      	ldr	r3, [r7, #12]
24009cfa:	22ff      	movs	r2, #255	; 0xff
24009cfc:	851a      	strh	r2, [r3, #40]	; 0x28
      xfermode = I2C_RELOAD_MODE;
24009cfe:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
24009d02:	617b      	str	r3, [r7, #20]
24009d04:	e007      	b.n	24009d16 <HAL_I2C_Master_Receive_DMA+0xa2>
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
24009d06:	68fb      	ldr	r3, [r7, #12]
24009d08:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
24009d0a:	b29a      	uxth	r2, r3
24009d0c:	68fb      	ldr	r3, [r7, #12]
24009d0e:	851a      	strh	r2, [r3, #40]	; 0x28
      xfermode = I2C_AUTOEND_MODE;
24009d10:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
24009d14:	617b      	str	r3, [r7, #20]
    }

    if (hi2c->XferSize > 0U)
24009d16:	68fb      	ldr	r3, [r7, #12]
24009d18:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
24009d1a:	2b00      	cmp	r3, #0
24009d1c:	d070      	beq.n	24009e00 <HAL_I2C_Master_Receive_DMA+0x18c>
    {
      if (hi2c->hdmarx != NULL)
24009d1e:	68fb      	ldr	r3, [r7, #12]
24009d20:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
24009d22:	2b00      	cmp	r3, #0
24009d24:	d020      	beq.n	24009d68 <HAL_I2C_Master_Receive_DMA+0xf4>
      {
        /* Set the I2C DMA transfer complete callback */
        hi2c->hdmarx->XferCpltCallback = I2C_DMAMasterReceiveCplt;
24009d26:	68fb      	ldr	r3, [r7, #12]
24009d28:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
24009d2a:	4a46      	ldr	r2, [pc, #280]	; (24009e44 <HAL_I2C_Master_Receive_DMA+0x1d0>)
24009d2c:	63da      	str	r2, [r3, #60]	; 0x3c

        /* Set the DMA error callback */
        hi2c->hdmarx->XferErrorCallback = I2C_DMAError;
24009d2e:	68fb      	ldr	r3, [r7, #12]
24009d30:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
24009d32:	4a45      	ldr	r2, [pc, #276]	; (24009e48 <HAL_I2C_Master_Receive_DMA+0x1d4>)
24009d34:	64da      	str	r2, [r3, #76]	; 0x4c

        /* Set the unused DMA callbacks to NULL */
        hi2c->hdmarx->XferHalfCpltCallback = NULL;
24009d36:	68fb      	ldr	r3, [r7, #12]
24009d38:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
24009d3a:	2200      	movs	r2, #0
24009d3c:	641a      	str	r2, [r3, #64]	; 0x40
        hi2c->hdmarx->XferAbortCallback = NULL;
24009d3e:	68fb      	ldr	r3, [r7, #12]
24009d40:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
24009d42:	2200      	movs	r2, #0
24009d44:	651a      	str	r2, [r3, #80]	; 0x50

        /* Enable the DMA stream or channel depends on Instance */
        dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->RXDR, (uint32_t)pData, hi2c->XferSize);
24009d46:	68fb      	ldr	r3, [r7, #12]
24009d48:	6bd8      	ldr	r0, [r3, #60]	; 0x3c
24009d4a:	68fb      	ldr	r3, [r7, #12]
24009d4c:	681b      	ldr	r3, [r3, #0]
24009d4e:	3324      	adds	r3, #36	; 0x24
24009d50:	4619      	mov	r1, r3
24009d52:	687a      	ldr	r2, [r7, #4]
24009d54:	68fb      	ldr	r3, [r7, #12]
24009d56:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
24009d58:	f7f8 fbfa 	bl	24002550 <HAL_DMA_Start_IT>
24009d5c:	4603      	mov	r3, r0
24009d5e:	74fb      	strb	r3, [r7, #19]
        __HAL_UNLOCK(hi2c);

        return HAL_ERROR;
      }

      if (dmaxferstatus == HAL_OK)
24009d60:	7cfb      	ldrb	r3, [r7, #19]
24009d62:	2b00      	cmp	r3, #0
24009d64:	d138      	bne.n	24009dd8 <HAL_I2C_Master_Receive_DMA+0x164>
24009d66:	e013      	b.n	24009d90 <HAL_I2C_Master_Receive_DMA+0x11c>
        hi2c->State     = HAL_I2C_STATE_READY;
24009d68:	68fb      	ldr	r3, [r7, #12]
24009d6a:	2220      	movs	r2, #32
24009d6c:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
        hi2c->Mode      = HAL_I2C_MODE_NONE;
24009d70:	68fb      	ldr	r3, [r7, #12]
24009d72:	2200      	movs	r2, #0
24009d74:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
        hi2c->ErrorCode |= HAL_I2C_ERROR_DMA_PARAM;
24009d78:	68fb      	ldr	r3, [r7, #12]
24009d7a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
24009d7c:	f043 0280 	orr.w	r2, r3, #128	; 0x80
24009d80:	68fb      	ldr	r3, [r7, #12]
24009d82:	645a      	str	r2, [r3, #68]	; 0x44
        __HAL_UNLOCK(hi2c);
24009d84:	68fb      	ldr	r3, [r7, #12]
24009d86:	2200      	movs	r2, #0
24009d88:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
        return HAL_ERROR;
24009d8c:	2301      	movs	r3, #1
24009d8e:	e050      	b.n	24009e32 <HAL_I2C_Master_Receive_DMA+0x1be>
      {
        /* Send Slave Address */
        /* Set NBYTES to read and reload if hi2c->XferCount > MAX_NBYTE_SIZE and generate RESTART */
        I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, I2C_GENERATE_START_READ);
24009d90:	68fb      	ldr	r3, [r7, #12]
24009d92:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
24009d94:	b2da      	uxtb	r2, r3
24009d96:	8979      	ldrh	r1, [r7, #10]
24009d98:	4b2c      	ldr	r3, [pc, #176]	; (24009e4c <HAL_I2C_Master_Receive_DMA+0x1d8>)
24009d9a:	9300      	str	r3, [sp, #0]
24009d9c:	697b      	ldr	r3, [r7, #20]
24009d9e:	68f8      	ldr	r0, [r7, #12]
24009da0:	f003 ffcc 	bl	2400dd3c <I2C_TransferConfig>

        /* Update XferCount value */
        hi2c->XferCount -= hi2c->XferSize;
24009da4:	68fb      	ldr	r3, [r7, #12]
24009da6:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
24009da8:	b29a      	uxth	r2, r3
24009daa:	68fb      	ldr	r3, [r7, #12]
24009dac:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
24009dae:	1ad3      	subs	r3, r2, r3
24009db0:	b29a      	uxth	r2, r3
24009db2:	68fb      	ldr	r3, [r7, #12]
24009db4:	855a      	strh	r2, [r3, #42]	; 0x2a

        /* Process Unlocked */
        __HAL_UNLOCK(hi2c);
24009db6:	68fb      	ldr	r3, [r7, #12]
24009db8:	2200      	movs	r2, #0
24009dba:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

        /* Note : The I2C interrupts must be enabled after unlocking current process
                  to avoid the risk of I2C interrupt handle execution before current
                  process unlock */
        /* Enable ERR and NACK interrupts */
        I2C_Enable_IRQ(hi2c, I2C_XFER_ERROR_IT);
24009dbe:	2110      	movs	r1, #16
24009dc0:	68f8      	ldr	r0, [r7, #12]
24009dc2:	f003 ffe9 	bl	2400dd98 <I2C_Enable_IRQ>

        /* Enable DMA Request */
        hi2c->Instance->CR1 |= I2C_CR1_RXDMAEN;
24009dc6:	68fb      	ldr	r3, [r7, #12]
24009dc8:	681b      	ldr	r3, [r3, #0]
24009dca:	681a      	ldr	r2, [r3, #0]
24009dcc:	68fb      	ldr	r3, [r7, #12]
24009dce:	681b      	ldr	r3, [r3, #0]
24009dd0:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
24009dd4:	601a      	str	r2, [r3, #0]
24009dd6:	e029      	b.n	24009e2c <HAL_I2C_Master_Receive_DMA+0x1b8>
      }
      else
      {
        /* Update I2C state */
        hi2c->State     = HAL_I2C_STATE_READY;
24009dd8:	68fb      	ldr	r3, [r7, #12]
24009dda:	2220      	movs	r2, #32
24009ddc:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
        hi2c->Mode      = HAL_I2C_MODE_NONE;
24009de0:	68fb      	ldr	r3, [r7, #12]
24009de2:	2200      	movs	r2, #0
24009de4:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

        /* Update I2C error code */
        hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
24009de8:	68fb      	ldr	r3, [r7, #12]
24009dea:	6c5b      	ldr	r3, [r3, #68]	; 0x44
24009dec:	f043 0210 	orr.w	r2, r3, #16
24009df0:	68fb      	ldr	r3, [r7, #12]
24009df2:	645a      	str	r2, [r3, #68]	; 0x44

        /* Process Unlocked */
        __HAL_UNLOCK(hi2c);
24009df4:	68fb      	ldr	r3, [r7, #12]
24009df6:	2200      	movs	r2, #0
24009df8:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

        return HAL_ERROR;
24009dfc:	2301      	movs	r3, #1
24009dfe:	e018      	b.n	24009e32 <HAL_I2C_Master_Receive_DMA+0x1be>
      }
    }
    else
    {
      /* Update Transfer ISR function pointer */
      hi2c->XferISR = I2C_Master_ISR_IT;
24009e00:	68fb      	ldr	r3, [r7, #12]
24009e02:	4a13      	ldr	r2, [pc, #76]	; (24009e50 <HAL_I2C_Master_Receive_DMA+0x1dc>)
24009e04:	635a      	str	r2, [r3, #52]	; 0x34

      /* Send Slave Address */
      /* Set NBYTES to read and generate START condition */
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_GENERATE_START_READ);
24009e06:	68fb      	ldr	r3, [r7, #12]
24009e08:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
24009e0a:	b2da      	uxtb	r2, r3
24009e0c:	8979      	ldrh	r1, [r7, #10]
24009e0e:	4b0f      	ldr	r3, [pc, #60]	; (24009e4c <HAL_I2C_Master_Receive_DMA+0x1d8>)
24009e10:	9300      	str	r3, [sp, #0]
24009e12:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
24009e16:	68f8      	ldr	r0, [r7, #12]
24009e18:	f003 ff90 	bl	2400dd3c <I2C_TransferConfig>

      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
24009e1c:	68fb      	ldr	r3, [r7, #12]
24009e1e:	2200      	movs	r2, #0
24009e20:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
                to avoid the risk of I2C interrupt handle execution before current
                process unlock */
      /* Enable ERR, TC, STOP, NACK, TXI interrupt */
      /* possible to enable all of these */
      /* I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */
      I2C_Enable_IRQ(hi2c, I2C_XFER_TX_IT);
24009e24:	2101      	movs	r1, #1
24009e26:	68f8      	ldr	r0, [r7, #12]
24009e28:	f003 ffb6 	bl	2400dd98 <I2C_Enable_IRQ>
    }

    return HAL_OK;
24009e2c:	2300      	movs	r3, #0
24009e2e:	e000      	b.n	24009e32 <HAL_I2C_Master_Receive_DMA+0x1be>
  }
  else
  {
    return HAL_BUSY;
24009e30:	2302      	movs	r3, #2
  }
}
24009e32:	4618      	mov	r0, r3
24009e34:	3718      	adds	r7, #24
24009e36:	46bd      	mov	sp, r7
24009e38:	bd80      	pop	{r7, pc}
24009e3a:	bf00      	nop
24009e3c:	ffff0000 	.word	0xffff0000
24009e40:	2400c30b 	.word	0x2400c30b
24009e44:	2400d579 	.word	0x2400d579
24009e48:	2400d775 	.word	0x2400d775
24009e4c:	80002400 	.word	0x80002400
24009e50:	2400beb3 	.word	0x2400beb3

24009e54 <HAL_I2C_Slave_Transmit_DMA>:
  * @param  pData Pointer to data buffer
  * @param  Size Amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Slave_Transmit_DMA(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size)
{
24009e54:	b580      	push	{r7, lr}
24009e56:	b086      	sub	sp, #24
24009e58:	af00      	add	r7, sp, #0
24009e5a:	60f8      	str	r0, [r7, #12]
24009e5c:	60b9      	str	r1, [r7, #8]
24009e5e:	4613      	mov	r3, r2
24009e60:	80fb      	strh	r3, [r7, #6]
  HAL_StatusTypeDef dmaxferstatus;

  if (hi2c->State == HAL_I2C_STATE_READY)
24009e62:	68fb      	ldr	r3, [r7, #12]
24009e64:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
24009e68:	b2db      	uxtb	r3, r3
24009e6a:	2b20      	cmp	r3, #32
24009e6c:	f040 809b 	bne.w	24009fa6 <HAL_I2C_Slave_Transmit_DMA+0x152>
  {
    if ((pData == NULL) || (Size == 0U))
24009e70:	68bb      	ldr	r3, [r7, #8]
24009e72:	2b00      	cmp	r3, #0
24009e74:	d002      	beq.n	24009e7c <HAL_I2C_Slave_Transmit_DMA+0x28>
24009e76:	88fb      	ldrh	r3, [r7, #6]
24009e78:	2b00      	cmp	r3, #0
24009e7a:	d105      	bne.n	24009e88 <HAL_I2C_Slave_Transmit_DMA+0x34>
    {
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
24009e7c:	68fb      	ldr	r3, [r7, #12]
24009e7e:	f44f 7200 	mov.w	r2, #512	; 0x200
24009e82:	645a      	str	r2, [r3, #68]	; 0x44
      return  HAL_ERROR;
24009e84:	2301      	movs	r3, #1
24009e86:	e08f      	b.n	24009fa8 <HAL_I2C_Slave_Transmit_DMA+0x154>
    }
    /* Process Locked */
    __HAL_LOCK(hi2c);
24009e88:	68fb      	ldr	r3, [r7, #12]
24009e8a:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
24009e8e:	2b01      	cmp	r3, #1
24009e90:	d101      	bne.n	24009e96 <HAL_I2C_Slave_Transmit_DMA+0x42>
24009e92:	2302      	movs	r3, #2
24009e94:	e088      	b.n	24009fa8 <HAL_I2C_Slave_Transmit_DMA+0x154>
24009e96:	68fb      	ldr	r3, [r7, #12]
24009e98:	2201      	movs	r2, #1
24009e9a:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    hi2c->State       = HAL_I2C_STATE_BUSY_TX;
24009e9e:	68fb      	ldr	r3, [r7, #12]
24009ea0:	2221      	movs	r2, #33	; 0x21
24009ea2:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode        = HAL_I2C_MODE_SLAVE;
24009ea6:	68fb      	ldr	r3, [r7, #12]
24009ea8:	2220      	movs	r2, #32
24009eaa:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
24009eae:	68fb      	ldr	r3, [r7, #12]
24009eb0:	2200      	movs	r2, #0
24009eb2:	645a      	str	r2, [r3, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr    = pData;
24009eb4:	68fb      	ldr	r3, [r7, #12]
24009eb6:	68ba      	ldr	r2, [r7, #8]
24009eb8:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount   = Size;
24009eba:	68fb      	ldr	r3, [r7, #12]
24009ebc:	88fa      	ldrh	r2, [r7, #6]
24009ebe:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferSize    = hi2c->XferCount;
24009ec0:	68fb      	ldr	r3, [r7, #12]
24009ec2:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
24009ec4:	b29a      	uxth	r2, r3
24009ec6:	68fb      	ldr	r3, [r7, #12]
24009ec8:	851a      	strh	r2, [r3, #40]	; 0x28
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
24009eca:	68fb      	ldr	r3, [r7, #12]
24009ecc:	4a38      	ldr	r2, [pc, #224]	; (24009fb0 <HAL_I2C_Slave_Transmit_DMA+0x15c>)
24009ece:	62da      	str	r2, [r3, #44]	; 0x2c
    hi2c->XferISR     = I2C_Slave_ISR_DMA;
24009ed0:	68fb      	ldr	r3, [r7, #12]
24009ed2:	4a38      	ldr	r2, [pc, #224]	; (24009fb4 <HAL_I2C_Slave_Transmit_DMA+0x160>)
24009ed4:	635a      	str	r2, [r3, #52]	; 0x34

    if (hi2c->hdmatx != NULL)
24009ed6:	68fb      	ldr	r3, [r7, #12]
24009ed8:	6b9b      	ldr	r3, [r3, #56]	; 0x38
24009eda:	2b00      	cmp	r3, #0
24009edc:	d020      	beq.n	24009f20 <HAL_I2C_Slave_Transmit_DMA+0xcc>
    {
      /* Set the I2C DMA transfer complete callback */
      hi2c->hdmatx->XferCpltCallback = I2C_DMASlaveTransmitCplt;
24009ede:	68fb      	ldr	r3, [r7, #12]
24009ee0:	6b9b      	ldr	r3, [r3, #56]	; 0x38
24009ee2:	4a35      	ldr	r2, [pc, #212]	; (24009fb8 <HAL_I2C_Slave_Transmit_DMA+0x164>)
24009ee4:	63da      	str	r2, [r3, #60]	; 0x3c

      /* Set the DMA error callback */
      hi2c->hdmatx->XferErrorCallback = I2C_DMAError;
24009ee6:	68fb      	ldr	r3, [r7, #12]
24009ee8:	6b9b      	ldr	r3, [r3, #56]	; 0x38
24009eea:	4a34      	ldr	r2, [pc, #208]	; (24009fbc <HAL_I2C_Slave_Transmit_DMA+0x168>)
24009eec:	64da      	str	r2, [r3, #76]	; 0x4c

      /* Set the unused DMA callbacks to NULL */
      hi2c->hdmatx->XferHalfCpltCallback = NULL;
24009eee:	68fb      	ldr	r3, [r7, #12]
24009ef0:	6b9b      	ldr	r3, [r3, #56]	; 0x38
24009ef2:	2200      	movs	r2, #0
24009ef4:	641a      	str	r2, [r3, #64]	; 0x40
      hi2c->hdmatx->XferAbortCallback = NULL;
24009ef6:	68fb      	ldr	r3, [r7, #12]
24009ef8:	6b9b      	ldr	r3, [r3, #56]	; 0x38
24009efa:	2200      	movs	r2, #0
24009efc:	651a      	str	r2, [r3, #80]	; 0x50

      /* Enable the DMA stream or channel depends on Instance */
      dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)pData, (uint32_t)&hi2c->Instance->TXDR, hi2c->XferSize);
24009efe:	68fb      	ldr	r3, [r7, #12]
24009f00:	6b98      	ldr	r0, [r3, #56]	; 0x38
24009f02:	68b9      	ldr	r1, [r7, #8]
24009f04:	68fb      	ldr	r3, [r7, #12]
24009f06:	681b      	ldr	r3, [r3, #0]
24009f08:	3328      	adds	r3, #40	; 0x28
24009f0a:	461a      	mov	r2, r3
24009f0c:	68fb      	ldr	r3, [r7, #12]
24009f0e:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
24009f10:	f7f8 fb1e 	bl	24002550 <HAL_DMA_Start_IT>
24009f14:	4603      	mov	r3, r0
24009f16:	75fb      	strb	r3, [r7, #23]
      __HAL_UNLOCK(hi2c);

      return HAL_ERROR;
    }

    if (dmaxferstatus == HAL_OK)
24009f18:	7dfb      	ldrb	r3, [r7, #23]
24009f1a:	2b00      	cmp	r3, #0
24009f1c:	d12f      	bne.n	24009f7e <HAL_I2C_Slave_Transmit_DMA+0x12a>
24009f1e:	e013      	b.n	24009f48 <HAL_I2C_Slave_Transmit_DMA+0xf4>
      hi2c->State     = HAL_I2C_STATE_LISTEN;
24009f20:	68fb      	ldr	r3, [r7, #12]
24009f22:	2228      	movs	r2, #40	; 0x28
24009f24:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
      hi2c->Mode      = HAL_I2C_MODE_NONE;
24009f28:	68fb      	ldr	r3, [r7, #12]
24009f2a:	2200      	movs	r2, #0
24009f2c:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
      hi2c->ErrorCode |= HAL_I2C_ERROR_DMA_PARAM;
24009f30:	68fb      	ldr	r3, [r7, #12]
24009f32:	6c5b      	ldr	r3, [r3, #68]	; 0x44
24009f34:	f043 0280 	orr.w	r2, r3, #128	; 0x80
24009f38:	68fb      	ldr	r3, [r7, #12]
24009f3a:	645a      	str	r2, [r3, #68]	; 0x44
      __HAL_UNLOCK(hi2c);
24009f3c:	68fb      	ldr	r3, [r7, #12]
24009f3e:	2200      	movs	r2, #0
24009f40:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      return HAL_ERROR;
24009f44:	2301      	movs	r3, #1
24009f46:	e02f      	b.n	24009fa8 <HAL_I2C_Slave_Transmit_DMA+0x154>
    {
      /* Enable Address Acknowledge */
      hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
24009f48:	68fb      	ldr	r3, [r7, #12]
24009f4a:	681b      	ldr	r3, [r3, #0]
24009f4c:	685a      	ldr	r2, [r3, #4]
24009f4e:	68fb      	ldr	r3, [r7, #12]
24009f50:	681b      	ldr	r3, [r3, #0]
24009f52:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
24009f56:	605a      	str	r2, [r3, #4]

      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
24009f58:	68fb      	ldr	r3, [r7, #12]
24009f5a:	2200      	movs	r2, #0
24009f5c:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

      /* Note : The I2C interrupts must be enabled after unlocking current process
                to avoid the risk of I2C interrupt handle execution before current
                process unlock */
      /* Enable ERR, STOP, NACK, ADDR interrupts */
      I2C_Enable_IRQ(hi2c, I2C_XFER_LISTEN_IT);
24009f60:	f44f 4100 	mov.w	r1, #32768	; 0x8000
24009f64:	68f8      	ldr	r0, [r7, #12]
24009f66:	f003 ff17 	bl	2400dd98 <I2C_Enable_IRQ>

      /* Enable DMA Request */
      hi2c->Instance->CR1 |= I2C_CR1_TXDMAEN;
24009f6a:	68fb      	ldr	r3, [r7, #12]
24009f6c:	681b      	ldr	r3, [r3, #0]
24009f6e:	681a      	ldr	r2, [r3, #0]
24009f70:	68fb      	ldr	r3, [r7, #12]
24009f72:	681b      	ldr	r3, [r3, #0]
24009f74:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
24009f78:	601a      	str	r2, [r3, #0]
      __HAL_UNLOCK(hi2c);

      return HAL_ERROR;
    }

    return HAL_OK;
24009f7a:	2300      	movs	r3, #0
24009f7c:	e014      	b.n	24009fa8 <HAL_I2C_Slave_Transmit_DMA+0x154>
      hi2c->State     = HAL_I2C_STATE_LISTEN;
24009f7e:	68fb      	ldr	r3, [r7, #12]
24009f80:	2228      	movs	r2, #40	; 0x28
24009f82:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
      hi2c->Mode      = HAL_I2C_MODE_NONE;
24009f86:	68fb      	ldr	r3, [r7, #12]
24009f88:	2200      	movs	r2, #0
24009f8a:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
      hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
24009f8e:	68fb      	ldr	r3, [r7, #12]
24009f90:	6c5b      	ldr	r3, [r3, #68]	; 0x44
24009f92:	f043 0210 	orr.w	r2, r3, #16
24009f96:	68fb      	ldr	r3, [r7, #12]
24009f98:	645a      	str	r2, [r3, #68]	; 0x44
      __HAL_UNLOCK(hi2c);
24009f9a:	68fb      	ldr	r3, [r7, #12]
24009f9c:	2200      	movs	r2, #0
24009f9e:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      return HAL_ERROR;
24009fa2:	2301      	movs	r3, #1
24009fa4:	e000      	b.n	24009fa8 <HAL_I2C_Slave_Transmit_DMA+0x154>
  }
  else
  {
    return HAL_BUSY;
24009fa6:	2302      	movs	r3, #2
  }
}
24009fa8:	4618      	mov	r0, r3
24009faa:	3718      	adds	r7, #24
24009fac:	46bd      	mov	sp, r7
24009fae:	bd80      	pop	{r7, pc}
24009fb0:	ffff0000 	.word	0xffff0000
24009fb4:	2400c4f1 	.word	0x2400c4f1
24009fb8:	2400d539 	.word	0x2400d539
24009fbc:	2400d775 	.word	0x2400d775

24009fc0 <HAL_I2C_Slave_Receive_DMA>:
  * @param  pData Pointer to data buffer
  * @param  Size Amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Slave_Receive_DMA(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size)
{
24009fc0:	b580      	push	{r7, lr}
24009fc2:	b086      	sub	sp, #24
24009fc4:	af00      	add	r7, sp, #0
24009fc6:	60f8      	str	r0, [r7, #12]
24009fc8:	60b9      	str	r1, [r7, #8]
24009fca:	4613      	mov	r3, r2
24009fcc:	80fb      	strh	r3, [r7, #6]
  HAL_StatusTypeDef dmaxferstatus;

  if (hi2c->State == HAL_I2C_STATE_READY)
24009fce:	68fb      	ldr	r3, [r7, #12]
24009fd0:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
24009fd4:	b2db      	uxtb	r3, r3
24009fd6:	2b20      	cmp	r3, #32
24009fd8:	f040 809b 	bne.w	2400a112 <HAL_I2C_Slave_Receive_DMA+0x152>
  {
    if ((pData == NULL) || (Size == 0U))
24009fdc:	68bb      	ldr	r3, [r7, #8]
24009fde:	2b00      	cmp	r3, #0
24009fe0:	d002      	beq.n	24009fe8 <HAL_I2C_Slave_Receive_DMA+0x28>
24009fe2:	88fb      	ldrh	r3, [r7, #6]
24009fe4:	2b00      	cmp	r3, #0
24009fe6:	d105      	bne.n	24009ff4 <HAL_I2C_Slave_Receive_DMA+0x34>
    {
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
24009fe8:	68fb      	ldr	r3, [r7, #12]
24009fea:	f44f 7200 	mov.w	r2, #512	; 0x200
24009fee:	645a      	str	r2, [r3, #68]	; 0x44
      return  HAL_ERROR;
24009ff0:	2301      	movs	r3, #1
24009ff2:	e08f      	b.n	2400a114 <HAL_I2C_Slave_Receive_DMA+0x154>
    }
    /* Process Locked */
    __HAL_LOCK(hi2c);
24009ff4:	68fb      	ldr	r3, [r7, #12]
24009ff6:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
24009ffa:	2b01      	cmp	r3, #1
24009ffc:	d101      	bne.n	2400a002 <HAL_I2C_Slave_Receive_DMA+0x42>
24009ffe:	2302      	movs	r3, #2
2400a000:	e088      	b.n	2400a114 <HAL_I2C_Slave_Receive_DMA+0x154>
2400a002:	68fb      	ldr	r3, [r7, #12]
2400a004:	2201      	movs	r2, #1
2400a006:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    hi2c->State       = HAL_I2C_STATE_BUSY_RX;
2400a00a:	68fb      	ldr	r3, [r7, #12]
2400a00c:	2222      	movs	r2, #34	; 0x22
2400a00e:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode        = HAL_I2C_MODE_SLAVE;
2400a012:	68fb      	ldr	r3, [r7, #12]
2400a014:	2220      	movs	r2, #32
2400a016:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
2400a01a:	68fb      	ldr	r3, [r7, #12]
2400a01c:	2200      	movs	r2, #0
2400a01e:	645a      	str	r2, [r3, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr    = pData;
2400a020:	68fb      	ldr	r3, [r7, #12]
2400a022:	68ba      	ldr	r2, [r7, #8]
2400a024:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount   = Size;
2400a026:	68fb      	ldr	r3, [r7, #12]
2400a028:	88fa      	ldrh	r2, [r7, #6]
2400a02a:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferSize    = hi2c->XferCount;
2400a02c:	68fb      	ldr	r3, [r7, #12]
2400a02e:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400a030:	b29a      	uxth	r2, r3
2400a032:	68fb      	ldr	r3, [r7, #12]
2400a034:	851a      	strh	r2, [r3, #40]	; 0x28
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
2400a036:	68fb      	ldr	r3, [r7, #12]
2400a038:	4a38      	ldr	r2, [pc, #224]	; (2400a11c <HAL_I2C_Slave_Receive_DMA+0x15c>)
2400a03a:	62da      	str	r2, [r3, #44]	; 0x2c
    hi2c->XferISR     = I2C_Slave_ISR_DMA;
2400a03c:	68fb      	ldr	r3, [r7, #12]
2400a03e:	4a38      	ldr	r2, [pc, #224]	; (2400a120 <HAL_I2C_Slave_Receive_DMA+0x160>)
2400a040:	635a      	str	r2, [r3, #52]	; 0x34

    if (hi2c->hdmarx != NULL)
2400a042:	68fb      	ldr	r3, [r7, #12]
2400a044:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400a046:	2b00      	cmp	r3, #0
2400a048:	d020      	beq.n	2400a08c <HAL_I2C_Slave_Receive_DMA+0xcc>
    {
      /* Set the I2C DMA transfer complete callback */
      hi2c->hdmarx->XferCpltCallback = I2C_DMASlaveReceiveCplt;
2400a04a:	68fb      	ldr	r3, [r7, #12]
2400a04c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400a04e:	4a35      	ldr	r2, [pc, #212]	; (2400a124 <HAL_I2C_Slave_Receive_DMA+0x164>)
2400a050:	63da      	str	r2, [r3, #60]	; 0x3c

      /* Set the DMA error callback */
      hi2c->hdmarx->XferErrorCallback = I2C_DMAError;
2400a052:	68fb      	ldr	r3, [r7, #12]
2400a054:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400a056:	4a34      	ldr	r2, [pc, #208]	; (2400a128 <HAL_I2C_Slave_Receive_DMA+0x168>)
2400a058:	64da      	str	r2, [r3, #76]	; 0x4c

      /* Set the unused DMA callbacks to NULL */
      hi2c->hdmarx->XferHalfCpltCallback = NULL;
2400a05a:	68fb      	ldr	r3, [r7, #12]
2400a05c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400a05e:	2200      	movs	r2, #0
2400a060:	641a      	str	r2, [r3, #64]	; 0x40
      hi2c->hdmarx->XferAbortCallback = NULL;
2400a062:	68fb      	ldr	r3, [r7, #12]
2400a064:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400a066:	2200      	movs	r2, #0
2400a068:	651a      	str	r2, [r3, #80]	; 0x50

      /* Enable the DMA stream or channel depends on Instance */
      dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->RXDR, (uint32_t)pData, hi2c->XferSize);
2400a06a:	68fb      	ldr	r3, [r7, #12]
2400a06c:	6bd8      	ldr	r0, [r3, #60]	; 0x3c
2400a06e:	68fb      	ldr	r3, [r7, #12]
2400a070:	681b      	ldr	r3, [r3, #0]
2400a072:	3324      	adds	r3, #36	; 0x24
2400a074:	4619      	mov	r1, r3
2400a076:	68ba      	ldr	r2, [r7, #8]
2400a078:	68fb      	ldr	r3, [r7, #12]
2400a07a:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400a07c:	f7f8 fa68 	bl	24002550 <HAL_DMA_Start_IT>
2400a080:	4603      	mov	r3, r0
2400a082:	75fb      	strb	r3, [r7, #23]
      __HAL_UNLOCK(hi2c);

      return HAL_ERROR;
    }

    if (dmaxferstatus == HAL_OK)
2400a084:	7dfb      	ldrb	r3, [r7, #23]
2400a086:	2b00      	cmp	r3, #0
2400a088:	d12f      	bne.n	2400a0ea <HAL_I2C_Slave_Receive_DMA+0x12a>
2400a08a:	e013      	b.n	2400a0b4 <HAL_I2C_Slave_Receive_DMA+0xf4>
      hi2c->State     = HAL_I2C_STATE_LISTEN;
2400a08c:	68fb      	ldr	r3, [r7, #12]
2400a08e:	2228      	movs	r2, #40	; 0x28
2400a090:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
      hi2c->Mode      = HAL_I2C_MODE_NONE;
2400a094:	68fb      	ldr	r3, [r7, #12]
2400a096:	2200      	movs	r2, #0
2400a098:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
      hi2c->ErrorCode |= HAL_I2C_ERROR_DMA_PARAM;
2400a09c:	68fb      	ldr	r3, [r7, #12]
2400a09e:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400a0a0:	f043 0280 	orr.w	r2, r3, #128	; 0x80
2400a0a4:	68fb      	ldr	r3, [r7, #12]
2400a0a6:	645a      	str	r2, [r3, #68]	; 0x44
      __HAL_UNLOCK(hi2c);
2400a0a8:	68fb      	ldr	r3, [r7, #12]
2400a0aa:	2200      	movs	r2, #0
2400a0ac:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      return HAL_ERROR;
2400a0b0:	2301      	movs	r3, #1
2400a0b2:	e02f      	b.n	2400a114 <HAL_I2C_Slave_Receive_DMA+0x154>
    {
      /* Enable Address Acknowledge */
      hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
2400a0b4:	68fb      	ldr	r3, [r7, #12]
2400a0b6:	681b      	ldr	r3, [r3, #0]
2400a0b8:	685a      	ldr	r2, [r3, #4]
2400a0ba:	68fb      	ldr	r3, [r7, #12]
2400a0bc:	681b      	ldr	r3, [r3, #0]
2400a0be:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
2400a0c2:	605a      	str	r2, [r3, #4]

      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
2400a0c4:	68fb      	ldr	r3, [r7, #12]
2400a0c6:	2200      	movs	r2, #0
2400a0c8:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

      /* Note : The I2C interrupts must be enabled after unlocking current process
                to avoid the risk of I2C interrupt handle execution before current
                process unlock */
      /* Enable ERR, STOP, NACK, ADDR interrupts */
      I2C_Enable_IRQ(hi2c, I2C_XFER_LISTEN_IT);
2400a0cc:	f44f 4100 	mov.w	r1, #32768	; 0x8000
2400a0d0:	68f8      	ldr	r0, [r7, #12]
2400a0d2:	f003 fe61 	bl	2400dd98 <I2C_Enable_IRQ>

      /* Enable DMA Request */
      hi2c->Instance->CR1 |= I2C_CR1_RXDMAEN;
2400a0d6:	68fb      	ldr	r3, [r7, #12]
2400a0d8:	681b      	ldr	r3, [r3, #0]
2400a0da:	681a      	ldr	r2, [r3, #0]
2400a0dc:	68fb      	ldr	r3, [r7, #12]
2400a0de:	681b      	ldr	r3, [r3, #0]
2400a0e0:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
2400a0e4:	601a      	str	r2, [r3, #0]
      __HAL_UNLOCK(hi2c);

      return HAL_ERROR;
    }

    return HAL_OK;
2400a0e6:	2300      	movs	r3, #0
2400a0e8:	e014      	b.n	2400a114 <HAL_I2C_Slave_Receive_DMA+0x154>
      hi2c->State     = HAL_I2C_STATE_LISTEN;
2400a0ea:	68fb      	ldr	r3, [r7, #12]
2400a0ec:	2228      	movs	r2, #40	; 0x28
2400a0ee:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
      hi2c->Mode      = HAL_I2C_MODE_NONE;
2400a0f2:	68fb      	ldr	r3, [r7, #12]
2400a0f4:	2200      	movs	r2, #0
2400a0f6:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
      hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
2400a0fa:	68fb      	ldr	r3, [r7, #12]
2400a0fc:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400a0fe:	f043 0210 	orr.w	r2, r3, #16
2400a102:	68fb      	ldr	r3, [r7, #12]
2400a104:	645a      	str	r2, [r3, #68]	; 0x44
      __HAL_UNLOCK(hi2c);
2400a106:	68fb      	ldr	r3, [r7, #12]
2400a108:	2200      	movs	r2, #0
2400a10a:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      return HAL_ERROR;
2400a10e:	2301      	movs	r3, #1
2400a110:	e000      	b.n	2400a114 <HAL_I2C_Slave_Receive_DMA+0x154>
  }
  else
  {
    return HAL_BUSY;
2400a112:	2302      	movs	r3, #2
  }
}
2400a114:	4618      	mov	r0, r3
2400a116:	3718      	adds	r7, #24
2400a118:	46bd      	mov	sp, r7
2400a11a:	bd80      	pop	{r7, pc}
2400a11c:	ffff0000 	.word	0xffff0000
2400a120:	2400c4f1 	.word	0x2400c4f1
2400a124:	2400d611 	.word	0x2400d611
2400a128:	2400d775 	.word	0x2400d775

2400a12c <HAL_I2C_Mem_Write>:
  * @param  Size Amount of data to be sent
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Mem_Write(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
2400a12c:	b580      	push	{r7, lr}
2400a12e:	b088      	sub	sp, #32
2400a130:	af02      	add	r7, sp, #8
2400a132:	60f8      	str	r0, [r7, #12]
2400a134:	4608      	mov	r0, r1
2400a136:	4611      	mov	r1, r2
2400a138:	461a      	mov	r2, r3
2400a13a:	4603      	mov	r3, r0
2400a13c:	817b      	strh	r3, [r7, #10]
2400a13e:	460b      	mov	r3, r1
2400a140:	813b      	strh	r3, [r7, #8]
2400a142:	4613      	mov	r3, r2
2400a144:	80fb      	strh	r3, [r7, #6]
  uint32_t tickstart;

  /* Check the parameters */
  assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));

  if (hi2c->State == HAL_I2C_STATE_READY)
2400a146:	68fb      	ldr	r3, [r7, #12]
2400a148:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400a14c:	b2db      	uxtb	r3, r3
2400a14e:	2b20      	cmp	r3, #32
2400a150:	f040 80f9 	bne.w	2400a346 <HAL_I2C_Mem_Write+0x21a>
  {
    if ((pData == NULL) || (Size == 0U))
2400a154:	6a3b      	ldr	r3, [r7, #32]
2400a156:	2b00      	cmp	r3, #0
2400a158:	d002      	beq.n	2400a160 <HAL_I2C_Mem_Write+0x34>
2400a15a:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
2400a15c:	2b00      	cmp	r3, #0
2400a15e:	d105      	bne.n	2400a16c <HAL_I2C_Mem_Write+0x40>
    {
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
2400a160:	68fb      	ldr	r3, [r7, #12]
2400a162:	f44f 7200 	mov.w	r2, #512	; 0x200
2400a166:	645a      	str	r2, [r3, #68]	; 0x44
      return  HAL_ERROR;
2400a168:	2301      	movs	r3, #1
2400a16a:	e0ed      	b.n	2400a348 <HAL_I2C_Mem_Write+0x21c>
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
2400a16c:	68fb      	ldr	r3, [r7, #12]
2400a16e:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2400a172:	2b01      	cmp	r3, #1
2400a174:	d101      	bne.n	2400a17a <HAL_I2C_Mem_Write+0x4e>
2400a176:	2302      	movs	r3, #2
2400a178:	e0e6      	b.n	2400a348 <HAL_I2C_Mem_Write+0x21c>
2400a17a:	68fb      	ldr	r3, [r7, #12]
2400a17c:	2201      	movs	r2, #1
2400a17e:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Init tickstart for timeout management*/
    tickstart = HAL_GetTick();
2400a182:	f7f6 fb67 	bl	24000854 <HAL_GetTick>
2400a186:	6178      	str	r0, [r7, #20]

    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
2400a188:	697b      	ldr	r3, [r7, #20]
2400a18a:	9300      	str	r3, [sp, #0]
2400a18c:	2319      	movs	r3, #25
2400a18e:	2201      	movs	r2, #1
2400a190:	f44f 4100 	mov.w	r1, #32768	; 0x8000
2400a194:	68f8      	ldr	r0, [r7, #12]
2400a196:	f003 fc43 	bl	2400da20 <I2C_WaitOnFlagUntilTimeout>
2400a19a:	4603      	mov	r3, r0
2400a19c:	2b00      	cmp	r3, #0
2400a19e:	d001      	beq.n	2400a1a4 <HAL_I2C_Mem_Write+0x78>
    {
      return HAL_ERROR;
2400a1a0:	2301      	movs	r3, #1
2400a1a2:	e0d1      	b.n	2400a348 <HAL_I2C_Mem_Write+0x21c>
    }

    hi2c->State     = HAL_I2C_STATE_BUSY_TX;
2400a1a4:	68fb      	ldr	r3, [r7, #12]
2400a1a6:	2221      	movs	r2, #33	; 0x21
2400a1a8:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode      = HAL_I2C_MODE_MEM;
2400a1ac:	68fb      	ldr	r3, [r7, #12]
2400a1ae:	2240      	movs	r2, #64	; 0x40
2400a1b0:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
2400a1b4:	68fb      	ldr	r3, [r7, #12]
2400a1b6:	2200      	movs	r2, #0
2400a1b8:	645a      	str	r2, [r3, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr  = pData;
2400a1ba:	68fb      	ldr	r3, [r7, #12]
2400a1bc:	6a3a      	ldr	r2, [r7, #32]
2400a1be:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount = Size;
2400a1c0:	68fb      	ldr	r3, [r7, #12]
2400a1c2:	8cba      	ldrh	r2, [r7, #36]	; 0x24
2400a1c4:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferISR   = NULL;
2400a1c6:	68fb      	ldr	r3, [r7, #12]
2400a1c8:	2200      	movs	r2, #0
2400a1ca:	635a      	str	r2, [r3, #52]	; 0x34

    /* Send Slave Address and Memory Address */
    if (I2C_RequestMemoryWrite(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
2400a1cc:	88f8      	ldrh	r0, [r7, #6]
2400a1ce:	893a      	ldrh	r2, [r7, #8]
2400a1d0:	8979      	ldrh	r1, [r7, #10]
2400a1d2:	697b      	ldr	r3, [r7, #20]
2400a1d4:	9301      	str	r3, [sp, #4]
2400a1d6:	6abb      	ldr	r3, [r7, #40]	; 0x28
2400a1d8:	9300      	str	r3, [sp, #0]
2400a1da:	4603      	mov	r3, r0
2400a1dc:	68f8      	ldr	r0, [r7, #12]
2400a1de:	f002 fb67 	bl	2400c8b0 <I2C_RequestMemoryWrite>
2400a1e2:	4603      	mov	r3, r0
2400a1e4:	2b00      	cmp	r3, #0
2400a1e6:	d005      	beq.n	2400a1f4 <HAL_I2C_Mem_Write+0xc8>
    {
      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
2400a1e8:	68fb      	ldr	r3, [r7, #12]
2400a1ea:	2200      	movs	r2, #0
2400a1ec:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      return HAL_ERROR;
2400a1f0:	2301      	movs	r3, #1
2400a1f2:	e0a9      	b.n	2400a348 <HAL_I2C_Mem_Write+0x21c>
    }

    /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE */
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
2400a1f4:	68fb      	ldr	r3, [r7, #12]
2400a1f6:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400a1f8:	b29b      	uxth	r3, r3
2400a1fa:	2bff      	cmp	r3, #255	; 0xff
2400a1fc:	d90e      	bls.n	2400a21c <HAL_I2C_Mem_Write+0xf0>
    {
      hi2c->XferSize = MAX_NBYTE_SIZE;
2400a1fe:	68fb      	ldr	r3, [r7, #12]
2400a200:	22ff      	movs	r2, #255	; 0xff
2400a202:	851a      	strh	r2, [r3, #40]	; 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
2400a204:	68fb      	ldr	r3, [r7, #12]
2400a206:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400a208:	b2da      	uxtb	r2, r3
2400a20a:	8979      	ldrh	r1, [r7, #10]
2400a20c:	2300      	movs	r3, #0
2400a20e:	9300      	str	r3, [sp, #0]
2400a210:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
2400a214:	68f8      	ldr	r0, [r7, #12]
2400a216:	f003 fd91 	bl	2400dd3c <I2C_TransferConfig>
2400a21a:	e00f      	b.n	2400a23c <HAL_I2C_Mem_Write+0x110>
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
2400a21c:	68fb      	ldr	r3, [r7, #12]
2400a21e:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400a220:	b29a      	uxth	r2, r3
2400a222:	68fb      	ldr	r3, [r7, #12]
2400a224:	851a      	strh	r2, [r3, #40]	; 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
2400a226:	68fb      	ldr	r3, [r7, #12]
2400a228:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400a22a:	b2da      	uxtb	r2, r3
2400a22c:	8979      	ldrh	r1, [r7, #10]
2400a22e:	2300      	movs	r3, #0
2400a230:	9300      	str	r3, [sp, #0]
2400a232:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
2400a236:	68f8      	ldr	r0, [r7, #12]
2400a238:	f003 fd80 	bl	2400dd3c <I2C_TransferConfig>
    }

    do
    {
      /* Wait until TXIS flag is set */
      if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
2400a23c:	697a      	ldr	r2, [r7, #20]
2400a23e:	6ab9      	ldr	r1, [r7, #40]	; 0x28
2400a240:	68f8      	ldr	r0, [r7, #12]
2400a242:	f003 fc2d 	bl	2400daa0 <I2C_WaitOnTXISFlagUntilTimeout>
2400a246:	4603      	mov	r3, r0
2400a248:	2b00      	cmp	r3, #0
2400a24a:	d001      	beq.n	2400a250 <HAL_I2C_Mem_Write+0x124>
      {
        return HAL_ERROR;
2400a24c:	2301      	movs	r3, #1
2400a24e:	e07b      	b.n	2400a348 <HAL_I2C_Mem_Write+0x21c>
      }

      /* Write data to TXDR */
      hi2c->Instance->TXDR = *hi2c->pBuffPtr;
2400a250:	68fb      	ldr	r3, [r7, #12]
2400a252:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2400a254:	781a      	ldrb	r2, [r3, #0]
2400a256:	68fb      	ldr	r3, [r7, #12]
2400a258:	681b      	ldr	r3, [r3, #0]
2400a25a:	629a      	str	r2, [r3, #40]	; 0x28

      /* Increment Buffer pointer */
      hi2c->pBuffPtr++;
2400a25c:	68fb      	ldr	r3, [r7, #12]
2400a25e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2400a260:	1c5a      	adds	r2, r3, #1
2400a262:	68fb      	ldr	r3, [r7, #12]
2400a264:	625a      	str	r2, [r3, #36]	; 0x24

      hi2c->XferCount--;
2400a266:	68fb      	ldr	r3, [r7, #12]
2400a268:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400a26a:	b29b      	uxth	r3, r3
2400a26c:	3b01      	subs	r3, #1
2400a26e:	b29a      	uxth	r2, r3
2400a270:	68fb      	ldr	r3, [r7, #12]
2400a272:	855a      	strh	r2, [r3, #42]	; 0x2a
      hi2c->XferSize--;
2400a274:	68fb      	ldr	r3, [r7, #12]
2400a276:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400a278:	3b01      	subs	r3, #1
2400a27a:	b29a      	uxth	r2, r3
2400a27c:	68fb      	ldr	r3, [r7, #12]
2400a27e:	851a      	strh	r2, [r3, #40]	; 0x28

      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
2400a280:	68fb      	ldr	r3, [r7, #12]
2400a282:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400a284:	b29b      	uxth	r3, r3
2400a286:	2b00      	cmp	r3, #0
2400a288:	d034      	beq.n	2400a2f4 <HAL_I2C_Mem_Write+0x1c8>
2400a28a:	68fb      	ldr	r3, [r7, #12]
2400a28c:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400a28e:	2b00      	cmp	r3, #0
2400a290:	d130      	bne.n	2400a2f4 <HAL_I2C_Mem_Write+0x1c8>
      {
        /* Wait until TCR flag is set */
        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, tickstart) != HAL_OK)
2400a292:	697b      	ldr	r3, [r7, #20]
2400a294:	9300      	str	r3, [sp, #0]
2400a296:	6abb      	ldr	r3, [r7, #40]	; 0x28
2400a298:	2200      	movs	r2, #0
2400a29a:	2180      	movs	r1, #128	; 0x80
2400a29c:	68f8      	ldr	r0, [r7, #12]
2400a29e:	f003 fbbf 	bl	2400da20 <I2C_WaitOnFlagUntilTimeout>
2400a2a2:	4603      	mov	r3, r0
2400a2a4:	2b00      	cmp	r3, #0
2400a2a6:	d001      	beq.n	2400a2ac <HAL_I2C_Mem_Write+0x180>
        {
          return HAL_ERROR;
2400a2a8:	2301      	movs	r3, #1
2400a2aa:	e04d      	b.n	2400a348 <HAL_I2C_Mem_Write+0x21c>
        }

        if (hi2c->XferCount > MAX_NBYTE_SIZE)
2400a2ac:	68fb      	ldr	r3, [r7, #12]
2400a2ae:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400a2b0:	b29b      	uxth	r3, r3
2400a2b2:	2bff      	cmp	r3, #255	; 0xff
2400a2b4:	d90e      	bls.n	2400a2d4 <HAL_I2C_Mem_Write+0x1a8>
        {
          hi2c->XferSize = MAX_NBYTE_SIZE;
2400a2b6:	68fb      	ldr	r3, [r7, #12]
2400a2b8:	22ff      	movs	r2, #255	; 0xff
2400a2ba:	851a      	strh	r2, [r3, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
2400a2bc:	68fb      	ldr	r3, [r7, #12]
2400a2be:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400a2c0:	b2da      	uxtb	r2, r3
2400a2c2:	8979      	ldrh	r1, [r7, #10]
2400a2c4:	2300      	movs	r3, #0
2400a2c6:	9300      	str	r3, [sp, #0]
2400a2c8:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
2400a2cc:	68f8      	ldr	r0, [r7, #12]
2400a2ce:	f003 fd35 	bl	2400dd3c <I2C_TransferConfig>
2400a2d2:	e00f      	b.n	2400a2f4 <HAL_I2C_Mem_Write+0x1c8>
        }
        else
        {
          hi2c->XferSize = hi2c->XferCount;
2400a2d4:	68fb      	ldr	r3, [r7, #12]
2400a2d6:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400a2d8:	b29a      	uxth	r2, r3
2400a2da:	68fb      	ldr	r3, [r7, #12]
2400a2dc:	851a      	strh	r2, [r3, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
2400a2de:	68fb      	ldr	r3, [r7, #12]
2400a2e0:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400a2e2:	b2da      	uxtb	r2, r3
2400a2e4:	8979      	ldrh	r1, [r7, #10]
2400a2e6:	2300      	movs	r3, #0
2400a2e8:	9300      	str	r3, [sp, #0]
2400a2ea:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
2400a2ee:	68f8      	ldr	r0, [r7, #12]
2400a2f0:	f003 fd24 	bl	2400dd3c <I2C_TransferConfig>
        }
      }

    }
    while (hi2c->XferCount > 0U);
2400a2f4:	68fb      	ldr	r3, [r7, #12]
2400a2f6:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400a2f8:	b29b      	uxth	r3, r3
2400a2fa:	2b00      	cmp	r3, #0
2400a2fc:	d19e      	bne.n	2400a23c <HAL_I2C_Mem_Write+0x110>

    /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
    /* Wait until STOPF flag is reset */
    if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
2400a2fe:	697a      	ldr	r2, [r7, #20]
2400a300:	6ab9      	ldr	r1, [r7, #40]	; 0x28
2400a302:	68f8      	ldr	r0, [r7, #12]
2400a304:	f003 fc0c 	bl	2400db20 <I2C_WaitOnSTOPFlagUntilTimeout>
2400a308:	4603      	mov	r3, r0
2400a30a:	2b00      	cmp	r3, #0
2400a30c:	d001      	beq.n	2400a312 <HAL_I2C_Mem_Write+0x1e6>
    {
      return HAL_ERROR;
2400a30e:	2301      	movs	r3, #1
2400a310:	e01a      	b.n	2400a348 <HAL_I2C_Mem_Write+0x21c>
    }

    /* Clear STOP Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
2400a312:	68fb      	ldr	r3, [r7, #12]
2400a314:	681b      	ldr	r3, [r3, #0]
2400a316:	2220      	movs	r2, #32
2400a318:	61da      	str	r2, [r3, #28]

    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);
2400a31a:	68fb      	ldr	r3, [r7, #12]
2400a31c:	681b      	ldr	r3, [r3, #0]
2400a31e:	6859      	ldr	r1, [r3, #4]
2400a320:	68fb      	ldr	r3, [r7, #12]
2400a322:	681a      	ldr	r2, [r3, #0]
2400a324:	4b0a      	ldr	r3, [pc, #40]	; (2400a350 <HAL_I2C_Mem_Write+0x224>)
2400a326:	400b      	ands	r3, r1
2400a328:	6053      	str	r3, [r2, #4]

    hi2c->State = HAL_I2C_STATE_READY;
2400a32a:	68fb      	ldr	r3, [r7, #12]
2400a32c:	2220      	movs	r2, #32
2400a32e:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode  = HAL_I2C_MODE_NONE;
2400a332:	68fb      	ldr	r3, [r7, #12]
2400a334:	2200      	movs	r2, #0
2400a336:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
2400a33a:	68fb      	ldr	r3, [r7, #12]
2400a33c:	2200      	movs	r2, #0
2400a33e:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    return HAL_OK;
2400a342:	2300      	movs	r3, #0
2400a344:	e000      	b.n	2400a348 <HAL_I2C_Mem_Write+0x21c>
  }
  else
  {
    return HAL_BUSY;
2400a346:	2302      	movs	r3, #2
  }
}
2400a348:	4618      	mov	r0, r3
2400a34a:	3718      	adds	r7, #24
2400a34c:	46bd      	mov	sp, r7
2400a34e:	bd80      	pop	{r7, pc}
2400a350:	fe00e800 	.word	0xfe00e800

2400a354 <HAL_I2C_Mem_Read>:
  * @param  Size Amount of data to be sent
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Mem_Read(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
2400a354:	b580      	push	{r7, lr}
2400a356:	b088      	sub	sp, #32
2400a358:	af02      	add	r7, sp, #8
2400a35a:	60f8      	str	r0, [r7, #12]
2400a35c:	4608      	mov	r0, r1
2400a35e:	4611      	mov	r1, r2
2400a360:	461a      	mov	r2, r3
2400a362:	4603      	mov	r3, r0
2400a364:	817b      	strh	r3, [r7, #10]
2400a366:	460b      	mov	r3, r1
2400a368:	813b      	strh	r3, [r7, #8]
2400a36a:	4613      	mov	r3, r2
2400a36c:	80fb      	strh	r3, [r7, #6]
  uint32_t tickstart;

  /* Check the parameters */
  assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));

  if (hi2c->State == HAL_I2C_STATE_READY)
2400a36e:	68fb      	ldr	r3, [r7, #12]
2400a370:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400a374:	b2db      	uxtb	r3, r3
2400a376:	2b20      	cmp	r3, #32
2400a378:	f040 80fd 	bne.w	2400a576 <HAL_I2C_Mem_Read+0x222>
  {
    if ((pData == NULL) || (Size == 0U))
2400a37c:	6a3b      	ldr	r3, [r7, #32]
2400a37e:	2b00      	cmp	r3, #0
2400a380:	d002      	beq.n	2400a388 <HAL_I2C_Mem_Read+0x34>
2400a382:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
2400a384:	2b00      	cmp	r3, #0
2400a386:	d105      	bne.n	2400a394 <HAL_I2C_Mem_Read+0x40>
    {
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
2400a388:	68fb      	ldr	r3, [r7, #12]
2400a38a:	f44f 7200 	mov.w	r2, #512	; 0x200
2400a38e:	645a      	str	r2, [r3, #68]	; 0x44
      return  HAL_ERROR;
2400a390:	2301      	movs	r3, #1
2400a392:	e0f1      	b.n	2400a578 <HAL_I2C_Mem_Read+0x224>
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
2400a394:	68fb      	ldr	r3, [r7, #12]
2400a396:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2400a39a:	2b01      	cmp	r3, #1
2400a39c:	d101      	bne.n	2400a3a2 <HAL_I2C_Mem_Read+0x4e>
2400a39e:	2302      	movs	r3, #2
2400a3a0:	e0ea      	b.n	2400a578 <HAL_I2C_Mem_Read+0x224>
2400a3a2:	68fb      	ldr	r3, [r7, #12]
2400a3a4:	2201      	movs	r2, #1
2400a3a6:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Init tickstart for timeout management*/
    tickstart = HAL_GetTick();
2400a3aa:	f7f6 fa53 	bl	24000854 <HAL_GetTick>
2400a3ae:	6178      	str	r0, [r7, #20]

    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
2400a3b0:	697b      	ldr	r3, [r7, #20]
2400a3b2:	9300      	str	r3, [sp, #0]
2400a3b4:	2319      	movs	r3, #25
2400a3b6:	2201      	movs	r2, #1
2400a3b8:	f44f 4100 	mov.w	r1, #32768	; 0x8000
2400a3bc:	68f8      	ldr	r0, [r7, #12]
2400a3be:	f003 fb2f 	bl	2400da20 <I2C_WaitOnFlagUntilTimeout>
2400a3c2:	4603      	mov	r3, r0
2400a3c4:	2b00      	cmp	r3, #0
2400a3c6:	d001      	beq.n	2400a3cc <HAL_I2C_Mem_Read+0x78>
    {
      return HAL_ERROR;
2400a3c8:	2301      	movs	r3, #1
2400a3ca:	e0d5      	b.n	2400a578 <HAL_I2C_Mem_Read+0x224>
    }

    hi2c->State     = HAL_I2C_STATE_BUSY_RX;
2400a3cc:	68fb      	ldr	r3, [r7, #12]
2400a3ce:	2222      	movs	r2, #34	; 0x22
2400a3d0:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode      = HAL_I2C_MODE_MEM;
2400a3d4:	68fb      	ldr	r3, [r7, #12]
2400a3d6:	2240      	movs	r2, #64	; 0x40
2400a3d8:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
2400a3dc:	68fb      	ldr	r3, [r7, #12]
2400a3de:	2200      	movs	r2, #0
2400a3e0:	645a      	str	r2, [r3, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr  = pData;
2400a3e2:	68fb      	ldr	r3, [r7, #12]
2400a3e4:	6a3a      	ldr	r2, [r7, #32]
2400a3e6:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount = Size;
2400a3e8:	68fb      	ldr	r3, [r7, #12]
2400a3ea:	8cba      	ldrh	r2, [r7, #36]	; 0x24
2400a3ec:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferISR   = NULL;
2400a3ee:	68fb      	ldr	r3, [r7, #12]
2400a3f0:	2200      	movs	r2, #0
2400a3f2:	635a      	str	r2, [r3, #52]	; 0x34

    /* Send Slave Address and Memory Address */
    if (I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
2400a3f4:	88f8      	ldrh	r0, [r7, #6]
2400a3f6:	893a      	ldrh	r2, [r7, #8]
2400a3f8:	8979      	ldrh	r1, [r7, #10]
2400a3fa:	697b      	ldr	r3, [r7, #20]
2400a3fc:	9301      	str	r3, [sp, #4]
2400a3fe:	6abb      	ldr	r3, [r7, #40]	; 0x28
2400a400:	9300      	str	r3, [sp, #0]
2400a402:	4603      	mov	r3, r0
2400a404:	68f8      	ldr	r0, [r7, #12]
2400a406:	f002 faa7 	bl	2400c958 <I2C_RequestMemoryRead>
2400a40a:	4603      	mov	r3, r0
2400a40c:	2b00      	cmp	r3, #0
2400a40e:	d005      	beq.n	2400a41c <HAL_I2C_Mem_Read+0xc8>
    {
      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
2400a410:	68fb      	ldr	r3, [r7, #12]
2400a412:	2200      	movs	r2, #0
2400a414:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      return HAL_ERROR;
2400a418:	2301      	movs	r3, #1
2400a41a:	e0ad      	b.n	2400a578 <HAL_I2C_Mem_Read+0x224>
    }

    /* Send Slave Address */
    /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE and generate RESTART */
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
2400a41c:	68fb      	ldr	r3, [r7, #12]
2400a41e:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400a420:	b29b      	uxth	r3, r3
2400a422:	2bff      	cmp	r3, #255	; 0xff
2400a424:	d90e      	bls.n	2400a444 <HAL_I2C_Mem_Read+0xf0>
    {
      hi2c->XferSize = MAX_NBYTE_SIZE;
2400a426:	68fb      	ldr	r3, [r7, #12]
2400a428:	22ff      	movs	r2, #255	; 0xff
2400a42a:	851a      	strh	r2, [r3, #40]	; 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_GENERATE_START_READ);
2400a42c:	68fb      	ldr	r3, [r7, #12]
2400a42e:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400a430:	b2da      	uxtb	r2, r3
2400a432:	8979      	ldrh	r1, [r7, #10]
2400a434:	4b52      	ldr	r3, [pc, #328]	; (2400a580 <HAL_I2C_Mem_Read+0x22c>)
2400a436:	9300      	str	r3, [sp, #0]
2400a438:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
2400a43c:	68f8      	ldr	r0, [r7, #12]
2400a43e:	f003 fc7d 	bl	2400dd3c <I2C_TransferConfig>
2400a442:	e00f      	b.n	2400a464 <HAL_I2C_Mem_Read+0x110>
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
2400a444:	68fb      	ldr	r3, [r7, #12]
2400a446:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400a448:	b29a      	uxth	r2, r3
2400a44a:	68fb      	ldr	r3, [r7, #12]
2400a44c:	851a      	strh	r2, [r3, #40]	; 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_GENERATE_START_READ);
2400a44e:	68fb      	ldr	r3, [r7, #12]
2400a450:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400a452:	b2da      	uxtb	r2, r3
2400a454:	8979      	ldrh	r1, [r7, #10]
2400a456:	4b4a      	ldr	r3, [pc, #296]	; (2400a580 <HAL_I2C_Mem_Read+0x22c>)
2400a458:	9300      	str	r3, [sp, #0]
2400a45a:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
2400a45e:	68f8      	ldr	r0, [r7, #12]
2400a460:	f003 fc6c 	bl	2400dd3c <I2C_TransferConfig>
    }

    do
    {
      /* Wait until RXNE flag is set */
      if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_RXNE, RESET, Timeout, tickstart) != HAL_OK)
2400a464:	697b      	ldr	r3, [r7, #20]
2400a466:	9300      	str	r3, [sp, #0]
2400a468:	6abb      	ldr	r3, [r7, #40]	; 0x28
2400a46a:	2200      	movs	r2, #0
2400a46c:	2104      	movs	r1, #4
2400a46e:	68f8      	ldr	r0, [r7, #12]
2400a470:	f003 fad6 	bl	2400da20 <I2C_WaitOnFlagUntilTimeout>
2400a474:	4603      	mov	r3, r0
2400a476:	2b00      	cmp	r3, #0
2400a478:	d001      	beq.n	2400a47e <HAL_I2C_Mem_Read+0x12a>
      {
        return HAL_ERROR;
2400a47a:	2301      	movs	r3, #1
2400a47c:	e07c      	b.n	2400a578 <HAL_I2C_Mem_Read+0x224>
      }

      /* Read data from RXDR */
      *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
2400a47e:	68fb      	ldr	r3, [r7, #12]
2400a480:	681b      	ldr	r3, [r3, #0]
2400a482:	6a5a      	ldr	r2, [r3, #36]	; 0x24
2400a484:	68fb      	ldr	r3, [r7, #12]
2400a486:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2400a488:	b2d2      	uxtb	r2, r2
2400a48a:	701a      	strb	r2, [r3, #0]

      /* Increment Buffer pointer */
      hi2c->pBuffPtr++;
2400a48c:	68fb      	ldr	r3, [r7, #12]
2400a48e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2400a490:	1c5a      	adds	r2, r3, #1
2400a492:	68fb      	ldr	r3, [r7, #12]
2400a494:	625a      	str	r2, [r3, #36]	; 0x24

      hi2c->XferSize--;
2400a496:	68fb      	ldr	r3, [r7, #12]
2400a498:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400a49a:	3b01      	subs	r3, #1
2400a49c:	b29a      	uxth	r2, r3
2400a49e:	68fb      	ldr	r3, [r7, #12]
2400a4a0:	851a      	strh	r2, [r3, #40]	; 0x28
      hi2c->XferCount--;
2400a4a2:	68fb      	ldr	r3, [r7, #12]
2400a4a4:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400a4a6:	b29b      	uxth	r3, r3
2400a4a8:	3b01      	subs	r3, #1
2400a4aa:	b29a      	uxth	r2, r3
2400a4ac:	68fb      	ldr	r3, [r7, #12]
2400a4ae:	855a      	strh	r2, [r3, #42]	; 0x2a

      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
2400a4b0:	68fb      	ldr	r3, [r7, #12]
2400a4b2:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400a4b4:	b29b      	uxth	r3, r3
2400a4b6:	2b00      	cmp	r3, #0
2400a4b8:	d034      	beq.n	2400a524 <HAL_I2C_Mem_Read+0x1d0>
2400a4ba:	68fb      	ldr	r3, [r7, #12]
2400a4bc:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400a4be:	2b00      	cmp	r3, #0
2400a4c0:	d130      	bne.n	2400a524 <HAL_I2C_Mem_Read+0x1d0>
      {
        /* Wait until TCR flag is set */
        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, tickstart) != HAL_OK)
2400a4c2:	697b      	ldr	r3, [r7, #20]
2400a4c4:	9300      	str	r3, [sp, #0]
2400a4c6:	6abb      	ldr	r3, [r7, #40]	; 0x28
2400a4c8:	2200      	movs	r2, #0
2400a4ca:	2180      	movs	r1, #128	; 0x80
2400a4cc:	68f8      	ldr	r0, [r7, #12]
2400a4ce:	f003 faa7 	bl	2400da20 <I2C_WaitOnFlagUntilTimeout>
2400a4d2:	4603      	mov	r3, r0
2400a4d4:	2b00      	cmp	r3, #0
2400a4d6:	d001      	beq.n	2400a4dc <HAL_I2C_Mem_Read+0x188>
        {
          return HAL_ERROR;
2400a4d8:	2301      	movs	r3, #1
2400a4da:	e04d      	b.n	2400a578 <HAL_I2C_Mem_Read+0x224>
        }

        if (hi2c->XferCount > MAX_NBYTE_SIZE)
2400a4dc:	68fb      	ldr	r3, [r7, #12]
2400a4de:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400a4e0:	b29b      	uxth	r3, r3
2400a4e2:	2bff      	cmp	r3, #255	; 0xff
2400a4e4:	d90e      	bls.n	2400a504 <HAL_I2C_Mem_Read+0x1b0>
        {
          hi2c->XferSize = MAX_NBYTE_SIZE;
2400a4e6:	68fb      	ldr	r3, [r7, #12]
2400a4e8:	22ff      	movs	r2, #255	; 0xff
2400a4ea:	851a      	strh	r2, [r3, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t) hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
2400a4ec:	68fb      	ldr	r3, [r7, #12]
2400a4ee:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400a4f0:	b2da      	uxtb	r2, r3
2400a4f2:	8979      	ldrh	r1, [r7, #10]
2400a4f4:	2300      	movs	r3, #0
2400a4f6:	9300      	str	r3, [sp, #0]
2400a4f8:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
2400a4fc:	68f8      	ldr	r0, [r7, #12]
2400a4fe:	f003 fc1d 	bl	2400dd3c <I2C_TransferConfig>
2400a502:	e00f      	b.n	2400a524 <HAL_I2C_Mem_Read+0x1d0>
        }
        else
        {
          hi2c->XferSize = hi2c->XferCount;
2400a504:	68fb      	ldr	r3, [r7, #12]
2400a506:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400a508:	b29a      	uxth	r2, r3
2400a50a:	68fb      	ldr	r3, [r7, #12]
2400a50c:	851a      	strh	r2, [r3, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
2400a50e:	68fb      	ldr	r3, [r7, #12]
2400a510:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400a512:	b2da      	uxtb	r2, r3
2400a514:	8979      	ldrh	r1, [r7, #10]
2400a516:	2300      	movs	r3, #0
2400a518:	9300      	str	r3, [sp, #0]
2400a51a:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
2400a51e:	68f8      	ldr	r0, [r7, #12]
2400a520:	f003 fc0c 	bl	2400dd3c <I2C_TransferConfig>
        }
      }
    }
    while (hi2c->XferCount > 0U);
2400a524:	68fb      	ldr	r3, [r7, #12]
2400a526:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400a528:	b29b      	uxth	r3, r3
2400a52a:	2b00      	cmp	r3, #0
2400a52c:	d19a      	bne.n	2400a464 <HAL_I2C_Mem_Read+0x110>

    /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
    /* Wait until STOPF flag is reset */
    if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
2400a52e:	697a      	ldr	r2, [r7, #20]
2400a530:	6ab9      	ldr	r1, [r7, #40]	; 0x28
2400a532:	68f8      	ldr	r0, [r7, #12]
2400a534:	f003 faf4 	bl	2400db20 <I2C_WaitOnSTOPFlagUntilTimeout>
2400a538:	4603      	mov	r3, r0
2400a53a:	2b00      	cmp	r3, #0
2400a53c:	d001      	beq.n	2400a542 <HAL_I2C_Mem_Read+0x1ee>
    {
      return HAL_ERROR;
2400a53e:	2301      	movs	r3, #1
2400a540:	e01a      	b.n	2400a578 <HAL_I2C_Mem_Read+0x224>
    }

    /* Clear STOP Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
2400a542:	68fb      	ldr	r3, [r7, #12]
2400a544:	681b      	ldr	r3, [r3, #0]
2400a546:	2220      	movs	r2, #32
2400a548:	61da      	str	r2, [r3, #28]

    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);
2400a54a:	68fb      	ldr	r3, [r7, #12]
2400a54c:	681b      	ldr	r3, [r3, #0]
2400a54e:	6859      	ldr	r1, [r3, #4]
2400a550:	68fb      	ldr	r3, [r7, #12]
2400a552:	681a      	ldr	r2, [r3, #0]
2400a554:	4b0b      	ldr	r3, [pc, #44]	; (2400a584 <HAL_I2C_Mem_Read+0x230>)
2400a556:	400b      	ands	r3, r1
2400a558:	6053      	str	r3, [r2, #4]

    hi2c->State = HAL_I2C_STATE_READY;
2400a55a:	68fb      	ldr	r3, [r7, #12]
2400a55c:	2220      	movs	r2, #32
2400a55e:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode  = HAL_I2C_MODE_NONE;
2400a562:	68fb      	ldr	r3, [r7, #12]
2400a564:	2200      	movs	r2, #0
2400a566:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
2400a56a:	68fb      	ldr	r3, [r7, #12]
2400a56c:	2200      	movs	r2, #0
2400a56e:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    return HAL_OK;
2400a572:	2300      	movs	r3, #0
2400a574:	e000      	b.n	2400a578 <HAL_I2C_Mem_Read+0x224>
  }
  else
  {
    return HAL_BUSY;
2400a576:	2302      	movs	r3, #2
  }
}
2400a578:	4618      	mov	r0, r3
2400a57a:	3718      	adds	r7, #24
2400a57c:	46bd      	mov	sp, r7
2400a57e:	bd80      	pop	{r7, pc}
2400a580:	80002400 	.word	0x80002400
2400a584:	fe00e800 	.word	0xfe00e800

2400a588 <HAL_I2C_Mem_Write_IT>:
  * @param  pData Pointer to data buffer
  * @param  Size Amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Mem_Write_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size)
{
2400a588:	b580      	push	{r7, lr}
2400a58a:	b088      	sub	sp, #32
2400a58c:	af02      	add	r7, sp, #8
2400a58e:	60f8      	str	r0, [r7, #12]
2400a590:	4608      	mov	r0, r1
2400a592:	4611      	mov	r1, r2
2400a594:	461a      	mov	r2, r3
2400a596:	4603      	mov	r3, r0
2400a598:	817b      	strh	r3, [r7, #10]
2400a59a:	460b      	mov	r3, r1
2400a59c:	813b      	strh	r3, [r7, #8]
2400a59e:	4613      	mov	r3, r2
2400a5a0:	80fb      	strh	r3, [r7, #6]
  uint32_t xfermode;

  /* Check the parameters */
  assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));

  if (hi2c->State == HAL_I2C_STATE_READY)
2400a5a2:	68fb      	ldr	r3, [r7, #12]
2400a5a4:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400a5a8:	b2db      	uxtb	r3, r3
2400a5aa:	2b20      	cmp	r3, #32
2400a5ac:	d176      	bne.n	2400a69c <HAL_I2C_Mem_Write_IT+0x114>
  {
    if ((pData == NULL) || (Size == 0U))
2400a5ae:	6a3b      	ldr	r3, [r7, #32]
2400a5b0:	2b00      	cmp	r3, #0
2400a5b2:	d002      	beq.n	2400a5ba <HAL_I2C_Mem_Write_IT+0x32>
2400a5b4:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
2400a5b6:	2b00      	cmp	r3, #0
2400a5b8:	d105      	bne.n	2400a5c6 <HAL_I2C_Mem_Write_IT+0x3e>
    {
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
2400a5ba:	68fb      	ldr	r3, [r7, #12]
2400a5bc:	f44f 7200 	mov.w	r2, #512	; 0x200
2400a5c0:	645a      	str	r2, [r3, #68]	; 0x44
      return  HAL_ERROR;
2400a5c2:	2301      	movs	r3, #1
2400a5c4:	e06b      	b.n	2400a69e <HAL_I2C_Mem_Write_IT+0x116>
    }

    if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
2400a5c6:	68fb      	ldr	r3, [r7, #12]
2400a5c8:	681b      	ldr	r3, [r3, #0]
2400a5ca:	699b      	ldr	r3, [r3, #24]
2400a5cc:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
2400a5d0:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
2400a5d4:	d101      	bne.n	2400a5da <HAL_I2C_Mem_Write_IT+0x52>
    {
      return HAL_BUSY;
2400a5d6:	2302      	movs	r3, #2
2400a5d8:	e061      	b.n	2400a69e <HAL_I2C_Mem_Write_IT+0x116>
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
2400a5da:	68fb      	ldr	r3, [r7, #12]
2400a5dc:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2400a5e0:	2b01      	cmp	r3, #1
2400a5e2:	d101      	bne.n	2400a5e8 <HAL_I2C_Mem_Write_IT+0x60>
2400a5e4:	2302      	movs	r3, #2
2400a5e6:	e05a      	b.n	2400a69e <HAL_I2C_Mem_Write_IT+0x116>
2400a5e8:	68fb      	ldr	r3, [r7, #12]
2400a5ea:	2201      	movs	r2, #1
2400a5ec:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Init tickstart for timeout management*/
    tickstart = HAL_GetTick();
2400a5f0:	f7f6 f930 	bl	24000854 <HAL_GetTick>
2400a5f4:	6138      	str	r0, [r7, #16]

    hi2c->State       = HAL_I2C_STATE_BUSY_TX;
2400a5f6:	68fb      	ldr	r3, [r7, #12]
2400a5f8:	2221      	movs	r2, #33	; 0x21
2400a5fa:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode        = HAL_I2C_MODE_MEM;
2400a5fe:	68fb      	ldr	r3, [r7, #12]
2400a600:	2240      	movs	r2, #64	; 0x40
2400a602:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
2400a606:	68fb      	ldr	r3, [r7, #12]
2400a608:	2200      	movs	r2, #0
2400a60a:	645a      	str	r2, [r3, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr    = pData;
2400a60c:	68fb      	ldr	r3, [r7, #12]
2400a60e:	6a3a      	ldr	r2, [r7, #32]
2400a610:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount   = Size;
2400a612:	68fb      	ldr	r3, [r7, #12]
2400a614:	8cba      	ldrh	r2, [r7, #36]	; 0x24
2400a616:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
2400a618:	68fb      	ldr	r3, [r7, #12]
2400a61a:	4a23      	ldr	r2, [pc, #140]	; (2400a6a8 <HAL_I2C_Mem_Write_IT+0x120>)
2400a61c:	62da      	str	r2, [r3, #44]	; 0x2c
    hi2c->XferISR     = I2C_Master_ISR_IT;
2400a61e:	68fb      	ldr	r3, [r7, #12]
2400a620:	4a22      	ldr	r2, [pc, #136]	; (2400a6ac <HAL_I2C_Mem_Write_IT+0x124>)
2400a622:	635a      	str	r2, [r3, #52]	; 0x34

    if (hi2c->XferCount > MAX_NBYTE_SIZE)
2400a624:	68fb      	ldr	r3, [r7, #12]
2400a626:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400a628:	b29b      	uxth	r3, r3
2400a62a:	2bff      	cmp	r3, #255	; 0xff
2400a62c:	d906      	bls.n	2400a63c <HAL_I2C_Mem_Write_IT+0xb4>
    {
      hi2c->XferSize = MAX_NBYTE_SIZE;
2400a62e:	68fb      	ldr	r3, [r7, #12]
2400a630:	22ff      	movs	r2, #255	; 0xff
2400a632:	851a      	strh	r2, [r3, #40]	; 0x28
      xfermode = I2C_RELOAD_MODE;
2400a634:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
2400a638:	617b      	str	r3, [r7, #20]
2400a63a:	e007      	b.n	2400a64c <HAL_I2C_Mem_Write_IT+0xc4>
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
2400a63c:	68fb      	ldr	r3, [r7, #12]
2400a63e:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400a640:	b29a      	uxth	r2, r3
2400a642:	68fb      	ldr	r3, [r7, #12]
2400a644:	851a      	strh	r2, [r3, #40]	; 0x28
      xfermode = I2C_AUTOEND_MODE;
2400a646:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
2400a64a:	617b      	str	r3, [r7, #20]
    }

    /* Send Slave Address and Memory Address */
    if (I2C_RequestMemoryWrite(hi2c, DevAddress, MemAddress, MemAddSize, I2C_TIMEOUT_FLAG, tickstart) != HAL_OK)
2400a64c:	88f8      	ldrh	r0, [r7, #6]
2400a64e:	893a      	ldrh	r2, [r7, #8]
2400a650:	8979      	ldrh	r1, [r7, #10]
2400a652:	693b      	ldr	r3, [r7, #16]
2400a654:	9301      	str	r3, [sp, #4]
2400a656:	2319      	movs	r3, #25
2400a658:	9300      	str	r3, [sp, #0]
2400a65a:	4603      	mov	r3, r0
2400a65c:	68f8      	ldr	r0, [r7, #12]
2400a65e:	f002 f927 	bl	2400c8b0 <I2C_RequestMemoryWrite>
2400a662:	4603      	mov	r3, r0
2400a664:	2b00      	cmp	r3, #0
2400a666:	d005      	beq.n	2400a674 <HAL_I2C_Mem_Write_IT+0xec>
    {
      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
2400a668:	68fb      	ldr	r3, [r7, #12]
2400a66a:	2200      	movs	r2, #0
2400a66c:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      return HAL_ERROR;
2400a670:	2301      	movs	r3, #1
2400a672:	e014      	b.n	2400a69e <HAL_I2C_Mem_Write_IT+0x116>
    }

    /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE and generate RESTART */
    I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, I2C_NO_STARTSTOP);
2400a674:	68fb      	ldr	r3, [r7, #12]
2400a676:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400a678:	b2da      	uxtb	r2, r3
2400a67a:	8979      	ldrh	r1, [r7, #10]
2400a67c:	2300      	movs	r3, #0
2400a67e:	9300      	str	r3, [sp, #0]
2400a680:	697b      	ldr	r3, [r7, #20]
2400a682:	68f8      	ldr	r0, [r7, #12]
2400a684:	f003 fb5a 	bl	2400dd3c <I2C_TransferConfig>

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
2400a688:	68fb      	ldr	r3, [r7, #12]
2400a68a:	2200      	movs	r2, #0
2400a68c:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
              process unlock */

    /* Enable ERR, TC, STOP, NACK, TXI interrupt */
    /* possible to enable all of these */
    /* I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */
    I2C_Enable_IRQ(hi2c, I2C_XFER_TX_IT);
2400a690:	2101      	movs	r1, #1
2400a692:	68f8      	ldr	r0, [r7, #12]
2400a694:	f003 fb80 	bl	2400dd98 <I2C_Enable_IRQ>

    return HAL_OK;
2400a698:	2300      	movs	r3, #0
2400a69a:	e000      	b.n	2400a69e <HAL_I2C_Mem_Write_IT+0x116>
  }
  else
  {
    return HAL_BUSY;
2400a69c:	2302      	movs	r3, #2
  }
}
2400a69e:	4618      	mov	r0, r3
2400a6a0:	3718      	adds	r7, #24
2400a6a2:	46bd      	mov	sp, r7
2400a6a4:	bd80      	pop	{r7, pc}
2400a6a6:	bf00      	nop
2400a6a8:	ffff0000 	.word	0xffff0000
2400a6ac:	2400beb3 	.word	0x2400beb3

2400a6b0 <HAL_I2C_Mem_Read_IT>:
  * @param  pData Pointer to data buffer
  * @param  Size Amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Mem_Read_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size)
{
2400a6b0:	b580      	push	{r7, lr}
2400a6b2:	b088      	sub	sp, #32
2400a6b4:	af02      	add	r7, sp, #8
2400a6b6:	60f8      	str	r0, [r7, #12]
2400a6b8:	4608      	mov	r0, r1
2400a6ba:	4611      	mov	r1, r2
2400a6bc:	461a      	mov	r2, r3
2400a6be:	4603      	mov	r3, r0
2400a6c0:	817b      	strh	r3, [r7, #10]
2400a6c2:	460b      	mov	r3, r1
2400a6c4:	813b      	strh	r3, [r7, #8]
2400a6c6:	4613      	mov	r3, r2
2400a6c8:	80fb      	strh	r3, [r7, #6]
  uint32_t xfermode;

  /* Check the parameters */
  assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));

  if (hi2c->State == HAL_I2C_STATE_READY)
2400a6ca:	68fb      	ldr	r3, [r7, #12]
2400a6cc:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400a6d0:	b2db      	uxtb	r3, r3
2400a6d2:	2b20      	cmp	r3, #32
2400a6d4:	d176      	bne.n	2400a7c4 <HAL_I2C_Mem_Read_IT+0x114>
  {
    if ((pData == NULL) || (Size == 0U))
2400a6d6:	6a3b      	ldr	r3, [r7, #32]
2400a6d8:	2b00      	cmp	r3, #0
2400a6da:	d002      	beq.n	2400a6e2 <HAL_I2C_Mem_Read_IT+0x32>
2400a6dc:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
2400a6de:	2b00      	cmp	r3, #0
2400a6e0:	d105      	bne.n	2400a6ee <HAL_I2C_Mem_Read_IT+0x3e>
    {
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
2400a6e2:	68fb      	ldr	r3, [r7, #12]
2400a6e4:	f44f 7200 	mov.w	r2, #512	; 0x200
2400a6e8:	645a      	str	r2, [r3, #68]	; 0x44
      return  HAL_ERROR;
2400a6ea:	2301      	movs	r3, #1
2400a6ec:	e06b      	b.n	2400a7c6 <HAL_I2C_Mem_Read_IT+0x116>
    }

    if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
2400a6ee:	68fb      	ldr	r3, [r7, #12]
2400a6f0:	681b      	ldr	r3, [r3, #0]
2400a6f2:	699b      	ldr	r3, [r3, #24]
2400a6f4:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
2400a6f8:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
2400a6fc:	d101      	bne.n	2400a702 <HAL_I2C_Mem_Read_IT+0x52>
    {
      return HAL_BUSY;
2400a6fe:	2302      	movs	r3, #2
2400a700:	e061      	b.n	2400a7c6 <HAL_I2C_Mem_Read_IT+0x116>
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
2400a702:	68fb      	ldr	r3, [r7, #12]
2400a704:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2400a708:	2b01      	cmp	r3, #1
2400a70a:	d101      	bne.n	2400a710 <HAL_I2C_Mem_Read_IT+0x60>
2400a70c:	2302      	movs	r3, #2
2400a70e:	e05a      	b.n	2400a7c6 <HAL_I2C_Mem_Read_IT+0x116>
2400a710:	68fb      	ldr	r3, [r7, #12]
2400a712:	2201      	movs	r2, #1
2400a714:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Init tickstart for timeout management*/
    tickstart = HAL_GetTick();
2400a718:	f7f6 f89c 	bl	24000854 <HAL_GetTick>
2400a71c:	6138      	str	r0, [r7, #16]

    hi2c->State       = HAL_I2C_STATE_BUSY_RX;
2400a71e:	68fb      	ldr	r3, [r7, #12]
2400a720:	2222      	movs	r2, #34	; 0x22
2400a722:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode        = HAL_I2C_MODE_MEM;
2400a726:	68fb      	ldr	r3, [r7, #12]
2400a728:	2240      	movs	r2, #64	; 0x40
2400a72a:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
2400a72e:	68fb      	ldr	r3, [r7, #12]
2400a730:	2200      	movs	r2, #0
2400a732:	645a      	str	r2, [r3, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr    = pData;
2400a734:	68fb      	ldr	r3, [r7, #12]
2400a736:	6a3a      	ldr	r2, [r7, #32]
2400a738:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount   = Size;
2400a73a:	68fb      	ldr	r3, [r7, #12]
2400a73c:	8cba      	ldrh	r2, [r7, #36]	; 0x24
2400a73e:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
2400a740:	68fb      	ldr	r3, [r7, #12]
2400a742:	4a23      	ldr	r2, [pc, #140]	; (2400a7d0 <HAL_I2C_Mem_Read_IT+0x120>)
2400a744:	62da      	str	r2, [r3, #44]	; 0x2c
    hi2c->XferISR     = I2C_Master_ISR_IT;
2400a746:	68fb      	ldr	r3, [r7, #12]
2400a748:	4a22      	ldr	r2, [pc, #136]	; (2400a7d4 <HAL_I2C_Mem_Read_IT+0x124>)
2400a74a:	635a      	str	r2, [r3, #52]	; 0x34

    if (hi2c->XferCount > MAX_NBYTE_SIZE)
2400a74c:	68fb      	ldr	r3, [r7, #12]
2400a74e:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400a750:	b29b      	uxth	r3, r3
2400a752:	2bff      	cmp	r3, #255	; 0xff
2400a754:	d906      	bls.n	2400a764 <HAL_I2C_Mem_Read_IT+0xb4>
    {
      hi2c->XferSize = MAX_NBYTE_SIZE;
2400a756:	68fb      	ldr	r3, [r7, #12]
2400a758:	22ff      	movs	r2, #255	; 0xff
2400a75a:	851a      	strh	r2, [r3, #40]	; 0x28
      xfermode = I2C_RELOAD_MODE;
2400a75c:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
2400a760:	617b      	str	r3, [r7, #20]
2400a762:	e007      	b.n	2400a774 <HAL_I2C_Mem_Read_IT+0xc4>
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
2400a764:	68fb      	ldr	r3, [r7, #12]
2400a766:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400a768:	b29a      	uxth	r2, r3
2400a76a:	68fb      	ldr	r3, [r7, #12]
2400a76c:	851a      	strh	r2, [r3, #40]	; 0x28
      xfermode = I2C_AUTOEND_MODE;
2400a76e:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
2400a772:	617b      	str	r3, [r7, #20]
    }

    /* Send Slave Address and Memory Address */
    if (I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, I2C_TIMEOUT_FLAG, tickstart) != HAL_OK)
2400a774:	88f8      	ldrh	r0, [r7, #6]
2400a776:	893a      	ldrh	r2, [r7, #8]
2400a778:	8979      	ldrh	r1, [r7, #10]
2400a77a:	693b      	ldr	r3, [r7, #16]
2400a77c:	9301      	str	r3, [sp, #4]
2400a77e:	2319      	movs	r3, #25
2400a780:	9300      	str	r3, [sp, #0]
2400a782:	4603      	mov	r3, r0
2400a784:	68f8      	ldr	r0, [r7, #12]
2400a786:	f002 f8e7 	bl	2400c958 <I2C_RequestMemoryRead>
2400a78a:	4603      	mov	r3, r0
2400a78c:	2b00      	cmp	r3, #0
2400a78e:	d005      	beq.n	2400a79c <HAL_I2C_Mem_Read_IT+0xec>
    {
      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
2400a790:	68fb      	ldr	r3, [r7, #12]
2400a792:	2200      	movs	r2, #0
2400a794:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      return HAL_ERROR;
2400a798:	2301      	movs	r3, #1
2400a79a:	e014      	b.n	2400a7c6 <HAL_I2C_Mem_Read_IT+0x116>
    }

    /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE and generate RESTART */
    I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, I2C_GENERATE_START_READ);
2400a79c:	68fb      	ldr	r3, [r7, #12]
2400a79e:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400a7a0:	b2da      	uxtb	r2, r3
2400a7a2:	8979      	ldrh	r1, [r7, #10]
2400a7a4:	4b0c      	ldr	r3, [pc, #48]	; (2400a7d8 <HAL_I2C_Mem_Read_IT+0x128>)
2400a7a6:	9300      	str	r3, [sp, #0]
2400a7a8:	697b      	ldr	r3, [r7, #20]
2400a7aa:	68f8      	ldr	r0, [r7, #12]
2400a7ac:	f003 fac6 	bl	2400dd3c <I2C_TransferConfig>

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
2400a7b0:	68fb      	ldr	r3, [r7, #12]
2400a7b2:	2200      	movs	r2, #0
2400a7b4:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
              process unlock */

    /* Enable ERR, TC, STOP, NACK, RXI interrupt */
    /* possible to enable all of these */
    /* I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */
    I2C_Enable_IRQ(hi2c, I2C_XFER_RX_IT);
2400a7b8:	2102      	movs	r1, #2
2400a7ba:	68f8      	ldr	r0, [r7, #12]
2400a7bc:	f003 faec 	bl	2400dd98 <I2C_Enable_IRQ>

    return HAL_OK;
2400a7c0:	2300      	movs	r3, #0
2400a7c2:	e000      	b.n	2400a7c6 <HAL_I2C_Mem_Read_IT+0x116>
  }
  else
  {
    return HAL_BUSY;
2400a7c4:	2302      	movs	r3, #2
  }
}
2400a7c6:	4618      	mov	r0, r3
2400a7c8:	3718      	adds	r7, #24
2400a7ca:	46bd      	mov	sp, r7
2400a7cc:	bd80      	pop	{r7, pc}
2400a7ce:	bf00      	nop
2400a7d0:	ffff0000 	.word	0xffff0000
2400a7d4:	2400beb3 	.word	0x2400beb3
2400a7d8:	80002400 	.word	0x80002400

2400a7dc <HAL_I2C_Mem_Write_DMA>:
  * @param  pData Pointer to data buffer
  * @param  Size Amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Mem_Write_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size)
{
2400a7dc:	b580      	push	{r7, lr}
2400a7de:	b08a      	sub	sp, #40	; 0x28
2400a7e0:	af02      	add	r7, sp, #8
2400a7e2:	60f8      	str	r0, [r7, #12]
2400a7e4:	4608      	mov	r0, r1
2400a7e6:	4611      	mov	r1, r2
2400a7e8:	461a      	mov	r2, r3
2400a7ea:	4603      	mov	r3, r0
2400a7ec:	817b      	strh	r3, [r7, #10]
2400a7ee:	460b      	mov	r3, r1
2400a7f0:	813b      	strh	r3, [r7, #8]
2400a7f2:	4613      	mov	r3, r2
2400a7f4:	80fb      	strh	r3, [r7, #6]
  HAL_StatusTypeDef dmaxferstatus;

  /* Check the parameters */
  assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));

  if (hi2c->State == HAL_I2C_STATE_READY)
2400a7f6:	68fb      	ldr	r3, [r7, #12]
2400a7f8:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400a7fc:	b2db      	uxtb	r3, r3
2400a7fe:	2b20      	cmp	r3, #32
2400a800:	f040 80d5 	bne.w	2400a9ae <HAL_I2C_Mem_Write_DMA+0x1d2>
  {
    if ((pData == NULL) || (Size == 0U))
2400a804:	6abb      	ldr	r3, [r7, #40]	; 0x28
2400a806:	2b00      	cmp	r3, #0
2400a808:	d002      	beq.n	2400a810 <HAL_I2C_Mem_Write_DMA+0x34>
2400a80a:	8dbb      	ldrh	r3, [r7, #44]	; 0x2c
2400a80c:	2b00      	cmp	r3, #0
2400a80e:	d105      	bne.n	2400a81c <HAL_I2C_Mem_Write_DMA+0x40>
    {
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
2400a810:	68fb      	ldr	r3, [r7, #12]
2400a812:	f44f 7200 	mov.w	r2, #512	; 0x200
2400a816:	645a      	str	r2, [r3, #68]	; 0x44
      return  HAL_ERROR;
2400a818:	2301      	movs	r3, #1
2400a81a:	e0c9      	b.n	2400a9b0 <HAL_I2C_Mem_Write_DMA+0x1d4>
    }

    if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
2400a81c:	68fb      	ldr	r3, [r7, #12]
2400a81e:	681b      	ldr	r3, [r3, #0]
2400a820:	699b      	ldr	r3, [r3, #24]
2400a822:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
2400a826:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
2400a82a:	d101      	bne.n	2400a830 <HAL_I2C_Mem_Write_DMA+0x54>
    {
      return HAL_BUSY;
2400a82c:	2302      	movs	r3, #2
2400a82e:	e0bf      	b.n	2400a9b0 <HAL_I2C_Mem_Write_DMA+0x1d4>
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
2400a830:	68fb      	ldr	r3, [r7, #12]
2400a832:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2400a836:	2b01      	cmp	r3, #1
2400a838:	d101      	bne.n	2400a83e <HAL_I2C_Mem_Write_DMA+0x62>
2400a83a:	2302      	movs	r3, #2
2400a83c:	e0b8      	b.n	2400a9b0 <HAL_I2C_Mem_Write_DMA+0x1d4>
2400a83e:	68fb      	ldr	r3, [r7, #12]
2400a840:	2201      	movs	r2, #1
2400a842:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Init tickstart for timeout management*/
    tickstart = HAL_GetTick();
2400a846:	f7f6 f805 	bl	24000854 <HAL_GetTick>
2400a84a:	61b8      	str	r0, [r7, #24]

    hi2c->State       = HAL_I2C_STATE_BUSY_TX;
2400a84c:	68fb      	ldr	r3, [r7, #12]
2400a84e:	2221      	movs	r2, #33	; 0x21
2400a850:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode        = HAL_I2C_MODE_MEM;
2400a854:	68fb      	ldr	r3, [r7, #12]
2400a856:	2240      	movs	r2, #64	; 0x40
2400a858:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
2400a85c:	68fb      	ldr	r3, [r7, #12]
2400a85e:	2200      	movs	r2, #0
2400a860:	645a      	str	r2, [r3, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr    = pData;
2400a862:	68fb      	ldr	r3, [r7, #12]
2400a864:	6aba      	ldr	r2, [r7, #40]	; 0x28
2400a866:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount   = Size;
2400a868:	68fb      	ldr	r3, [r7, #12]
2400a86a:	8dba      	ldrh	r2, [r7, #44]	; 0x2c
2400a86c:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
2400a86e:	68fb      	ldr	r3, [r7, #12]
2400a870:	4a51      	ldr	r2, [pc, #324]	; (2400a9b8 <HAL_I2C_Mem_Write_DMA+0x1dc>)
2400a872:	62da      	str	r2, [r3, #44]	; 0x2c
    hi2c->XferISR     = I2C_Master_ISR_DMA;
2400a874:	68fb      	ldr	r3, [r7, #12]
2400a876:	4a51      	ldr	r2, [pc, #324]	; (2400a9bc <HAL_I2C_Mem_Write_DMA+0x1e0>)
2400a878:	635a      	str	r2, [r3, #52]	; 0x34

    if (hi2c->XferCount > MAX_NBYTE_SIZE)
2400a87a:	68fb      	ldr	r3, [r7, #12]
2400a87c:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400a87e:	b29b      	uxth	r3, r3
2400a880:	2bff      	cmp	r3, #255	; 0xff
2400a882:	d906      	bls.n	2400a892 <HAL_I2C_Mem_Write_DMA+0xb6>
    {
      hi2c->XferSize = MAX_NBYTE_SIZE;
2400a884:	68fb      	ldr	r3, [r7, #12]
2400a886:	22ff      	movs	r2, #255	; 0xff
2400a888:	851a      	strh	r2, [r3, #40]	; 0x28
      xfermode = I2C_RELOAD_MODE;
2400a88a:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
2400a88e:	61fb      	str	r3, [r7, #28]
2400a890:	e007      	b.n	2400a8a2 <HAL_I2C_Mem_Write_DMA+0xc6>
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
2400a892:	68fb      	ldr	r3, [r7, #12]
2400a894:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400a896:	b29a      	uxth	r2, r3
2400a898:	68fb      	ldr	r3, [r7, #12]
2400a89a:	851a      	strh	r2, [r3, #40]	; 0x28
      xfermode = I2C_AUTOEND_MODE;
2400a89c:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
2400a8a0:	61fb      	str	r3, [r7, #28]
    }

    /* Send Slave Address and Memory Address */
    if (I2C_RequestMemoryWrite(hi2c, DevAddress, MemAddress, MemAddSize, I2C_TIMEOUT_FLAG, tickstart) != HAL_OK)
2400a8a2:	88f8      	ldrh	r0, [r7, #6]
2400a8a4:	893a      	ldrh	r2, [r7, #8]
2400a8a6:	8979      	ldrh	r1, [r7, #10]
2400a8a8:	69bb      	ldr	r3, [r7, #24]
2400a8aa:	9301      	str	r3, [sp, #4]
2400a8ac:	2319      	movs	r3, #25
2400a8ae:	9300      	str	r3, [sp, #0]
2400a8b0:	4603      	mov	r3, r0
2400a8b2:	68f8      	ldr	r0, [r7, #12]
2400a8b4:	f001 fffc 	bl	2400c8b0 <I2C_RequestMemoryWrite>
2400a8b8:	4603      	mov	r3, r0
2400a8ba:	2b00      	cmp	r3, #0
2400a8bc:	d005      	beq.n	2400a8ca <HAL_I2C_Mem_Write_DMA+0xee>
    {
      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
2400a8be:	68fb      	ldr	r3, [r7, #12]
2400a8c0:	2200      	movs	r2, #0
2400a8c2:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      return HAL_ERROR;
2400a8c6:	2301      	movs	r3, #1
2400a8c8:	e072      	b.n	2400a9b0 <HAL_I2C_Mem_Write_DMA+0x1d4>
    }


    if (hi2c->hdmatx != NULL)
2400a8ca:	68fb      	ldr	r3, [r7, #12]
2400a8cc:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400a8ce:	2b00      	cmp	r3, #0
2400a8d0:	d020      	beq.n	2400a914 <HAL_I2C_Mem_Write_DMA+0x138>
    {
      /* Set the I2C DMA transfer complete callback */
      hi2c->hdmatx->XferCpltCallback = I2C_DMAMasterTransmitCplt;
2400a8d2:	68fb      	ldr	r3, [r7, #12]
2400a8d4:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400a8d6:	4a3a      	ldr	r2, [pc, #232]	; (2400a9c0 <HAL_I2C_Mem_Write_DMA+0x1e4>)
2400a8d8:	63da      	str	r2, [r3, #60]	; 0x3c

      /* Set the DMA error callback */
      hi2c->hdmatx->XferErrorCallback = I2C_DMAError;
2400a8da:	68fb      	ldr	r3, [r7, #12]
2400a8dc:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400a8de:	4a39      	ldr	r2, [pc, #228]	; (2400a9c4 <HAL_I2C_Mem_Write_DMA+0x1e8>)
2400a8e0:	64da      	str	r2, [r3, #76]	; 0x4c

      /* Set the unused DMA callbacks to NULL */
      hi2c->hdmatx->XferHalfCpltCallback = NULL;
2400a8e2:	68fb      	ldr	r3, [r7, #12]
2400a8e4:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400a8e6:	2200      	movs	r2, #0
2400a8e8:	641a      	str	r2, [r3, #64]	; 0x40
      hi2c->hdmatx->XferAbortCallback = NULL;
2400a8ea:	68fb      	ldr	r3, [r7, #12]
2400a8ec:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400a8ee:	2200      	movs	r2, #0
2400a8f0:	651a      	str	r2, [r3, #80]	; 0x50

      /* Enable the DMA stream or channel depends on Instance */
      dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)pData, (uint32_t)&hi2c->Instance->TXDR, hi2c->XferSize);
2400a8f2:	68fb      	ldr	r3, [r7, #12]
2400a8f4:	6b98      	ldr	r0, [r3, #56]	; 0x38
2400a8f6:	6ab9      	ldr	r1, [r7, #40]	; 0x28
2400a8f8:	68fb      	ldr	r3, [r7, #12]
2400a8fa:	681b      	ldr	r3, [r3, #0]
2400a8fc:	3328      	adds	r3, #40	; 0x28
2400a8fe:	461a      	mov	r2, r3
2400a900:	68fb      	ldr	r3, [r7, #12]
2400a902:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400a904:	f7f7 fe24 	bl	24002550 <HAL_DMA_Start_IT>
2400a908:	4603      	mov	r3, r0
2400a90a:	75fb      	strb	r3, [r7, #23]
      __HAL_UNLOCK(hi2c);

      return HAL_ERROR;
    }

    if (dmaxferstatus == HAL_OK)
2400a90c:	7dfb      	ldrb	r3, [r7, #23]
2400a90e:	2b00      	cmp	r3, #0
2400a910:	d139      	bne.n	2400a986 <HAL_I2C_Mem_Write_DMA+0x1aa>
2400a912:	e013      	b.n	2400a93c <HAL_I2C_Mem_Write_DMA+0x160>
      hi2c->State     = HAL_I2C_STATE_READY;
2400a914:	68fb      	ldr	r3, [r7, #12]
2400a916:	2220      	movs	r2, #32
2400a918:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
      hi2c->Mode      = HAL_I2C_MODE_NONE;
2400a91c:	68fb      	ldr	r3, [r7, #12]
2400a91e:	2200      	movs	r2, #0
2400a920:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
      hi2c->ErrorCode |= HAL_I2C_ERROR_DMA_PARAM;
2400a924:	68fb      	ldr	r3, [r7, #12]
2400a926:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400a928:	f043 0280 	orr.w	r2, r3, #128	; 0x80
2400a92c:	68fb      	ldr	r3, [r7, #12]
2400a92e:	645a      	str	r2, [r3, #68]	; 0x44
      __HAL_UNLOCK(hi2c);
2400a930:	68fb      	ldr	r3, [r7, #12]
2400a932:	2200      	movs	r2, #0
2400a934:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      return HAL_ERROR;
2400a938:	2301      	movs	r3, #1
2400a93a:	e039      	b.n	2400a9b0 <HAL_I2C_Mem_Write_DMA+0x1d4>
    {
      /* Send Slave Address */
      /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE and generate RESTART */
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, I2C_NO_STARTSTOP);
2400a93c:	68fb      	ldr	r3, [r7, #12]
2400a93e:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400a940:	b2da      	uxtb	r2, r3
2400a942:	8979      	ldrh	r1, [r7, #10]
2400a944:	2300      	movs	r3, #0
2400a946:	9300      	str	r3, [sp, #0]
2400a948:	69fb      	ldr	r3, [r7, #28]
2400a94a:	68f8      	ldr	r0, [r7, #12]
2400a94c:	f003 f9f6 	bl	2400dd3c <I2C_TransferConfig>

      /* Update XferCount value */
      hi2c->XferCount -= hi2c->XferSize;
2400a950:	68fb      	ldr	r3, [r7, #12]
2400a952:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400a954:	b29a      	uxth	r2, r3
2400a956:	68fb      	ldr	r3, [r7, #12]
2400a958:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400a95a:	1ad3      	subs	r3, r2, r3
2400a95c:	b29a      	uxth	r2, r3
2400a95e:	68fb      	ldr	r3, [r7, #12]
2400a960:	855a      	strh	r2, [r3, #42]	; 0x2a

      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
2400a962:	68fb      	ldr	r3, [r7, #12]
2400a964:	2200      	movs	r2, #0
2400a966:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

      /* Note : The I2C interrupts must be enabled after unlocking current process
                to avoid the risk of I2C interrupt handle execution before current
                process unlock */
      /* Enable ERR and NACK interrupts */
      I2C_Enable_IRQ(hi2c, I2C_XFER_ERROR_IT);
2400a96a:	2110      	movs	r1, #16
2400a96c:	68f8      	ldr	r0, [r7, #12]
2400a96e:	f003 fa13 	bl	2400dd98 <I2C_Enable_IRQ>

      /* Enable DMA Request */
      hi2c->Instance->CR1 |= I2C_CR1_TXDMAEN;
2400a972:	68fb      	ldr	r3, [r7, #12]
2400a974:	681b      	ldr	r3, [r3, #0]
2400a976:	681a      	ldr	r2, [r3, #0]
2400a978:	68fb      	ldr	r3, [r7, #12]
2400a97a:	681b      	ldr	r3, [r3, #0]
2400a97c:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
2400a980:	601a      	str	r2, [r3, #0]
      __HAL_UNLOCK(hi2c);

      return HAL_ERROR;
    }

    return HAL_OK;
2400a982:	2300      	movs	r3, #0
2400a984:	e014      	b.n	2400a9b0 <HAL_I2C_Mem_Write_DMA+0x1d4>
      hi2c->State     = HAL_I2C_STATE_READY;
2400a986:	68fb      	ldr	r3, [r7, #12]
2400a988:	2220      	movs	r2, #32
2400a98a:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
      hi2c->Mode      = HAL_I2C_MODE_NONE;
2400a98e:	68fb      	ldr	r3, [r7, #12]
2400a990:	2200      	movs	r2, #0
2400a992:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
      hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
2400a996:	68fb      	ldr	r3, [r7, #12]
2400a998:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400a99a:	f043 0210 	orr.w	r2, r3, #16
2400a99e:	68fb      	ldr	r3, [r7, #12]
2400a9a0:	645a      	str	r2, [r3, #68]	; 0x44
      __HAL_UNLOCK(hi2c);
2400a9a2:	68fb      	ldr	r3, [r7, #12]
2400a9a4:	2200      	movs	r2, #0
2400a9a6:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      return HAL_ERROR;
2400a9aa:	2301      	movs	r3, #1
2400a9ac:	e000      	b.n	2400a9b0 <HAL_I2C_Mem_Write_DMA+0x1d4>
  }
  else
  {
    return HAL_BUSY;
2400a9ae:	2302      	movs	r3, #2
  }
}
2400a9b0:	4618      	mov	r0, r3
2400a9b2:	3720      	adds	r7, #32
2400a9b4:	46bd      	mov	sp, r7
2400a9b6:	bd80      	pop	{r7, pc}
2400a9b8:	ffff0000 	.word	0xffff0000
2400a9bc:	2400c30b 	.word	0x2400c30b
2400a9c0:	2400d4a3 	.word	0x2400d4a3
2400a9c4:	2400d775 	.word	0x2400d775

2400a9c8 <HAL_I2C_Mem_Read_DMA>:
  * @param  pData Pointer to data buffer
  * @param  Size Amount of data to be read
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Mem_Read_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size)
{
2400a9c8:	b580      	push	{r7, lr}
2400a9ca:	b08a      	sub	sp, #40	; 0x28
2400a9cc:	af02      	add	r7, sp, #8
2400a9ce:	60f8      	str	r0, [r7, #12]
2400a9d0:	4608      	mov	r0, r1
2400a9d2:	4611      	mov	r1, r2
2400a9d4:	461a      	mov	r2, r3
2400a9d6:	4603      	mov	r3, r0
2400a9d8:	817b      	strh	r3, [r7, #10]
2400a9da:	460b      	mov	r3, r1
2400a9dc:	813b      	strh	r3, [r7, #8]
2400a9de:	4613      	mov	r3, r2
2400a9e0:	80fb      	strh	r3, [r7, #6]
  HAL_StatusTypeDef dmaxferstatus;

  /* Check the parameters */
  assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));

  if (hi2c->State == HAL_I2C_STATE_READY)
2400a9e2:	68fb      	ldr	r3, [r7, #12]
2400a9e4:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400a9e8:	b2db      	uxtb	r3, r3
2400a9ea:	2b20      	cmp	r3, #32
2400a9ec:	f040 80d5 	bne.w	2400ab9a <HAL_I2C_Mem_Read_DMA+0x1d2>
  {
    if ((pData == NULL) || (Size == 0U))
2400a9f0:	6abb      	ldr	r3, [r7, #40]	; 0x28
2400a9f2:	2b00      	cmp	r3, #0
2400a9f4:	d002      	beq.n	2400a9fc <HAL_I2C_Mem_Read_DMA+0x34>
2400a9f6:	8dbb      	ldrh	r3, [r7, #44]	; 0x2c
2400a9f8:	2b00      	cmp	r3, #0
2400a9fa:	d105      	bne.n	2400aa08 <HAL_I2C_Mem_Read_DMA+0x40>
    {
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
2400a9fc:	68fb      	ldr	r3, [r7, #12]
2400a9fe:	f44f 7200 	mov.w	r2, #512	; 0x200
2400aa02:	645a      	str	r2, [r3, #68]	; 0x44
      return  HAL_ERROR;
2400aa04:	2301      	movs	r3, #1
2400aa06:	e0c9      	b.n	2400ab9c <HAL_I2C_Mem_Read_DMA+0x1d4>
    }

    if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
2400aa08:	68fb      	ldr	r3, [r7, #12]
2400aa0a:	681b      	ldr	r3, [r3, #0]
2400aa0c:	699b      	ldr	r3, [r3, #24]
2400aa0e:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
2400aa12:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
2400aa16:	d101      	bne.n	2400aa1c <HAL_I2C_Mem_Read_DMA+0x54>
    {
      return HAL_BUSY;
2400aa18:	2302      	movs	r3, #2
2400aa1a:	e0bf      	b.n	2400ab9c <HAL_I2C_Mem_Read_DMA+0x1d4>
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
2400aa1c:	68fb      	ldr	r3, [r7, #12]
2400aa1e:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2400aa22:	2b01      	cmp	r3, #1
2400aa24:	d101      	bne.n	2400aa2a <HAL_I2C_Mem_Read_DMA+0x62>
2400aa26:	2302      	movs	r3, #2
2400aa28:	e0b8      	b.n	2400ab9c <HAL_I2C_Mem_Read_DMA+0x1d4>
2400aa2a:	68fb      	ldr	r3, [r7, #12]
2400aa2c:	2201      	movs	r2, #1
2400aa2e:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Init tickstart for timeout management*/
    tickstart = HAL_GetTick();
2400aa32:	f7f5 ff0f 	bl	24000854 <HAL_GetTick>
2400aa36:	61b8      	str	r0, [r7, #24]

    hi2c->State       = HAL_I2C_STATE_BUSY_RX;
2400aa38:	68fb      	ldr	r3, [r7, #12]
2400aa3a:	2222      	movs	r2, #34	; 0x22
2400aa3c:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode        = HAL_I2C_MODE_MEM;
2400aa40:	68fb      	ldr	r3, [r7, #12]
2400aa42:	2240      	movs	r2, #64	; 0x40
2400aa44:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
2400aa48:	68fb      	ldr	r3, [r7, #12]
2400aa4a:	2200      	movs	r2, #0
2400aa4c:	645a      	str	r2, [r3, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr    = pData;
2400aa4e:	68fb      	ldr	r3, [r7, #12]
2400aa50:	6aba      	ldr	r2, [r7, #40]	; 0x28
2400aa52:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount   = Size;
2400aa54:	68fb      	ldr	r3, [r7, #12]
2400aa56:	8dba      	ldrh	r2, [r7, #44]	; 0x2c
2400aa58:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
2400aa5a:	68fb      	ldr	r3, [r7, #12]
2400aa5c:	4a51      	ldr	r2, [pc, #324]	; (2400aba4 <HAL_I2C_Mem_Read_DMA+0x1dc>)
2400aa5e:	62da      	str	r2, [r3, #44]	; 0x2c
    hi2c->XferISR     = I2C_Master_ISR_DMA;
2400aa60:	68fb      	ldr	r3, [r7, #12]
2400aa62:	4a51      	ldr	r2, [pc, #324]	; (2400aba8 <HAL_I2C_Mem_Read_DMA+0x1e0>)
2400aa64:	635a      	str	r2, [r3, #52]	; 0x34

    if (hi2c->XferCount > MAX_NBYTE_SIZE)
2400aa66:	68fb      	ldr	r3, [r7, #12]
2400aa68:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400aa6a:	b29b      	uxth	r3, r3
2400aa6c:	2bff      	cmp	r3, #255	; 0xff
2400aa6e:	d906      	bls.n	2400aa7e <HAL_I2C_Mem_Read_DMA+0xb6>
    {
      hi2c->XferSize = MAX_NBYTE_SIZE;
2400aa70:	68fb      	ldr	r3, [r7, #12]
2400aa72:	22ff      	movs	r2, #255	; 0xff
2400aa74:	851a      	strh	r2, [r3, #40]	; 0x28
      xfermode = I2C_RELOAD_MODE;
2400aa76:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
2400aa7a:	61fb      	str	r3, [r7, #28]
2400aa7c:	e007      	b.n	2400aa8e <HAL_I2C_Mem_Read_DMA+0xc6>
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
2400aa7e:	68fb      	ldr	r3, [r7, #12]
2400aa80:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400aa82:	b29a      	uxth	r2, r3
2400aa84:	68fb      	ldr	r3, [r7, #12]
2400aa86:	851a      	strh	r2, [r3, #40]	; 0x28
      xfermode = I2C_AUTOEND_MODE;
2400aa88:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
2400aa8c:	61fb      	str	r3, [r7, #28]
    }

    /* Send Slave Address and Memory Address */
    if (I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, I2C_TIMEOUT_FLAG, tickstart) != HAL_OK)
2400aa8e:	88f8      	ldrh	r0, [r7, #6]
2400aa90:	893a      	ldrh	r2, [r7, #8]
2400aa92:	8979      	ldrh	r1, [r7, #10]
2400aa94:	69bb      	ldr	r3, [r7, #24]
2400aa96:	9301      	str	r3, [sp, #4]
2400aa98:	2319      	movs	r3, #25
2400aa9a:	9300      	str	r3, [sp, #0]
2400aa9c:	4603      	mov	r3, r0
2400aa9e:	68f8      	ldr	r0, [r7, #12]
2400aaa0:	f001 ff5a 	bl	2400c958 <I2C_RequestMemoryRead>
2400aaa4:	4603      	mov	r3, r0
2400aaa6:	2b00      	cmp	r3, #0
2400aaa8:	d005      	beq.n	2400aab6 <HAL_I2C_Mem_Read_DMA+0xee>
    {
      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
2400aaaa:	68fb      	ldr	r3, [r7, #12]
2400aaac:	2200      	movs	r2, #0
2400aaae:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      return HAL_ERROR;
2400aab2:	2301      	movs	r3, #1
2400aab4:	e072      	b.n	2400ab9c <HAL_I2C_Mem_Read_DMA+0x1d4>
    }

    if (hi2c->hdmarx != NULL)
2400aab6:	68fb      	ldr	r3, [r7, #12]
2400aab8:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400aaba:	2b00      	cmp	r3, #0
2400aabc:	d020      	beq.n	2400ab00 <HAL_I2C_Mem_Read_DMA+0x138>
    {
      /* Set the I2C DMA transfer complete callback */
      hi2c->hdmarx->XferCpltCallback = I2C_DMAMasterReceiveCplt;
2400aabe:	68fb      	ldr	r3, [r7, #12]
2400aac0:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400aac2:	4a3a      	ldr	r2, [pc, #232]	; (2400abac <HAL_I2C_Mem_Read_DMA+0x1e4>)
2400aac4:	63da      	str	r2, [r3, #60]	; 0x3c

      /* Set the DMA error callback */
      hi2c->hdmarx->XferErrorCallback = I2C_DMAError;
2400aac6:	68fb      	ldr	r3, [r7, #12]
2400aac8:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400aaca:	4a39      	ldr	r2, [pc, #228]	; (2400abb0 <HAL_I2C_Mem_Read_DMA+0x1e8>)
2400aacc:	64da      	str	r2, [r3, #76]	; 0x4c

      /* Set the unused DMA callbacks to NULL */
      hi2c->hdmarx->XferHalfCpltCallback = NULL;
2400aace:	68fb      	ldr	r3, [r7, #12]
2400aad0:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400aad2:	2200      	movs	r2, #0
2400aad4:	641a      	str	r2, [r3, #64]	; 0x40
      hi2c->hdmarx->XferAbortCallback = NULL;
2400aad6:	68fb      	ldr	r3, [r7, #12]
2400aad8:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400aada:	2200      	movs	r2, #0
2400aadc:	651a      	str	r2, [r3, #80]	; 0x50

      /* Enable the DMA stream or channel depends on Instance */
      dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->RXDR, (uint32_t)pData, hi2c->XferSize);
2400aade:	68fb      	ldr	r3, [r7, #12]
2400aae0:	6bd8      	ldr	r0, [r3, #60]	; 0x3c
2400aae2:	68fb      	ldr	r3, [r7, #12]
2400aae4:	681b      	ldr	r3, [r3, #0]
2400aae6:	3324      	adds	r3, #36	; 0x24
2400aae8:	4619      	mov	r1, r3
2400aaea:	6aba      	ldr	r2, [r7, #40]	; 0x28
2400aaec:	68fb      	ldr	r3, [r7, #12]
2400aaee:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400aaf0:	f7f7 fd2e 	bl	24002550 <HAL_DMA_Start_IT>
2400aaf4:	4603      	mov	r3, r0
2400aaf6:	75fb      	strb	r3, [r7, #23]
      __HAL_UNLOCK(hi2c);

      return HAL_ERROR;
    }

    if (dmaxferstatus == HAL_OK)
2400aaf8:	7dfb      	ldrb	r3, [r7, #23]
2400aafa:	2b00      	cmp	r3, #0
2400aafc:	d139      	bne.n	2400ab72 <HAL_I2C_Mem_Read_DMA+0x1aa>
2400aafe:	e013      	b.n	2400ab28 <HAL_I2C_Mem_Read_DMA+0x160>
      hi2c->State     = HAL_I2C_STATE_READY;
2400ab00:	68fb      	ldr	r3, [r7, #12]
2400ab02:	2220      	movs	r2, #32
2400ab04:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
      hi2c->Mode      = HAL_I2C_MODE_NONE;
2400ab08:	68fb      	ldr	r3, [r7, #12]
2400ab0a:	2200      	movs	r2, #0
2400ab0c:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
      hi2c->ErrorCode |= HAL_I2C_ERROR_DMA_PARAM;
2400ab10:	68fb      	ldr	r3, [r7, #12]
2400ab12:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400ab14:	f043 0280 	orr.w	r2, r3, #128	; 0x80
2400ab18:	68fb      	ldr	r3, [r7, #12]
2400ab1a:	645a      	str	r2, [r3, #68]	; 0x44
      __HAL_UNLOCK(hi2c);
2400ab1c:	68fb      	ldr	r3, [r7, #12]
2400ab1e:	2200      	movs	r2, #0
2400ab20:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      return HAL_ERROR;
2400ab24:	2301      	movs	r3, #1
2400ab26:	e039      	b.n	2400ab9c <HAL_I2C_Mem_Read_DMA+0x1d4>
    {
      /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE and generate RESTART */
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, I2C_GENERATE_START_READ);
2400ab28:	68fb      	ldr	r3, [r7, #12]
2400ab2a:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400ab2c:	b2da      	uxtb	r2, r3
2400ab2e:	8979      	ldrh	r1, [r7, #10]
2400ab30:	4b20      	ldr	r3, [pc, #128]	; (2400abb4 <HAL_I2C_Mem_Read_DMA+0x1ec>)
2400ab32:	9300      	str	r3, [sp, #0]
2400ab34:	69fb      	ldr	r3, [r7, #28]
2400ab36:	68f8      	ldr	r0, [r7, #12]
2400ab38:	f003 f900 	bl	2400dd3c <I2C_TransferConfig>

      /* Update XferCount value */
      hi2c->XferCount -= hi2c->XferSize;
2400ab3c:	68fb      	ldr	r3, [r7, #12]
2400ab3e:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400ab40:	b29a      	uxth	r2, r3
2400ab42:	68fb      	ldr	r3, [r7, #12]
2400ab44:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400ab46:	1ad3      	subs	r3, r2, r3
2400ab48:	b29a      	uxth	r2, r3
2400ab4a:	68fb      	ldr	r3, [r7, #12]
2400ab4c:	855a      	strh	r2, [r3, #42]	; 0x2a

      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
2400ab4e:	68fb      	ldr	r3, [r7, #12]
2400ab50:	2200      	movs	r2, #0
2400ab52:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

      /* Note : The I2C interrupts must be enabled after unlocking current process
                to avoid the risk of I2C interrupt handle execution before current
                process unlock */
      /* Enable ERR and NACK interrupts */
      I2C_Enable_IRQ(hi2c, I2C_XFER_ERROR_IT);
2400ab56:	2110      	movs	r1, #16
2400ab58:	68f8      	ldr	r0, [r7, #12]
2400ab5a:	f003 f91d 	bl	2400dd98 <I2C_Enable_IRQ>

      /* Enable DMA Request */
      hi2c->Instance->CR1 |= I2C_CR1_RXDMAEN;
2400ab5e:	68fb      	ldr	r3, [r7, #12]
2400ab60:	681b      	ldr	r3, [r3, #0]
2400ab62:	681a      	ldr	r2, [r3, #0]
2400ab64:	68fb      	ldr	r3, [r7, #12]
2400ab66:	681b      	ldr	r3, [r3, #0]
2400ab68:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
2400ab6c:	601a      	str	r2, [r3, #0]
      __HAL_UNLOCK(hi2c);

      return HAL_ERROR;
    }

    return HAL_OK;
2400ab6e:	2300      	movs	r3, #0
2400ab70:	e014      	b.n	2400ab9c <HAL_I2C_Mem_Read_DMA+0x1d4>
      hi2c->State     = HAL_I2C_STATE_READY;
2400ab72:	68fb      	ldr	r3, [r7, #12]
2400ab74:	2220      	movs	r2, #32
2400ab76:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
      hi2c->Mode      = HAL_I2C_MODE_NONE;
2400ab7a:	68fb      	ldr	r3, [r7, #12]
2400ab7c:	2200      	movs	r2, #0
2400ab7e:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
      hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
2400ab82:	68fb      	ldr	r3, [r7, #12]
2400ab84:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400ab86:	f043 0210 	orr.w	r2, r3, #16
2400ab8a:	68fb      	ldr	r3, [r7, #12]
2400ab8c:	645a      	str	r2, [r3, #68]	; 0x44
      __HAL_UNLOCK(hi2c);
2400ab8e:	68fb      	ldr	r3, [r7, #12]
2400ab90:	2200      	movs	r2, #0
2400ab92:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      return HAL_ERROR;
2400ab96:	2301      	movs	r3, #1
2400ab98:	e000      	b.n	2400ab9c <HAL_I2C_Mem_Read_DMA+0x1d4>
  }
  else
  {
    return HAL_BUSY;
2400ab9a:	2302      	movs	r3, #2
  }
}
2400ab9c:	4618      	mov	r0, r3
2400ab9e:	3720      	adds	r7, #32
2400aba0:	46bd      	mov	sp, r7
2400aba2:	bd80      	pop	{r7, pc}
2400aba4:	ffff0000 	.word	0xffff0000
2400aba8:	2400c30b 	.word	0x2400c30b
2400abac:	2400d579 	.word	0x2400d579
2400abb0:	2400d775 	.word	0x2400d775
2400abb4:	80002400 	.word	0x80002400

2400abb8 <HAL_I2C_IsDeviceReady>:
  * @param  Trials Number of trials
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_IsDeviceReady(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint32_t Trials, uint32_t Timeout)
{
2400abb8:	b580      	push	{r7, lr}
2400abba:	b08a      	sub	sp, #40	; 0x28
2400abbc:	af02      	add	r7, sp, #8
2400abbe:	60f8      	str	r0, [r7, #12]
2400abc0:	607a      	str	r2, [r7, #4]
2400abc2:	603b      	str	r3, [r7, #0]
2400abc4:	460b      	mov	r3, r1
2400abc6:	817b      	strh	r3, [r7, #10]
  uint32_t tickstart;

  __IO uint32_t I2C_Trials = 0UL;
2400abc8:	2300      	movs	r3, #0
2400abca:	617b      	str	r3, [r7, #20]

  FlagStatus tmp1;
  FlagStatus tmp2;

  if (hi2c->State == HAL_I2C_STATE_READY)
2400abcc:	68fb      	ldr	r3, [r7, #12]
2400abce:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400abd2:	b2db      	uxtb	r3, r3
2400abd4:	2b20      	cmp	r3, #32
2400abd6:	f040 80ef 	bne.w	2400adb8 <HAL_I2C_IsDeviceReady+0x200>
  {
    if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
2400abda:	68fb      	ldr	r3, [r7, #12]
2400abdc:	681b      	ldr	r3, [r3, #0]
2400abde:	699b      	ldr	r3, [r3, #24]
2400abe0:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
2400abe4:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
2400abe8:	d101      	bne.n	2400abee <HAL_I2C_IsDeviceReady+0x36>
    {
      return HAL_BUSY;
2400abea:	2302      	movs	r3, #2
2400abec:	e0e5      	b.n	2400adba <HAL_I2C_IsDeviceReady+0x202>
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
2400abee:	68fb      	ldr	r3, [r7, #12]
2400abf0:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2400abf4:	2b01      	cmp	r3, #1
2400abf6:	d101      	bne.n	2400abfc <HAL_I2C_IsDeviceReady+0x44>
2400abf8:	2302      	movs	r3, #2
2400abfa:	e0de      	b.n	2400adba <HAL_I2C_IsDeviceReady+0x202>
2400abfc:	68fb      	ldr	r3, [r7, #12]
2400abfe:	2201      	movs	r2, #1
2400ac00:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    hi2c->State = HAL_I2C_STATE_BUSY;
2400ac04:	68fb      	ldr	r3, [r7, #12]
2400ac06:	2224      	movs	r2, #36	; 0x24
2400ac08:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
2400ac0c:	68fb      	ldr	r3, [r7, #12]
2400ac0e:	2200      	movs	r2, #0
2400ac10:	645a      	str	r2, [r3, #68]	; 0x44

    do
    {
      /* Generate Start */
      hi2c->Instance->CR2 = I2C_GENERATE_START(hi2c->Init.AddressingMode, DevAddress);
2400ac12:	68fb      	ldr	r3, [r7, #12]
2400ac14:	68db      	ldr	r3, [r3, #12]
2400ac16:	2b01      	cmp	r3, #1
2400ac18:	d105      	bne.n	2400ac26 <HAL_I2C_IsDeviceReady+0x6e>
2400ac1a:	897b      	ldrh	r3, [r7, #10]
2400ac1c:	f3c3 0209 	ubfx	r2, r3, #0, #10
2400ac20:	4b68      	ldr	r3, [pc, #416]	; (2400adc4 <HAL_I2C_IsDeviceReady+0x20c>)
2400ac22:	4313      	orrs	r3, r2
2400ac24:	e004      	b.n	2400ac30 <HAL_I2C_IsDeviceReady+0x78>
2400ac26:	897b      	ldrh	r3, [r7, #10]
2400ac28:	f3c3 0309 	ubfx	r3, r3, #0, #10
2400ac2c:	f443 5320 	orr.w	r3, r3, #10240	; 0x2800
2400ac30:	68fa      	ldr	r2, [r7, #12]
2400ac32:	6812      	ldr	r2, [r2, #0]
2400ac34:	6053      	str	r3, [r2, #4]

      /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
      /* Wait until STOPF flag is set or a NACK flag is set*/
      tickstart = HAL_GetTick();
2400ac36:	f7f5 fe0d 	bl	24000854 <HAL_GetTick>
2400ac3a:	61b8      	str	r0, [r7, #24]

      tmp1 = __HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF);
2400ac3c:	68fb      	ldr	r3, [r7, #12]
2400ac3e:	681b      	ldr	r3, [r3, #0]
2400ac40:	699b      	ldr	r3, [r3, #24]
2400ac42:	f003 0320 	and.w	r3, r3, #32
2400ac46:	2b20      	cmp	r3, #32
2400ac48:	bf0c      	ite	eq
2400ac4a:	2301      	moveq	r3, #1
2400ac4c:	2300      	movne	r3, #0
2400ac4e:	b2db      	uxtb	r3, r3
2400ac50:	77fb      	strb	r3, [r7, #31]
      tmp2 = __HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF);
2400ac52:	68fb      	ldr	r3, [r7, #12]
2400ac54:	681b      	ldr	r3, [r3, #0]
2400ac56:	699b      	ldr	r3, [r3, #24]
2400ac58:	f003 0310 	and.w	r3, r3, #16
2400ac5c:	2b10      	cmp	r3, #16
2400ac5e:	bf0c      	ite	eq
2400ac60:	2301      	moveq	r3, #1
2400ac62:	2300      	movne	r3, #0
2400ac64:	b2db      	uxtb	r3, r3
2400ac66:	77bb      	strb	r3, [r7, #30]

      while ((tmp1 == RESET) && (tmp2 == RESET))
2400ac68:	e034      	b.n	2400acd4 <HAL_I2C_IsDeviceReady+0x11c>
      {
        if (Timeout != HAL_MAX_DELAY)
2400ac6a:	683b      	ldr	r3, [r7, #0]
2400ac6c:	f1b3 3fff 	cmp.w	r3, #4294967295
2400ac70:	d01a      	beq.n	2400aca8 <HAL_I2C_IsDeviceReady+0xf0>
        {
          if (((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
2400ac72:	f7f5 fdef 	bl	24000854 <HAL_GetTick>
2400ac76:	4602      	mov	r2, r0
2400ac78:	69bb      	ldr	r3, [r7, #24]
2400ac7a:	1ad3      	subs	r3, r2, r3
2400ac7c:	683a      	ldr	r2, [r7, #0]
2400ac7e:	429a      	cmp	r2, r3
2400ac80:	d302      	bcc.n	2400ac88 <HAL_I2C_IsDeviceReady+0xd0>
2400ac82:	683b      	ldr	r3, [r7, #0]
2400ac84:	2b00      	cmp	r3, #0
2400ac86:	d10f      	bne.n	2400aca8 <HAL_I2C_IsDeviceReady+0xf0>
          {
            /* Update I2C state */
            hi2c->State = HAL_I2C_STATE_READY;
2400ac88:	68fb      	ldr	r3, [r7, #12]
2400ac8a:	2220      	movs	r2, #32
2400ac8c:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

            /* Update I2C error code */
            hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
2400ac90:	68fb      	ldr	r3, [r7, #12]
2400ac92:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400ac94:	f043 0220 	orr.w	r2, r3, #32
2400ac98:	68fb      	ldr	r3, [r7, #12]
2400ac9a:	645a      	str	r2, [r3, #68]	; 0x44

            /* Process Unlocked */
            __HAL_UNLOCK(hi2c);
2400ac9c:	68fb      	ldr	r3, [r7, #12]
2400ac9e:	2200      	movs	r2, #0
2400aca0:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

            return HAL_ERROR;
2400aca4:	2301      	movs	r3, #1
2400aca6:	e088      	b.n	2400adba <HAL_I2C_IsDeviceReady+0x202>
          }
        }

        tmp1 = __HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF);
2400aca8:	68fb      	ldr	r3, [r7, #12]
2400acaa:	681b      	ldr	r3, [r3, #0]
2400acac:	699b      	ldr	r3, [r3, #24]
2400acae:	f003 0320 	and.w	r3, r3, #32
2400acb2:	2b20      	cmp	r3, #32
2400acb4:	bf0c      	ite	eq
2400acb6:	2301      	moveq	r3, #1
2400acb8:	2300      	movne	r3, #0
2400acba:	b2db      	uxtb	r3, r3
2400acbc:	77fb      	strb	r3, [r7, #31]
        tmp2 = __HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF);
2400acbe:	68fb      	ldr	r3, [r7, #12]
2400acc0:	681b      	ldr	r3, [r3, #0]
2400acc2:	699b      	ldr	r3, [r3, #24]
2400acc4:	f003 0310 	and.w	r3, r3, #16
2400acc8:	2b10      	cmp	r3, #16
2400acca:	bf0c      	ite	eq
2400accc:	2301      	moveq	r3, #1
2400acce:	2300      	movne	r3, #0
2400acd0:	b2db      	uxtb	r3, r3
2400acd2:	77bb      	strb	r3, [r7, #30]
      while ((tmp1 == RESET) && (tmp2 == RESET))
2400acd4:	7ffb      	ldrb	r3, [r7, #31]
2400acd6:	2b00      	cmp	r3, #0
2400acd8:	d102      	bne.n	2400ace0 <HAL_I2C_IsDeviceReady+0x128>
2400acda:	7fbb      	ldrb	r3, [r7, #30]
2400acdc:	2b00      	cmp	r3, #0
2400acde:	d0c4      	beq.n	2400ac6a <HAL_I2C_IsDeviceReady+0xb2>
      }

      /* Check if the NACKF flag has not been set */
      if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == RESET)
2400ace0:	68fb      	ldr	r3, [r7, #12]
2400ace2:	681b      	ldr	r3, [r3, #0]
2400ace4:	699b      	ldr	r3, [r3, #24]
2400ace6:	f003 0310 	and.w	r3, r3, #16
2400acea:	2b10      	cmp	r3, #16
2400acec:	d01a      	beq.n	2400ad24 <HAL_I2C_IsDeviceReady+0x16c>
      {
        /* Wait until STOPF flag is reset */
        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_STOPF, RESET, Timeout, tickstart) != HAL_OK)
2400acee:	69bb      	ldr	r3, [r7, #24]
2400acf0:	9300      	str	r3, [sp, #0]
2400acf2:	683b      	ldr	r3, [r7, #0]
2400acf4:	2200      	movs	r2, #0
2400acf6:	2120      	movs	r1, #32
2400acf8:	68f8      	ldr	r0, [r7, #12]
2400acfa:	f002 fe91 	bl	2400da20 <I2C_WaitOnFlagUntilTimeout>
2400acfe:	4603      	mov	r3, r0
2400ad00:	2b00      	cmp	r3, #0
2400ad02:	d001      	beq.n	2400ad08 <HAL_I2C_IsDeviceReady+0x150>
        {
          return HAL_ERROR;
2400ad04:	2301      	movs	r3, #1
2400ad06:	e058      	b.n	2400adba <HAL_I2C_IsDeviceReady+0x202>
        }

        /* Clear STOP Flag */
        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
2400ad08:	68fb      	ldr	r3, [r7, #12]
2400ad0a:	681b      	ldr	r3, [r3, #0]
2400ad0c:	2220      	movs	r2, #32
2400ad0e:	61da      	str	r2, [r3, #28]

        /* Device is ready */
        hi2c->State = HAL_I2C_STATE_READY;
2400ad10:	68fb      	ldr	r3, [r7, #12]
2400ad12:	2220      	movs	r2, #32
2400ad14:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

        /* Process Unlocked */
        __HAL_UNLOCK(hi2c);
2400ad18:	68fb      	ldr	r3, [r7, #12]
2400ad1a:	2200      	movs	r2, #0
2400ad1c:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

        return HAL_OK;
2400ad20:	2300      	movs	r3, #0
2400ad22:	e04a      	b.n	2400adba <HAL_I2C_IsDeviceReady+0x202>
      }
      else
      {
        /* Wait until STOPF flag is reset */
        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_STOPF, RESET, Timeout, tickstart) != HAL_OK)
2400ad24:	69bb      	ldr	r3, [r7, #24]
2400ad26:	9300      	str	r3, [sp, #0]
2400ad28:	683b      	ldr	r3, [r7, #0]
2400ad2a:	2200      	movs	r2, #0
2400ad2c:	2120      	movs	r1, #32
2400ad2e:	68f8      	ldr	r0, [r7, #12]
2400ad30:	f002 fe76 	bl	2400da20 <I2C_WaitOnFlagUntilTimeout>
2400ad34:	4603      	mov	r3, r0
2400ad36:	2b00      	cmp	r3, #0
2400ad38:	d001      	beq.n	2400ad3e <HAL_I2C_IsDeviceReady+0x186>
        {
          return HAL_ERROR;
2400ad3a:	2301      	movs	r3, #1
2400ad3c:	e03d      	b.n	2400adba <HAL_I2C_IsDeviceReady+0x202>
        }

        /* Clear NACK Flag */
        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
2400ad3e:	68fb      	ldr	r3, [r7, #12]
2400ad40:	681b      	ldr	r3, [r3, #0]
2400ad42:	2210      	movs	r2, #16
2400ad44:	61da      	str	r2, [r3, #28]

        /* Clear STOP Flag, auto generated with autoend*/
        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
2400ad46:	68fb      	ldr	r3, [r7, #12]
2400ad48:	681b      	ldr	r3, [r3, #0]
2400ad4a:	2220      	movs	r2, #32
2400ad4c:	61da      	str	r2, [r3, #28]
      }

      /* Check if the maximum allowed number of trials has been reached */
      if (I2C_Trials == Trials)
2400ad4e:	697b      	ldr	r3, [r7, #20]
2400ad50:	687a      	ldr	r2, [r7, #4]
2400ad52:	429a      	cmp	r2, r3
2400ad54:	d118      	bne.n	2400ad88 <HAL_I2C_IsDeviceReady+0x1d0>
      {
        /* Generate Stop */
        hi2c->Instance->CR2 |= I2C_CR2_STOP;
2400ad56:	68fb      	ldr	r3, [r7, #12]
2400ad58:	681b      	ldr	r3, [r3, #0]
2400ad5a:	685a      	ldr	r2, [r3, #4]
2400ad5c:	68fb      	ldr	r3, [r7, #12]
2400ad5e:	681b      	ldr	r3, [r3, #0]
2400ad60:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
2400ad64:	605a      	str	r2, [r3, #4]

        /* Wait until STOPF flag is reset */
        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_STOPF, RESET, Timeout, tickstart) != HAL_OK)
2400ad66:	69bb      	ldr	r3, [r7, #24]
2400ad68:	9300      	str	r3, [sp, #0]
2400ad6a:	683b      	ldr	r3, [r7, #0]
2400ad6c:	2200      	movs	r2, #0
2400ad6e:	2120      	movs	r1, #32
2400ad70:	68f8      	ldr	r0, [r7, #12]
2400ad72:	f002 fe55 	bl	2400da20 <I2C_WaitOnFlagUntilTimeout>
2400ad76:	4603      	mov	r3, r0
2400ad78:	2b00      	cmp	r3, #0
2400ad7a:	d001      	beq.n	2400ad80 <HAL_I2C_IsDeviceReady+0x1c8>
        {
          return HAL_ERROR;
2400ad7c:	2301      	movs	r3, #1
2400ad7e:	e01c      	b.n	2400adba <HAL_I2C_IsDeviceReady+0x202>
        }

        /* Clear STOP Flag */
        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
2400ad80:	68fb      	ldr	r3, [r7, #12]
2400ad82:	681b      	ldr	r3, [r3, #0]
2400ad84:	2220      	movs	r2, #32
2400ad86:	61da      	str	r2, [r3, #28]
      }

      /* Increment Trials */
      I2C_Trials++;
2400ad88:	697b      	ldr	r3, [r7, #20]
2400ad8a:	3301      	adds	r3, #1
2400ad8c:	617b      	str	r3, [r7, #20]
    }
    while (I2C_Trials < Trials);
2400ad8e:	697b      	ldr	r3, [r7, #20]
2400ad90:	687a      	ldr	r2, [r7, #4]
2400ad92:	429a      	cmp	r2, r3
2400ad94:	f63f af3d 	bhi.w	2400ac12 <HAL_I2C_IsDeviceReady+0x5a>

    /* Update I2C state */
    hi2c->State = HAL_I2C_STATE_READY;
2400ad98:	68fb      	ldr	r3, [r7, #12]
2400ad9a:	2220      	movs	r2, #32
2400ad9c:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

    /* Update I2C error code */
    hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
2400ada0:	68fb      	ldr	r3, [r7, #12]
2400ada2:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400ada4:	f043 0220 	orr.w	r2, r3, #32
2400ada8:	68fb      	ldr	r3, [r7, #12]
2400adaa:	645a      	str	r2, [r3, #68]	; 0x44

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
2400adac:	68fb      	ldr	r3, [r7, #12]
2400adae:	2200      	movs	r2, #0
2400adb0:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    return HAL_ERROR;
2400adb4:	2301      	movs	r3, #1
2400adb6:	e000      	b.n	2400adba <HAL_I2C_IsDeviceReady+0x202>
  }
  else
  {
    return HAL_BUSY;
2400adb8:	2302      	movs	r3, #2
  }
}
2400adba:	4618      	mov	r0, r3
2400adbc:	3720      	adds	r7, #32
2400adbe:	46bd      	mov	sp, r7
2400adc0:	bd80      	pop	{r7, pc}
2400adc2:	bf00      	nop
2400adc4:	02002000 	.word	0x02002000

2400adc8 <HAL_I2C_Master_Seq_Transmit_IT>:
  * @param  Size Amount of data to be sent
  * @param  XferOptions Options of Transfer, value of @ref I2C_XFEROPTIONS
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Master_Seq_Transmit_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size, uint32_t XferOptions)
{
2400adc8:	b580      	push	{r7, lr}
2400adca:	b088      	sub	sp, #32
2400adcc:	af02      	add	r7, sp, #8
2400adce:	60f8      	str	r0, [r7, #12]
2400add0:	607a      	str	r2, [r7, #4]
2400add2:	461a      	mov	r2, r3
2400add4:	460b      	mov	r3, r1
2400add6:	817b      	strh	r3, [r7, #10]
2400add8:	4613      	mov	r3, r2
2400adda:	813b      	strh	r3, [r7, #8]
  uint32_t xfermode;
  uint32_t xferrequest = I2C_GENERATE_START_WRITE;
2400addc:	4b3a      	ldr	r3, [pc, #232]	; (2400aec8 <HAL_I2C_Master_Seq_Transmit_IT+0x100>)
2400adde:	613b      	str	r3, [r7, #16]

  /* Check the parameters */
  assert_param(IS_I2C_TRANSFER_OPTIONS_REQUEST(XferOptions));

  if (hi2c->State == HAL_I2C_STATE_READY)
2400ade0:	68fb      	ldr	r3, [r7, #12]
2400ade2:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400ade6:	b2db      	uxtb	r3, r3
2400ade8:	2b20      	cmp	r3, #32
2400adea:	d167      	bne.n	2400aebc <HAL_I2C_Master_Seq_Transmit_IT+0xf4>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
2400adec:	68fb      	ldr	r3, [r7, #12]
2400adee:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2400adf2:	2b01      	cmp	r3, #1
2400adf4:	d101      	bne.n	2400adfa <HAL_I2C_Master_Seq_Transmit_IT+0x32>
2400adf6:	2302      	movs	r3, #2
2400adf8:	e061      	b.n	2400aebe <HAL_I2C_Master_Seq_Transmit_IT+0xf6>
2400adfa:	68fb      	ldr	r3, [r7, #12]
2400adfc:	2201      	movs	r2, #1
2400adfe:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    hi2c->State     = HAL_I2C_STATE_BUSY_TX;
2400ae02:	68fb      	ldr	r3, [r7, #12]
2400ae04:	2221      	movs	r2, #33	; 0x21
2400ae06:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode      = HAL_I2C_MODE_MASTER;
2400ae0a:	68fb      	ldr	r3, [r7, #12]
2400ae0c:	2210      	movs	r2, #16
2400ae0e:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
2400ae12:	68fb      	ldr	r3, [r7, #12]
2400ae14:	2200      	movs	r2, #0
2400ae16:	645a      	str	r2, [r3, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr    = pData;
2400ae18:	68fb      	ldr	r3, [r7, #12]
2400ae1a:	687a      	ldr	r2, [r7, #4]
2400ae1c:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount   = Size;
2400ae1e:	68fb      	ldr	r3, [r7, #12]
2400ae20:	893a      	ldrh	r2, [r7, #8]
2400ae22:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferOptions = XferOptions;
2400ae24:	68fb      	ldr	r3, [r7, #12]
2400ae26:	6a3a      	ldr	r2, [r7, #32]
2400ae28:	62da      	str	r2, [r3, #44]	; 0x2c
    hi2c->XferISR     = I2C_Master_ISR_IT;
2400ae2a:	68fb      	ldr	r3, [r7, #12]
2400ae2c:	4a27      	ldr	r2, [pc, #156]	; (2400aecc <HAL_I2C_Master_Seq_Transmit_IT+0x104>)
2400ae2e:	635a      	str	r2, [r3, #52]	; 0x34

    /* If hi2c->XferCount > MAX_NBYTE_SIZE, use reload mode */
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
2400ae30:	68fb      	ldr	r3, [r7, #12]
2400ae32:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400ae34:	b29b      	uxth	r3, r3
2400ae36:	2bff      	cmp	r3, #255	; 0xff
2400ae38:	d906      	bls.n	2400ae48 <HAL_I2C_Master_Seq_Transmit_IT+0x80>
    {
      hi2c->XferSize = MAX_NBYTE_SIZE;
2400ae3a:	68fb      	ldr	r3, [r7, #12]
2400ae3c:	22ff      	movs	r2, #255	; 0xff
2400ae3e:	851a      	strh	r2, [r3, #40]	; 0x28
      xfermode = I2C_RELOAD_MODE;
2400ae40:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
2400ae44:	617b      	str	r3, [r7, #20]
2400ae46:	e007      	b.n	2400ae58 <HAL_I2C_Master_Seq_Transmit_IT+0x90>
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
2400ae48:	68fb      	ldr	r3, [r7, #12]
2400ae4a:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400ae4c:	b29a      	uxth	r2, r3
2400ae4e:	68fb      	ldr	r3, [r7, #12]
2400ae50:	851a      	strh	r2, [r3, #40]	; 0x28
      xfermode = hi2c->XferOptions;
2400ae52:	68fb      	ldr	r3, [r7, #12]
2400ae54:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2400ae56:	617b      	str	r3, [r7, #20]
    }

    /* If transfer direction not change and there is no request to start another frame, do not generate Restart Condition */
    /* Mean Previous state is same as current state */
    if ((hi2c->PreviousState == I2C_STATE_MASTER_BUSY_TX) && (IS_I2C_TRANSFER_OTHER_OPTIONS_REQUEST(XferOptions) == 0))
2400ae58:	68fb      	ldr	r3, [r7, #12]
2400ae5a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
2400ae5c:	2b11      	cmp	r3, #17
2400ae5e:	d10e      	bne.n	2400ae7e <HAL_I2C_Master_Seq_Transmit_IT+0xb6>
2400ae60:	6a3b      	ldr	r3, [r7, #32]
2400ae62:	2baa      	cmp	r3, #170	; 0xaa
2400ae64:	d003      	beq.n	2400ae6e <HAL_I2C_Master_Seq_Transmit_IT+0xa6>
2400ae66:	6a3b      	ldr	r3, [r7, #32]
2400ae68:	f5b3 4f2a 	cmp.w	r3, #43520	; 0xaa00
2400ae6c:	d101      	bne.n	2400ae72 <HAL_I2C_Master_Seq_Transmit_IT+0xaa>
2400ae6e:	2301      	movs	r3, #1
2400ae70:	e000      	b.n	2400ae74 <HAL_I2C_Master_Seq_Transmit_IT+0xac>
2400ae72:	2300      	movs	r3, #0
2400ae74:	2b00      	cmp	r3, #0
2400ae76:	d102      	bne.n	2400ae7e <HAL_I2C_Master_Seq_Transmit_IT+0xb6>
    {
      xferrequest = I2C_NO_STARTSTOP;
2400ae78:	2300      	movs	r3, #0
2400ae7a:	613b      	str	r3, [r7, #16]
2400ae7c:	e00a      	b.n	2400ae94 <HAL_I2C_Master_Seq_Transmit_IT+0xcc>
    }
    else
    {
      /* Convert OTHER_xxx XferOptions if any */
      I2C_ConvertOtherXferOptions(hi2c);
2400ae7e:	68f8      	ldr	r0, [r7, #12]
2400ae80:	f003 f84c 	bl	2400df1c <I2C_ConvertOtherXferOptions>

      /* Update xfermode accordingly if no reload is necessary */
      if (hi2c->XferCount < MAX_NBYTE_SIZE)
2400ae84:	68fb      	ldr	r3, [r7, #12]
2400ae86:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400ae88:	b29b      	uxth	r3, r3
2400ae8a:	2bfe      	cmp	r3, #254	; 0xfe
2400ae8c:	d802      	bhi.n	2400ae94 <HAL_I2C_Master_Seq_Transmit_IT+0xcc>
      {
        xfermode = hi2c->XferOptions;
2400ae8e:	68fb      	ldr	r3, [r7, #12]
2400ae90:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2400ae92:	617b      	str	r3, [r7, #20]
      }
    }

    /* Send Slave Address and set NBYTES to write */
    I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, xferrequest);
2400ae94:	68fb      	ldr	r3, [r7, #12]
2400ae96:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400ae98:	b2da      	uxtb	r2, r3
2400ae9a:	8979      	ldrh	r1, [r7, #10]
2400ae9c:	693b      	ldr	r3, [r7, #16]
2400ae9e:	9300      	str	r3, [sp, #0]
2400aea0:	697b      	ldr	r3, [r7, #20]
2400aea2:	68f8      	ldr	r0, [r7, #12]
2400aea4:	f002 ff4a 	bl	2400dd3c <I2C_TransferConfig>

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
2400aea8:	68fb      	ldr	r3, [r7, #12]
2400aeaa:	2200      	movs	r2, #0
2400aeac:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Note : The I2C interrupts must be enabled after unlocking current process
              to avoid the risk of I2C interrupt handle execution before current
              process unlock */
    I2C_Enable_IRQ(hi2c, I2C_XFER_TX_IT);
2400aeb0:	2101      	movs	r1, #1
2400aeb2:	68f8      	ldr	r0, [r7, #12]
2400aeb4:	f002 ff70 	bl	2400dd98 <I2C_Enable_IRQ>

    return HAL_OK;
2400aeb8:	2300      	movs	r3, #0
2400aeba:	e000      	b.n	2400aebe <HAL_I2C_Master_Seq_Transmit_IT+0xf6>
  }
  else
  {
    return HAL_BUSY;
2400aebc:	2302      	movs	r3, #2
  }
}
2400aebe:	4618      	mov	r0, r3
2400aec0:	3718      	adds	r7, #24
2400aec2:	46bd      	mov	sp, r7
2400aec4:	bd80      	pop	{r7, pc}
2400aec6:	bf00      	nop
2400aec8:	80002000 	.word	0x80002000
2400aecc:	2400beb3 	.word	0x2400beb3

2400aed0 <HAL_I2C_Master_Seq_Transmit_DMA>:
  * @param  Size Amount of data to be sent
  * @param  XferOptions Options of Transfer, value of @ref I2C_XFEROPTIONS
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Master_Seq_Transmit_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size, uint32_t XferOptions)
{
2400aed0:	b580      	push	{r7, lr}
2400aed2:	b08a      	sub	sp, #40	; 0x28
2400aed4:	af02      	add	r7, sp, #8
2400aed6:	60f8      	str	r0, [r7, #12]
2400aed8:	607a      	str	r2, [r7, #4]
2400aeda:	461a      	mov	r2, r3
2400aedc:	460b      	mov	r3, r1
2400aede:	817b      	strh	r3, [r7, #10]
2400aee0:	4613      	mov	r3, r2
2400aee2:	813b      	strh	r3, [r7, #8]
  uint32_t xfermode;
  uint32_t xferrequest = I2C_GENERATE_START_WRITE;
2400aee4:	4b77      	ldr	r3, [pc, #476]	; (2400b0c4 <HAL_I2C_Master_Seq_Transmit_DMA+0x1f4>)
2400aee6:	61bb      	str	r3, [r7, #24]
  HAL_StatusTypeDef dmaxferstatus;

  /* Check the parameters */
  assert_param(IS_I2C_TRANSFER_OPTIONS_REQUEST(XferOptions));

  if (hi2c->State == HAL_I2C_STATE_READY)
2400aee8:	68fb      	ldr	r3, [r7, #12]
2400aeea:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400aeee:	b2db      	uxtb	r3, r3
2400aef0:	2b20      	cmp	r3, #32
2400aef2:	f040 80e1 	bne.w	2400b0b8 <HAL_I2C_Master_Seq_Transmit_DMA+0x1e8>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
2400aef6:	68fb      	ldr	r3, [r7, #12]
2400aef8:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2400aefc:	2b01      	cmp	r3, #1
2400aefe:	d101      	bne.n	2400af04 <HAL_I2C_Master_Seq_Transmit_DMA+0x34>
2400af00:	2302      	movs	r3, #2
2400af02:	e0da      	b.n	2400b0ba <HAL_I2C_Master_Seq_Transmit_DMA+0x1ea>
2400af04:	68fb      	ldr	r3, [r7, #12]
2400af06:	2201      	movs	r2, #1
2400af08:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    hi2c->State     = HAL_I2C_STATE_BUSY_TX;
2400af0c:	68fb      	ldr	r3, [r7, #12]
2400af0e:	2221      	movs	r2, #33	; 0x21
2400af10:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode      = HAL_I2C_MODE_MASTER;
2400af14:	68fb      	ldr	r3, [r7, #12]
2400af16:	2210      	movs	r2, #16
2400af18:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
2400af1c:	68fb      	ldr	r3, [r7, #12]
2400af1e:	2200      	movs	r2, #0
2400af20:	645a      	str	r2, [r3, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr    = pData;
2400af22:	68fb      	ldr	r3, [r7, #12]
2400af24:	687a      	ldr	r2, [r7, #4]
2400af26:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount   = Size;
2400af28:	68fb      	ldr	r3, [r7, #12]
2400af2a:	893a      	ldrh	r2, [r7, #8]
2400af2c:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferOptions = XferOptions;
2400af2e:	68fb      	ldr	r3, [r7, #12]
2400af30:	6aba      	ldr	r2, [r7, #40]	; 0x28
2400af32:	62da      	str	r2, [r3, #44]	; 0x2c
    hi2c->XferISR     = I2C_Master_ISR_DMA;
2400af34:	68fb      	ldr	r3, [r7, #12]
2400af36:	4a64      	ldr	r2, [pc, #400]	; (2400b0c8 <HAL_I2C_Master_Seq_Transmit_DMA+0x1f8>)
2400af38:	635a      	str	r2, [r3, #52]	; 0x34

    /* If hi2c->XferCount > MAX_NBYTE_SIZE, use reload mode */
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
2400af3a:	68fb      	ldr	r3, [r7, #12]
2400af3c:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400af3e:	b29b      	uxth	r3, r3
2400af40:	2bff      	cmp	r3, #255	; 0xff
2400af42:	d906      	bls.n	2400af52 <HAL_I2C_Master_Seq_Transmit_DMA+0x82>
    {
      hi2c->XferSize = MAX_NBYTE_SIZE;
2400af44:	68fb      	ldr	r3, [r7, #12]
2400af46:	22ff      	movs	r2, #255	; 0xff
2400af48:	851a      	strh	r2, [r3, #40]	; 0x28
      xfermode = I2C_RELOAD_MODE;
2400af4a:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
2400af4e:	61fb      	str	r3, [r7, #28]
2400af50:	e007      	b.n	2400af62 <HAL_I2C_Master_Seq_Transmit_DMA+0x92>
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
2400af52:	68fb      	ldr	r3, [r7, #12]
2400af54:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400af56:	b29a      	uxth	r2, r3
2400af58:	68fb      	ldr	r3, [r7, #12]
2400af5a:	851a      	strh	r2, [r3, #40]	; 0x28
      xfermode = hi2c->XferOptions;
2400af5c:	68fb      	ldr	r3, [r7, #12]
2400af5e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2400af60:	61fb      	str	r3, [r7, #28]
    }

    /* If transfer direction not change and there is no request to start another frame, do not generate Restart Condition */
    /* Mean Previous state is same as current state */
    if ((hi2c->PreviousState == I2C_STATE_MASTER_BUSY_TX) && (IS_I2C_TRANSFER_OTHER_OPTIONS_REQUEST(XferOptions) == 0))
2400af62:	68fb      	ldr	r3, [r7, #12]
2400af64:	6b1b      	ldr	r3, [r3, #48]	; 0x30
2400af66:	2b11      	cmp	r3, #17
2400af68:	d10e      	bne.n	2400af88 <HAL_I2C_Master_Seq_Transmit_DMA+0xb8>
2400af6a:	6abb      	ldr	r3, [r7, #40]	; 0x28
2400af6c:	2baa      	cmp	r3, #170	; 0xaa
2400af6e:	d003      	beq.n	2400af78 <HAL_I2C_Master_Seq_Transmit_DMA+0xa8>
2400af70:	6abb      	ldr	r3, [r7, #40]	; 0x28
2400af72:	f5b3 4f2a 	cmp.w	r3, #43520	; 0xaa00
2400af76:	d101      	bne.n	2400af7c <HAL_I2C_Master_Seq_Transmit_DMA+0xac>
2400af78:	2301      	movs	r3, #1
2400af7a:	e000      	b.n	2400af7e <HAL_I2C_Master_Seq_Transmit_DMA+0xae>
2400af7c:	2300      	movs	r3, #0
2400af7e:	2b00      	cmp	r3, #0
2400af80:	d102      	bne.n	2400af88 <HAL_I2C_Master_Seq_Transmit_DMA+0xb8>
    {
      xferrequest = I2C_NO_STARTSTOP;
2400af82:	2300      	movs	r3, #0
2400af84:	61bb      	str	r3, [r7, #24]
2400af86:	e00a      	b.n	2400af9e <HAL_I2C_Master_Seq_Transmit_DMA+0xce>
    }
    else
    {
      /* Convert OTHER_xxx XferOptions if any */
      I2C_ConvertOtherXferOptions(hi2c);
2400af88:	68f8      	ldr	r0, [r7, #12]
2400af8a:	f002 ffc7 	bl	2400df1c <I2C_ConvertOtherXferOptions>

      /* Update xfermode accordingly if no reload is necessary */
      if (hi2c->XferCount < MAX_NBYTE_SIZE)
2400af8e:	68fb      	ldr	r3, [r7, #12]
2400af90:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400af92:	b29b      	uxth	r3, r3
2400af94:	2bfe      	cmp	r3, #254	; 0xfe
2400af96:	d802      	bhi.n	2400af9e <HAL_I2C_Master_Seq_Transmit_DMA+0xce>
      {
        xfermode = hi2c->XferOptions;
2400af98:	68fb      	ldr	r3, [r7, #12]
2400af9a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2400af9c:	61fb      	str	r3, [r7, #28]
      }
    }

    if (hi2c->XferSize > 0U)
2400af9e:	68fb      	ldr	r3, [r7, #12]
2400afa0:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400afa2:	2b00      	cmp	r3, #0
2400afa4:	d070      	beq.n	2400b088 <HAL_I2C_Master_Seq_Transmit_DMA+0x1b8>
    {
      if (hi2c->hdmatx != NULL)
2400afa6:	68fb      	ldr	r3, [r7, #12]
2400afa8:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400afaa:	2b00      	cmp	r3, #0
2400afac:	d020      	beq.n	2400aff0 <HAL_I2C_Master_Seq_Transmit_DMA+0x120>
      {
        /* Set the I2C DMA transfer complete callback */
        hi2c->hdmatx->XferCpltCallback = I2C_DMAMasterTransmitCplt;
2400afae:	68fb      	ldr	r3, [r7, #12]
2400afb0:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400afb2:	4a46      	ldr	r2, [pc, #280]	; (2400b0cc <HAL_I2C_Master_Seq_Transmit_DMA+0x1fc>)
2400afb4:	63da      	str	r2, [r3, #60]	; 0x3c

        /* Set the DMA error callback */
        hi2c->hdmatx->XferErrorCallback = I2C_DMAError;
2400afb6:	68fb      	ldr	r3, [r7, #12]
2400afb8:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400afba:	4a45      	ldr	r2, [pc, #276]	; (2400b0d0 <HAL_I2C_Master_Seq_Transmit_DMA+0x200>)
2400afbc:	64da      	str	r2, [r3, #76]	; 0x4c

        /* Set the unused DMA callbacks to NULL */
        hi2c->hdmatx->XferHalfCpltCallback = NULL;
2400afbe:	68fb      	ldr	r3, [r7, #12]
2400afc0:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400afc2:	2200      	movs	r2, #0
2400afc4:	641a      	str	r2, [r3, #64]	; 0x40
        hi2c->hdmatx->XferAbortCallback = NULL;
2400afc6:	68fb      	ldr	r3, [r7, #12]
2400afc8:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400afca:	2200      	movs	r2, #0
2400afcc:	651a      	str	r2, [r3, #80]	; 0x50

        /* Enable the DMA stream or channel depends on Instance */
        dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)pData, (uint32_t)&hi2c->Instance->TXDR, hi2c->XferSize);
2400afce:	68fb      	ldr	r3, [r7, #12]
2400afd0:	6b98      	ldr	r0, [r3, #56]	; 0x38
2400afd2:	6879      	ldr	r1, [r7, #4]
2400afd4:	68fb      	ldr	r3, [r7, #12]
2400afd6:	681b      	ldr	r3, [r3, #0]
2400afd8:	3328      	adds	r3, #40	; 0x28
2400afda:	461a      	mov	r2, r3
2400afdc:	68fb      	ldr	r3, [r7, #12]
2400afde:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400afe0:	f7f7 fab6 	bl	24002550 <HAL_DMA_Start_IT>
2400afe4:	4603      	mov	r3, r0
2400afe6:	75fb      	strb	r3, [r7, #23]
        __HAL_UNLOCK(hi2c);

        return HAL_ERROR;
      }

      if (dmaxferstatus == HAL_OK)
2400afe8:	7dfb      	ldrb	r3, [r7, #23]
2400afea:	2b00      	cmp	r3, #0
2400afec:	d138      	bne.n	2400b060 <HAL_I2C_Master_Seq_Transmit_DMA+0x190>
2400afee:	e013      	b.n	2400b018 <HAL_I2C_Master_Seq_Transmit_DMA+0x148>
        hi2c->State     = HAL_I2C_STATE_READY;
2400aff0:	68fb      	ldr	r3, [r7, #12]
2400aff2:	2220      	movs	r2, #32
2400aff4:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
        hi2c->Mode      = HAL_I2C_MODE_NONE;
2400aff8:	68fb      	ldr	r3, [r7, #12]
2400affa:	2200      	movs	r2, #0
2400affc:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
        hi2c->ErrorCode |= HAL_I2C_ERROR_DMA_PARAM;
2400b000:	68fb      	ldr	r3, [r7, #12]
2400b002:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400b004:	f043 0280 	orr.w	r2, r3, #128	; 0x80
2400b008:	68fb      	ldr	r3, [r7, #12]
2400b00a:	645a      	str	r2, [r3, #68]	; 0x44
        __HAL_UNLOCK(hi2c);
2400b00c:	68fb      	ldr	r3, [r7, #12]
2400b00e:	2200      	movs	r2, #0
2400b010:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
        return HAL_ERROR;
2400b014:	2301      	movs	r3, #1
2400b016:	e050      	b.n	2400b0ba <HAL_I2C_Master_Seq_Transmit_DMA+0x1ea>
      {
        /* Send Slave Address and set NBYTES to write */
        I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, xferrequest);
2400b018:	68fb      	ldr	r3, [r7, #12]
2400b01a:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400b01c:	b2da      	uxtb	r2, r3
2400b01e:	8979      	ldrh	r1, [r7, #10]
2400b020:	69bb      	ldr	r3, [r7, #24]
2400b022:	9300      	str	r3, [sp, #0]
2400b024:	69fb      	ldr	r3, [r7, #28]
2400b026:	68f8      	ldr	r0, [r7, #12]
2400b028:	f002 fe88 	bl	2400dd3c <I2C_TransferConfig>

        /* Update XferCount value */
        hi2c->XferCount -= hi2c->XferSize;
2400b02c:	68fb      	ldr	r3, [r7, #12]
2400b02e:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400b030:	b29a      	uxth	r2, r3
2400b032:	68fb      	ldr	r3, [r7, #12]
2400b034:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400b036:	1ad3      	subs	r3, r2, r3
2400b038:	b29a      	uxth	r2, r3
2400b03a:	68fb      	ldr	r3, [r7, #12]
2400b03c:	855a      	strh	r2, [r3, #42]	; 0x2a

        /* Process Unlocked */
        __HAL_UNLOCK(hi2c);
2400b03e:	68fb      	ldr	r3, [r7, #12]
2400b040:	2200      	movs	r2, #0
2400b042:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

        /* Note : The I2C interrupts must be enabled after unlocking current process
                  to avoid the risk of I2C interrupt handle execution before current
                  process unlock */
        /* Enable ERR and NACK interrupts */
        I2C_Enable_IRQ(hi2c, I2C_XFER_ERROR_IT);
2400b046:	2110      	movs	r1, #16
2400b048:	68f8      	ldr	r0, [r7, #12]
2400b04a:	f002 fea5 	bl	2400dd98 <I2C_Enable_IRQ>

        /* Enable DMA Request */
        hi2c->Instance->CR1 |= I2C_CR1_TXDMAEN;
2400b04e:	68fb      	ldr	r3, [r7, #12]
2400b050:	681b      	ldr	r3, [r3, #0]
2400b052:	681a      	ldr	r2, [r3, #0]
2400b054:	68fb      	ldr	r3, [r7, #12]
2400b056:	681b      	ldr	r3, [r3, #0]
2400b058:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
2400b05c:	601a      	str	r2, [r3, #0]
2400b05e:	e029      	b.n	2400b0b4 <HAL_I2C_Master_Seq_Transmit_DMA+0x1e4>
      }
      else
      {
        /* Update I2C state */
        hi2c->State     = HAL_I2C_STATE_READY;
2400b060:	68fb      	ldr	r3, [r7, #12]
2400b062:	2220      	movs	r2, #32
2400b064:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
        hi2c->Mode      = HAL_I2C_MODE_NONE;
2400b068:	68fb      	ldr	r3, [r7, #12]
2400b06a:	2200      	movs	r2, #0
2400b06c:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

        /* Update I2C error code */
        hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
2400b070:	68fb      	ldr	r3, [r7, #12]
2400b072:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400b074:	f043 0210 	orr.w	r2, r3, #16
2400b078:	68fb      	ldr	r3, [r7, #12]
2400b07a:	645a      	str	r2, [r3, #68]	; 0x44

        /* Process Unlocked */
        __HAL_UNLOCK(hi2c);
2400b07c:	68fb      	ldr	r3, [r7, #12]
2400b07e:	2200      	movs	r2, #0
2400b080:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

        return HAL_ERROR;
2400b084:	2301      	movs	r3, #1
2400b086:	e018      	b.n	2400b0ba <HAL_I2C_Master_Seq_Transmit_DMA+0x1ea>
      }
    }
    else
    {
      /* Update Transfer ISR function pointer */
      hi2c->XferISR = I2C_Master_ISR_IT;
2400b088:	68fb      	ldr	r3, [r7, #12]
2400b08a:	4a12      	ldr	r2, [pc, #72]	; (2400b0d4 <HAL_I2C_Master_Seq_Transmit_DMA+0x204>)
2400b08c:	635a      	str	r2, [r3, #52]	; 0x34

      /* Send Slave Address */
      /* Set NBYTES to write and generate START condition */
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_GENERATE_START_WRITE);
2400b08e:	68fb      	ldr	r3, [r7, #12]
2400b090:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400b092:	b2da      	uxtb	r2, r3
2400b094:	8979      	ldrh	r1, [r7, #10]
2400b096:	4b0b      	ldr	r3, [pc, #44]	; (2400b0c4 <HAL_I2C_Master_Seq_Transmit_DMA+0x1f4>)
2400b098:	9300      	str	r3, [sp, #0]
2400b09a:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
2400b09e:	68f8      	ldr	r0, [r7, #12]
2400b0a0:	f002 fe4c 	bl	2400dd3c <I2C_TransferConfig>

      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
2400b0a4:	68fb      	ldr	r3, [r7, #12]
2400b0a6:	2200      	movs	r2, #0
2400b0a8:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
                to avoid the risk of I2C interrupt handle execution before current
                process unlock */
      /* Enable ERR, TC, STOP, NACK, TXI interrupt */
      /* possible to enable all of these */
      /* I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */
      I2C_Enable_IRQ(hi2c, I2C_XFER_TX_IT);
2400b0ac:	2101      	movs	r1, #1
2400b0ae:	68f8      	ldr	r0, [r7, #12]
2400b0b0:	f002 fe72 	bl	2400dd98 <I2C_Enable_IRQ>
    }

    return HAL_OK;
2400b0b4:	2300      	movs	r3, #0
2400b0b6:	e000      	b.n	2400b0ba <HAL_I2C_Master_Seq_Transmit_DMA+0x1ea>
  }
  else
  {
    return HAL_BUSY;
2400b0b8:	2302      	movs	r3, #2
  }
}
2400b0ba:	4618      	mov	r0, r3
2400b0bc:	3720      	adds	r7, #32
2400b0be:	46bd      	mov	sp, r7
2400b0c0:	bd80      	pop	{r7, pc}
2400b0c2:	bf00      	nop
2400b0c4:	80002000 	.word	0x80002000
2400b0c8:	2400c30b 	.word	0x2400c30b
2400b0cc:	2400d4a3 	.word	0x2400d4a3
2400b0d0:	2400d775 	.word	0x2400d775
2400b0d4:	2400beb3 	.word	0x2400beb3

2400b0d8 <HAL_I2C_Master_Seq_Receive_IT>:
  * @param  Size Amount of data to be sent
  * @param  XferOptions Options of Transfer, value of @ref I2C_XFEROPTIONS
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Master_Seq_Receive_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size, uint32_t XferOptions)
{
2400b0d8:	b580      	push	{r7, lr}
2400b0da:	b088      	sub	sp, #32
2400b0dc:	af02      	add	r7, sp, #8
2400b0de:	60f8      	str	r0, [r7, #12]
2400b0e0:	607a      	str	r2, [r7, #4]
2400b0e2:	461a      	mov	r2, r3
2400b0e4:	460b      	mov	r3, r1
2400b0e6:	817b      	strh	r3, [r7, #10]
2400b0e8:	4613      	mov	r3, r2
2400b0ea:	813b      	strh	r3, [r7, #8]
  uint32_t xfermode;
  uint32_t xferrequest = I2C_GENERATE_START_READ;
2400b0ec:	4b3a      	ldr	r3, [pc, #232]	; (2400b1d8 <HAL_I2C_Master_Seq_Receive_IT+0x100>)
2400b0ee:	613b      	str	r3, [r7, #16]

  /* Check the parameters */
  assert_param(IS_I2C_TRANSFER_OPTIONS_REQUEST(XferOptions));

  if (hi2c->State == HAL_I2C_STATE_READY)
2400b0f0:	68fb      	ldr	r3, [r7, #12]
2400b0f2:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400b0f6:	b2db      	uxtb	r3, r3
2400b0f8:	2b20      	cmp	r3, #32
2400b0fa:	d167      	bne.n	2400b1cc <HAL_I2C_Master_Seq_Receive_IT+0xf4>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
2400b0fc:	68fb      	ldr	r3, [r7, #12]
2400b0fe:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2400b102:	2b01      	cmp	r3, #1
2400b104:	d101      	bne.n	2400b10a <HAL_I2C_Master_Seq_Receive_IT+0x32>
2400b106:	2302      	movs	r3, #2
2400b108:	e061      	b.n	2400b1ce <HAL_I2C_Master_Seq_Receive_IT+0xf6>
2400b10a:	68fb      	ldr	r3, [r7, #12]
2400b10c:	2201      	movs	r2, #1
2400b10e:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    hi2c->State     = HAL_I2C_STATE_BUSY_RX;
2400b112:	68fb      	ldr	r3, [r7, #12]
2400b114:	2222      	movs	r2, #34	; 0x22
2400b116:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode      = HAL_I2C_MODE_MASTER;
2400b11a:	68fb      	ldr	r3, [r7, #12]
2400b11c:	2210      	movs	r2, #16
2400b11e:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
2400b122:	68fb      	ldr	r3, [r7, #12]
2400b124:	2200      	movs	r2, #0
2400b126:	645a      	str	r2, [r3, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr    = pData;
2400b128:	68fb      	ldr	r3, [r7, #12]
2400b12a:	687a      	ldr	r2, [r7, #4]
2400b12c:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount   = Size;
2400b12e:	68fb      	ldr	r3, [r7, #12]
2400b130:	893a      	ldrh	r2, [r7, #8]
2400b132:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferOptions = XferOptions;
2400b134:	68fb      	ldr	r3, [r7, #12]
2400b136:	6a3a      	ldr	r2, [r7, #32]
2400b138:	62da      	str	r2, [r3, #44]	; 0x2c
    hi2c->XferISR     = I2C_Master_ISR_IT;
2400b13a:	68fb      	ldr	r3, [r7, #12]
2400b13c:	4a27      	ldr	r2, [pc, #156]	; (2400b1dc <HAL_I2C_Master_Seq_Receive_IT+0x104>)
2400b13e:	635a      	str	r2, [r3, #52]	; 0x34

    /* If hi2c->XferCount > MAX_NBYTE_SIZE, use reload mode */
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
2400b140:	68fb      	ldr	r3, [r7, #12]
2400b142:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400b144:	b29b      	uxth	r3, r3
2400b146:	2bff      	cmp	r3, #255	; 0xff
2400b148:	d906      	bls.n	2400b158 <HAL_I2C_Master_Seq_Receive_IT+0x80>
    {
      hi2c->XferSize = MAX_NBYTE_SIZE;
2400b14a:	68fb      	ldr	r3, [r7, #12]
2400b14c:	22ff      	movs	r2, #255	; 0xff
2400b14e:	851a      	strh	r2, [r3, #40]	; 0x28
      xfermode = I2C_RELOAD_MODE;
2400b150:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
2400b154:	617b      	str	r3, [r7, #20]
2400b156:	e007      	b.n	2400b168 <HAL_I2C_Master_Seq_Receive_IT+0x90>
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
2400b158:	68fb      	ldr	r3, [r7, #12]
2400b15a:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400b15c:	b29a      	uxth	r2, r3
2400b15e:	68fb      	ldr	r3, [r7, #12]
2400b160:	851a      	strh	r2, [r3, #40]	; 0x28
      xfermode = hi2c->XferOptions;
2400b162:	68fb      	ldr	r3, [r7, #12]
2400b164:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2400b166:	617b      	str	r3, [r7, #20]
    }

    /* If transfer direction not change and there is no request to start another frame, do not generate Restart Condition */
    /* Mean Previous state is same as current state */
    if ((hi2c->PreviousState == I2C_STATE_MASTER_BUSY_RX) && (IS_I2C_TRANSFER_OTHER_OPTIONS_REQUEST(XferOptions) == 0))
2400b168:	68fb      	ldr	r3, [r7, #12]
2400b16a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
2400b16c:	2b12      	cmp	r3, #18
2400b16e:	d10e      	bne.n	2400b18e <HAL_I2C_Master_Seq_Receive_IT+0xb6>
2400b170:	6a3b      	ldr	r3, [r7, #32]
2400b172:	2baa      	cmp	r3, #170	; 0xaa
2400b174:	d003      	beq.n	2400b17e <HAL_I2C_Master_Seq_Receive_IT+0xa6>
2400b176:	6a3b      	ldr	r3, [r7, #32]
2400b178:	f5b3 4f2a 	cmp.w	r3, #43520	; 0xaa00
2400b17c:	d101      	bne.n	2400b182 <HAL_I2C_Master_Seq_Receive_IT+0xaa>
2400b17e:	2301      	movs	r3, #1
2400b180:	e000      	b.n	2400b184 <HAL_I2C_Master_Seq_Receive_IT+0xac>
2400b182:	2300      	movs	r3, #0
2400b184:	2b00      	cmp	r3, #0
2400b186:	d102      	bne.n	2400b18e <HAL_I2C_Master_Seq_Receive_IT+0xb6>
    {
      xferrequest = I2C_NO_STARTSTOP;
2400b188:	2300      	movs	r3, #0
2400b18a:	613b      	str	r3, [r7, #16]
2400b18c:	e00a      	b.n	2400b1a4 <HAL_I2C_Master_Seq_Receive_IT+0xcc>
    }
    else
    {
      /* Convert OTHER_xxx XferOptions if any */
      I2C_ConvertOtherXferOptions(hi2c);
2400b18e:	68f8      	ldr	r0, [r7, #12]
2400b190:	f002 fec4 	bl	2400df1c <I2C_ConvertOtherXferOptions>

      /* Update xfermode accordingly if no reload is necessary */
      if (hi2c->XferCount < MAX_NBYTE_SIZE)
2400b194:	68fb      	ldr	r3, [r7, #12]
2400b196:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400b198:	b29b      	uxth	r3, r3
2400b19a:	2bfe      	cmp	r3, #254	; 0xfe
2400b19c:	d802      	bhi.n	2400b1a4 <HAL_I2C_Master_Seq_Receive_IT+0xcc>
      {
        xfermode = hi2c->XferOptions;
2400b19e:	68fb      	ldr	r3, [r7, #12]
2400b1a0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2400b1a2:	617b      	str	r3, [r7, #20]
      }
    }

    /* Send Slave Address and set NBYTES to read */
    I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, xferrequest);
2400b1a4:	68fb      	ldr	r3, [r7, #12]
2400b1a6:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400b1a8:	b2da      	uxtb	r2, r3
2400b1aa:	8979      	ldrh	r1, [r7, #10]
2400b1ac:	693b      	ldr	r3, [r7, #16]
2400b1ae:	9300      	str	r3, [sp, #0]
2400b1b0:	697b      	ldr	r3, [r7, #20]
2400b1b2:	68f8      	ldr	r0, [r7, #12]
2400b1b4:	f002 fdc2 	bl	2400dd3c <I2C_TransferConfig>

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
2400b1b8:	68fb      	ldr	r3, [r7, #12]
2400b1ba:	2200      	movs	r2, #0
2400b1bc:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Note : The I2C interrupts must be enabled after unlocking current process
              to avoid the risk of I2C interrupt handle execution before current
              process unlock */
    I2C_Enable_IRQ(hi2c, I2C_XFER_RX_IT);
2400b1c0:	2102      	movs	r1, #2
2400b1c2:	68f8      	ldr	r0, [r7, #12]
2400b1c4:	f002 fde8 	bl	2400dd98 <I2C_Enable_IRQ>

    return HAL_OK;
2400b1c8:	2300      	movs	r3, #0
2400b1ca:	e000      	b.n	2400b1ce <HAL_I2C_Master_Seq_Receive_IT+0xf6>
  }
  else
  {
    return HAL_BUSY;
2400b1cc:	2302      	movs	r3, #2
  }
}
2400b1ce:	4618      	mov	r0, r3
2400b1d0:	3718      	adds	r7, #24
2400b1d2:	46bd      	mov	sp, r7
2400b1d4:	bd80      	pop	{r7, pc}
2400b1d6:	bf00      	nop
2400b1d8:	80002400 	.word	0x80002400
2400b1dc:	2400beb3 	.word	0x2400beb3

2400b1e0 <HAL_I2C_Master_Seq_Receive_DMA>:
  * @param  Size Amount of data to be sent
  * @param  XferOptions Options of Transfer, value of @ref I2C_XFEROPTIONS
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Master_Seq_Receive_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size, uint32_t XferOptions)
{
2400b1e0:	b580      	push	{r7, lr}
2400b1e2:	b08a      	sub	sp, #40	; 0x28
2400b1e4:	af02      	add	r7, sp, #8
2400b1e6:	60f8      	str	r0, [r7, #12]
2400b1e8:	607a      	str	r2, [r7, #4]
2400b1ea:	461a      	mov	r2, r3
2400b1ec:	460b      	mov	r3, r1
2400b1ee:	817b      	strh	r3, [r7, #10]
2400b1f0:	4613      	mov	r3, r2
2400b1f2:	813b      	strh	r3, [r7, #8]
  uint32_t xfermode;
  uint32_t xferrequest = I2C_GENERATE_START_READ;
2400b1f4:	4b77      	ldr	r3, [pc, #476]	; (2400b3d4 <HAL_I2C_Master_Seq_Receive_DMA+0x1f4>)
2400b1f6:	61bb      	str	r3, [r7, #24]
  HAL_StatusTypeDef dmaxferstatus;

  /* Check the parameters */
  assert_param(IS_I2C_TRANSFER_OPTIONS_REQUEST(XferOptions));

  if (hi2c->State == HAL_I2C_STATE_READY)
2400b1f8:	68fb      	ldr	r3, [r7, #12]
2400b1fa:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400b1fe:	b2db      	uxtb	r3, r3
2400b200:	2b20      	cmp	r3, #32
2400b202:	f040 80e1 	bne.w	2400b3c8 <HAL_I2C_Master_Seq_Receive_DMA+0x1e8>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
2400b206:	68fb      	ldr	r3, [r7, #12]
2400b208:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2400b20c:	2b01      	cmp	r3, #1
2400b20e:	d101      	bne.n	2400b214 <HAL_I2C_Master_Seq_Receive_DMA+0x34>
2400b210:	2302      	movs	r3, #2
2400b212:	e0da      	b.n	2400b3ca <HAL_I2C_Master_Seq_Receive_DMA+0x1ea>
2400b214:	68fb      	ldr	r3, [r7, #12]
2400b216:	2201      	movs	r2, #1
2400b218:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    hi2c->State     = HAL_I2C_STATE_BUSY_RX;
2400b21c:	68fb      	ldr	r3, [r7, #12]
2400b21e:	2222      	movs	r2, #34	; 0x22
2400b220:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode      = HAL_I2C_MODE_MASTER;
2400b224:	68fb      	ldr	r3, [r7, #12]
2400b226:	2210      	movs	r2, #16
2400b228:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
2400b22c:	68fb      	ldr	r3, [r7, #12]
2400b22e:	2200      	movs	r2, #0
2400b230:	645a      	str	r2, [r3, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr    = pData;
2400b232:	68fb      	ldr	r3, [r7, #12]
2400b234:	687a      	ldr	r2, [r7, #4]
2400b236:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount   = Size;
2400b238:	68fb      	ldr	r3, [r7, #12]
2400b23a:	893a      	ldrh	r2, [r7, #8]
2400b23c:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferOptions = XferOptions;
2400b23e:	68fb      	ldr	r3, [r7, #12]
2400b240:	6aba      	ldr	r2, [r7, #40]	; 0x28
2400b242:	62da      	str	r2, [r3, #44]	; 0x2c
    hi2c->XferISR     = I2C_Master_ISR_DMA;
2400b244:	68fb      	ldr	r3, [r7, #12]
2400b246:	4a64      	ldr	r2, [pc, #400]	; (2400b3d8 <HAL_I2C_Master_Seq_Receive_DMA+0x1f8>)
2400b248:	635a      	str	r2, [r3, #52]	; 0x34

    /* If hi2c->XferCount > MAX_NBYTE_SIZE, use reload mode */
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
2400b24a:	68fb      	ldr	r3, [r7, #12]
2400b24c:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400b24e:	b29b      	uxth	r3, r3
2400b250:	2bff      	cmp	r3, #255	; 0xff
2400b252:	d906      	bls.n	2400b262 <HAL_I2C_Master_Seq_Receive_DMA+0x82>
    {
      hi2c->XferSize = MAX_NBYTE_SIZE;
2400b254:	68fb      	ldr	r3, [r7, #12]
2400b256:	22ff      	movs	r2, #255	; 0xff
2400b258:	851a      	strh	r2, [r3, #40]	; 0x28
      xfermode = I2C_RELOAD_MODE;
2400b25a:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
2400b25e:	61fb      	str	r3, [r7, #28]
2400b260:	e007      	b.n	2400b272 <HAL_I2C_Master_Seq_Receive_DMA+0x92>
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
2400b262:	68fb      	ldr	r3, [r7, #12]
2400b264:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400b266:	b29a      	uxth	r2, r3
2400b268:	68fb      	ldr	r3, [r7, #12]
2400b26a:	851a      	strh	r2, [r3, #40]	; 0x28
      xfermode = hi2c->XferOptions;
2400b26c:	68fb      	ldr	r3, [r7, #12]
2400b26e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2400b270:	61fb      	str	r3, [r7, #28]
    }

    /* If transfer direction not change and there is no request to start another frame, do not generate Restart Condition */
    /* Mean Previous state is same as current state */
    if ((hi2c->PreviousState == I2C_STATE_MASTER_BUSY_RX) && (IS_I2C_TRANSFER_OTHER_OPTIONS_REQUEST(XferOptions) == 0))
2400b272:	68fb      	ldr	r3, [r7, #12]
2400b274:	6b1b      	ldr	r3, [r3, #48]	; 0x30
2400b276:	2b12      	cmp	r3, #18
2400b278:	d10e      	bne.n	2400b298 <HAL_I2C_Master_Seq_Receive_DMA+0xb8>
2400b27a:	6abb      	ldr	r3, [r7, #40]	; 0x28
2400b27c:	2baa      	cmp	r3, #170	; 0xaa
2400b27e:	d003      	beq.n	2400b288 <HAL_I2C_Master_Seq_Receive_DMA+0xa8>
2400b280:	6abb      	ldr	r3, [r7, #40]	; 0x28
2400b282:	f5b3 4f2a 	cmp.w	r3, #43520	; 0xaa00
2400b286:	d101      	bne.n	2400b28c <HAL_I2C_Master_Seq_Receive_DMA+0xac>
2400b288:	2301      	movs	r3, #1
2400b28a:	e000      	b.n	2400b28e <HAL_I2C_Master_Seq_Receive_DMA+0xae>
2400b28c:	2300      	movs	r3, #0
2400b28e:	2b00      	cmp	r3, #0
2400b290:	d102      	bne.n	2400b298 <HAL_I2C_Master_Seq_Receive_DMA+0xb8>
    {
      xferrequest = I2C_NO_STARTSTOP;
2400b292:	2300      	movs	r3, #0
2400b294:	61bb      	str	r3, [r7, #24]
2400b296:	e00a      	b.n	2400b2ae <HAL_I2C_Master_Seq_Receive_DMA+0xce>
    }
    else
    {
      /* Convert OTHER_xxx XferOptions if any */
      I2C_ConvertOtherXferOptions(hi2c);
2400b298:	68f8      	ldr	r0, [r7, #12]
2400b29a:	f002 fe3f 	bl	2400df1c <I2C_ConvertOtherXferOptions>

      /* Update xfermode accordingly if no reload is necessary */
      if (hi2c->XferCount < MAX_NBYTE_SIZE)
2400b29e:	68fb      	ldr	r3, [r7, #12]
2400b2a0:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400b2a2:	b29b      	uxth	r3, r3
2400b2a4:	2bfe      	cmp	r3, #254	; 0xfe
2400b2a6:	d802      	bhi.n	2400b2ae <HAL_I2C_Master_Seq_Receive_DMA+0xce>
      {
        xfermode = hi2c->XferOptions;
2400b2a8:	68fb      	ldr	r3, [r7, #12]
2400b2aa:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2400b2ac:	61fb      	str	r3, [r7, #28]
      }
    }

    if (hi2c->XferSize > 0U)
2400b2ae:	68fb      	ldr	r3, [r7, #12]
2400b2b0:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400b2b2:	2b00      	cmp	r3, #0
2400b2b4:	d070      	beq.n	2400b398 <HAL_I2C_Master_Seq_Receive_DMA+0x1b8>
    {
      if (hi2c->hdmarx != NULL)
2400b2b6:	68fb      	ldr	r3, [r7, #12]
2400b2b8:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400b2ba:	2b00      	cmp	r3, #0
2400b2bc:	d020      	beq.n	2400b300 <HAL_I2C_Master_Seq_Receive_DMA+0x120>
      {
        /* Set the I2C DMA transfer complete callback */
        hi2c->hdmarx->XferCpltCallback = I2C_DMAMasterReceiveCplt;
2400b2be:	68fb      	ldr	r3, [r7, #12]
2400b2c0:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400b2c2:	4a46      	ldr	r2, [pc, #280]	; (2400b3dc <HAL_I2C_Master_Seq_Receive_DMA+0x1fc>)
2400b2c4:	63da      	str	r2, [r3, #60]	; 0x3c

        /* Set the DMA error callback */
        hi2c->hdmarx->XferErrorCallback = I2C_DMAError;
2400b2c6:	68fb      	ldr	r3, [r7, #12]
2400b2c8:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400b2ca:	4a45      	ldr	r2, [pc, #276]	; (2400b3e0 <HAL_I2C_Master_Seq_Receive_DMA+0x200>)
2400b2cc:	64da      	str	r2, [r3, #76]	; 0x4c

        /* Set the unused DMA callbacks to NULL */
        hi2c->hdmarx->XferHalfCpltCallback = NULL;
2400b2ce:	68fb      	ldr	r3, [r7, #12]
2400b2d0:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400b2d2:	2200      	movs	r2, #0
2400b2d4:	641a      	str	r2, [r3, #64]	; 0x40
        hi2c->hdmarx->XferAbortCallback = NULL;
2400b2d6:	68fb      	ldr	r3, [r7, #12]
2400b2d8:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400b2da:	2200      	movs	r2, #0
2400b2dc:	651a      	str	r2, [r3, #80]	; 0x50

        /* Enable the DMA stream or channel depends on Instance */
        dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->RXDR, (uint32_t)pData, hi2c->XferSize);
2400b2de:	68fb      	ldr	r3, [r7, #12]
2400b2e0:	6bd8      	ldr	r0, [r3, #60]	; 0x3c
2400b2e2:	68fb      	ldr	r3, [r7, #12]
2400b2e4:	681b      	ldr	r3, [r3, #0]
2400b2e6:	3324      	adds	r3, #36	; 0x24
2400b2e8:	4619      	mov	r1, r3
2400b2ea:	687a      	ldr	r2, [r7, #4]
2400b2ec:	68fb      	ldr	r3, [r7, #12]
2400b2ee:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400b2f0:	f7f7 f92e 	bl	24002550 <HAL_DMA_Start_IT>
2400b2f4:	4603      	mov	r3, r0
2400b2f6:	75fb      	strb	r3, [r7, #23]
        __HAL_UNLOCK(hi2c);

        return HAL_ERROR;
      }

      if (dmaxferstatus == HAL_OK)
2400b2f8:	7dfb      	ldrb	r3, [r7, #23]
2400b2fa:	2b00      	cmp	r3, #0
2400b2fc:	d138      	bne.n	2400b370 <HAL_I2C_Master_Seq_Receive_DMA+0x190>
2400b2fe:	e013      	b.n	2400b328 <HAL_I2C_Master_Seq_Receive_DMA+0x148>
        hi2c->State     = HAL_I2C_STATE_READY;
2400b300:	68fb      	ldr	r3, [r7, #12]
2400b302:	2220      	movs	r2, #32
2400b304:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
        hi2c->Mode      = HAL_I2C_MODE_NONE;
2400b308:	68fb      	ldr	r3, [r7, #12]
2400b30a:	2200      	movs	r2, #0
2400b30c:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
        hi2c->ErrorCode |= HAL_I2C_ERROR_DMA_PARAM;
2400b310:	68fb      	ldr	r3, [r7, #12]
2400b312:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400b314:	f043 0280 	orr.w	r2, r3, #128	; 0x80
2400b318:	68fb      	ldr	r3, [r7, #12]
2400b31a:	645a      	str	r2, [r3, #68]	; 0x44
        __HAL_UNLOCK(hi2c);
2400b31c:	68fb      	ldr	r3, [r7, #12]
2400b31e:	2200      	movs	r2, #0
2400b320:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
        return HAL_ERROR;
2400b324:	2301      	movs	r3, #1
2400b326:	e050      	b.n	2400b3ca <HAL_I2C_Master_Seq_Receive_DMA+0x1ea>
      {
        /* Send Slave Address and set NBYTES to read */
        I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, xferrequest);
2400b328:	68fb      	ldr	r3, [r7, #12]
2400b32a:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400b32c:	b2da      	uxtb	r2, r3
2400b32e:	8979      	ldrh	r1, [r7, #10]
2400b330:	69bb      	ldr	r3, [r7, #24]
2400b332:	9300      	str	r3, [sp, #0]
2400b334:	69fb      	ldr	r3, [r7, #28]
2400b336:	68f8      	ldr	r0, [r7, #12]
2400b338:	f002 fd00 	bl	2400dd3c <I2C_TransferConfig>

        /* Update XferCount value */
        hi2c->XferCount -= hi2c->XferSize;
2400b33c:	68fb      	ldr	r3, [r7, #12]
2400b33e:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400b340:	b29a      	uxth	r2, r3
2400b342:	68fb      	ldr	r3, [r7, #12]
2400b344:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400b346:	1ad3      	subs	r3, r2, r3
2400b348:	b29a      	uxth	r2, r3
2400b34a:	68fb      	ldr	r3, [r7, #12]
2400b34c:	855a      	strh	r2, [r3, #42]	; 0x2a

        /* Process Unlocked */
        __HAL_UNLOCK(hi2c);
2400b34e:	68fb      	ldr	r3, [r7, #12]
2400b350:	2200      	movs	r2, #0
2400b352:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

        /* Note : The I2C interrupts must be enabled after unlocking current process
                  to avoid the risk of I2C interrupt handle execution before current
                  process unlock */
        /* Enable ERR and NACK interrupts */
        I2C_Enable_IRQ(hi2c, I2C_XFER_ERROR_IT);
2400b356:	2110      	movs	r1, #16
2400b358:	68f8      	ldr	r0, [r7, #12]
2400b35a:	f002 fd1d 	bl	2400dd98 <I2C_Enable_IRQ>

        /* Enable DMA Request */
        hi2c->Instance->CR1 |= I2C_CR1_RXDMAEN;
2400b35e:	68fb      	ldr	r3, [r7, #12]
2400b360:	681b      	ldr	r3, [r3, #0]
2400b362:	681a      	ldr	r2, [r3, #0]
2400b364:	68fb      	ldr	r3, [r7, #12]
2400b366:	681b      	ldr	r3, [r3, #0]
2400b368:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
2400b36c:	601a      	str	r2, [r3, #0]
2400b36e:	e029      	b.n	2400b3c4 <HAL_I2C_Master_Seq_Receive_DMA+0x1e4>
      }
      else
      {
        /* Update I2C state */
        hi2c->State     = HAL_I2C_STATE_READY;
2400b370:	68fb      	ldr	r3, [r7, #12]
2400b372:	2220      	movs	r2, #32
2400b374:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
        hi2c->Mode      = HAL_I2C_MODE_NONE;
2400b378:	68fb      	ldr	r3, [r7, #12]
2400b37a:	2200      	movs	r2, #0
2400b37c:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

        /* Update I2C error code */
        hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
2400b380:	68fb      	ldr	r3, [r7, #12]
2400b382:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400b384:	f043 0210 	orr.w	r2, r3, #16
2400b388:	68fb      	ldr	r3, [r7, #12]
2400b38a:	645a      	str	r2, [r3, #68]	; 0x44

        /* Process Unlocked */
        __HAL_UNLOCK(hi2c);
2400b38c:	68fb      	ldr	r3, [r7, #12]
2400b38e:	2200      	movs	r2, #0
2400b390:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

        return HAL_ERROR;
2400b394:	2301      	movs	r3, #1
2400b396:	e018      	b.n	2400b3ca <HAL_I2C_Master_Seq_Receive_DMA+0x1ea>
      }
    }
    else
    {
      /* Update Transfer ISR function pointer */
      hi2c->XferISR = I2C_Master_ISR_IT;
2400b398:	68fb      	ldr	r3, [r7, #12]
2400b39a:	4a12      	ldr	r2, [pc, #72]	; (2400b3e4 <HAL_I2C_Master_Seq_Receive_DMA+0x204>)
2400b39c:	635a      	str	r2, [r3, #52]	; 0x34

      /* Send Slave Address */
      /* Set NBYTES to read and generate START condition */
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_GENERATE_START_READ);
2400b39e:	68fb      	ldr	r3, [r7, #12]
2400b3a0:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400b3a2:	b2da      	uxtb	r2, r3
2400b3a4:	8979      	ldrh	r1, [r7, #10]
2400b3a6:	4b0b      	ldr	r3, [pc, #44]	; (2400b3d4 <HAL_I2C_Master_Seq_Receive_DMA+0x1f4>)
2400b3a8:	9300      	str	r3, [sp, #0]
2400b3aa:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
2400b3ae:	68f8      	ldr	r0, [r7, #12]
2400b3b0:	f002 fcc4 	bl	2400dd3c <I2C_TransferConfig>

      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
2400b3b4:	68fb      	ldr	r3, [r7, #12]
2400b3b6:	2200      	movs	r2, #0
2400b3b8:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
                to avoid the risk of I2C interrupt handle execution before current
                process unlock */
      /* Enable ERR, TC, STOP, NACK, TXI interrupt */
      /* possible to enable all of these */
      /* I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */
      I2C_Enable_IRQ(hi2c, I2C_XFER_TX_IT);
2400b3bc:	2101      	movs	r1, #1
2400b3be:	68f8      	ldr	r0, [r7, #12]
2400b3c0:	f002 fcea 	bl	2400dd98 <I2C_Enable_IRQ>
    }

    return HAL_OK;
2400b3c4:	2300      	movs	r3, #0
2400b3c6:	e000      	b.n	2400b3ca <HAL_I2C_Master_Seq_Receive_DMA+0x1ea>
  }
  else
  {
    return HAL_BUSY;
2400b3c8:	2302      	movs	r3, #2
  }
}
2400b3ca:	4618      	mov	r0, r3
2400b3cc:	3720      	adds	r7, #32
2400b3ce:	46bd      	mov	sp, r7
2400b3d0:	bd80      	pop	{r7, pc}
2400b3d2:	bf00      	nop
2400b3d4:	80002400 	.word	0x80002400
2400b3d8:	2400c30b 	.word	0x2400c30b
2400b3dc:	2400d579 	.word	0x2400d579
2400b3e0:	2400d775 	.word	0x2400d775
2400b3e4:	2400beb3 	.word	0x2400beb3

2400b3e8 <HAL_I2C_Slave_Seq_Transmit_IT>:
  * @param  Size Amount of data to be sent
  * @param  XferOptions Options of Transfer, value of @ref I2C_XFEROPTIONS
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Slave_Seq_Transmit_IT(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size, uint32_t XferOptions)
{
2400b3e8:	b580      	push	{r7, lr}
2400b3ea:	b084      	sub	sp, #16
2400b3ec:	af00      	add	r7, sp, #0
2400b3ee:	60f8      	str	r0, [r7, #12]
2400b3f0:	60b9      	str	r1, [r7, #8]
2400b3f2:	603b      	str	r3, [r7, #0]
2400b3f4:	4613      	mov	r3, r2
2400b3f6:	80fb      	strh	r3, [r7, #6]
  /* Check the parameters */
  assert_param(IS_I2C_TRANSFER_OPTIONS_REQUEST(XferOptions));

  if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) == (uint32_t)HAL_I2C_STATE_LISTEN)
2400b3f8:	68fb      	ldr	r3, [r7, #12]
2400b3fa:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400b3fe:	b2db      	uxtb	r3, r3
2400b400:	f003 0328 	and.w	r3, r3, #40	; 0x28
2400b404:	2b28      	cmp	r3, #40	; 0x28
2400b406:	f040 808a 	bne.w	2400b51e <HAL_I2C_Slave_Seq_Transmit_IT+0x136>
  {
    if ((pData == NULL) || (Size == 0U))
2400b40a:	68bb      	ldr	r3, [r7, #8]
2400b40c:	2b00      	cmp	r3, #0
2400b40e:	d002      	beq.n	2400b416 <HAL_I2C_Slave_Seq_Transmit_IT+0x2e>
2400b410:	88fb      	ldrh	r3, [r7, #6]
2400b412:	2b00      	cmp	r3, #0
2400b414:	d105      	bne.n	2400b422 <HAL_I2C_Slave_Seq_Transmit_IT+0x3a>
    {
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
2400b416:	68fb      	ldr	r3, [r7, #12]
2400b418:	f44f 7200 	mov.w	r2, #512	; 0x200
2400b41c:	645a      	str	r2, [r3, #68]	; 0x44
      return  HAL_ERROR;
2400b41e:	2301      	movs	r3, #1
2400b420:	e07e      	b.n	2400b520 <HAL_I2C_Slave_Seq_Transmit_IT+0x138>
    }

    /* Disable Interrupts, to prevent preemption during treatment in case of multicall */
    I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT | I2C_XFER_TX_IT);
2400b422:	f248 0101 	movw	r1, #32769	; 0x8001
2400b426:	68f8      	ldr	r0, [r7, #12]
2400b428:	f002 fd1a 	bl	2400de60 <I2C_Disable_IRQ>

    /* Process Locked */
    __HAL_LOCK(hi2c);
2400b42c:	68fb      	ldr	r3, [r7, #12]
2400b42e:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2400b432:	2b01      	cmp	r3, #1
2400b434:	d101      	bne.n	2400b43a <HAL_I2C_Slave_Seq_Transmit_IT+0x52>
2400b436:	2302      	movs	r3, #2
2400b438:	e072      	b.n	2400b520 <HAL_I2C_Slave_Seq_Transmit_IT+0x138>
2400b43a:	68fb      	ldr	r3, [r7, #12]
2400b43c:	2201      	movs	r2, #1
2400b43e:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* I2C cannot manage full duplex exchange so disable previous IT enabled if any */
    /* and then toggle the HAL slave RX state to TX state */
    if (hi2c->State == HAL_I2C_STATE_BUSY_RX_LISTEN)
2400b442:	68fb      	ldr	r3, [r7, #12]
2400b444:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400b448:	b2db      	uxtb	r3, r3
2400b44a:	2b2a      	cmp	r3, #42	; 0x2a
2400b44c:	d12a      	bne.n	2400b4a4 <HAL_I2C_Slave_Seq_Transmit_IT+0xbc>
    {
      /* Disable associated Interrupts */
      I2C_Disable_IRQ(hi2c, I2C_XFER_RX_IT);
2400b44e:	2102      	movs	r1, #2
2400b450:	68f8      	ldr	r0, [r7, #12]
2400b452:	f002 fd05 	bl	2400de60 <I2C_Disable_IRQ>

      /* Abort DMA Xfer if any */
      if ((hi2c->Instance->CR1 & I2C_CR1_RXDMAEN) == I2C_CR1_RXDMAEN)
2400b456:	68fb      	ldr	r3, [r7, #12]
2400b458:	681b      	ldr	r3, [r3, #0]
2400b45a:	681b      	ldr	r3, [r3, #0]
2400b45c:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
2400b460:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
2400b464:	d11e      	bne.n	2400b4a4 <HAL_I2C_Slave_Seq_Transmit_IT+0xbc>
      {
        hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN;
2400b466:	68fb      	ldr	r3, [r7, #12]
2400b468:	681b      	ldr	r3, [r3, #0]
2400b46a:	681a      	ldr	r2, [r3, #0]
2400b46c:	68fb      	ldr	r3, [r7, #12]
2400b46e:	681b      	ldr	r3, [r3, #0]
2400b470:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
2400b474:	601a      	str	r2, [r3, #0]

        if (hi2c->hdmarx != NULL)
2400b476:	68fb      	ldr	r3, [r7, #12]
2400b478:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400b47a:	2b00      	cmp	r3, #0
2400b47c:	d012      	beq.n	2400b4a4 <HAL_I2C_Slave_Seq_Transmit_IT+0xbc>
        {
          /* Set the I2C DMA Abort callback :
           will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */
          hi2c->hdmarx->XferAbortCallback = I2C_DMAAbort;
2400b47e:	68fb      	ldr	r3, [r7, #12]
2400b480:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400b482:	4a29      	ldr	r2, [pc, #164]	; (2400b528 <HAL_I2C_Slave_Seq_Transmit_IT+0x140>)
2400b484:	651a      	str	r2, [r3, #80]	; 0x50

          /* Abort DMA RX */
          if (HAL_DMA_Abort_IT(hi2c->hdmarx) != HAL_OK)
2400b486:	68fb      	ldr	r3, [r7, #12]
2400b488:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400b48a:	4618      	mov	r0, r3
2400b48c:	f7f7 fde8 	bl	24003060 <HAL_DMA_Abort_IT>
2400b490:	4603      	mov	r3, r0
2400b492:	2b00      	cmp	r3, #0
2400b494:	d006      	beq.n	2400b4a4 <HAL_I2C_Slave_Seq_Transmit_IT+0xbc>
          {
            /* Call Directly XferAbortCallback function in case of error */
            hi2c->hdmarx->XferAbortCallback(hi2c->hdmarx);
2400b496:	68fb      	ldr	r3, [r7, #12]
2400b498:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400b49a:	6d1b      	ldr	r3, [r3, #80]	; 0x50
2400b49c:	68fa      	ldr	r2, [r7, #12]
2400b49e:	6bd2      	ldr	r2, [r2, #60]	; 0x3c
2400b4a0:	4610      	mov	r0, r2
2400b4a2:	4798      	blx	r3
          }
        }
      }
    }

    hi2c->State     = HAL_I2C_STATE_BUSY_TX_LISTEN;
2400b4a4:	68fb      	ldr	r3, [r7, #12]
2400b4a6:	2229      	movs	r2, #41	; 0x29
2400b4a8:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode      = HAL_I2C_MODE_SLAVE;
2400b4ac:	68fb      	ldr	r3, [r7, #12]
2400b4ae:	2220      	movs	r2, #32
2400b4b0:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
2400b4b4:	68fb      	ldr	r3, [r7, #12]
2400b4b6:	2200      	movs	r2, #0
2400b4b8:	645a      	str	r2, [r3, #68]	; 0x44

    /* Enable Address Acknowledge */
    hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
2400b4ba:	68fb      	ldr	r3, [r7, #12]
2400b4bc:	681b      	ldr	r3, [r3, #0]
2400b4be:	685a      	ldr	r2, [r3, #4]
2400b4c0:	68fb      	ldr	r3, [r7, #12]
2400b4c2:	681b      	ldr	r3, [r3, #0]
2400b4c4:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
2400b4c8:	605a      	str	r2, [r3, #4]

    /* Prepare transfer parameters */
    hi2c->pBuffPtr    = pData;
2400b4ca:	68fb      	ldr	r3, [r7, #12]
2400b4cc:	68ba      	ldr	r2, [r7, #8]
2400b4ce:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount   = Size;
2400b4d0:	68fb      	ldr	r3, [r7, #12]
2400b4d2:	88fa      	ldrh	r2, [r7, #6]
2400b4d4:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferSize    = hi2c->XferCount;
2400b4d6:	68fb      	ldr	r3, [r7, #12]
2400b4d8:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400b4da:	b29a      	uxth	r2, r3
2400b4dc:	68fb      	ldr	r3, [r7, #12]
2400b4de:	851a      	strh	r2, [r3, #40]	; 0x28
    hi2c->XferOptions = XferOptions;
2400b4e0:	68fb      	ldr	r3, [r7, #12]
2400b4e2:	683a      	ldr	r2, [r7, #0]
2400b4e4:	62da      	str	r2, [r3, #44]	; 0x2c
    hi2c->XferISR     = I2C_Slave_ISR_IT;
2400b4e6:	68fb      	ldr	r3, [r7, #12]
2400b4e8:	4a10      	ldr	r2, [pc, #64]	; (2400b52c <HAL_I2C_Slave_Seq_Transmit_IT+0x144>)
2400b4ea:	635a      	str	r2, [r3, #52]	; 0x34

    if (I2C_GET_DIR(hi2c) == I2C_DIRECTION_RECEIVE)
2400b4ec:	68fb      	ldr	r3, [r7, #12]
2400b4ee:	681b      	ldr	r3, [r3, #0]
2400b4f0:	699b      	ldr	r3, [r3, #24]
2400b4f2:	0c1b      	lsrs	r3, r3, #16
2400b4f4:	b2db      	uxtb	r3, r3
2400b4f6:	f003 0301 	and.w	r3, r3, #1
2400b4fa:	b2db      	uxtb	r3, r3
2400b4fc:	2b01      	cmp	r3, #1
2400b4fe:	d103      	bne.n	2400b508 <HAL_I2C_Slave_Seq_Transmit_IT+0x120>
    {
      /* Clear ADDR flag after prepare the transfer parameters */
      /* This action will generate an acknowledge to the Master */
      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
2400b500:	68fb      	ldr	r3, [r7, #12]
2400b502:	681b      	ldr	r3, [r3, #0]
2400b504:	2208      	movs	r2, #8
2400b506:	61da      	str	r2, [r3, #28]
    }

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
2400b508:	68fb      	ldr	r3, [r7, #12]
2400b50a:	2200      	movs	r2, #0
2400b50c:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Note : The I2C interrupts must be enabled after unlocking current process
    to avoid the risk of I2C interrupt handle execution before current
    process unlock */
    /* REnable ADDR interrupt */
    I2C_Enable_IRQ(hi2c, I2C_XFER_TX_IT | I2C_XFER_LISTEN_IT);
2400b510:	f248 0101 	movw	r1, #32769	; 0x8001
2400b514:	68f8      	ldr	r0, [r7, #12]
2400b516:	f002 fc3f 	bl	2400dd98 <I2C_Enable_IRQ>

    return HAL_OK;
2400b51a:	2300      	movs	r3, #0
2400b51c:	e000      	b.n	2400b520 <HAL_I2C_Slave_Seq_Transmit_IT+0x138>
  }
  else
  {
    return HAL_ERROR;
2400b51e:	2301      	movs	r3, #1
  }
}
2400b520:	4618      	mov	r0, r3
2400b522:	3710      	adds	r7, #16
2400b524:	46bd      	mov	sp, r7
2400b526:	bd80      	pop	{r7, pc}
2400b528:	2400d9e5 	.word	0x2400d9e5
2400b52c:	2400c105 	.word	0x2400c105

2400b530 <HAL_I2C_Slave_Seq_Transmit_DMA>:
  * @param  Size Amount of data to be sent
  * @param  XferOptions Options of Transfer, value of @ref I2C_XFEROPTIONS
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Slave_Seq_Transmit_DMA(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size, uint32_t XferOptions)
{
2400b530:	b580      	push	{r7, lr}
2400b532:	b086      	sub	sp, #24
2400b534:	af00      	add	r7, sp, #0
2400b536:	60f8      	str	r0, [r7, #12]
2400b538:	60b9      	str	r1, [r7, #8]
2400b53a:	603b      	str	r3, [r7, #0]
2400b53c:	4613      	mov	r3, r2
2400b53e:	80fb      	strh	r3, [r7, #6]
  HAL_StatusTypeDef dmaxferstatus;

  /* Check the parameters */
  assert_param(IS_I2C_TRANSFER_OPTIONS_REQUEST(XferOptions));

  if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) == (uint32_t)HAL_I2C_STATE_LISTEN)
2400b540:	68fb      	ldr	r3, [r7, #12]
2400b542:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400b546:	b2db      	uxtb	r3, r3
2400b548:	f003 0328 	and.w	r3, r3, #40	; 0x28
2400b54c:	2b28      	cmp	r3, #40	; 0x28
2400b54e:	f040 811a 	bne.w	2400b786 <HAL_I2C_Slave_Seq_Transmit_DMA+0x256>
  {
    if ((pData == NULL) || (Size == 0U))
2400b552:	68bb      	ldr	r3, [r7, #8]
2400b554:	2b00      	cmp	r3, #0
2400b556:	d002      	beq.n	2400b55e <HAL_I2C_Slave_Seq_Transmit_DMA+0x2e>
2400b558:	88fb      	ldrh	r3, [r7, #6]
2400b55a:	2b00      	cmp	r3, #0
2400b55c:	d105      	bne.n	2400b56a <HAL_I2C_Slave_Seq_Transmit_DMA+0x3a>
    {
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
2400b55e:	68fb      	ldr	r3, [r7, #12]
2400b560:	f44f 7200 	mov.w	r2, #512	; 0x200
2400b564:	645a      	str	r2, [r3, #68]	; 0x44
      return  HAL_ERROR;
2400b566:	2301      	movs	r3, #1
2400b568:	e10e      	b.n	2400b788 <HAL_I2C_Slave_Seq_Transmit_DMA+0x258>
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
2400b56a:	68fb      	ldr	r3, [r7, #12]
2400b56c:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2400b570:	2b01      	cmp	r3, #1
2400b572:	d101      	bne.n	2400b578 <HAL_I2C_Slave_Seq_Transmit_DMA+0x48>
2400b574:	2302      	movs	r3, #2
2400b576:	e107      	b.n	2400b788 <HAL_I2C_Slave_Seq_Transmit_DMA+0x258>
2400b578:	68fb      	ldr	r3, [r7, #12]
2400b57a:	2201      	movs	r2, #1
2400b57c:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Disable Interrupts, to prevent preemption during treatment in case of multicall */
    I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT | I2C_XFER_TX_IT);
2400b580:	f248 0101 	movw	r1, #32769	; 0x8001
2400b584:	68f8      	ldr	r0, [r7, #12]
2400b586:	f002 fc6b 	bl	2400de60 <I2C_Disable_IRQ>

    /* I2C cannot manage full duplex exchange so disable previous IT enabled if any */
    /* and then toggle the HAL slave RX state to TX state */
    if (hi2c->State == HAL_I2C_STATE_BUSY_RX_LISTEN)
2400b58a:	68fb      	ldr	r3, [r7, #12]
2400b58c:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400b590:	b2db      	uxtb	r3, r3
2400b592:	2b2a      	cmp	r3, #42	; 0x2a
2400b594:	d12b      	bne.n	2400b5ee <HAL_I2C_Slave_Seq_Transmit_DMA+0xbe>
    {
      /* Disable associated Interrupts */
      I2C_Disable_IRQ(hi2c, I2C_XFER_RX_IT);
2400b596:	2102      	movs	r1, #2
2400b598:	68f8      	ldr	r0, [r7, #12]
2400b59a:	f002 fc61 	bl	2400de60 <I2C_Disable_IRQ>

      if ((hi2c->Instance->CR1 & I2C_CR1_RXDMAEN) == I2C_CR1_RXDMAEN)
2400b59e:	68fb      	ldr	r3, [r7, #12]
2400b5a0:	681b      	ldr	r3, [r3, #0]
2400b5a2:	681b      	ldr	r3, [r3, #0]
2400b5a4:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
2400b5a8:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
2400b5ac:	d14c      	bne.n	2400b648 <HAL_I2C_Slave_Seq_Transmit_DMA+0x118>
      {
        /* Abort DMA Xfer if any */
        if (hi2c->hdmarx != NULL)
2400b5ae:	68fb      	ldr	r3, [r7, #12]
2400b5b0:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400b5b2:	2b00      	cmp	r3, #0
2400b5b4:	d048      	beq.n	2400b648 <HAL_I2C_Slave_Seq_Transmit_DMA+0x118>
        {
          hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN;
2400b5b6:	68fb      	ldr	r3, [r7, #12]
2400b5b8:	681b      	ldr	r3, [r3, #0]
2400b5ba:	681a      	ldr	r2, [r3, #0]
2400b5bc:	68fb      	ldr	r3, [r7, #12]
2400b5be:	681b      	ldr	r3, [r3, #0]
2400b5c0:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
2400b5c4:	601a      	str	r2, [r3, #0]

          /* Set the I2C DMA Abort callback :
           will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */
          hi2c->hdmarx->XferAbortCallback = I2C_DMAAbort;
2400b5c6:	68fb      	ldr	r3, [r7, #12]
2400b5c8:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400b5ca:	4a71      	ldr	r2, [pc, #452]	; (2400b790 <HAL_I2C_Slave_Seq_Transmit_DMA+0x260>)
2400b5cc:	651a      	str	r2, [r3, #80]	; 0x50

          /* Abort DMA RX */
          if (HAL_DMA_Abort_IT(hi2c->hdmarx) != HAL_OK)
2400b5ce:	68fb      	ldr	r3, [r7, #12]
2400b5d0:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400b5d2:	4618      	mov	r0, r3
2400b5d4:	f7f7 fd44 	bl	24003060 <HAL_DMA_Abort_IT>
2400b5d8:	4603      	mov	r3, r0
2400b5da:	2b00      	cmp	r3, #0
2400b5dc:	d034      	beq.n	2400b648 <HAL_I2C_Slave_Seq_Transmit_DMA+0x118>
          {
            /* Call Directly XferAbortCallback function in case of error */
            hi2c->hdmarx->XferAbortCallback(hi2c->hdmarx);
2400b5de:	68fb      	ldr	r3, [r7, #12]
2400b5e0:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400b5e2:	6d1b      	ldr	r3, [r3, #80]	; 0x50
2400b5e4:	68fa      	ldr	r2, [r7, #12]
2400b5e6:	6bd2      	ldr	r2, [r2, #60]	; 0x3c
2400b5e8:	4610      	mov	r0, r2
2400b5ea:	4798      	blx	r3
2400b5ec:	e02c      	b.n	2400b648 <HAL_I2C_Slave_Seq_Transmit_DMA+0x118>
          }
        }
      }
    }
    else if (hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN)
2400b5ee:	68fb      	ldr	r3, [r7, #12]
2400b5f0:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400b5f4:	b2db      	uxtb	r3, r3
2400b5f6:	2b29      	cmp	r3, #41	; 0x29
2400b5f8:	d126      	bne.n	2400b648 <HAL_I2C_Slave_Seq_Transmit_DMA+0x118>
    {
      if ((hi2c->Instance->CR1 & I2C_CR1_TXDMAEN) == I2C_CR1_TXDMAEN)
2400b5fa:	68fb      	ldr	r3, [r7, #12]
2400b5fc:	681b      	ldr	r3, [r3, #0]
2400b5fe:	681b      	ldr	r3, [r3, #0]
2400b600:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
2400b604:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
2400b608:	d11e      	bne.n	2400b648 <HAL_I2C_Slave_Seq_Transmit_DMA+0x118>
      {
        hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;
2400b60a:	68fb      	ldr	r3, [r7, #12]
2400b60c:	681b      	ldr	r3, [r3, #0]
2400b60e:	681a      	ldr	r2, [r3, #0]
2400b610:	68fb      	ldr	r3, [r7, #12]
2400b612:	681b      	ldr	r3, [r3, #0]
2400b614:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
2400b618:	601a      	str	r2, [r3, #0]

        /* Abort DMA Xfer if any */
        if (hi2c->hdmatx != NULL)
2400b61a:	68fb      	ldr	r3, [r7, #12]
2400b61c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400b61e:	2b00      	cmp	r3, #0
2400b620:	d012      	beq.n	2400b648 <HAL_I2C_Slave_Seq_Transmit_DMA+0x118>
        {
          /* Set the I2C DMA Abort callback :
           will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */
          hi2c->hdmatx->XferAbortCallback = I2C_DMAAbort;
2400b622:	68fb      	ldr	r3, [r7, #12]
2400b624:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400b626:	4a5a      	ldr	r2, [pc, #360]	; (2400b790 <HAL_I2C_Slave_Seq_Transmit_DMA+0x260>)
2400b628:	651a      	str	r2, [r3, #80]	; 0x50

          /* Abort DMA TX */
          if (HAL_DMA_Abort_IT(hi2c->hdmatx) != HAL_OK)
2400b62a:	68fb      	ldr	r3, [r7, #12]
2400b62c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400b62e:	4618      	mov	r0, r3
2400b630:	f7f7 fd16 	bl	24003060 <HAL_DMA_Abort_IT>
2400b634:	4603      	mov	r3, r0
2400b636:	2b00      	cmp	r3, #0
2400b638:	d006      	beq.n	2400b648 <HAL_I2C_Slave_Seq_Transmit_DMA+0x118>
          {
            /* Call Directly XferAbortCallback function in case of error */
            hi2c->hdmatx->XferAbortCallback(hi2c->hdmatx);
2400b63a:	68fb      	ldr	r3, [r7, #12]
2400b63c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400b63e:	6d1b      	ldr	r3, [r3, #80]	; 0x50
2400b640:	68fa      	ldr	r2, [r7, #12]
2400b642:	6b92      	ldr	r2, [r2, #56]	; 0x38
2400b644:	4610      	mov	r0, r2
2400b646:	4798      	blx	r3
    else
    {
      /* Nothing to do */
    }

    hi2c->State     = HAL_I2C_STATE_BUSY_TX_LISTEN;
2400b648:	68fb      	ldr	r3, [r7, #12]
2400b64a:	2229      	movs	r2, #41	; 0x29
2400b64c:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode      = HAL_I2C_MODE_SLAVE;
2400b650:	68fb      	ldr	r3, [r7, #12]
2400b652:	2220      	movs	r2, #32
2400b654:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
2400b658:	68fb      	ldr	r3, [r7, #12]
2400b65a:	2200      	movs	r2, #0
2400b65c:	645a      	str	r2, [r3, #68]	; 0x44

    /* Enable Address Acknowledge */
    hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
2400b65e:	68fb      	ldr	r3, [r7, #12]
2400b660:	681b      	ldr	r3, [r3, #0]
2400b662:	685a      	ldr	r2, [r3, #4]
2400b664:	68fb      	ldr	r3, [r7, #12]
2400b666:	681b      	ldr	r3, [r3, #0]
2400b668:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
2400b66c:	605a      	str	r2, [r3, #4]

    /* Prepare transfer parameters */
    hi2c->pBuffPtr    = pData;
2400b66e:	68fb      	ldr	r3, [r7, #12]
2400b670:	68ba      	ldr	r2, [r7, #8]
2400b672:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount   = Size;
2400b674:	68fb      	ldr	r3, [r7, #12]
2400b676:	88fa      	ldrh	r2, [r7, #6]
2400b678:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferSize    = hi2c->XferCount;
2400b67a:	68fb      	ldr	r3, [r7, #12]
2400b67c:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400b67e:	b29a      	uxth	r2, r3
2400b680:	68fb      	ldr	r3, [r7, #12]
2400b682:	851a      	strh	r2, [r3, #40]	; 0x28
    hi2c->XferOptions = XferOptions;
2400b684:	68fb      	ldr	r3, [r7, #12]
2400b686:	683a      	ldr	r2, [r7, #0]
2400b688:	62da      	str	r2, [r3, #44]	; 0x2c
    hi2c->XferISR     = I2C_Slave_ISR_DMA;
2400b68a:	68fb      	ldr	r3, [r7, #12]
2400b68c:	4a41      	ldr	r2, [pc, #260]	; (2400b794 <HAL_I2C_Slave_Seq_Transmit_DMA+0x264>)
2400b68e:	635a      	str	r2, [r3, #52]	; 0x34

    if (hi2c->hdmatx != NULL)
2400b690:	68fb      	ldr	r3, [r7, #12]
2400b692:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400b694:	2b00      	cmp	r3, #0
2400b696:	d020      	beq.n	2400b6da <HAL_I2C_Slave_Seq_Transmit_DMA+0x1aa>
    {
      /* Set the I2C DMA transfer complete callback */
      hi2c->hdmatx->XferCpltCallback = I2C_DMASlaveTransmitCplt;
2400b698:	68fb      	ldr	r3, [r7, #12]
2400b69a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400b69c:	4a3e      	ldr	r2, [pc, #248]	; (2400b798 <HAL_I2C_Slave_Seq_Transmit_DMA+0x268>)
2400b69e:	63da      	str	r2, [r3, #60]	; 0x3c

      /* Set the DMA error callback */
      hi2c->hdmatx->XferErrorCallback = I2C_DMAError;
2400b6a0:	68fb      	ldr	r3, [r7, #12]
2400b6a2:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400b6a4:	4a3d      	ldr	r2, [pc, #244]	; (2400b79c <HAL_I2C_Slave_Seq_Transmit_DMA+0x26c>)
2400b6a6:	64da      	str	r2, [r3, #76]	; 0x4c

      /* Set the unused DMA callbacks to NULL */
      hi2c->hdmatx->XferHalfCpltCallback = NULL;
2400b6a8:	68fb      	ldr	r3, [r7, #12]
2400b6aa:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400b6ac:	2200      	movs	r2, #0
2400b6ae:	641a      	str	r2, [r3, #64]	; 0x40
      hi2c->hdmatx->XferAbortCallback = NULL;
2400b6b0:	68fb      	ldr	r3, [r7, #12]
2400b6b2:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400b6b4:	2200      	movs	r2, #0
2400b6b6:	651a      	str	r2, [r3, #80]	; 0x50

      /* Enable the DMA stream or channel depends on Instance */
      dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)pData, (uint32_t)&hi2c->Instance->TXDR, hi2c->XferSize);
2400b6b8:	68fb      	ldr	r3, [r7, #12]
2400b6ba:	6b98      	ldr	r0, [r3, #56]	; 0x38
2400b6bc:	68b9      	ldr	r1, [r7, #8]
2400b6be:	68fb      	ldr	r3, [r7, #12]
2400b6c0:	681b      	ldr	r3, [r3, #0]
2400b6c2:	3328      	adds	r3, #40	; 0x28
2400b6c4:	461a      	mov	r2, r3
2400b6c6:	68fb      	ldr	r3, [r7, #12]
2400b6c8:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400b6ca:	f7f6 ff41 	bl	24002550 <HAL_DMA_Start_IT>
2400b6ce:	4603      	mov	r3, r0
2400b6d0:	75fb      	strb	r3, [r7, #23]
      __HAL_UNLOCK(hi2c);

      return HAL_ERROR;
    }

    if (dmaxferstatus == HAL_OK)
2400b6d2:	7dfb      	ldrb	r3, [r7, #23]
2400b6d4:	2b00      	cmp	r3, #0
2400b6d6:	d12b      	bne.n	2400b730 <HAL_I2C_Slave_Seq_Transmit_DMA+0x200>
2400b6d8:	e013      	b.n	2400b702 <HAL_I2C_Slave_Seq_Transmit_DMA+0x1d2>
      hi2c->State     = HAL_I2C_STATE_LISTEN;
2400b6da:	68fb      	ldr	r3, [r7, #12]
2400b6dc:	2228      	movs	r2, #40	; 0x28
2400b6de:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
      hi2c->Mode      = HAL_I2C_MODE_NONE;
2400b6e2:	68fb      	ldr	r3, [r7, #12]
2400b6e4:	2200      	movs	r2, #0
2400b6e6:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
      hi2c->ErrorCode |= HAL_I2C_ERROR_DMA_PARAM;
2400b6ea:	68fb      	ldr	r3, [r7, #12]
2400b6ec:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400b6ee:	f043 0280 	orr.w	r2, r3, #128	; 0x80
2400b6f2:	68fb      	ldr	r3, [r7, #12]
2400b6f4:	645a      	str	r2, [r3, #68]	; 0x44
      __HAL_UNLOCK(hi2c);
2400b6f6:	68fb      	ldr	r3, [r7, #12]
2400b6f8:	2200      	movs	r2, #0
2400b6fa:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      return HAL_ERROR;
2400b6fe:	2301      	movs	r3, #1
2400b700:	e042      	b.n	2400b788 <HAL_I2C_Slave_Seq_Transmit_DMA+0x258>
    {
      /* Update XferCount value */
      hi2c->XferCount -= hi2c->XferSize;
2400b702:	68fb      	ldr	r3, [r7, #12]
2400b704:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400b706:	b29a      	uxth	r2, r3
2400b708:	68fb      	ldr	r3, [r7, #12]
2400b70a:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400b70c:	1ad3      	subs	r3, r2, r3
2400b70e:	b29a      	uxth	r2, r3
2400b710:	68fb      	ldr	r3, [r7, #12]
2400b712:	855a      	strh	r2, [r3, #42]	; 0x2a

      /* Reset XferSize */
      hi2c->XferSize = 0;
2400b714:	68fb      	ldr	r3, [r7, #12]
2400b716:	2200      	movs	r2, #0
2400b718:	851a      	strh	r2, [r3, #40]	; 0x28
      __HAL_UNLOCK(hi2c);

      return HAL_ERROR;
    }

    if (I2C_GET_DIR(hi2c) == I2C_DIRECTION_RECEIVE)
2400b71a:	68fb      	ldr	r3, [r7, #12]
2400b71c:	681b      	ldr	r3, [r3, #0]
2400b71e:	699b      	ldr	r3, [r3, #24]
2400b720:	0c1b      	lsrs	r3, r3, #16
2400b722:	b2db      	uxtb	r3, r3
2400b724:	f003 0301 	and.w	r3, r3, #1
2400b728:	b2db      	uxtb	r3, r3
2400b72a:	2b01      	cmp	r3, #1
2400b72c:	d118      	bne.n	2400b760 <HAL_I2C_Slave_Seq_Transmit_DMA+0x230>
2400b72e:	e013      	b.n	2400b758 <HAL_I2C_Slave_Seq_Transmit_DMA+0x228>
      hi2c->State     = HAL_I2C_STATE_LISTEN;
2400b730:	68fb      	ldr	r3, [r7, #12]
2400b732:	2228      	movs	r2, #40	; 0x28
2400b734:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
      hi2c->Mode      = HAL_I2C_MODE_NONE;
2400b738:	68fb      	ldr	r3, [r7, #12]
2400b73a:	2200      	movs	r2, #0
2400b73c:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
      hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
2400b740:	68fb      	ldr	r3, [r7, #12]
2400b742:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400b744:	f043 0210 	orr.w	r2, r3, #16
2400b748:	68fb      	ldr	r3, [r7, #12]
2400b74a:	645a      	str	r2, [r3, #68]	; 0x44
      __HAL_UNLOCK(hi2c);
2400b74c:	68fb      	ldr	r3, [r7, #12]
2400b74e:	2200      	movs	r2, #0
2400b750:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      return HAL_ERROR;
2400b754:	2301      	movs	r3, #1
2400b756:	e017      	b.n	2400b788 <HAL_I2C_Slave_Seq_Transmit_DMA+0x258>
    {
      /* Clear ADDR flag after prepare the transfer parameters */
      /* This action will generate an acknowledge to the Master */
      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
2400b758:	68fb      	ldr	r3, [r7, #12]
2400b75a:	681b      	ldr	r3, [r3, #0]
2400b75c:	2208      	movs	r2, #8
2400b75e:	61da      	str	r2, [r3, #28]
    }

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
2400b760:	68fb      	ldr	r3, [r7, #12]
2400b762:	2200      	movs	r2, #0
2400b764:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Note : The I2C interrupts must be enabled after unlocking current process
    to avoid the risk of I2C interrupt handle execution before current
    process unlock */
    /* Enable ERR, STOP, NACK, ADDR interrupts */
    I2C_Enable_IRQ(hi2c, I2C_XFER_LISTEN_IT);
2400b768:	f44f 4100 	mov.w	r1, #32768	; 0x8000
2400b76c:	68f8      	ldr	r0, [r7, #12]
2400b76e:	f002 fb13 	bl	2400dd98 <I2C_Enable_IRQ>

    /* Enable DMA Request */
    hi2c->Instance->CR1 |= I2C_CR1_TXDMAEN;
2400b772:	68fb      	ldr	r3, [r7, #12]
2400b774:	681b      	ldr	r3, [r3, #0]
2400b776:	681a      	ldr	r2, [r3, #0]
2400b778:	68fb      	ldr	r3, [r7, #12]
2400b77a:	681b      	ldr	r3, [r3, #0]
2400b77c:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
2400b780:	601a      	str	r2, [r3, #0]

    return HAL_OK;
2400b782:	2300      	movs	r3, #0
2400b784:	e000      	b.n	2400b788 <HAL_I2C_Slave_Seq_Transmit_DMA+0x258>
  }
  else
  {
    return HAL_ERROR;
2400b786:	2301      	movs	r3, #1
  }
}
2400b788:	4618      	mov	r0, r3
2400b78a:	3718      	adds	r7, #24
2400b78c:	46bd      	mov	sp, r7
2400b78e:	bd80      	pop	{r7, pc}
2400b790:	2400d9e5 	.word	0x2400d9e5
2400b794:	2400c4f1 	.word	0x2400c4f1
2400b798:	2400d539 	.word	0x2400d539
2400b79c:	2400d775 	.word	0x2400d775

2400b7a0 <HAL_I2C_Slave_Seq_Receive_IT>:
  * @param  Size Amount of data to be sent
  * @param  XferOptions Options of Transfer, value of @ref I2C_XFEROPTIONS
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Slave_Seq_Receive_IT(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size, uint32_t XferOptions)
{
2400b7a0:	b580      	push	{r7, lr}
2400b7a2:	b084      	sub	sp, #16
2400b7a4:	af00      	add	r7, sp, #0
2400b7a6:	60f8      	str	r0, [r7, #12]
2400b7a8:	60b9      	str	r1, [r7, #8]
2400b7aa:	603b      	str	r3, [r7, #0]
2400b7ac:	4613      	mov	r3, r2
2400b7ae:	80fb      	strh	r3, [r7, #6]
  /* Check the parameters */
  assert_param(IS_I2C_TRANSFER_OPTIONS_REQUEST(XferOptions));

  if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) == (uint32_t)HAL_I2C_STATE_LISTEN)
2400b7b0:	68fb      	ldr	r3, [r7, #12]
2400b7b2:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400b7b6:	b2db      	uxtb	r3, r3
2400b7b8:	f003 0328 	and.w	r3, r3, #40	; 0x28
2400b7bc:	2b28      	cmp	r3, #40	; 0x28
2400b7be:	f040 808a 	bne.w	2400b8d6 <HAL_I2C_Slave_Seq_Receive_IT+0x136>
  {
    if ((pData == NULL) || (Size == 0U))
2400b7c2:	68bb      	ldr	r3, [r7, #8]
2400b7c4:	2b00      	cmp	r3, #0
2400b7c6:	d002      	beq.n	2400b7ce <HAL_I2C_Slave_Seq_Receive_IT+0x2e>
2400b7c8:	88fb      	ldrh	r3, [r7, #6]
2400b7ca:	2b00      	cmp	r3, #0
2400b7cc:	d105      	bne.n	2400b7da <HAL_I2C_Slave_Seq_Receive_IT+0x3a>
    {
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
2400b7ce:	68fb      	ldr	r3, [r7, #12]
2400b7d0:	f44f 7200 	mov.w	r2, #512	; 0x200
2400b7d4:	645a      	str	r2, [r3, #68]	; 0x44
      return  HAL_ERROR;
2400b7d6:	2301      	movs	r3, #1
2400b7d8:	e07e      	b.n	2400b8d8 <HAL_I2C_Slave_Seq_Receive_IT+0x138>
    }

    /* Disable Interrupts, to prevent preemption during treatment in case of multicall */
    I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT | I2C_XFER_RX_IT);
2400b7da:	f248 0102 	movw	r1, #32770	; 0x8002
2400b7de:	68f8      	ldr	r0, [r7, #12]
2400b7e0:	f002 fb3e 	bl	2400de60 <I2C_Disable_IRQ>

    /* Process Locked */
    __HAL_LOCK(hi2c);
2400b7e4:	68fb      	ldr	r3, [r7, #12]
2400b7e6:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2400b7ea:	2b01      	cmp	r3, #1
2400b7ec:	d101      	bne.n	2400b7f2 <HAL_I2C_Slave_Seq_Receive_IT+0x52>
2400b7ee:	2302      	movs	r3, #2
2400b7f0:	e072      	b.n	2400b8d8 <HAL_I2C_Slave_Seq_Receive_IT+0x138>
2400b7f2:	68fb      	ldr	r3, [r7, #12]
2400b7f4:	2201      	movs	r2, #1
2400b7f6:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* I2C cannot manage full duplex exchange so disable previous IT enabled if any */
    /* and then toggle the HAL slave TX state to RX state */
    if (hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN)
2400b7fa:	68fb      	ldr	r3, [r7, #12]
2400b7fc:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400b800:	b2db      	uxtb	r3, r3
2400b802:	2b29      	cmp	r3, #41	; 0x29
2400b804:	d12a      	bne.n	2400b85c <HAL_I2C_Slave_Seq_Receive_IT+0xbc>
    {
      /* Disable associated Interrupts */
      I2C_Disable_IRQ(hi2c, I2C_XFER_TX_IT);
2400b806:	2101      	movs	r1, #1
2400b808:	68f8      	ldr	r0, [r7, #12]
2400b80a:	f002 fb29 	bl	2400de60 <I2C_Disable_IRQ>

      if ((hi2c->Instance->CR1 & I2C_CR1_TXDMAEN) == I2C_CR1_TXDMAEN)
2400b80e:	68fb      	ldr	r3, [r7, #12]
2400b810:	681b      	ldr	r3, [r3, #0]
2400b812:	681b      	ldr	r3, [r3, #0]
2400b814:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
2400b818:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
2400b81c:	d11e      	bne.n	2400b85c <HAL_I2C_Slave_Seq_Receive_IT+0xbc>
      {
        hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;
2400b81e:	68fb      	ldr	r3, [r7, #12]
2400b820:	681b      	ldr	r3, [r3, #0]
2400b822:	681a      	ldr	r2, [r3, #0]
2400b824:	68fb      	ldr	r3, [r7, #12]
2400b826:	681b      	ldr	r3, [r3, #0]
2400b828:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
2400b82c:	601a      	str	r2, [r3, #0]

        /* Abort DMA Xfer if any */
        if (hi2c->hdmatx != NULL)
2400b82e:	68fb      	ldr	r3, [r7, #12]
2400b830:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400b832:	2b00      	cmp	r3, #0
2400b834:	d012      	beq.n	2400b85c <HAL_I2C_Slave_Seq_Receive_IT+0xbc>
        {
          /* Set the I2C DMA Abort callback :
           will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */
          hi2c->hdmatx->XferAbortCallback = I2C_DMAAbort;
2400b836:	68fb      	ldr	r3, [r7, #12]
2400b838:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400b83a:	4a29      	ldr	r2, [pc, #164]	; (2400b8e0 <HAL_I2C_Slave_Seq_Receive_IT+0x140>)
2400b83c:	651a      	str	r2, [r3, #80]	; 0x50

          /* Abort DMA TX */
          if (HAL_DMA_Abort_IT(hi2c->hdmatx) != HAL_OK)
2400b83e:	68fb      	ldr	r3, [r7, #12]
2400b840:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400b842:	4618      	mov	r0, r3
2400b844:	f7f7 fc0c 	bl	24003060 <HAL_DMA_Abort_IT>
2400b848:	4603      	mov	r3, r0
2400b84a:	2b00      	cmp	r3, #0
2400b84c:	d006      	beq.n	2400b85c <HAL_I2C_Slave_Seq_Receive_IT+0xbc>
          {
            /* Call Directly XferAbortCallback function in case of error */
            hi2c->hdmatx->XferAbortCallback(hi2c->hdmatx);
2400b84e:	68fb      	ldr	r3, [r7, #12]
2400b850:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400b852:	6d1b      	ldr	r3, [r3, #80]	; 0x50
2400b854:	68fa      	ldr	r2, [r7, #12]
2400b856:	6b92      	ldr	r2, [r2, #56]	; 0x38
2400b858:	4610      	mov	r0, r2
2400b85a:	4798      	blx	r3
          }
        }
      }
    }

    hi2c->State     = HAL_I2C_STATE_BUSY_RX_LISTEN;
2400b85c:	68fb      	ldr	r3, [r7, #12]
2400b85e:	222a      	movs	r2, #42	; 0x2a
2400b860:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode      = HAL_I2C_MODE_SLAVE;
2400b864:	68fb      	ldr	r3, [r7, #12]
2400b866:	2220      	movs	r2, #32
2400b868:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
2400b86c:	68fb      	ldr	r3, [r7, #12]
2400b86e:	2200      	movs	r2, #0
2400b870:	645a      	str	r2, [r3, #68]	; 0x44

    /* Enable Address Acknowledge */
    hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
2400b872:	68fb      	ldr	r3, [r7, #12]
2400b874:	681b      	ldr	r3, [r3, #0]
2400b876:	685a      	ldr	r2, [r3, #4]
2400b878:	68fb      	ldr	r3, [r7, #12]
2400b87a:	681b      	ldr	r3, [r3, #0]
2400b87c:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
2400b880:	605a      	str	r2, [r3, #4]

    /* Prepare transfer parameters */
    hi2c->pBuffPtr    = pData;
2400b882:	68fb      	ldr	r3, [r7, #12]
2400b884:	68ba      	ldr	r2, [r7, #8]
2400b886:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount   = Size;
2400b888:	68fb      	ldr	r3, [r7, #12]
2400b88a:	88fa      	ldrh	r2, [r7, #6]
2400b88c:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferSize    = hi2c->XferCount;
2400b88e:	68fb      	ldr	r3, [r7, #12]
2400b890:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400b892:	b29a      	uxth	r2, r3
2400b894:	68fb      	ldr	r3, [r7, #12]
2400b896:	851a      	strh	r2, [r3, #40]	; 0x28
    hi2c->XferOptions = XferOptions;
2400b898:	68fb      	ldr	r3, [r7, #12]
2400b89a:	683a      	ldr	r2, [r7, #0]
2400b89c:	62da      	str	r2, [r3, #44]	; 0x2c
    hi2c->XferISR     = I2C_Slave_ISR_IT;
2400b89e:	68fb      	ldr	r3, [r7, #12]
2400b8a0:	4a10      	ldr	r2, [pc, #64]	; (2400b8e4 <HAL_I2C_Slave_Seq_Receive_IT+0x144>)
2400b8a2:	635a      	str	r2, [r3, #52]	; 0x34

    if (I2C_GET_DIR(hi2c) == I2C_DIRECTION_TRANSMIT)
2400b8a4:	68fb      	ldr	r3, [r7, #12]
2400b8a6:	681b      	ldr	r3, [r3, #0]
2400b8a8:	699b      	ldr	r3, [r3, #24]
2400b8aa:	0c1b      	lsrs	r3, r3, #16
2400b8ac:	b2db      	uxtb	r3, r3
2400b8ae:	f003 0301 	and.w	r3, r3, #1
2400b8b2:	b2db      	uxtb	r3, r3
2400b8b4:	2b00      	cmp	r3, #0
2400b8b6:	d103      	bne.n	2400b8c0 <HAL_I2C_Slave_Seq_Receive_IT+0x120>
    {
      /* Clear ADDR flag after prepare the transfer parameters */
      /* This action will generate an acknowledge to the Master */
      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
2400b8b8:	68fb      	ldr	r3, [r7, #12]
2400b8ba:	681b      	ldr	r3, [r3, #0]
2400b8bc:	2208      	movs	r2, #8
2400b8be:	61da      	str	r2, [r3, #28]
    }

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
2400b8c0:	68fb      	ldr	r3, [r7, #12]
2400b8c2:	2200      	movs	r2, #0
2400b8c4:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Note : The I2C interrupts must be enabled after unlocking current process
    to avoid the risk of I2C interrupt handle execution before current
    process unlock */
    /* REnable ADDR interrupt */
    I2C_Enable_IRQ(hi2c, I2C_XFER_RX_IT | I2C_XFER_LISTEN_IT);
2400b8c8:	f248 0102 	movw	r1, #32770	; 0x8002
2400b8cc:	68f8      	ldr	r0, [r7, #12]
2400b8ce:	f002 fa63 	bl	2400dd98 <I2C_Enable_IRQ>

    return HAL_OK;
2400b8d2:	2300      	movs	r3, #0
2400b8d4:	e000      	b.n	2400b8d8 <HAL_I2C_Slave_Seq_Receive_IT+0x138>
  }
  else
  {
    return HAL_ERROR;
2400b8d6:	2301      	movs	r3, #1
  }
}
2400b8d8:	4618      	mov	r0, r3
2400b8da:	3710      	adds	r7, #16
2400b8dc:	46bd      	mov	sp, r7
2400b8de:	bd80      	pop	{r7, pc}
2400b8e0:	2400d9e5 	.word	0x2400d9e5
2400b8e4:	2400c105 	.word	0x2400c105

2400b8e8 <HAL_I2C_Slave_Seq_Receive_DMA>:
  * @param  Size Amount of data to be sent
  * @param  XferOptions Options of Transfer, value of @ref I2C_XFEROPTIONS
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Slave_Seq_Receive_DMA(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size, uint32_t XferOptions)
{
2400b8e8:	b580      	push	{r7, lr}
2400b8ea:	b086      	sub	sp, #24
2400b8ec:	af00      	add	r7, sp, #0
2400b8ee:	60f8      	str	r0, [r7, #12]
2400b8f0:	60b9      	str	r1, [r7, #8]
2400b8f2:	603b      	str	r3, [r7, #0]
2400b8f4:	4613      	mov	r3, r2
2400b8f6:	80fb      	strh	r3, [r7, #6]
  HAL_StatusTypeDef dmaxferstatus;

  /* Check the parameters */
  assert_param(IS_I2C_TRANSFER_OPTIONS_REQUEST(XferOptions));

  if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) == (uint32_t)HAL_I2C_STATE_LISTEN)
2400b8f8:	68fb      	ldr	r3, [r7, #12]
2400b8fa:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400b8fe:	b2db      	uxtb	r3, r3
2400b900:	f003 0328 	and.w	r3, r3, #40	; 0x28
2400b904:	2b28      	cmp	r3, #40	; 0x28
2400b906:	f040 811a 	bne.w	2400bb3e <HAL_I2C_Slave_Seq_Receive_DMA+0x256>
  {
    if ((pData == NULL) || (Size == 0U))
2400b90a:	68bb      	ldr	r3, [r7, #8]
2400b90c:	2b00      	cmp	r3, #0
2400b90e:	d002      	beq.n	2400b916 <HAL_I2C_Slave_Seq_Receive_DMA+0x2e>
2400b910:	88fb      	ldrh	r3, [r7, #6]
2400b912:	2b00      	cmp	r3, #0
2400b914:	d105      	bne.n	2400b922 <HAL_I2C_Slave_Seq_Receive_DMA+0x3a>
    {
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
2400b916:	68fb      	ldr	r3, [r7, #12]
2400b918:	f44f 7200 	mov.w	r2, #512	; 0x200
2400b91c:	645a      	str	r2, [r3, #68]	; 0x44
      return  HAL_ERROR;
2400b91e:	2301      	movs	r3, #1
2400b920:	e10e      	b.n	2400bb40 <HAL_I2C_Slave_Seq_Receive_DMA+0x258>
    }

    /* Disable Interrupts, to prevent preemption during treatment in case of multicall */
    I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT | I2C_XFER_RX_IT);
2400b922:	f248 0102 	movw	r1, #32770	; 0x8002
2400b926:	68f8      	ldr	r0, [r7, #12]
2400b928:	f002 fa9a 	bl	2400de60 <I2C_Disable_IRQ>

    /* Process Locked */
    __HAL_LOCK(hi2c);
2400b92c:	68fb      	ldr	r3, [r7, #12]
2400b92e:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2400b932:	2b01      	cmp	r3, #1
2400b934:	d101      	bne.n	2400b93a <HAL_I2C_Slave_Seq_Receive_DMA+0x52>
2400b936:	2302      	movs	r3, #2
2400b938:	e102      	b.n	2400bb40 <HAL_I2C_Slave_Seq_Receive_DMA+0x258>
2400b93a:	68fb      	ldr	r3, [r7, #12]
2400b93c:	2201      	movs	r2, #1
2400b93e:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* I2C cannot manage full duplex exchange so disable previous IT enabled if any */
    /* and then toggle the HAL slave TX state to RX state */
    if (hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN)
2400b942:	68fb      	ldr	r3, [r7, #12]
2400b944:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400b948:	b2db      	uxtb	r3, r3
2400b94a:	2b29      	cmp	r3, #41	; 0x29
2400b94c:	d12b      	bne.n	2400b9a6 <HAL_I2C_Slave_Seq_Receive_DMA+0xbe>
    {
      /* Disable associated Interrupts */
      I2C_Disable_IRQ(hi2c, I2C_XFER_TX_IT);
2400b94e:	2101      	movs	r1, #1
2400b950:	68f8      	ldr	r0, [r7, #12]
2400b952:	f002 fa85 	bl	2400de60 <I2C_Disable_IRQ>

      if ((hi2c->Instance->CR1 & I2C_CR1_TXDMAEN) == I2C_CR1_TXDMAEN)
2400b956:	68fb      	ldr	r3, [r7, #12]
2400b958:	681b      	ldr	r3, [r3, #0]
2400b95a:	681b      	ldr	r3, [r3, #0]
2400b95c:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
2400b960:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
2400b964:	d14c      	bne.n	2400ba00 <HAL_I2C_Slave_Seq_Receive_DMA+0x118>
      {
        /* Abort DMA Xfer if any */
        if (hi2c->hdmatx != NULL)
2400b966:	68fb      	ldr	r3, [r7, #12]
2400b968:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400b96a:	2b00      	cmp	r3, #0
2400b96c:	d048      	beq.n	2400ba00 <HAL_I2C_Slave_Seq_Receive_DMA+0x118>
        {
          hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;
2400b96e:	68fb      	ldr	r3, [r7, #12]
2400b970:	681b      	ldr	r3, [r3, #0]
2400b972:	681a      	ldr	r2, [r3, #0]
2400b974:	68fb      	ldr	r3, [r7, #12]
2400b976:	681b      	ldr	r3, [r3, #0]
2400b978:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
2400b97c:	601a      	str	r2, [r3, #0]

          /* Set the I2C DMA Abort callback :
           will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */
          hi2c->hdmatx->XferAbortCallback = I2C_DMAAbort;
2400b97e:	68fb      	ldr	r3, [r7, #12]
2400b980:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400b982:	4a71      	ldr	r2, [pc, #452]	; (2400bb48 <HAL_I2C_Slave_Seq_Receive_DMA+0x260>)
2400b984:	651a      	str	r2, [r3, #80]	; 0x50

          /* Abort DMA TX */
          if (HAL_DMA_Abort_IT(hi2c->hdmatx) != HAL_OK)
2400b986:	68fb      	ldr	r3, [r7, #12]
2400b988:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400b98a:	4618      	mov	r0, r3
2400b98c:	f7f7 fb68 	bl	24003060 <HAL_DMA_Abort_IT>
2400b990:	4603      	mov	r3, r0
2400b992:	2b00      	cmp	r3, #0
2400b994:	d034      	beq.n	2400ba00 <HAL_I2C_Slave_Seq_Receive_DMA+0x118>
          {
            /* Call Directly XferAbortCallback function in case of error */
            hi2c->hdmatx->XferAbortCallback(hi2c->hdmatx);
2400b996:	68fb      	ldr	r3, [r7, #12]
2400b998:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400b99a:	6d1b      	ldr	r3, [r3, #80]	; 0x50
2400b99c:	68fa      	ldr	r2, [r7, #12]
2400b99e:	6b92      	ldr	r2, [r2, #56]	; 0x38
2400b9a0:	4610      	mov	r0, r2
2400b9a2:	4798      	blx	r3
2400b9a4:	e02c      	b.n	2400ba00 <HAL_I2C_Slave_Seq_Receive_DMA+0x118>
          }
        }
      }
    }
    else if (hi2c->State == HAL_I2C_STATE_BUSY_RX_LISTEN)
2400b9a6:	68fb      	ldr	r3, [r7, #12]
2400b9a8:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400b9ac:	b2db      	uxtb	r3, r3
2400b9ae:	2b2a      	cmp	r3, #42	; 0x2a
2400b9b0:	d126      	bne.n	2400ba00 <HAL_I2C_Slave_Seq_Receive_DMA+0x118>
    {
      if ((hi2c->Instance->CR1 & I2C_CR1_RXDMAEN) == I2C_CR1_RXDMAEN)
2400b9b2:	68fb      	ldr	r3, [r7, #12]
2400b9b4:	681b      	ldr	r3, [r3, #0]
2400b9b6:	681b      	ldr	r3, [r3, #0]
2400b9b8:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
2400b9bc:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
2400b9c0:	d11e      	bne.n	2400ba00 <HAL_I2C_Slave_Seq_Receive_DMA+0x118>
      {
        hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN;
2400b9c2:	68fb      	ldr	r3, [r7, #12]
2400b9c4:	681b      	ldr	r3, [r3, #0]
2400b9c6:	681a      	ldr	r2, [r3, #0]
2400b9c8:	68fb      	ldr	r3, [r7, #12]
2400b9ca:	681b      	ldr	r3, [r3, #0]
2400b9cc:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
2400b9d0:	601a      	str	r2, [r3, #0]

        /* Abort DMA Xfer if any */
        if (hi2c->hdmarx != NULL)
2400b9d2:	68fb      	ldr	r3, [r7, #12]
2400b9d4:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400b9d6:	2b00      	cmp	r3, #0
2400b9d8:	d012      	beq.n	2400ba00 <HAL_I2C_Slave_Seq_Receive_DMA+0x118>
        {
          /* Set the I2C DMA Abort callback :
           will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */
          hi2c->hdmarx->XferAbortCallback = I2C_DMAAbort;
2400b9da:	68fb      	ldr	r3, [r7, #12]
2400b9dc:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400b9de:	4a5a      	ldr	r2, [pc, #360]	; (2400bb48 <HAL_I2C_Slave_Seq_Receive_DMA+0x260>)
2400b9e0:	651a      	str	r2, [r3, #80]	; 0x50

          /* Abort DMA RX */
          if (HAL_DMA_Abort_IT(hi2c->hdmarx) != HAL_OK)
2400b9e2:	68fb      	ldr	r3, [r7, #12]
2400b9e4:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400b9e6:	4618      	mov	r0, r3
2400b9e8:	f7f7 fb3a 	bl	24003060 <HAL_DMA_Abort_IT>
2400b9ec:	4603      	mov	r3, r0
2400b9ee:	2b00      	cmp	r3, #0
2400b9f0:	d006      	beq.n	2400ba00 <HAL_I2C_Slave_Seq_Receive_DMA+0x118>
          {
            /* Call Directly XferAbortCallback function in case of error */
            hi2c->hdmarx->XferAbortCallback(hi2c->hdmarx);
2400b9f2:	68fb      	ldr	r3, [r7, #12]
2400b9f4:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400b9f6:	6d1b      	ldr	r3, [r3, #80]	; 0x50
2400b9f8:	68fa      	ldr	r2, [r7, #12]
2400b9fa:	6bd2      	ldr	r2, [r2, #60]	; 0x3c
2400b9fc:	4610      	mov	r0, r2
2400b9fe:	4798      	blx	r3
    else
    {
      /* Nothing to do */
    }

    hi2c->State     = HAL_I2C_STATE_BUSY_RX_LISTEN;
2400ba00:	68fb      	ldr	r3, [r7, #12]
2400ba02:	222a      	movs	r2, #42	; 0x2a
2400ba04:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode      = HAL_I2C_MODE_SLAVE;
2400ba08:	68fb      	ldr	r3, [r7, #12]
2400ba0a:	2220      	movs	r2, #32
2400ba0c:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
2400ba10:	68fb      	ldr	r3, [r7, #12]
2400ba12:	2200      	movs	r2, #0
2400ba14:	645a      	str	r2, [r3, #68]	; 0x44

    /* Enable Address Acknowledge */
    hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
2400ba16:	68fb      	ldr	r3, [r7, #12]
2400ba18:	681b      	ldr	r3, [r3, #0]
2400ba1a:	685a      	ldr	r2, [r3, #4]
2400ba1c:	68fb      	ldr	r3, [r7, #12]
2400ba1e:	681b      	ldr	r3, [r3, #0]
2400ba20:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
2400ba24:	605a      	str	r2, [r3, #4]

    /* Prepare transfer parameters */
    hi2c->pBuffPtr    = pData;
2400ba26:	68fb      	ldr	r3, [r7, #12]
2400ba28:	68ba      	ldr	r2, [r7, #8]
2400ba2a:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount   = Size;
2400ba2c:	68fb      	ldr	r3, [r7, #12]
2400ba2e:	88fa      	ldrh	r2, [r7, #6]
2400ba30:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferSize    = hi2c->XferCount;
2400ba32:	68fb      	ldr	r3, [r7, #12]
2400ba34:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400ba36:	b29a      	uxth	r2, r3
2400ba38:	68fb      	ldr	r3, [r7, #12]
2400ba3a:	851a      	strh	r2, [r3, #40]	; 0x28
    hi2c->XferOptions = XferOptions;
2400ba3c:	68fb      	ldr	r3, [r7, #12]
2400ba3e:	683a      	ldr	r2, [r7, #0]
2400ba40:	62da      	str	r2, [r3, #44]	; 0x2c
    hi2c->XferISR     = I2C_Slave_ISR_DMA;
2400ba42:	68fb      	ldr	r3, [r7, #12]
2400ba44:	4a41      	ldr	r2, [pc, #260]	; (2400bb4c <HAL_I2C_Slave_Seq_Receive_DMA+0x264>)
2400ba46:	635a      	str	r2, [r3, #52]	; 0x34

    if (hi2c->hdmarx != NULL)
2400ba48:	68fb      	ldr	r3, [r7, #12]
2400ba4a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400ba4c:	2b00      	cmp	r3, #0
2400ba4e:	d020      	beq.n	2400ba92 <HAL_I2C_Slave_Seq_Receive_DMA+0x1aa>
    {
      /* Set the I2C DMA transfer complete callback */
      hi2c->hdmarx->XferCpltCallback = I2C_DMASlaveReceiveCplt;
2400ba50:	68fb      	ldr	r3, [r7, #12]
2400ba52:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400ba54:	4a3e      	ldr	r2, [pc, #248]	; (2400bb50 <HAL_I2C_Slave_Seq_Receive_DMA+0x268>)
2400ba56:	63da      	str	r2, [r3, #60]	; 0x3c

      /* Set the DMA error callback */
      hi2c->hdmarx->XferErrorCallback = I2C_DMAError;
2400ba58:	68fb      	ldr	r3, [r7, #12]
2400ba5a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400ba5c:	4a3d      	ldr	r2, [pc, #244]	; (2400bb54 <HAL_I2C_Slave_Seq_Receive_DMA+0x26c>)
2400ba5e:	64da      	str	r2, [r3, #76]	; 0x4c

      /* Set the unused DMA callbacks to NULL */
      hi2c->hdmarx->XferHalfCpltCallback = NULL;
2400ba60:	68fb      	ldr	r3, [r7, #12]
2400ba62:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400ba64:	2200      	movs	r2, #0
2400ba66:	641a      	str	r2, [r3, #64]	; 0x40
      hi2c->hdmarx->XferAbortCallback = NULL;
2400ba68:	68fb      	ldr	r3, [r7, #12]
2400ba6a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400ba6c:	2200      	movs	r2, #0
2400ba6e:	651a      	str	r2, [r3, #80]	; 0x50

      /* Enable the DMA stream or channel depends on Instance */
      dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->RXDR, (uint32_t)pData, hi2c->XferSize);
2400ba70:	68fb      	ldr	r3, [r7, #12]
2400ba72:	6bd8      	ldr	r0, [r3, #60]	; 0x3c
2400ba74:	68fb      	ldr	r3, [r7, #12]
2400ba76:	681b      	ldr	r3, [r3, #0]
2400ba78:	3324      	adds	r3, #36	; 0x24
2400ba7a:	4619      	mov	r1, r3
2400ba7c:	68ba      	ldr	r2, [r7, #8]
2400ba7e:	68fb      	ldr	r3, [r7, #12]
2400ba80:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400ba82:	f7f6 fd65 	bl	24002550 <HAL_DMA_Start_IT>
2400ba86:	4603      	mov	r3, r0
2400ba88:	75fb      	strb	r3, [r7, #23]
      __HAL_UNLOCK(hi2c);

      return HAL_ERROR;
    }

    if (dmaxferstatus == HAL_OK)
2400ba8a:	7dfb      	ldrb	r3, [r7, #23]
2400ba8c:	2b00      	cmp	r3, #0
2400ba8e:	d12b      	bne.n	2400bae8 <HAL_I2C_Slave_Seq_Receive_DMA+0x200>
2400ba90:	e013      	b.n	2400baba <HAL_I2C_Slave_Seq_Receive_DMA+0x1d2>
      hi2c->State     = HAL_I2C_STATE_LISTEN;
2400ba92:	68fb      	ldr	r3, [r7, #12]
2400ba94:	2228      	movs	r2, #40	; 0x28
2400ba96:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
      hi2c->Mode      = HAL_I2C_MODE_NONE;
2400ba9a:	68fb      	ldr	r3, [r7, #12]
2400ba9c:	2200      	movs	r2, #0
2400ba9e:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
      hi2c->ErrorCode |= HAL_I2C_ERROR_DMA_PARAM;
2400baa2:	68fb      	ldr	r3, [r7, #12]
2400baa4:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400baa6:	f043 0280 	orr.w	r2, r3, #128	; 0x80
2400baaa:	68fb      	ldr	r3, [r7, #12]
2400baac:	645a      	str	r2, [r3, #68]	; 0x44
      __HAL_UNLOCK(hi2c);
2400baae:	68fb      	ldr	r3, [r7, #12]
2400bab0:	2200      	movs	r2, #0
2400bab2:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      return HAL_ERROR;
2400bab6:	2301      	movs	r3, #1
2400bab8:	e042      	b.n	2400bb40 <HAL_I2C_Slave_Seq_Receive_DMA+0x258>
    {
      /* Update XferCount value */
      hi2c->XferCount -= hi2c->XferSize;
2400baba:	68fb      	ldr	r3, [r7, #12]
2400babc:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400babe:	b29a      	uxth	r2, r3
2400bac0:	68fb      	ldr	r3, [r7, #12]
2400bac2:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400bac4:	1ad3      	subs	r3, r2, r3
2400bac6:	b29a      	uxth	r2, r3
2400bac8:	68fb      	ldr	r3, [r7, #12]
2400baca:	855a      	strh	r2, [r3, #42]	; 0x2a

      /* Reset XferSize */
      hi2c->XferSize = 0;
2400bacc:	68fb      	ldr	r3, [r7, #12]
2400bace:	2200      	movs	r2, #0
2400bad0:	851a      	strh	r2, [r3, #40]	; 0x28
      __HAL_UNLOCK(hi2c);

      return HAL_ERROR;
    }

    if (I2C_GET_DIR(hi2c) == I2C_DIRECTION_TRANSMIT)
2400bad2:	68fb      	ldr	r3, [r7, #12]
2400bad4:	681b      	ldr	r3, [r3, #0]
2400bad6:	699b      	ldr	r3, [r3, #24]
2400bad8:	0c1b      	lsrs	r3, r3, #16
2400bada:	b2db      	uxtb	r3, r3
2400badc:	f003 0301 	and.w	r3, r3, #1
2400bae0:	b2db      	uxtb	r3, r3
2400bae2:	2b00      	cmp	r3, #0
2400bae4:	d118      	bne.n	2400bb18 <HAL_I2C_Slave_Seq_Receive_DMA+0x230>
2400bae6:	e013      	b.n	2400bb10 <HAL_I2C_Slave_Seq_Receive_DMA+0x228>
      hi2c->State     = HAL_I2C_STATE_LISTEN;
2400bae8:	68fb      	ldr	r3, [r7, #12]
2400baea:	2228      	movs	r2, #40	; 0x28
2400baec:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
      hi2c->Mode      = HAL_I2C_MODE_NONE;
2400baf0:	68fb      	ldr	r3, [r7, #12]
2400baf2:	2200      	movs	r2, #0
2400baf4:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
      hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
2400baf8:	68fb      	ldr	r3, [r7, #12]
2400bafa:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400bafc:	f043 0210 	orr.w	r2, r3, #16
2400bb00:	68fb      	ldr	r3, [r7, #12]
2400bb02:	645a      	str	r2, [r3, #68]	; 0x44
      __HAL_UNLOCK(hi2c);
2400bb04:	68fb      	ldr	r3, [r7, #12]
2400bb06:	2200      	movs	r2, #0
2400bb08:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      return HAL_ERROR;
2400bb0c:	2301      	movs	r3, #1
2400bb0e:	e017      	b.n	2400bb40 <HAL_I2C_Slave_Seq_Receive_DMA+0x258>
    {
      /* Clear ADDR flag after prepare the transfer parameters */
      /* This action will generate an acknowledge to the Master */
      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
2400bb10:	68fb      	ldr	r3, [r7, #12]
2400bb12:	681b      	ldr	r3, [r3, #0]
2400bb14:	2208      	movs	r2, #8
2400bb16:	61da      	str	r2, [r3, #28]
    }

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
2400bb18:	68fb      	ldr	r3, [r7, #12]
2400bb1a:	2200      	movs	r2, #0
2400bb1c:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Note : The I2C interrupts must be enabled after unlocking current process
    to avoid the risk of I2C interrupt handle execution before current
    process unlock */
    /* REnable ADDR interrupt */
    I2C_Enable_IRQ(hi2c, I2C_XFER_RX_IT | I2C_XFER_LISTEN_IT);
2400bb20:	f248 0102 	movw	r1, #32770	; 0x8002
2400bb24:	68f8      	ldr	r0, [r7, #12]
2400bb26:	f002 f937 	bl	2400dd98 <I2C_Enable_IRQ>

    /* Enable DMA Request */
    hi2c->Instance->CR1 |= I2C_CR1_RXDMAEN;
2400bb2a:	68fb      	ldr	r3, [r7, #12]
2400bb2c:	681b      	ldr	r3, [r3, #0]
2400bb2e:	681a      	ldr	r2, [r3, #0]
2400bb30:	68fb      	ldr	r3, [r7, #12]
2400bb32:	681b      	ldr	r3, [r3, #0]
2400bb34:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
2400bb38:	601a      	str	r2, [r3, #0]

    return HAL_OK;
2400bb3a:	2300      	movs	r3, #0
2400bb3c:	e000      	b.n	2400bb40 <HAL_I2C_Slave_Seq_Receive_DMA+0x258>
  }
  else
  {
    return HAL_ERROR;
2400bb3e:	2301      	movs	r3, #1
  }
}
2400bb40:	4618      	mov	r0, r3
2400bb42:	3718      	adds	r7, #24
2400bb44:	46bd      	mov	sp, r7
2400bb46:	bd80      	pop	{r7, pc}
2400bb48:	2400d9e5 	.word	0x2400d9e5
2400bb4c:	2400c4f1 	.word	0x2400c4f1
2400bb50:	2400d611 	.word	0x2400d611
2400bb54:	2400d775 	.word	0x2400d775

2400bb58 <HAL_I2C_EnableListen_IT>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_EnableListen_IT(I2C_HandleTypeDef *hi2c)
{
2400bb58:	b580      	push	{r7, lr}
2400bb5a:	b082      	sub	sp, #8
2400bb5c:	af00      	add	r7, sp, #0
2400bb5e:	6078      	str	r0, [r7, #4]
  if (hi2c->State == HAL_I2C_STATE_READY)
2400bb60:	687b      	ldr	r3, [r7, #4]
2400bb62:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400bb66:	b2db      	uxtb	r3, r3
2400bb68:	2b20      	cmp	r3, #32
2400bb6a:	d10d      	bne.n	2400bb88 <HAL_I2C_EnableListen_IT+0x30>
  {
    hi2c->State = HAL_I2C_STATE_LISTEN;
2400bb6c:	687b      	ldr	r3, [r7, #4]
2400bb6e:	2228      	movs	r2, #40	; 0x28
2400bb70:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->XferISR = I2C_Slave_ISR_IT;
2400bb74:	687b      	ldr	r3, [r7, #4]
2400bb76:	4a07      	ldr	r2, [pc, #28]	; (2400bb94 <HAL_I2C_EnableListen_IT+0x3c>)
2400bb78:	635a      	str	r2, [r3, #52]	; 0x34

    /* Enable the Address Match interrupt */
    I2C_Enable_IRQ(hi2c, I2C_XFER_LISTEN_IT);
2400bb7a:	f44f 4100 	mov.w	r1, #32768	; 0x8000
2400bb7e:	6878      	ldr	r0, [r7, #4]
2400bb80:	f002 f90a 	bl	2400dd98 <I2C_Enable_IRQ>

    return HAL_OK;
2400bb84:	2300      	movs	r3, #0
2400bb86:	e000      	b.n	2400bb8a <HAL_I2C_EnableListen_IT+0x32>
  }
  else
  {
    return HAL_BUSY;
2400bb88:	2302      	movs	r3, #2
  }
}
2400bb8a:	4618      	mov	r0, r3
2400bb8c:	3708      	adds	r7, #8
2400bb8e:	46bd      	mov	sp, r7
2400bb90:	bd80      	pop	{r7, pc}
2400bb92:	bf00      	nop
2400bb94:	2400c105 	.word	0x2400c105

2400bb98 <HAL_I2C_DisableListen_IT>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_DisableListen_IT(I2C_HandleTypeDef *hi2c)
{
2400bb98:	b580      	push	{r7, lr}
2400bb9a:	b084      	sub	sp, #16
2400bb9c:	af00      	add	r7, sp, #0
2400bb9e:	6078      	str	r0, [r7, #4]
  /* Declaration of tmp to prevent undefined behavior of volatile usage */
  uint32_t tmp;

  /* Disable Address listen mode only if a transfer is not ongoing */
  if (hi2c->State == HAL_I2C_STATE_LISTEN)
2400bba0:	687b      	ldr	r3, [r7, #4]
2400bba2:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400bba6:	b2db      	uxtb	r3, r3
2400bba8:	2b28      	cmp	r3, #40	; 0x28
2400bbaa:	d121      	bne.n	2400bbf0 <HAL_I2C_DisableListen_IT+0x58>
  {
    tmp = (uint32_t)(hi2c->State) & I2C_STATE_MSK;
2400bbac:	687b      	ldr	r3, [r7, #4]
2400bbae:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400bbb2:	b2db      	uxtb	r3, r3
2400bbb4:	f003 0303 	and.w	r3, r3, #3
2400bbb8:	60fb      	str	r3, [r7, #12]
    hi2c->PreviousState = tmp | (uint32_t)(hi2c->Mode);
2400bbba:	687b      	ldr	r3, [r7, #4]
2400bbbc:	f893 3042 	ldrb.w	r3, [r3, #66]	; 0x42
2400bbc0:	b2db      	uxtb	r3, r3
2400bbc2:	461a      	mov	r2, r3
2400bbc4:	68fb      	ldr	r3, [r7, #12]
2400bbc6:	431a      	orrs	r2, r3
2400bbc8:	687b      	ldr	r3, [r7, #4]
2400bbca:	631a      	str	r2, [r3, #48]	; 0x30
    hi2c->State = HAL_I2C_STATE_READY;
2400bbcc:	687b      	ldr	r3, [r7, #4]
2400bbce:	2220      	movs	r2, #32
2400bbd0:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode = HAL_I2C_MODE_NONE;
2400bbd4:	687b      	ldr	r3, [r7, #4]
2400bbd6:	2200      	movs	r2, #0
2400bbd8:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->XferISR = NULL;
2400bbdc:	687b      	ldr	r3, [r7, #4]
2400bbde:	2200      	movs	r2, #0
2400bbe0:	635a      	str	r2, [r3, #52]	; 0x34

    /* Disable the Address Match interrupt */
    I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT);
2400bbe2:	f44f 4100 	mov.w	r1, #32768	; 0x8000
2400bbe6:	6878      	ldr	r0, [r7, #4]
2400bbe8:	f002 f93a 	bl	2400de60 <I2C_Disable_IRQ>

    return HAL_OK;
2400bbec:	2300      	movs	r3, #0
2400bbee:	e000      	b.n	2400bbf2 <HAL_I2C_DisableListen_IT+0x5a>
  }
  else
  {
    return HAL_BUSY;
2400bbf0:	2302      	movs	r3, #2
  }
}
2400bbf2:	4618      	mov	r0, r3
2400bbf4:	3710      	adds	r7, #16
2400bbf6:	46bd      	mov	sp, r7
2400bbf8:	bd80      	pop	{r7, pc}
	...

2400bbfc <HAL_I2C_Master_Abort_IT>:
  * @param  DevAddress Target device address: The device 7 bits address value
  *         in datasheet must be shifted to the left before calling the interface
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Master_Abort_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress)
{
2400bbfc:	b580      	push	{r7, lr}
2400bbfe:	b084      	sub	sp, #16
2400bc00:	af02      	add	r7, sp, #8
2400bc02:	6078      	str	r0, [r7, #4]
2400bc04:	460b      	mov	r3, r1
2400bc06:	807b      	strh	r3, [r7, #2]
  if (hi2c->Mode == HAL_I2C_MODE_MASTER)
2400bc08:	687b      	ldr	r3, [r7, #4]
2400bc0a:	f893 3042 	ldrb.w	r3, [r3, #66]	; 0x42
2400bc0e:	b2db      	uxtb	r3, r3
2400bc10:	2b10      	cmp	r3, #16
2400bc12:	d13c      	bne.n	2400bc8e <HAL_I2C_Master_Abort_IT+0x92>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
2400bc14:	687b      	ldr	r3, [r7, #4]
2400bc16:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2400bc1a:	2b01      	cmp	r3, #1
2400bc1c:	d101      	bne.n	2400bc22 <HAL_I2C_Master_Abort_IT+0x26>
2400bc1e:	2302      	movs	r3, #2
2400bc20:	e036      	b.n	2400bc90 <HAL_I2C_Master_Abort_IT+0x94>
2400bc22:	687b      	ldr	r3, [r7, #4]
2400bc24:	2201      	movs	r2, #1
2400bc26:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Disable Interrupts and Store Previous state */
    if (hi2c->State == HAL_I2C_STATE_BUSY_TX)
2400bc2a:	687b      	ldr	r3, [r7, #4]
2400bc2c:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400bc30:	b2db      	uxtb	r3, r3
2400bc32:	2b21      	cmp	r3, #33	; 0x21
2400bc34:	d107      	bne.n	2400bc46 <HAL_I2C_Master_Abort_IT+0x4a>
    {
      I2C_Disable_IRQ(hi2c, I2C_XFER_TX_IT);
2400bc36:	2101      	movs	r1, #1
2400bc38:	6878      	ldr	r0, [r7, #4]
2400bc3a:	f002 f911 	bl	2400de60 <I2C_Disable_IRQ>
      hi2c->PreviousState = I2C_STATE_MASTER_BUSY_TX;
2400bc3e:	687b      	ldr	r3, [r7, #4]
2400bc40:	2211      	movs	r2, #17
2400bc42:	631a      	str	r2, [r3, #48]	; 0x30
2400bc44:	e00c      	b.n	2400bc60 <HAL_I2C_Master_Abort_IT+0x64>
    }
    else if (hi2c->State == HAL_I2C_STATE_BUSY_RX)
2400bc46:	687b      	ldr	r3, [r7, #4]
2400bc48:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400bc4c:	b2db      	uxtb	r3, r3
2400bc4e:	2b22      	cmp	r3, #34	; 0x22
2400bc50:	d106      	bne.n	2400bc60 <HAL_I2C_Master_Abort_IT+0x64>
    {
      I2C_Disable_IRQ(hi2c, I2C_XFER_RX_IT);
2400bc52:	2102      	movs	r1, #2
2400bc54:	6878      	ldr	r0, [r7, #4]
2400bc56:	f002 f903 	bl	2400de60 <I2C_Disable_IRQ>
      hi2c->PreviousState = I2C_STATE_MASTER_BUSY_RX;
2400bc5a:	687b      	ldr	r3, [r7, #4]
2400bc5c:	2212      	movs	r2, #18
2400bc5e:	631a      	str	r2, [r3, #48]	; 0x30
    {
      /* Do nothing */
    }

    /* Set State at HAL_I2C_STATE_ABORT */
    hi2c->State = HAL_I2C_STATE_ABORT;
2400bc60:	687b      	ldr	r3, [r7, #4]
2400bc62:	2260      	movs	r2, #96	; 0x60
2400bc64:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

    /* Set NBYTES to 1 to generate a dummy read on I2C peripheral */
    /* Set AUTOEND mode, this will generate a NACK then STOP condition to abort the current transfer */
    I2C_TransferConfig(hi2c, DevAddress, 1, I2C_AUTOEND_MODE, I2C_GENERATE_STOP);
2400bc68:	8879      	ldrh	r1, [r7, #2]
2400bc6a:	4b0b      	ldr	r3, [pc, #44]	; (2400bc98 <HAL_I2C_Master_Abort_IT+0x9c>)
2400bc6c:	9300      	str	r3, [sp, #0]
2400bc6e:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
2400bc72:	2201      	movs	r2, #1
2400bc74:	6878      	ldr	r0, [r7, #4]
2400bc76:	f002 f861 	bl	2400dd3c <I2C_TransferConfig>

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
2400bc7a:	687b      	ldr	r3, [r7, #4]
2400bc7c:	2200      	movs	r2, #0
2400bc7e:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Note : The I2C interrupts must be enabled after unlocking current process
              to avoid the risk of I2C interrupt handle execution before current
              process unlock */
    I2C_Enable_IRQ(hi2c, I2C_XFER_CPLT_IT);
2400bc82:	2120      	movs	r1, #32
2400bc84:	6878      	ldr	r0, [r7, #4]
2400bc86:	f002 f887 	bl	2400dd98 <I2C_Enable_IRQ>

    return HAL_OK;
2400bc8a:	2300      	movs	r3, #0
2400bc8c:	e000      	b.n	2400bc90 <HAL_I2C_Master_Abort_IT+0x94>
  }
  else
  {
    /* Wrong usage of abort function */
    /* This function should be used only in case of abort monitored by master device */
    return HAL_ERROR;
2400bc8e:	2301      	movs	r3, #1
  }
}
2400bc90:	4618      	mov	r0, r3
2400bc92:	3708      	adds	r7, #8
2400bc94:	46bd      	mov	sp, r7
2400bc96:	bd80      	pop	{r7, pc}
2400bc98:	80004000 	.word	0x80004000

2400bc9c <HAL_I2C_EV_IRQHandler>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
void HAL_I2C_EV_IRQHandler(I2C_HandleTypeDef *hi2c)
{
2400bc9c:	b580      	push	{r7, lr}
2400bc9e:	b084      	sub	sp, #16
2400bca0:	af00      	add	r7, sp, #0
2400bca2:	6078      	str	r0, [r7, #4]
  /* Get current IT Flags and IT sources value */
  uint32_t itflags   = READ_REG(hi2c->Instance->ISR);
2400bca4:	687b      	ldr	r3, [r7, #4]
2400bca6:	681b      	ldr	r3, [r3, #0]
2400bca8:	699b      	ldr	r3, [r3, #24]
2400bcaa:	60fb      	str	r3, [r7, #12]
  uint32_t itsources = READ_REG(hi2c->Instance->CR1);
2400bcac:	687b      	ldr	r3, [r7, #4]
2400bcae:	681b      	ldr	r3, [r3, #0]
2400bcb0:	681b      	ldr	r3, [r3, #0]
2400bcb2:	60bb      	str	r3, [r7, #8]

  /* I2C events treatment -------------------------------------*/
  if (hi2c->XferISR != NULL)
2400bcb4:	687b      	ldr	r3, [r7, #4]
2400bcb6:	6b5b      	ldr	r3, [r3, #52]	; 0x34
2400bcb8:	2b00      	cmp	r3, #0
2400bcba:	d005      	beq.n	2400bcc8 <HAL_I2C_EV_IRQHandler+0x2c>
  {
    hi2c->XferISR(hi2c, itflags, itsources);
2400bcbc:	687b      	ldr	r3, [r7, #4]
2400bcbe:	6b5b      	ldr	r3, [r3, #52]	; 0x34
2400bcc0:	68ba      	ldr	r2, [r7, #8]
2400bcc2:	68f9      	ldr	r1, [r7, #12]
2400bcc4:	6878      	ldr	r0, [r7, #4]
2400bcc6:	4798      	blx	r3
  }
}
2400bcc8:	bf00      	nop
2400bcca:	3710      	adds	r7, #16
2400bccc:	46bd      	mov	sp, r7
2400bcce:	bd80      	pop	{r7, pc}

2400bcd0 <HAL_I2C_ER_IRQHandler>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
void HAL_I2C_ER_IRQHandler(I2C_HandleTypeDef *hi2c)
{
2400bcd0:	b580      	push	{r7, lr}
2400bcd2:	b086      	sub	sp, #24
2400bcd4:	af00      	add	r7, sp, #0
2400bcd6:	6078      	str	r0, [r7, #4]
  uint32_t itflags   = READ_REG(hi2c->Instance->ISR);
2400bcd8:	687b      	ldr	r3, [r7, #4]
2400bcda:	681b      	ldr	r3, [r3, #0]
2400bcdc:	699b      	ldr	r3, [r3, #24]
2400bcde:	617b      	str	r3, [r7, #20]
  uint32_t itsources = READ_REG(hi2c->Instance->CR1);
2400bce0:	687b      	ldr	r3, [r7, #4]
2400bce2:	681b      	ldr	r3, [r3, #0]
2400bce4:	681b      	ldr	r3, [r3, #0]
2400bce6:	613b      	str	r3, [r7, #16]
  uint32_t tmperror;

  /* I2C Bus error interrupt occurred ------------------------------------*/
  if ((I2C_CHECK_FLAG(itflags, I2C_FLAG_BERR) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_ERRI) != RESET))
2400bce8:	697b      	ldr	r3, [r7, #20]
2400bcea:	0a1b      	lsrs	r3, r3, #8
2400bcec:	f003 0301 	and.w	r3, r3, #1
2400bcf0:	2b00      	cmp	r3, #0
2400bcf2:	d010      	beq.n	2400bd16 <HAL_I2C_ER_IRQHandler+0x46>
2400bcf4:	693b      	ldr	r3, [r7, #16]
2400bcf6:	09db      	lsrs	r3, r3, #7
2400bcf8:	f003 0301 	and.w	r3, r3, #1
2400bcfc:	2b00      	cmp	r3, #0
2400bcfe:	d00a      	beq.n	2400bd16 <HAL_I2C_ER_IRQHandler+0x46>
  {
    hi2c->ErrorCode |= HAL_I2C_ERROR_BERR;
2400bd00:	687b      	ldr	r3, [r7, #4]
2400bd02:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400bd04:	f043 0201 	orr.w	r2, r3, #1
2400bd08:	687b      	ldr	r3, [r7, #4]
2400bd0a:	645a      	str	r2, [r3, #68]	; 0x44

    /* Clear BERR flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_BERR);
2400bd0c:	687b      	ldr	r3, [r7, #4]
2400bd0e:	681b      	ldr	r3, [r3, #0]
2400bd10:	f44f 7280 	mov.w	r2, #256	; 0x100
2400bd14:	61da      	str	r2, [r3, #28]
  }

  /* I2C Over-Run/Under-Run interrupt occurred ----------------------------------------*/
  if ((I2C_CHECK_FLAG(itflags, I2C_FLAG_OVR) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_ERRI) != RESET))
2400bd16:	697b      	ldr	r3, [r7, #20]
2400bd18:	0a9b      	lsrs	r3, r3, #10
2400bd1a:	f003 0301 	and.w	r3, r3, #1
2400bd1e:	2b00      	cmp	r3, #0
2400bd20:	d010      	beq.n	2400bd44 <HAL_I2C_ER_IRQHandler+0x74>
2400bd22:	693b      	ldr	r3, [r7, #16]
2400bd24:	09db      	lsrs	r3, r3, #7
2400bd26:	f003 0301 	and.w	r3, r3, #1
2400bd2a:	2b00      	cmp	r3, #0
2400bd2c:	d00a      	beq.n	2400bd44 <HAL_I2C_ER_IRQHandler+0x74>
  {
    hi2c->ErrorCode |= HAL_I2C_ERROR_OVR;
2400bd2e:	687b      	ldr	r3, [r7, #4]
2400bd30:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400bd32:	f043 0208 	orr.w	r2, r3, #8
2400bd36:	687b      	ldr	r3, [r7, #4]
2400bd38:	645a      	str	r2, [r3, #68]	; 0x44

    /* Clear OVR flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_OVR);
2400bd3a:	687b      	ldr	r3, [r7, #4]
2400bd3c:	681b      	ldr	r3, [r3, #0]
2400bd3e:	f44f 6280 	mov.w	r2, #1024	; 0x400
2400bd42:	61da      	str	r2, [r3, #28]
  }

  /* I2C Arbitration Loss error interrupt occurred -------------------------------------*/
  if ((I2C_CHECK_FLAG(itflags, I2C_FLAG_ARLO) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_ERRI) != RESET))
2400bd44:	697b      	ldr	r3, [r7, #20]
2400bd46:	0a5b      	lsrs	r3, r3, #9
2400bd48:	f003 0301 	and.w	r3, r3, #1
2400bd4c:	2b00      	cmp	r3, #0
2400bd4e:	d010      	beq.n	2400bd72 <HAL_I2C_ER_IRQHandler+0xa2>
2400bd50:	693b      	ldr	r3, [r7, #16]
2400bd52:	09db      	lsrs	r3, r3, #7
2400bd54:	f003 0301 	and.w	r3, r3, #1
2400bd58:	2b00      	cmp	r3, #0
2400bd5a:	d00a      	beq.n	2400bd72 <HAL_I2C_ER_IRQHandler+0xa2>
  {
    hi2c->ErrorCode |= HAL_I2C_ERROR_ARLO;
2400bd5c:	687b      	ldr	r3, [r7, #4]
2400bd5e:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400bd60:	f043 0202 	orr.w	r2, r3, #2
2400bd64:	687b      	ldr	r3, [r7, #4]
2400bd66:	645a      	str	r2, [r3, #68]	; 0x44

    /* Clear ARLO flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ARLO);
2400bd68:	687b      	ldr	r3, [r7, #4]
2400bd6a:	681b      	ldr	r3, [r3, #0]
2400bd6c:	f44f 7200 	mov.w	r2, #512	; 0x200
2400bd70:	61da      	str	r2, [r3, #28]
  }

  /* Store current volatile hi2c->ErrorCode, misra rule */
  tmperror = hi2c->ErrorCode;
2400bd72:	687b      	ldr	r3, [r7, #4]
2400bd74:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400bd76:	60fb      	str	r3, [r7, #12]

  /* Call the Error Callback in case of Error detected */
  if ((tmperror & (HAL_I2C_ERROR_BERR | HAL_I2C_ERROR_OVR | HAL_I2C_ERROR_ARLO)) !=  HAL_I2C_ERROR_NONE)
2400bd78:	68fb      	ldr	r3, [r7, #12]
2400bd7a:	f003 030b 	and.w	r3, r3, #11
2400bd7e:	2b00      	cmp	r3, #0
2400bd80:	d003      	beq.n	2400bd8a <HAL_I2C_ER_IRQHandler+0xba>
  {
    I2C_ITError(hi2c, tmperror);
2400bd82:	68f9      	ldr	r1, [r7, #12]
2400bd84:	6878      	ldr	r0, [r7, #4]
2400bd86:	f001 fa71 	bl	2400d26c <I2C_ITError>
  }
}
2400bd8a:	bf00      	nop
2400bd8c:	3718      	adds	r7, #24
2400bd8e:	46bd      	mov	sp, r7
2400bd90:	bd80      	pop	{r7, pc}

2400bd92 <HAL_I2C_MasterTxCpltCallback>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
__weak void HAL_I2C_MasterTxCpltCallback(I2C_HandleTypeDef *hi2c)
{
2400bd92:	b480      	push	{r7}
2400bd94:	b083      	sub	sp, #12
2400bd96:	af00      	add	r7, sp, #0
2400bd98:	6078      	str	r0, [r7, #4]
  UNUSED(hi2c);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_MasterTxCpltCallback could be implemented in the user file
   */
}
2400bd9a:	bf00      	nop
2400bd9c:	370c      	adds	r7, #12
2400bd9e:	46bd      	mov	sp, r7
2400bda0:	f85d 7b04 	ldr.w	r7, [sp], #4
2400bda4:	4770      	bx	lr

2400bda6 <HAL_I2C_MasterRxCpltCallback>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
__weak void HAL_I2C_MasterRxCpltCallback(I2C_HandleTypeDef *hi2c)
{
2400bda6:	b480      	push	{r7}
2400bda8:	b083      	sub	sp, #12
2400bdaa:	af00      	add	r7, sp, #0
2400bdac:	6078      	str	r0, [r7, #4]
  UNUSED(hi2c);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_MasterRxCpltCallback could be implemented in the user file
   */
}
2400bdae:	bf00      	nop
2400bdb0:	370c      	adds	r7, #12
2400bdb2:	46bd      	mov	sp, r7
2400bdb4:	f85d 7b04 	ldr.w	r7, [sp], #4
2400bdb8:	4770      	bx	lr

2400bdba <HAL_I2C_SlaveTxCpltCallback>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
__weak void HAL_I2C_SlaveTxCpltCallback(I2C_HandleTypeDef *hi2c)
{
2400bdba:	b480      	push	{r7}
2400bdbc:	b083      	sub	sp, #12
2400bdbe:	af00      	add	r7, sp, #0
2400bdc0:	6078      	str	r0, [r7, #4]
  UNUSED(hi2c);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_SlaveTxCpltCallback could be implemented in the user file
   */
}
2400bdc2:	bf00      	nop
2400bdc4:	370c      	adds	r7, #12
2400bdc6:	46bd      	mov	sp, r7
2400bdc8:	f85d 7b04 	ldr.w	r7, [sp], #4
2400bdcc:	4770      	bx	lr

2400bdce <HAL_I2C_SlaveRxCpltCallback>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
__weak void HAL_I2C_SlaveRxCpltCallback(I2C_HandleTypeDef *hi2c)
{
2400bdce:	b480      	push	{r7}
2400bdd0:	b083      	sub	sp, #12
2400bdd2:	af00      	add	r7, sp, #0
2400bdd4:	6078      	str	r0, [r7, #4]
  UNUSED(hi2c);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_SlaveRxCpltCallback could be implemented in the user file
   */
}
2400bdd6:	bf00      	nop
2400bdd8:	370c      	adds	r7, #12
2400bdda:	46bd      	mov	sp, r7
2400bddc:	f85d 7b04 	ldr.w	r7, [sp], #4
2400bde0:	4770      	bx	lr

2400bde2 <HAL_I2C_AddrCallback>:
  * @param  TransferDirection Master request Transfer Direction (Write/Read), value of @ref I2C_XFERDIRECTION
  * @param  AddrMatchCode Address Match Code
  * @retval None
  */
__weak void HAL_I2C_AddrCallback(I2C_HandleTypeDef *hi2c, uint8_t TransferDirection, uint16_t AddrMatchCode)
{
2400bde2:	b480      	push	{r7}
2400bde4:	b083      	sub	sp, #12
2400bde6:	af00      	add	r7, sp, #0
2400bde8:	6078      	str	r0, [r7, #4]
2400bdea:	460b      	mov	r3, r1
2400bdec:	70fb      	strb	r3, [r7, #3]
2400bdee:	4613      	mov	r3, r2
2400bdf0:	803b      	strh	r3, [r7, #0]
  UNUSED(AddrMatchCode);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_AddrCallback() could be implemented in the user file
   */
}
2400bdf2:	bf00      	nop
2400bdf4:	370c      	adds	r7, #12
2400bdf6:	46bd      	mov	sp, r7
2400bdf8:	f85d 7b04 	ldr.w	r7, [sp], #4
2400bdfc:	4770      	bx	lr

2400bdfe <HAL_I2C_ListenCpltCallback>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
__weak void HAL_I2C_ListenCpltCallback(I2C_HandleTypeDef *hi2c)
{
2400bdfe:	b480      	push	{r7}
2400be00:	b083      	sub	sp, #12
2400be02:	af00      	add	r7, sp, #0
2400be04:	6078      	str	r0, [r7, #4]
  UNUSED(hi2c);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_ListenCpltCallback() could be implemented in the user file
   */
}
2400be06:	bf00      	nop
2400be08:	370c      	adds	r7, #12
2400be0a:	46bd      	mov	sp, r7
2400be0c:	f85d 7b04 	ldr.w	r7, [sp], #4
2400be10:	4770      	bx	lr

2400be12 <HAL_I2C_MemTxCpltCallback>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
__weak void HAL_I2C_MemTxCpltCallback(I2C_HandleTypeDef *hi2c)
{
2400be12:	b480      	push	{r7}
2400be14:	b083      	sub	sp, #12
2400be16:	af00      	add	r7, sp, #0
2400be18:	6078      	str	r0, [r7, #4]
  UNUSED(hi2c);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_MemTxCpltCallback could be implemented in the user file
   */
}
2400be1a:	bf00      	nop
2400be1c:	370c      	adds	r7, #12
2400be1e:	46bd      	mov	sp, r7
2400be20:	f85d 7b04 	ldr.w	r7, [sp], #4
2400be24:	4770      	bx	lr

2400be26 <HAL_I2C_MemRxCpltCallback>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
__weak void HAL_I2C_MemRxCpltCallback(I2C_HandleTypeDef *hi2c)
{
2400be26:	b480      	push	{r7}
2400be28:	b083      	sub	sp, #12
2400be2a:	af00      	add	r7, sp, #0
2400be2c:	6078      	str	r0, [r7, #4]
  UNUSED(hi2c);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_MemRxCpltCallback could be implemented in the user file
   */
}
2400be2e:	bf00      	nop
2400be30:	370c      	adds	r7, #12
2400be32:	46bd      	mov	sp, r7
2400be34:	f85d 7b04 	ldr.w	r7, [sp], #4
2400be38:	4770      	bx	lr

2400be3a <HAL_I2C_ErrorCallback>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
__weak void HAL_I2C_ErrorCallback(I2C_HandleTypeDef *hi2c)
{
2400be3a:	b480      	push	{r7}
2400be3c:	b083      	sub	sp, #12
2400be3e:	af00      	add	r7, sp, #0
2400be40:	6078      	str	r0, [r7, #4]
  UNUSED(hi2c);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_ErrorCallback could be implemented in the user file
   */
}
2400be42:	bf00      	nop
2400be44:	370c      	adds	r7, #12
2400be46:	46bd      	mov	sp, r7
2400be48:	f85d 7b04 	ldr.w	r7, [sp], #4
2400be4c:	4770      	bx	lr

2400be4e <HAL_I2C_AbortCpltCallback>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
__weak void HAL_I2C_AbortCpltCallback(I2C_HandleTypeDef *hi2c)
{
2400be4e:	b480      	push	{r7}
2400be50:	b083      	sub	sp, #12
2400be52:	af00      	add	r7, sp, #0
2400be54:	6078      	str	r0, [r7, #4]
  UNUSED(hi2c);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_AbortCpltCallback could be implemented in the user file
   */
}
2400be56:	bf00      	nop
2400be58:	370c      	adds	r7, #12
2400be5a:	46bd      	mov	sp, r7
2400be5c:	f85d 7b04 	ldr.w	r7, [sp], #4
2400be60:	4770      	bx	lr

2400be62 <HAL_I2C_GetState>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval HAL state
  */
HAL_I2C_StateTypeDef HAL_I2C_GetState(I2C_HandleTypeDef *hi2c)
{
2400be62:	b480      	push	{r7}
2400be64:	b083      	sub	sp, #12
2400be66:	af00      	add	r7, sp, #0
2400be68:	6078      	str	r0, [r7, #4]
  /* Return I2C handle state */
  return hi2c->State;
2400be6a:	687b      	ldr	r3, [r7, #4]
2400be6c:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400be70:	b2db      	uxtb	r3, r3
}
2400be72:	4618      	mov	r0, r3
2400be74:	370c      	adds	r7, #12
2400be76:	46bd      	mov	sp, r7
2400be78:	f85d 7b04 	ldr.w	r7, [sp], #4
2400be7c:	4770      	bx	lr

2400be7e <HAL_I2C_GetMode>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *         the configuration information for I2C module
  * @retval HAL mode
  */
HAL_I2C_ModeTypeDef HAL_I2C_GetMode(I2C_HandleTypeDef *hi2c)
{
2400be7e:	b480      	push	{r7}
2400be80:	b083      	sub	sp, #12
2400be82:	af00      	add	r7, sp, #0
2400be84:	6078      	str	r0, [r7, #4]
  return hi2c->Mode;
2400be86:	687b      	ldr	r3, [r7, #4]
2400be88:	f893 3042 	ldrb.w	r3, [r3, #66]	; 0x42
2400be8c:	b2db      	uxtb	r3, r3
}
2400be8e:	4618      	mov	r0, r3
2400be90:	370c      	adds	r7, #12
2400be92:	46bd      	mov	sp, r7
2400be94:	f85d 7b04 	ldr.w	r7, [sp], #4
2400be98:	4770      	bx	lr

2400be9a <HAL_I2C_GetError>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *              the configuration information for the specified I2C.
* @retval I2C Error Code
*/
uint32_t HAL_I2C_GetError(I2C_HandleTypeDef *hi2c)
{
2400be9a:	b480      	push	{r7}
2400be9c:	b083      	sub	sp, #12
2400be9e:	af00      	add	r7, sp, #0
2400bea0:	6078      	str	r0, [r7, #4]
  return hi2c->ErrorCode;
2400bea2:	687b      	ldr	r3, [r7, #4]
2400bea4:	6c5b      	ldr	r3, [r3, #68]	; 0x44
}
2400bea6:	4618      	mov	r0, r3
2400bea8:	370c      	adds	r7, #12
2400beaa:	46bd      	mov	sp, r7
2400beac:	f85d 7b04 	ldr.w	r7, [sp], #4
2400beb0:	4770      	bx	lr

2400beb2 <I2C_Master_ISR_IT>:
  * @param  ITFlags Interrupt flags to handle.
  * @param  ITSources Interrupt sources enabled.
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_Master_ISR_IT(struct __I2C_HandleTypeDef *hi2c, uint32_t ITFlags, uint32_t ITSources)
{
2400beb2:	b580      	push	{r7, lr}
2400beb4:	b088      	sub	sp, #32
2400beb6:	af02      	add	r7, sp, #8
2400beb8:	60f8      	str	r0, [r7, #12]
2400beba:	60b9      	str	r1, [r7, #8]
2400bebc:	607a      	str	r2, [r7, #4]
  uint16_t devaddress;
  uint32_t tmpITFlags = ITFlags;
2400bebe:	68bb      	ldr	r3, [r7, #8]
2400bec0:	617b      	str	r3, [r7, #20]

  /* Process Locked */
  __HAL_LOCK(hi2c);
2400bec2:	68fb      	ldr	r3, [r7, #12]
2400bec4:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2400bec8:	2b01      	cmp	r3, #1
2400beca:	d101      	bne.n	2400bed0 <I2C_Master_ISR_IT+0x1e>
2400becc:	2302      	movs	r3, #2
2400bece:	e115      	b.n	2400c0fc <I2C_Master_ISR_IT+0x24a>
2400bed0:	68fb      	ldr	r3, [r7, #12]
2400bed2:	2201      	movs	r2, #1
2400bed4:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_AF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_NACKI) != RESET))
2400bed8:	697b      	ldr	r3, [r7, #20]
2400beda:	091b      	lsrs	r3, r3, #4
2400bedc:	f003 0301 	and.w	r3, r3, #1
2400bee0:	2b00      	cmp	r3, #0
2400bee2:	d013      	beq.n	2400bf0c <I2C_Master_ISR_IT+0x5a>
2400bee4:	687b      	ldr	r3, [r7, #4]
2400bee6:	091b      	lsrs	r3, r3, #4
2400bee8:	f003 0301 	and.w	r3, r3, #1
2400beec:	2b00      	cmp	r3, #0
2400beee:	d00d      	beq.n	2400bf0c <I2C_Master_ISR_IT+0x5a>
  {
    /* Clear NACK Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
2400bef0:	68fb      	ldr	r3, [r7, #12]
2400bef2:	681b      	ldr	r3, [r3, #0]
2400bef4:	2210      	movs	r2, #16
2400bef6:	61da      	str	r2, [r3, #28]

    /* Set corresponding Error Code */
    /* No need to generate STOP, it is automatically done */
    /* Error callback will be send during stop flag treatment */
    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
2400bef8:	68fb      	ldr	r3, [r7, #12]
2400befa:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400befc:	f043 0204 	orr.w	r2, r3, #4
2400bf00:	68fb      	ldr	r3, [r7, #12]
2400bf02:	645a      	str	r2, [r3, #68]	; 0x44

    /* Flush TX register */
    I2C_Flush_TXDR(hi2c);
2400bf04:	68f8      	ldr	r0, [r7, #12]
2400bf06:	f001 faa8 	bl	2400d45a <I2C_Flush_TXDR>
2400bf0a:	e0e2      	b.n	2400c0d2 <I2C_Master_ISR_IT+0x220>
  }
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_RXNE) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_RXI) != RESET))
2400bf0c:	697b      	ldr	r3, [r7, #20]
2400bf0e:	089b      	lsrs	r3, r3, #2
2400bf10:	f003 0301 	and.w	r3, r3, #1
2400bf14:	2b00      	cmp	r3, #0
2400bf16:	d023      	beq.n	2400bf60 <I2C_Master_ISR_IT+0xae>
2400bf18:	687b      	ldr	r3, [r7, #4]
2400bf1a:	089b      	lsrs	r3, r3, #2
2400bf1c:	f003 0301 	and.w	r3, r3, #1
2400bf20:	2b00      	cmp	r3, #0
2400bf22:	d01d      	beq.n	2400bf60 <I2C_Master_ISR_IT+0xae>
  {
    /* Remove RXNE flag on temporary variable as read done */
    tmpITFlags &= ~I2C_FLAG_RXNE;
2400bf24:	697b      	ldr	r3, [r7, #20]
2400bf26:	f023 0304 	bic.w	r3, r3, #4
2400bf2a:	617b      	str	r3, [r7, #20]

    /* Read data from RXDR */
    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
2400bf2c:	68fb      	ldr	r3, [r7, #12]
2400bf2e:	681b      	ldr	r3, [r3, #0]
2400bf30:	6a5a      	ldr	r2, [r3, #36]	; 0x24
2400bf32:	68fb      	ldr	r3, [r7, #12]
2400bf34:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2400bf36:	b2d2      	uxtb	r2, r2
2400bf38:	701a      	strb	r2, [r3, #0]

    /* Increment Buffer pointer */
    hi2c->pBuffPtr++;
2400bf3a:	68fb      	ldr	r3, [r7, #12]
2400bf3c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2400bf3e:	1c5a      	adds	r2, r3, #1
2400bf40:	68fb      	ldr	r3, [r7, #12]
2400bf42:	625a      	str	r2, [r3, #36]	; 0x24

    hi2c->XferSize--;
2400bf44:	68fb      	ldr	r3, [r7, #12]
2400bf46:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400bf48:	3b01      	subs	r3, #1
2400bf4a:	b29a      	uxth	r2, r3
2400bf4c:	68fb      	ldr	r3, [r7, #12]
2400bf4e:	851a      	strh	r2, [r3, #40]	; 0x28
    hi2c->XferCount--;
2400bf50:	68fb      	ldr	r3, [r7, #12]
2400bf52:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400bf54:	b29b      	uxth	r3, r3
2400bf56:	3b01      	subs	r3, #1
2400bf58:	b29a      	uxth	r2, r3
2400bf5a:	68fb      	ldr	r3, [r7, #12]
2400bf5c:	855a      	strh	r2, [r3, #42]	; 0x2a
2400bf5e:	e0b8      	b.n	2400c0d2 <I2C_Master_ISR_IT+0x220>
  }
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_TXIS) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TXI) != RESET))
2400bf60:	697b      	ldr	r3, [r7, #20]
2400bf62:	085b      	lsrs	r3, r3, #1
2400bf64:	f003 0301 	and.w	r3, r3, #1
2400bf68:	2b00      	cmp	r3, #0
2400bf6a:	d01e      	beq.n	2400bfaa <I2C_Master_ISR_IT+0xf8>
2400bf6c:	687b      	ldr	r3, [r7, #4]
2400bf6e:	085b      	lsrs	r3, r3, #1
2400bf70:	f003 0301 	and.w	r3, r3, #1
2400bf74:	2b00      	cmp	r3, #0
2400bf76:	d018      	beq.n	2400bfaa <I2C_Master_ISR_IT+0xf8>
  {
    /* Write data to TXDR */
    hi2c->Instance->TXDR = *hi2c->pBuffPtr;
2400bf78:	68fb      	ldr	r3, [r7, #12]
2400bf7a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2400bf7c:	781a      	ldrb	r2, [r3, #0]
2400bf7e:	68fb      	ldr	r3, [r7, #12]
2400bf80:	681b      	ldr	r3, [r3, #0]
2400bf82:	629a      	str	r2, [r3, #40]	; 0x28

    /* Increment Buffer pointer */
    hi2c->pBuffPtr++;
2400bf84:	68fb      	ldr	r3, [r7, #12]
2400bf86:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2400bf88:	1c5a      	adds	r2, r3, #1
2400bf8a:	68fb      	ldr	r3, [r7, #12]
2400bf8c:	625a      	str	r2, [r3, #36]	; 0x24

    hi2c->XferSize--;
2400bf8e:	68fb      	ldr	r3, [r7, #12]
2400bf90:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400bf92:	3b01      	subs	r3, #1
2400bf94:	b29a      	uxth	r2, r3
2400bf96:	68fb      	ldr	r3, [r7, #12]
2400bf98:	851a      	strh	r2, [r3, #40]	; 0x28
    hi2c->XferCount--;
2400bf9a:	68fb      	ldr	r3, [r7, #12]
2400bf9c:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400bf9e:	b29b      	uxth	r3, r3
2400bfa0:	3b01      	subs	r3, #1
2400bfa2:	b29a      	uxth	r2, r3
2400bfa4:	68fb      	ldr	r3, [r7, #12]
2400bfa6:	855a      	strh	r2, [r3, #42]	; 0x2a
2400bfa8:	e093      	b.n	2400c0d2 <I2C_Master_ISR_IT+0x220>
  }
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_TCR) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TCI) != RESET))
2400bfaa:	697b      	ldr	r3, [r7, #20]
2400bfac:	09db      	lsrs	r3, r3, #7
2400bfae:	f003 0301 	and.w	r3, r3, #1
2400bfb2:	2b00      	cmp	r3, #0
2400bfb4:	d05e      	beq.n	2400c074 <I2C_Master_ISR_IT+0x1c2>
2400bfb6:	687b      	ldr	r3, [r7, #4]
2400bfb8:	099b      	lsrs	r3, r3, #6
2400bfba:	f003 0301 	and.w	r3, r3, #1
2400bfbe:	2b00      	cmp	r3, #0
2400bfc0:	d058      	beq.n	2400c074 <I2C_Master_ISR_IT+0x1c2>
  {
    if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
2400bfc2:	68fb      	ldr	r3, [r7, #12]
2400bfc4:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400bfc6:	b29b      	uxth	r3, r3
2400bfc8:	2b00      	cmp	r3, #0
2400bfca:	d041      	beq.n	2400c050 <I2C_Master_ISR_IT+0x19e>
2400bfcc:	68fb      	ldr	r3, [r7, #12]
2400bfce:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400bfd0:	2b00      	cmp	r3, #0
2400bfd2:	d13d      	bne.n	2400c050 <I2C_Master_ISR_IT+0x19e>
    {
      devaddress = (uint16_t)(hi2c->Instance->CR2 & I2C_CR2_SADD);
2400bfd4:	68fb      	ldr	r3, [r7, #12]
2400bfd6:	681b      	ldr	r3, [r3, #0]
2400bfd8:	685b      	ldr	r3, [r3, #4]
2400bfda:	b29b      	uxth	r3, r3
2400bfdc:	f3c3 0309 	ubfx	r3, r3, #0, #10
2400bfe0:	827b      	strh	r3, [r7, #18]

      if (hi2c->XferCount > MAX_NBYTE_SIZE)
2400bfe2:	68fb      	ldr	r3, [r7, #12]
2400bfe4:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400bfe6:	b29b      	uxth	r3, r3
2400bfe8:	2bff      	cmp	r3, #255	; 0xff
2400bfea:	d90e      	bls.n	2400c00a <I2C_Master_ISR_IT+0x158>
      {
        hi2c->XferSize = MAX_NBYTE_SIZE;
2400bfec:	68fb      	ldr	r3, [r7, #12]
2400bfee:	22ff      	movs	r2, #255	; 0xff
2400bff0:	851a      	strh	r2, [r3, #40]	; 0x28
        I2C_TransferConfig(hi2c, devaddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
2400bff2:	68fb      	ldr	r3, [r7, #12]
2400bff4:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400bff6:	b2da      	uxtb	r2, r3
2400bff8:	8a79      	ldrh	r1, [r7, #18]
2400bffa:	2300      	movs	r3, #0
2400bffc:	9300      	str	r3, [sp, #0]
2400bffe:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
2400c002:	68f8      	ldr	r0, [r7, #12]
2400c004:	f001 fe9a 	bl	2400dd3c <I2C_TransferConfig>
      if (hi2c->XferCount > MAX_NBYTE_SIZE)
2400c008:	e033      	b.n	2400c072 <I2C_Master_ISR_IT+0x1c0>
      }
      else
      {
        hi2c->XferSize = hi2c->XferCount;
2400c00a:	68fb      	ldr	r3, [r7, #12]
2400c00c:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400c00e:	b29a      	uxth	r2, r3
2400c010:	68fb      	ldr	r3, [r7, #12]
2400c012:	851a      	strh	r2, [r3, #40]	; 0x28
        if (hi2c->XferOptions != I2C_NO_OPTION_FRAME)
2400c014:	68fb      	ldr	r3, [r7, #12]
2400c016:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2400c018:	f513 3f80 	cmn.w	r3, #65536	; 0x10000
2400c01c:	d00c      	beq.n	2400c038 <I2C_Master_ISR_IT+0x186>
        {
          I2C_TransferConfig(hi2c, devaddress, (uint8_t)hi2c->XferSize, hi2c->XferOptions, I2C_NO_STARTSTOP);
2400c01e:	68fb      	ldr	r3, [r7, #12]
2400c020:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400c022:	b2da      	uxtb	r2, r3
2400c024:	68fb      	ldr	r3, [r7, #12]
2400c026:	6ad8      	ldr	r0, [r3, #44]	; 0x2c
2400c028:	8a79      	ldrh	r1, [r7, #18]
2400c02a:	2300      	movs	r3, #0
2400c02c:	9300      	str	r3, [sp, #0]
2400c02e:	4603      	mov	r3, r0
2400c030:	68f8      	ldr	r0, [r7, #12]
2400c032:	f001 fe83 	bl	2400dd3c <I2C_TransferConfig>
      if (hi2c->XferCount > MAX_NBYTE_SIZE)
2400c036:	e01c      	b.n	2400c072 <I2C_Master_ISR_IT+0x1c0>
        }
        else
        {
          I2C_TransferConfig(hi2c, devaddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
2400c038:	68fb      	ldr	r3, [r7, #12]
2400c03a:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400c03c:	b2da      	uxtb	r2, r3
2400c03e:	8a79      	ldrh	r1, [r7, #18]
2400c040:	2300      	movs	r3, #0
2400c042:	9300      	str	r3, [sp, #0]
2400c044:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
2400c048:	68f8      	ldr	r0, [r7, #12]
2400c04a:	f001 fe77 	bl	2400dd3c <I2C_TransferConfig>
      if (hi2c->XferCount > MAX_NBYTE_SIZE)
2400c04e:	e010      	b.n	2400c072 <I2C_Master_ISR_IT+0x1c0>
      }
    }
    else
    {
      /* Call TxCpltCallback() if no stop mode is set */
      if (I2C_GET_STOP_MODE(hi2c) != I2C_AUTOEND_MODE)
2400c050:	68fb      	ldr	r3, [r7, #12]
2400c052:	681b      	ldr	r3, [r3, #0]
2400c054:	685b      	ldr	r3, [r3, #4]
2400c056:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
2400c05a:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
2400c05e:	d003      	beq.n	2400c068 <I2C_Master_ISR_IT+0x1b6>
      {
        /* Call I2C Master Sequential complete process */
        I2C_ITMasterSeqCplt(hi2c);
2400c060:	68f8      	ldr	r0, [r7, #12]
2400c062:	f000 fd51 	bl	2400cb08 <I2C_ITMasterSeqCplt>
    if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
2400c066:	e034      	b.n	2400c0d2 <I2C_Master_ISR_IT+0x220>
      }
      else
      {
        /* Wrong size Status regarding TCR flag event */
        /* Call the corresponding callback to inform upper layer of End of Transfer */
        I2C_ITError(hi2c, HAL_I2C_ERROR_SIZE);
2400c068:	2140      	movs	r1, #64	; 0x40
2400c06a:	68f8      	ldr	r0, [r7, #12]
2400c06c:	f001 f8fe 	bl	2400d26c <I2C_ITError>
    if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
2400c070:	e02f      	b.n	2400c0d2 <I2C_Master_ISR_IT+0x220>
2400c072:	e02e      	b.n	2400c0d2 <I2C_Master_ISR_IT+0x220>
      }
    }
  }
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_TC) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TCI) != RESET))
2400c074:	697b      	ldr	r3, [r7, #20]
2400c076:	099b      	lsrs	r3, r3, #6
2400c078:	f003 0301 	and.w	r3, r3, #1
2400c07c:	2b00      	cmp	r3, #0
2400c07e:	d028      	beq.n	2400c0d2 <I2C_Master_ISR_IT+0x220>
2400c080:	687b      	ldr	r3, [r7, #4]
2400c082:	099b      	lsrs	r3, r3, #6
2400c084:	f003 0301 	and.w	r3, r3, #1
2400c088:	2b00      	cmp	r3, #0
2400c08a:	d022      	beq.n	2400c0d2 <I2C_Master_ISR_IT+0x220>
  {
    if (hi2c->XferCount == 0U)
2400c08c:	68fb      	ldr	r3, [r7, #12]
2400c08e:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400c090:	b29b      	uxth	r3, r3
2400c092:	2b00      	cmp	r3, #0
2400c094:	d119      	bne.n	2400c0ca <I2C_Master_ISR_IT+0x218>
    {
      if (I2C_GET_STOP_MODE(hi2c) != I2C_AUTOEND_MODE)
2400c096:	68fb      	ldr	r3, [r7, #12]
2400c098:	681b      	ldr	r3, [r3, #0]
2400c09a:	685b      	ldr	r3, [r3, #4]
2400c09c:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
2400c0a0:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
2400c0a4:	d015      	beq.n	2400c0d2 <I2C_Master_ISR_IT+0x220>
      {
        /* Generate a stop condition in case of no transfer option */
        if (hi2c->XferOptions == I2C_NO_OPTION_FRAME)
2400c0a6:	68fb      	ldr	r3, [r7, #12]
2400c0a8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2400c0aa:	f513 3f80 	cmn.w	r3, #65536	; 0x10000
2400c0ae:	d108      	bne.n	2400c0c2 <I2C_Master_ISR_IT+0x210>
        {
          /* Generate Stop */
          hi2c->Instance->CR2 |= I2C_CR2_STOP;
2400c0b0:	68fb      	ldr	r3, [r7, #12]
2400c0b2:	681b      	ldr	r3, [r3, #0]
2400c0b4:	685a      	ldr	r2, [r3, #4]
2400c0b6:	68fb      	ldr	r3, [r7, #12]
2400c0b8:	681b      	ldr	r3, [r3, #0]
2400c0ba:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
2400c0be:	605a      	str	r2, [r3, #4]
2400c0c0:	e007      	b.n	2400c0d2 <I2C_Master_ISR_IT+0x220>
        }
        else
        {
          /* Call I2C Master Sequential complete process */
          I2C_ITMasterSeqCplt(hi2c);
2400c0c2:	68f8      	ldr	r0, [r7, #12]
2400c0c4:	f000 fd20 	bl	2400cb08 <I2C_ITMasterSeqCplt>
2400c0c8:	e003      	b.n	2400c0d2 <I2C_Master_ISR_IT+0x220>
    }
    else
    {
      /* Wrong size Status regarding TC flag event */
      /* Call the corresponding callback to inform upper layer of End of Transfer */
      I2C_ITError(hi2c, HAL_I2C_ERROR_SIZE);
2400c0ca:	2140      	movs	r1, #64	; 0x40
2400c0cc:	68f8      	ldr	r0, [r7, #12]
2400c0ce:	f001 f8cd 	bl	2400d26c <I2C_ITError>
  else
  {
    /* Nothing to do */
  }

  if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_STOPF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_STOPI) != RESET))
2400c0d2:	697b      	ldr	r3, [r7, #20]
2400c0d4:	095b      	lsrs	r3, r3, #5
2400c0d6:	f003 0301 	and.w	r3, r3, #1
2400c0da:	2b00      	cmp	r3, #0
2400c0dc:	d009      	beq.n	2400c0f2 <I2C_Master_ISR_IT+0x240>
2400c0de:	687b      	ldr	r3, [r7, #4]
2400c0e0:	095b      	lsrs	r3, r3, #5
2400c0e2:	f003 0301 	and.w	r3, r3, #1
2400c0e6:	2b00      	cmp	r3, #0
2400c0e8:	d003      	beq.n	2400c0f2 <I2C_Master_ISR_IT+0x240>
  {
    /* Call I2C Master complete process */
    I2C_ITMasterCplt(hi2c, tmpITFlags);
2400c0ea:	6979      	ldr	r1, [r7, #20]
2400c0ec:	68f8      	ldr	r0, [r7, #12]
2400c0ee:	f000 fda7 	bl	2400cc40 <I2C_ITMasterCplt>
  }

  /* Process Unlocked */
  __HAL_UNLOCK(hi2c);
2400c0f2:	68fb      	ldr	r3, [r7, #12]
2400c0f4:	2200      	movs	r2, #0
2400c0f6:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  return HAL_OK;
2400c0fa:	2300      	movs	r3, #0
}
2400c0fc:	4618      	mov	r0, r3
2400c0fe:	3718      	adds	r7, #24
2400c100:	46bd      	mov	sp, r7
2400c102:	bd80      	pop	{r7, pc}

2400c104 <I2C_Slave_ISR_IT>:
  * @param  ITFlags Interrupt flags to handle.
  * @param  ITSources Interrupt sources enabled.
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_Slave_ISR_IT(struct __I2C_HandleTypeDef *hi2c, uint32_t ITFlags, uint32_t ITSources)
{
2400c104:	b580      	push	{r7, lr}
2400c106:	b086      	sub	sp, #24
2400c108:	af00      	add	r7, sp, #0
2400c10a:	60f8      	str	r0, [r7, #12]
2400c10c:	60b9      	str	r1, [r7, #8]
2400c10e:	607a      	str	r2, [r7, #4]
  uint32_t tmpoptions = hi2c->XferOptions;
2400c110:	68fb      	ldr	r3, [r7, #12]
2400c112:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2400c114:	617b      	str	r3, [r7, #20]
  uint32_t tmpITFlags = ITFlags;
2400c116:	68bb      	ldr	r3, [r7, #8]
2400c118:	613b      	str	r3, [r7, #16]

  /* Process locked */
  __HAL_LOCK(hi2c);
2400c11a:	68fb      	ldr	r3, [r7, #12]
2400c11c:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2400c120:	2b01      	cmp	r3, #1
2400c122:	d101      	bne.n	2400c128 <I2C_Slave_ISR_IT+0x24>
2400c124:	2302      	movs	r3, #2
2400c126:	e0ec      	b.n	2400c302 <I2C_Slave_ISR_IT+0x1fe>
2400c128:	68fb      	ldr	r3, [r7, #12]
2400c12a:	2201      	movs	r2, #1
2400c12c:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  /* Check if STOPF is set */
  if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_STOPF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_STOPI) != RESET))
2400c130:	693b      	ldr	r3, [r7, #16]
2400c132:	095b      	lsrs	r3, r3, #5
2400c134:	f003 0301 	and.w	r3, r3, #1
2400c138:	2b00      	cmp	r3, #0
2400c13a:	d009      	beq.n	2400c150 <I2C_Slave_ISR_IT+0x4c>
2400c13c:	687b      	ldr	r3, [r7, #4]
2400c13e:	095b      	lsrs	r3, r3, #5
2400c140:	f003 0301 	and.w	r3, r3, #1
2400c144:	2b00      	cmp	r3, #0
2400c146:	d003      	beq.n	2400c150 <I2C_Slave_ISR_IT+0x4c>
  {
    /* Call I2C Slave complete process */
    I2C_ITSlaveCplt(hi2c, tmpITFlags);
2400c148:	6939      	ldr	r1, [r7, #16]
2400c14a:	68f8      	ldr	r0, [r7, #12]
2400c14c:	f000 fe40 	bl	2400cdd0 <I2C_ITSlaveCplt>
  }

  if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_AF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_NACKI) != RESET))
2400c150:	693b      	ldr	r3, [r7, #16]
2400c152:	091b      	lsrs	r3, r3, #4
2400c154:	f003 0301 	and.w	r3, r3, #1
2400c158:	2b00      	cmp	r3, #0
2400c15a:	d04d      	beq.n	2400c1f8 <I2C_Slave_ISR_IT+0xf4>
2400c15c:	687b      	ldr	r3, [r7, #4]
2400c15e:	091b      	lsrs	r3, r3, #4
2400c160:	f003 0301 	and.w	r3, r3, #1
2400c164:	2b00      	cmp	r3, #0
2400c166:	d047      	beq.n	2400c1f8 <I2C_Slave_ISR_IT+0xf4>
  {
    /* Check that I2C transfer finished */
    /* if yes, normal use case, a NACK is sent by the MASTER when Transfer is finished */
    /* Mean XferCount == 0*/
    /* So clear Flag NACKF only */
    if (hi2c->XferCount == 0U)
2400c168:	68fb      	ldr	r3, [r7, #12]
2400c16a:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400c16c:	b29b      	uxth	r3, r3
2400c16e:	2b00      	cmp	r3, #0
2400c170:	d128      	bne.n	2400c1c4 <I2C_Slave_ISR_IT+0xc0>
    {
      if ((hi2c->State == HAL_I2C_STATE_LISTEN) && (tmpoptions == I2C_FIRST_AND_LAST_FRAME)) /* Same action must be done for (tmpoptions == I2C_LAST_FRAME) which removed for Warning[Pa134]: left and right operands are identical */
2400c172:	68fb      	ldr	r3, [r7, #12]
2400c174:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400c178:	b2db      	uxtb	r3, r3
2400c17a:	2b28      	cmp	r3, #40	; 0x28
2400c17c:	d108      	bne.n	2400c190 <I2C_Slave_ISR_IT+0x8c>
2400c17e:	697b      	ldr	r3, [r7, #20]
2400c180:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
2400c184:	d104      	bne.n	2400c190 <I2C_Slave_ISR_IT+0x8c>
      {
        /* Call I2C Listen complete process */
        I2C_ITListenCplt(hi2c, tmpITFlags);
2400c186:	6939      	ldr	r1, [r7, #16]
2400c188:	68f8      	ldr	r0, [r7, #12]
2400c18a:	f001 f819 	bl	2400d1c0 <I2C_ITListenCplt>
2400c18e:	e032      	b.n	2400c1f6 <I2C_Slave_ISR_IT+0xf2>
      }
      else if ((hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN) && (tmpoptions != I2C_NO_OPTION_FRAME))
2400c190:	68fb      	ldr	r3, [r7, #12]
2400c192:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400c196:	b2db      	uxtb	r3, r3
2400c198:	2b29      	cmp	r3, #41	; 0x29
2400c19a:	d10e      	bne.n	2400c1ba <I2C_Slave_ISR_IT+0xb6>
2400c19c:	697b      	ldr	r3, [r7, #20]
2400c19e:	f513 3f80 	cmn.w	r3, #65536	; 0x10000
2400c1a2:	d00a      	beq.n	2400c1ba <I2C_Slave_ISR_IT+0xb6>
      {
        /* Clear NACK Flag */
        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
2400c1a4:	68fb      	ldr	r3, [r7, #12]
2400c1a6:	681b      	ldr	r3, [r3, #0]
2400c1a8:	2210      	movs	r2, #16
2400c1aa:	61da      	str	r2, [r3, #28]

        /* Flush TX register */
        I2C_Flush_TXDR(hi2c);
2400c1ac:	68f8      	ldr	r0, [r7, #12]
2400c1ae:	f001 f954 	bl	2400d45a <I2C_Flush_TXDR>

        /* Last Byte is Transmitted */
        /* Call I2C Slave Sequential complete process */
        I2C_ITSlaveSeqCplt(hi2c);
2400c1b2:	68f8      	ldr	r0, [r7, #12]
2400c1b4:	f000 fce5 	bl	2400cb82 <I2C_ITSlaveSeqCplt>
2400c1b8:	e01d      	b.n	2400c1f6 <I2C_Slave_ISR_IT+0xf2>
      }
      else
      {
        /* Clear NACK Flag */
        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
2400c1ba:	68fb      	ldr	r3, [r7, #12]
2400c1bc:	681b      	ldr	r3, [r3, #0]
2400c1be:	2210      	movs	r2, #16
2400c1c0:	61da      	str	r2, [r3, #28]
    if (hi2c->XferCount == 0U)
2400c1c2:	e096      	b.n	2400c2f2 <I2C_Slave_ISR_IT+0x1ee>
    }
    else
    {
      /* if no, error use case, a Non-Acknowledge of last Data is generated by the MASTER*/
      /* Clear NACK Flag */
      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
2400c1c4:	68fb      	ldr	r3, [r7, #12]
2400c1c6:	681b      	ldr	r3, [r3, #0]
2400c1c8:	2210      	movs	r2, #16
2400c1ca:	61da      	str	r2, [r3, #28]

      /* Set ErrorCode corresponding to a Non-Acknowledge */
      hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
2400c1cc:	68fb      	ldr	r3, [r7, #12]
2400c1ce:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400c1d0:	f043 0204 	orr.w	r2, r3, #4
2400c1d4:	68fb      	ldr	r3, [r7, #12]
2400c1d6:	645a      	str	r2, [r3, #68]	; 0x44

      if ((tmpoptions == I2C_FIRST_FRAME) || (tmpoptions == I2C_NEXT_FRAME))
2400c1d8:	697b      	ldr	r3, [r7, #20]
2400c1da:	2b00      	cmp	r3, #0
2400c1dc:	d004      	beq.n	2400c1e8 <I2C_Slave_ISR_IT+0xe4>
2400c1de:	697b      	ldr	r3, [r7, #20]
2400c1e0:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
2400c1e4:	f040 8085 	bne.w	2400c2f2 <I2C_Slave_ISR_IT+0x1ee>
      {
        /* Call the corresponding callback to inform upper layer of End of Transfer */
        I2C_ITError(hi2c, hi2c->ErrorCode);
2400c1e8:	68fb      	ldr	r3, [r7, #12]
2400c1ea:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400c1ec:	4619      	mov	r1, r3
2400c1ee:	68f8      	ldr	r0, [r7, #12]
2400c1f0:	f001 f83c 	bl	2400d26c <I2C_ITError>
    if (hi2c->XferCount == 0U)
2400c1f4:	e07d      	b.n	2400c2f2 <I2C_Slave_ISR_IT+0x1ee>
2400c1f6:	e07c      	b.n	2400c2f2 <I2C_Slave_ISR_IT+0x1ee>
      }
    }
  }
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_RXNE) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_RXI) != RESET))
2400c1f8:	693b      	ldr	r3, [r7, #16]
2400c1fa:	089b      	lsrs	r3, r3, #2
2400c1fc:	f003 0301 	and.w	r3, r3, #1
2400c200:	2b00      	cmp	r3, #0
2400c202:	d030      	beq.n	2400c266 <I2C_Slave_ISR_IT+0x162>
2400c204:	687b      	ldr	r3, [r7, #4]
2400c206:	089b      	lsrs	r3, r3, #2
2400c208:	f003 0301 	and.w	r3, r3, #1
2400c20c:	2b00      	cmp	r3, #0
2400c20e:	d02a      	beq.n	2400c266 <I2C_Slave_ISR_IT+0x162>
  {
    if (hi2c->XferCount > 0U)
2400c210:	68fb      	ldr	r3, [r7, #12]
2400c212:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400c214:	b29b      	uxth	r3, r3
2400c216:	2b00      	cmp	r3, #0
2400c218:	d018      	beq.n	2400c24c <I2C_Slave_ISR_IT+0x148>
    {
      /* Read data from RXDR */
      *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
2400c21a:	68fb      	ldr	r3, [r7, #12]
2400c21c:	681b      	ldr	r3, [r3, #0]
2400c21e:	6a5a      	ldr	r2, [r3, #36]	; 0x24
2400c220:	68fb      	ldr	r3, [r7, #12]
2400c222:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2400c224:	b2d2      	uxtb	r2, r2
2400c226:	701a      	strb	r2, [r3, #0]

      /* Increment Buffer pointer */
      hi2c->pBuffPtr++;
2400c228:	68fb      	ldr	r3, [r7, #12]
2400c22a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2400c22c:	1c5a      	adds	r2, r3, #1
2400c22e:	68fb      	ldr	r3, [r7, #12]
2400c230:	625a      	str	r2, [r3, #36]	; 0x24

      hi2c->XferSize--;
2400c232:	68fb      	ldr	r3, [r7, #12]
2400c234:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400c236:	3b01      	subs	r3, #1
2400c238:	b29a      	uxth	r2, r3
2400c23a:	68fb      	ldr	r3, [r7, #12]
2400c23c:	851a      	strh	r2, [r3, #40]	; 0x28
      hi2c->XferCount--;
2400c23e:	68fb      	ldr	r3, [r7, #12]
2400c240:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400c242:	b29b      	uxth	r3, r3
2400c244:	3b01      	subs	r3, #1
2400c246:	b29a      	uxth	r2, r3
2400c248:	68fb      	ldr	r3, [r7, #12]
2400c24a:	855a      	strh	r2, [r3, #42]	; 0x2a
    }

    if ((hi2c->XferCount == 0U) && \
2400c24c:	68fb      	ldr	r3, [r7, #12]
2400c24e:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400c250:	b29b      	uxth	r3, r3
2400c252:	2b00      	cmp	r3, #0
2400c254:	d14f      	bne.n	2400c2f6 <I2C_Slave_ISR_IT+0x1f2>
2400c256:	697b      	ldr	r3, [r7, #20]
2400c258:	f513 3f80 	cmn.w	r3, #65536	; 0x10000
2400c25c:	d04b      	beq.n	2400c2f6 <I2C_Slave_ISR_IT+0x1f2>
        (tmpoptions != I2C_NO_OPTION_FRAME))
    {
      /* Call I2C Slave Sequential complete process */
      I2C_ITSlaveSeqCplt(hi2c);
2400c25e:	68f8      	ldr	r0, [r7, #12]
2400c260:	f000 fc8f 	bl	2400cb82 <I2C_ITSlaveSeqCplt>
    if ((hi2c->XferCount == 0U) && \
2400c264:	e047      	b.n	2400c2f6 <I2C_Slave_ISR_IT+0x1f2>
    }
  }
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_ADDR) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_ADDRI) != RESET))
2400c266:	693b      	ldr	r3, [r7, #16]
2400c268:	08db      	lsrs	r3, r3, #3
2400c26a:	f003 0301 	and.w	r3, r3, #1
2400c26e:	2b00      	cmp	r3, #0
2400c270:	d00a      	beq.n	2400c288 <I2C_Slave_ISR_IT+0x184>
2400c272:	687b      	ldr	r3, [r7, #4]
2400c274:	08db      	lsrs	r3, r3, #3
2400c276:	f003 0301 	and.w	r3, r3, #1
2400c27a:	2b00      	cmp	r3, #0
2400c27c:	d004      	beq.n	2400c288 <I2C_Slave_ISR_IT+0x184>
  {
    I2C_ITAddrCplt(hi2c, tmpITFlags);
2400c27e:	6939      	ldr	r1, [r7, #16]
2400c280:	68f8      	ldr	r0, [r7, #12]
2400c282:	f000 fbbd 	bl	2400ca00 <I2C_ITAddrCplt>
2400c286:	e037      	b.n	2400c2f8 <I2C_Slave_ISR_IT+0x1f4>
  }
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_TXIS) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TXI) != RESET))
2400c288:	693b      	ldr	r3, [r7, #16]
2400c28a:	085b      	lsrs	r3, r3, #1
2400c28c:	f003 0301 	and.w	r3, r3, #1
2400c290:	2b00      	cmp	r3, #0
2400c292:	d031      	beq.n	2400c2f8 <I2C_Slave_ISR_IT+0x1f4>
2400c294:	687b      	ldr	r3, [r7, #4]
2400c296:	085b      	lsrs	r3, r3, #1
2400c298:	f003 0301 	and.w	r3, r3, #1
2400c29c:	2b00      	cmp	r3, #0
2400c29e:	d02b      	beq.n	2400c2f8 <I2C_Slave_ISR_IT+0x1f4>
  {
    /* Write data to TXDR only if XferCount not reach "0" */
    /* A TXIS flag can be set, during STOP treatment      */
    /* Check if all Datas have already been sent */
    /* If it is the case, this last write in TXDR is not sent, correspond to a dummy TXIS event */
    if (hi2c->XferCount > 0U)
2400c2a0:	68fb      	ldr	r3, [r7, #12]
2400c2a2:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400c2a4:	b29b      	uxth	r3, r3
2400c2a6:	2b00      	cmp	r3, #0
2400c2a8:	d018      	beq.n	2400c2dc <I2C_Slave_ISR_IT+0x1d8>
    {
      /* Write data to TXDR */
      hi2c->Instance->TXDR = *hi2c->pBuffPtr;
2400c2aa:	68fb      	ldr	r3, [r7, #12]
2400c2ac:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2400c2ae:	781a      	ldrb	r2, [r3, #0]
2400c2b0:	68fb      	ldr	r3, [r7, #12]
2400c2b2:	681b      	ldr	r3, [r3, #0]
2400c2b4:	629a      	str	r2, [r3, #40]	; 0x28

      /* Increment Buffer pointer */
      hi2c->pBuffPtr++;
2400c2b6:	68fb      	ldr	r3, [r7, #12]
2400c2b8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2400c2ba:	1c5a      	adds	r2, r3, #1
2400c2bc:	68fb      	ldr	r3, [r7, #12]
2400c2be:	625a      	str	r2, [r3, #36]	; 0x24

      hi2c->XferCount--;
2400c2c0:	68fb      	ldr	r3, [r7, #12]
2400c2c2:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400c2c4:	b29b      	uxth	r3, r3
2400c2c6:	3b01      	subs	r3, #1
2400c2c8:	b29a      	uxth	r2, r3
2400c2ca:	68fb      	ldr	r3, [r7, #12]
2400c2cc:	855a      	strh	r2, [r3, #42]	; 0x2a
      hi2c->XferSize--;
2400c2ce:	68fb      	ldr	r3, [r7, #12]
2400c2d0:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400c2d2:	3b01      	subs	r3, #1
2400c2d4:	b29a      	uxth	r2, r3
2400c2d6:	68fb      	ldr	r3, [r7, #12]
2400c2d8:	851a      	strh	r2, [r3, #40]	; 0x28
2400c2da:	e00d      	b.n	2400c2f8 <I2C_Slave_ISR_IT+0x1f4>
    }
    else
    {
      if ((tmpoptions == I2C_NEXT_FRAME) || (tmpoptions == I2C_FIRST_FRAME))
2400c2dc:	697b      	ldr	r3, [r7, #20]
2400c2de:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
2400c2e2:	d002      	beq.n	2400c2ea <I2C_Slave_ISR_IT+0x1e6>
2400c2e4:	697b      	ldr	r3, [r7, #20]
2400c2e6:	2b00      	cmp	r3, #0
2400c2e8:	d106      	bne.n	2400c2f8 <I2C_Slave_ISR_IT+0x1f4>
      {
        /* Last Byte is Transmitted */
        /* Call I2C Slave Sequential complete process */
        I2C_ITSlaveSeqCplt(hi2c);
2400c2ea:	68f8      	ldr	r0, [r7, #12]
2400c2ec:	f000 fc49 	bl	2400cb82 <I2C_ITSlaveSeqCplt>
2400c2f0:	e002      	b.n	2400c2f8 <I2C_Slave_ISR_IT+0x1f4>
    if (hi2c->XferCount == 0U)
2400c2f2:	bf00      	nop
2400c2f4:	e000      	b.n	2400c2f8 <I2C_Slave_ISR_IT+0x1f4>
    if ((hi2c->XferCount == 0U) && \
2400c2f6:	bf00      	nop
  {
    /* Nothing to do */
  }

  /* Process Unlocked */
  __HAL_UNLOCK(hi2c);
2400c2f8:	68fb      	ldr	r3, [r7, #12]
2400c2fa:	2200      	movs	r2, #0
2400c2fc:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  return HAL_OK;
2400c300:	2300      	movs	r3, #0
}
2400c302:	4618      	mov	r0, r3
2400c304:	3718      	adds	r7, #24
2400c306:	46bd      	mov	sp, r7
2400c308:	bd80      	pop	{r7, pc}

2400c30a <I2C_Master_ISR_DMA>:
  * @param  ITFlags Interrupt flags to handle.
  * @param  ITSources Interrupt sources enabled.
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_Master_ISR_DMA(struct __I2C_HandleTypeDef *hi2c, uint32_t ITFlags, uint32_t ITSources)
{
2400c30a:	b580      	push	{r7, lr}
2400c30c:	b088      	sub	sp, #32
2400c30e:	af02      	add	r7, sp, #8
2400c310:	60f8      	str	r0, [r7, #12]
2400c312:	60b9      	str	r1, [r7, #8]
2400c314:	607a      	str	r2, [r7, #4]
  uint16_t devaddress;
  uint32_t xfermode;

  /* Process Locked */
  __HAL_LOCK(hi2c);
2400c316:	68fb      	ldr	r3, [r7, #12]
2400c318:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2400c31c:	2b01      	cmp	r3, #1
2400c31e:	d101      	bne.n	2400c324 <I2C_Master_ISR_DMA+0x1a>
2400c320:	2302      	movs	r3, #2
2400c322:	e0e1      	b.n	2400c4e8 <I2C_Master_ISR_DMA+0x1de>
2400c324:	68fb      	ldr	r3, [r7, #12]
2400c326:	2201      	movs	r2, #1
2400c328:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_AF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_NACKI) != RESET))
2400c32c:	68bb      	ldr	r3, [r7, #8]
2400c32e:	091b      	lsrs	r3, r3, #4
2400c330:	f003 0301 	and.w	r3, r3, #1
2400c334:	2b00      	cmp	r3, #0
2400c336:	d017      	beq.n	2400c368 <I2C_Master_ISR_DMA+0x5e>
2400c338:	687b      	ldr	r3, [r7, #4]
2400c33a:	091b      	lsrs	r3, r3, #4
2400c33c:	f003 0301 	and.w	r3, r3, #1
2400c340:	2b00      	cmp	r3, #0
2400c342:	d011      	beq.n	2400c368 <I2C_Master_ISR_DMA+0x5e>
  {
    /* Clear NACK Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
2400c344:	68fb      	ldr	r3, [r7, #12]
2400c346:	681b      	ldr	r3, [r3, #0]
2400c348:	2210      	movs	r2, #16
2400c34a:	61da      	str	r2, [r3, #28]

    /* Set corresponding Error Code */
    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
2400c34c:	68fb      	ldr	r3, [r7, #12]
2400c34e:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400c350:	f043 0204 	orr.w	r2, r3, #4
2400c354:	68fb      	ldr	r3, [r7, #12]
2400c356:	645a      	str	r2, [r3, #68]	; 0x44

    /* No need to generate STOP, it is automatically done */
    /* But enable STOP interrupt, to treat it */
    /* Error callback will be send during stop flag treatment */
    I2C_Enable_IRQ(hi2c, I2C_XFER_CPLT_IT);
2400c358:	2120      	movs	r1, #32
2400c35a:	68f8      	ldr	r0, [r7, #12]
2400c35c:	f001 fd1c 	bl	2400dd98 <I2C_Enable_IRQ>

    /* Flush TX register */
    I2C_Flush_TXDR(hi2c);
2400c360:	68f8      	ldr	r0, [r7, #12]
2400c362:	f001 f87a 	bl	2400d45a <I2C_Flush_TXDR>
2400c366:	e0ba      	b.n	2400c4de <I2C_Master_ISR_DMA+0x1d4>
  }
  else if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_TCR) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TCI) != RESET))
2400c368:	68bb      	ldr	r3, [r7, #8]
2400c36a:	09db      	lsrs	r3, r3, #7
2400c36c:	f003 0301 	and.w	r3, r3, #1
2400c370:	2b00      	cmp	r3, #0
2400c372:	d072      	beq.n	2400c45a <I2C_Master_ISR_DMA+0x150>
2400c374:	687b      	ldr	r3, [r7, #4]
2400c376:	099b      	lsrs	r3, r3, #6
2400c378:	f003 0301 	and.w	r3, r3, #1
2400c37c:	2b00      	cmp	r3, #0
2400c37e:	d06c      	beq.n	2400c45a <I2C_Master_ISR_DMA+0x150>
  {
    /* Disable TC interrupt */
    __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_TCI);
2400c380:	68fb      	ldr	r3, [r7, #12]
2400c382:	681b      	ldr	r3, [r3, #0]
2400c384:	681a      	ldr	r2, [r3, #0]
2400c386:	68fb      	ldr	r3, [r7, #12]
2400c388:	681b      	ldr	r3, [r3, #0]
2400c38a:	f022 0240 	bic.w	r2, r2, #64	; 0x40
2400c38e:	601a      	str	r2, [r3, #0]

    if (hi2c->XferCount != 0U)
2400c390:	68fb      	ldr	r3, [r7, #12]
2400c392:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400c394:	b29b      	uxth	r3, r3
2400c396:	2b00      	cmp	r3, #0
2400c398:	d04e      	beq.n	2400c438 <I2C_Master_ISR_DMA+0x12e>
    {
      /* Recover Slave address */
      devaddress = (uint16_t)(hi2c->Instance->CR2 & I2C_CR2_SADD);
2400c39a:	68fb      	ldr	r3, [r7, #12]
2400c39c:	681b      	ldr	r3, [r3, #0]
2400c39e:	685b      	ldr	r3, [r3, #4]
2400c3a0:	b29b      	uxth	r3, r3
2400c3a2:	f3c3 0309 	ubfx	r3, r3, #0, #10
2400c3a6:	827b      	strh	r3, [r7, #18]

      /* Prepare the new XferSize to transfer */
      if (hi2c->XferCount > MAX_NBYTE_SIZE)
2400c3a8:	68fb      	ldr	r3, [r7, #12]
2400c3aa:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400c3ac:	b29b      	uxth	r3, r3
2400c3ae:	2bff      	cmp	r3, #255	; 0xff
2400c3b0:	d906      	bls.n	2400c3c0 <I2C_Master_ISR_DMA+0xb6>
      {
        hi2c->XferSize = MAX_NBYTE_SIZE;
2400c3b2:	68fb      	ldr	r3, [r7, #12]
2400c3b4:	22ff      	movs	r2, #255	; 0xff
2400c3b6:	851a      	strh	r2, [r3, #40]	; 0x28
        xfermode = I2C_RELOAD_MODE;
2400c3b8:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
2400c3bc:	617b      	str	r3, [r7, #20]
2400c3be:	e010      	b.n	2400c3e2 <I2C_Master_ISR_DMA+0xd8>
      }
      else
      {
        hi2c->XferSize = hi2c->XferCount;
2400c3c0:	68fb      	ldr	r3, [r7, #12]
2400c3c2:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400c3c4:	b29a      	uxth	r2, r3
2400c3c6:	68fb      	ldr	r3, [r7, #12]
2400c3c8:	851a      	strh	r2, [r3, #40]	; 0x28
        if (hi2c->XferOptions != I2C_NO_OPTION_FRAME)
2400c3ca:	68fb      	ldr	r3, [r7, #12]
2400c3cc:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2400c3ce:	f513 3f80 	cmn.w	r3, #65536	; 0x10000
2400c3d2:	d003      	beq.n	2400c3dc <I2C_Master_ISR_DMA+0xd2>
        {
          xfermode = hi2c->XferOptions;
2400c3d4:	68fb      	ldr	r3, [r7, #12]
2400c3d6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2400c3d8:	617b      	str	r3, [r7, #20]
2400c3da:	e002      	b.n	2400c3e2 <I2C_Master_ISR_DMA+0xd8>
        }
        else
        {
          xfermode = I2C_AUTOEND_MODE;
2400c3dc:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
2400c3e0:	617b      	str	r3, [r7, #20]
        }
      }

      /* Set the new XferSize in Nbytes register */
      I2C_TransferConfig(hi2c, devaddress, (uint8_t)hi2c->XferSize, xfermode, I2C_NO_STARTSTOP);
2400c3e2:	68fb      	ldr	r3, [r7, #12]
2400c3e4:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400c3e6:	b2da      	uxtb	r2, r3
2400c3e8:	8a79      	ldrh	r1, [r7, #18]
2400c3ea:	2300      	movs	r3, #0
2400c3ec:	9300      	str	r3, [sp, #0]
2400c3ee:	697b      	ldr	r3, [r7, #20]
2400c3f0:	68f8      	ldr	r0, [r7, #12]
2400c3f2:	f001 fca3 	bl	2400dd3c <I2C_TransferConfig>

      /* Update XferCount value */
      hi2c->XferCount -= hi2c->XferSize;
2400c3f6:	68fb      	ldr	r3, [r7, #12]
2400c3f8:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400c3fa:	b29a      	uxth	r2, r3
2400c3fc:	68fb      	ldr	r3, [r7, #12]
2400c3fe:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400c400:	1ad3      	subs	r3, r2, r3
2400c402:	b29a      	uxth	r2, r3
2400c404:	68fb      	ldr	r3, [r7, #12]
2400c406:	855a      	strh	r2, [r3, #42]	; 0x2a

      /* Enable DMA Request */
      if (hi2c->State == HAL_I2C_STATE_BUSY_RX)
2400c408:	68fb      	ldr	r3, [r7, #12]
2400c40a:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400c40e:	b2db      	uxtb	r3, r3
2400c410:	2b22      	cmp	r3, #34	; 0x22
2400c412:	d108      	bne.n	2400c426 <I2C_Master_ISR_DMA+0x11c>
      {
        hi2c->Instance->CR1 |= I2C_CR1_RXDMAEN;
2400c414:	68fb      	ldr	r3, [r7, #12]
2400c416:	681b      	ldr	r3, [r3, #0]
2400c418:	681a      	ldr	r2, [r3, #0]
2400c41a:	68fb      	ldr	r3, [r7, #12]
2400c41c:	681b      	ldr	r3, [r3, #0]
2400c41e:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
2400c422:	601a      	str	r2, [r3, #0]
    if (hi2c->XferCount != 0U)
2400c424:	e05b      	b.n	2400c4de <I2C_Master_ISR_DMA+0x1d4>
      }
      else
      {
        hi2c->Instance->CR1 |= I2C_CR1_TXDMAEN;
2400c426:	68fb      	ldr	r3, [r7, #12]
2400c428:	681b      	ldr	r3, [r3, #0]
2400c42a:	681a      	ldr	r2, [r3, #0]
2400c42c:	68fb      	ldr	r3, [r7, #12]
2400c42e:	681b      	ldr	r3, [r3, #0]
2400c430:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
2400c434:	601a      	str	r2, [r3, #0]
    if (hi2c->XferCount != 0U)
2400c436:	e052      	b.n	2400c4de <I2C_Master_ISR_DMA+0x1d4>
      }
    }
    else
    {
      /* Call TxCpltCallback() if no stop mode is set */
      if (I2C_GET_STOP_MODE(hi2c) != I2C_AUTOEND_MODE)
2400c438:	68fb      	ldr	r3, [r7, #12]
2400c43a:	681b      	ldr	r3, [r3, #0]
2400c43c:	685b      	ldr	r3, [r3, #4]
2400c43e:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
2400c442:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
2400c446:	d003      	beq.n	2400c450 <I2C_Master_ISR_DMA+0x146>
      {
        /* Call I2C Master Sequential complete process */
        I2C_ITMasterSeqCplt(hi2c);
2400c448:	68f8      	ldr	r0, [r7, #12]
2400c44a:	f000 fb5d 	bl	2400cb08 <I2C_ITMasterSeqCplt>
    if (hi2c->XferCount != 0U)
2400c44e:	e046      	b.n	2400c4de <I2C_Master_ISR_DMA+0x1d4>
      }
      else
      {
        /* Wrong size Status regarding TCR flag event */
        /* Call the corresponding callback to inform upper layer of End of Transfer */
        I2C_ITError(hi2c, HAL_I2C_ERROR_SIZE);
2400c450:	2140      	movs	r1, #64	; 0x40
2400c452:	68f8      	ldr	r0, [r7, #12]
2400c454:	f000 ff0a 	bl	2400d26c <I2C_ITError>
    if (hi2c->XferCount != 0U)
2400c458:	e041      	b.n	2400c4de <I2C_Master_ISR_DMA+0x1d4>
      }
    }
  }
  else if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_TC) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TCI) != RESET))
2400c45a:	68bb      	ldr	r3, [r7, #8]
2400c45c:	099b      	lsrs	r3, r3, #6
2400c45e:	f003 0301 	and.w	r3, r3, #1
2400c462:	2b00      	cmp	r3, #0
2400c464:	d029      	beq.n	2400c4ba <I2C_Master_ISR_DMA+0x1b0>
2400c466:	687b      	ldr	r3, [r7, #4]
2400c468:	099b      	lsrs	r3, r3, #6
2400c46a:	f003 0301 	and.w	r3, r3, #1
2400c46e:	2b00      	cmp	r3, #0
2400c470:	d023      	beq.n	2400c4ba <I2C_Master_ISR_DMA+0x1b0>
  {
    if (hi2c->XferCount == 0U)
2400c472:	68fb      	ldr	r3, [r7, #12]
2400c474:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400c476:	b29b      	uxth	r3, r3
2400c478:	2b00      	cmp	r3, #0
2400c47a:	d119      	bne.n	2400c4b0 <I2C_Master_ISR_DMA+0x1a6>
    {
      if (I2C_GET_STOP_MODE(hi2c) != I2C_AUTOEND_MODE)
2400c47c:	68fb      	ldr	r3, [r7, #12]
2400c47e:	681b      	ldr	r3, [r3, #0]
2400c480:	685b      	ldr	r3, [r3, #4]
2400c482:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
2400c486:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
2400c48a:	d027      	beq.n	2400c4dc <I2C_Master_ISR_DMA+0x1d2>
      {
        /* Generate a stop condition in case of no transfer option */
        if (hi2c->XferOptions == I2C_NO_OPTION_FRAME)
2400c48c:	68fb      	ldr	r3, [r7, #12]
2400c48e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2400c490:	f513 3f80 	cmn.w	r3, #65536	; 0x10000
2400c494:	d108      	bne.n	2400c4a8 <I2C_Master_ISR_DMA+0x19e>
        {
          /* Generate Stop */
          hi2c->Instance->CR2 |= I2C_CR2_STOP;
2400c496:	68fb      	ldr	r3, [r7, #12]
2400c498:	681b      	ldr	r3, [r3, #0]
2400c49a:	685a      	ldr	r2, [r3, #4]
2400c49c:	68fb      	ldr	r3, [r7, #12]
2400c49e:	681b      	ldr	r3, [r3, #0]
2400c4a0:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
2400c4a4:	605a      	str	r2, [r3, #4]
    if (hi2c->XferCount == 0U)
2400c4a6:	e019      	b.n	2400c4dc <I2C_Master_ISR_DMA+0x1d2>
        }
        else
        {
          /* Call I2C Master Sequential complete process */
          I2C_ITMasterSeqCplt(hi2c);
2400c4a8:	68f8      	ldr	r0, [r7, #12]
2400c4aa:	f000 fb2d 	bl	2400cb08 <I2C_ITMasterSeqCplt>
    if (hi2c->XferCount == 0U)
2400c4ae:	e015      	b.n	2400c4dc <I2C_Master_ISR_DMA+0x1d2>
    }
    else
    {
      /* Wrong size Status regarding TC flag event */
      /* Call the corresponding callback to inform upper layer of End of Transfer */
      I2C_ITError(hi2c, HAL_I2C_ERROR_SIZE);
2400c4b0:	2140      	movs	r1, #64	; 0x40
2400c4b2:	68f8      	ldr	r0, [r7, #12]
2400c4b4:	f000 feda 	bl	2400d26c <I2C_ITError>
    if (hi2c->XferCount == 0U)
2400c4b8:	e010      	b.n	2400c4dc <I2C_Master_ISR_DMA+0x1d2>
    }
  }
  else if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_STOPF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_STOPI) != RESET))
2400c4ba:	68bb      	ldr	r3, [r7, #8]
2400c4bc:	095b      	lsrs	r3, r3, #5
2400c4be:	f003 0301 	and.w	r3, r3, #1
2400c4c2:	2b00      	cmp	r3, #0
2400c4c4:	d00b      	beq.n	2400c4de <I2C_Master_ISR_DMA+0x1d4>
2400c4c6:	687b      	ldr	r3, [r7, #4]
2400c4c8:	095b      	lsrs	r3, r3, #5
2400c4ca:	f003 0301 	and.w	r3, r3, #1
2400c4ce:	2b00      	cmp	r3, #0
2400c4d0:	d005      	beq.n	2400c4de <I2C_Master_ISR_DMA+0x1d4>
  {
    /* Call I2C Master complete process */
    I2C_ITMasterCplt(hi2c, ITFlags);
2400c4d2:	68b9      	ldr	r1, [r7, #8]
2400c4d4:	68f8      	ldr	r0, [r7, #12]
2400c4d6:	f000 fbb3 	bl	2400cc40 <I2C_ITMasterCplt>
2400c4da:	e000      	b.n	2400c4de <I2C_Master_ISR_DMA+0x1d4>
    if (hi2c->XferCount == 0U)
2400c4dc:	bf00      	nop
  {
    /* Nothing to do */
  }

  /* Process Unlocked */
  __HAL_UNLOCK(hi2c);
2400c4de:	68fb      	ldr	r3, [r7, #12]
2400c4e0:	2200      	movs	r2, #0
2400c4e2:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  return HAL_OK;
2400c4e6:	2300      	movs	r3, #0
}
2400c4e8:	4618      	mov	r0, r3
2400c4ea:	3718      	adds	r7, #24
2400c4ec:	46bd      	mov	sp, r7
2400c4ee:	bd80      	pop	{r7, pc}

2400c4f0 <I2C_Slave_ISR_DMA>:
  * @param  ITFlags Interrupt flags to handle.
  * @param  ITSources Interrupt sources enabled.
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_Slave_ISR_DMA(struct __I2C_HandleTypeDef *hi2c, uint32_t ITFlags, uint32_t ITSources)
{
2400c4f0:	b580      	push	{r7, lr}
2400c4f2:	b088      	sub	sp, #32
2400c4f4:	af00      	add	r7, sp, #0
2400c4f6:	60f8      	str	r0, [r7, #12]
2400c4f8:	60b9      	str	r1, [r7, #8]
2400c4fa:	607a      	str	r2, [r7, #4]
  uint32_t tmpoptions = hi2c->XferOptions;
2400c4fc:	68fb      	ldr	r3, [r7, #12]
2400c4fe:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2400c500:	61bb      	str	r3, [r7, #24]
  uint32_t treatdmanack = 0U;
2400c502:	2300      	movs	r3, #0
2400c504:	61fb      	str	r3, [r7, #28]
  HAL_I2C_StateTypeDef tmpstate;

  /* Process locked */
  __HAL_LOCK(hi2c);
2400c506:	68fb      	ldr	r3, [r7, #12]
2400c508:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2400c50c:	2b01      	cmp	r3, #1
2400c50e:	d101      	bne.n	2400c514 <I2C_Slave_ISR_DMA+0x24>
2400c510:	2302      	movs	r3, #2
2400c512:	e1c8      	b.n	2400c8a6 <I2C_Slave_ISR_DMA+0x3b6>
2400c514:	68fb      	ldr	r3, [r7, #12]
2400c516:	2201      	movs	r2, #1
2400c518:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  /* Check if STOPF is set */
  if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_STOPF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_STOPI) != RESET))
2400c51c:	68bb      	ldr	r3, [r7, #8]
2400c51e:	095b      	lsrs	r3, r3, #5
2400c520:	f003 0301 	and.w	r3, r3, #1
2400c524:	2b00      	cmp	r3, #0
2400c526:	d009      	beq.n	2400c53c <I2C_Slave_ISR_DMA+0x4c>
2400c528:	687b      	ldr	r3, [r7, #4]
2400c52a:	095b      	lsrs	r3, r3, #5
2400c52c:	f003 0301 	and.w	r3, r3, #1
2400c530:	2b00      	cmp	r3, #0
2400c532:	d003      	beq.n	2400c53c <I2C_Slave_ISR_DMA+0x4c>
  {
    /* Call I2C Slave complete process */
    I2C_ITSlaveCplt(hi2c, ITFlags);
2400c534:	68b9      	ldr	r1, [r7, #8]
2400c536:	68f8      	ldr	r0, [r7, #12]
2400c538:	f000 fc4a 	bl	2400cdd0 <I2C_ITSlaveCplt>
  }

  if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_AF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_NACKI) != RESET))
2400c53c:	68bb      	ldr	r3, [r7, #8]
2400c53e:	091b      	lsrs	r3, r3, #4
2400c540:	f003 0301 	and.w	r3, r3, #1
2400c544:	2b00      	cmp	r3, #0
2400c546:	f000 8199 	beq.w	2400c87c <I2C_Slave_ISR_DMA+0x38c>
2400c54a:	687b      	ldr	r3, [r7, #4]
2400c54c:	091b      	lsrs	r3, r3, #4
2400c54e:	f003 0301 	and.w	r3, r3, #1
2400c552:	2b00      	cmp	r3, #0
2400c554:	f000 8192 	beq.w	2400c87c <I2C_Slave_ISR_DMA+0x38c>
  {
    /* Check that I2C transfer finished */
    /* if yes, normal use case, a NACK is sent by the MASTER when Transfer is finished */
    /* Mean XferCount == 0 */
    /* So clear Flag NACKF only */
    if ((I2C_CHECK_IT_SOURCE(ITSources, I2C_CR1_TXDMAEN) != RESET) ||
2400c558:	687b      	ldr	r3, [r7, #4]
2400c55a:	0b9b      	lsrs	r3, r3, #14
2400c55c:	f003 0301 	and.w	r3, r3, #1
2400c560:	2b00      	cmp	r3, #0
2400c562:	d106      	bne.n	2400c572 <I2C_Slave_ISR_DMA+0x82>
        (I2C_CHECK_IT_SOURCE(ITSources, I2C_CR1_RXDMAEN) != RESET))
2400c564:	687b      	ldr	r3, [r7, #4]
2400c566:	0bdb      	lsrs	r3, r3, #15
2400c568:	f003 0301 	and.w	r3, r3, #1
    if ((I2C_CHECK_IT_SOURCE(ITSources, I2C_CR1_TXDMAEN) != RESET) ||
2400c56c:	2b00      	cmp	r3, #0
2400c56e:	f000 817e 	beq.w	2400c86e <I2C_Slave_ISR_DMA+0x37e>
    {
      /* Split check of hdmarx, for MISRA compliance */
      if (hi2c->hdmarx != NULL)
2400c572:	68fb      	ldr	r3, [r7, #12]
2400c574:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400c576:	2b00      	cmp	r3, #0
2400c578:	d07c      	beq.n	2400c674 <I2C_Slave_ISR_DMA+0x184>
      {
        if (I2C_CHECK_IT_SOURCE(ITSources, I2C_CR1_RXDMAEN) != RESET)
2400c57a:	687b      	ldr	r3, [r7, #4]
2400c57c:	0bdb      	lsrs	r3, r3, #15
2400c57e:	f003 0301 	and.w	r3, r3, #1
2400c582:	2b00      	cmp	r3, #0
2400c584:	d076      	beq.n	2400c674 <I2C_Slave_ISR_DMA+0x184>
        {
          if (__HAL_DMA_GET_COUNTER(hi2c->hdmarx) == 0U)
2400c586:	68fb      	ldr	r3, [r7, #12]
2400c588:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400c58a:	681b      	ldr	r3, [r3, #0]
2400c58c:	4a8d      	ldr	r2, [pc, #564]	; (2400c7c4 <I2C_Slave_ISR_DMA+0x2d4>)
2400c58e:	4293      	cmp	r3, r2
2400c590:	d059      	beq.n	2400c646 <I2C_Slave_ISR_DMA+0x156>
2400c592:	68fb      	ldr	r3, [r7, #12]
2400c594:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400c596:	681b      	ldr	r3, [r3, #0]
2400c598:	4a8b      	ldr	r2, [pc, #556]	; (2400c7c8 <I2C_Slave_ISR_DMA+0x2d8>)
2400c59a:	4293      	cmp	r3, r2
2400c59c:	d053      	beq.n	2400c646 <I2C_Slave_ISR_DMA+0x156>
2400c59e:	68fb      	ldr	r3, [r7, #12]
2400c5a0:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400c5a2:	681b      	ldr	r3, [r3, #0]
2400c5a4:	4a89      	ldr	r2, [pc, #548]	; (2400c7cc <I2C_Slave_ISR_DMA+0x2dc>)
2400c5a6:	4293      	cmp	r3, r2
2400c5a8:	d04d      	beq.n	2400c646 <I2C_Slave_ISR_DMA+0x156>
2400c5aa:	68fb      	ldr	r3, [r7, #12]
2400c5ac:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400c5ae:	681b      	ldr	r3, [r3, #0]
2400c5b0:	4a87      	ldr	r2, [pc, #540]	; (2400c7d0 <I2C_Slave_ISR_DMA+0x2e0>)
2400c5b2:	4293      	cmp	r3, r2
2400c5b4:	d047      	beq.n	2400c646 <I2C_Slave_ISR_DMA+0x156>
2400c5b6:	68fb      	ldr	r3, [r7, #12]
2400c5b8:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400c5ba:	681b      	ldr	r3, [r3, #0]
2400c5bc:	4a85      	ldr	r2, [pc, #532]	; (2400c7d4 <I2C_Slave_ISR_DMA+0x2e4>)
2400c5be:	4293      	cmp	r3, r2
2400c5c0:	d041      	beq.n	2400c646 <I2C_Slave_ISR_DMA+0x156>
2400c5c2:	68fb      	ldr	r3, [r7, #12]
2400c5c4:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400c5c6:	681b      	ldr	r3, [r3, #0]
2400c5c8:	4a83      	ldr	r2, [pc, #524]	; (2400c7d8 <I2C_Slave_ISR_DMA+0x2e8>)
2400c5ca:	4293      	cmp	r3, r2
2400c5cc:	d03b      	beq.n	2400c646 <I2C_Slave_ISR_DMA+0x156>
2400c5ce:	68fb      	ldr	r3, [r7, #12]
2400c5d0:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400c5d2:	681b      	ldr	r3, [r3, #0]
2400c5d4:	4a81      	ldr	r2, [pc, #516]	; (2400c7dc <I2C_Slave_ISR_DMA+0x2ec>)
2400c5d6:	4293      	cmp	r3, r2
2400c5d8:	d035      	beq.n	2400c646 <I2C_Slave_ISR_DMA+0x156>
2400c5da:	68fb      	ldr	r3, [r7, #12]
2400c5dc:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400c5de:	681b      	ldr	r3, [r3, #0]
2400c5e0:	4a7f      	ldr	r2, [pc, #508]	; (2400c7e0 <I2C_Slave_ISR_DMA+0x2f0>)
2400c5e2:	4293      	cmp	r3, r2
2400c5e4:	d02f      	beq.n	2400c646 <I2C_Slave_ISR_DMA+0x156>
2400c5e6:	68fb      	ldr	r3, [r7, #12]
2400c5e8:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400c5ea:	681b      	ldr	r3, [r3, #0]
2400c5ec:	4a7d      	ldr	r2, [pc, #500]	; (2400c7e4 <I2C_Slave_ISR_DMA+0x2f4>)
2400c5ee:	4293      	cmp	r3, r2
2400c5f0:	d029      	beq.n	2400c646 <I2C_Slave_ISR_DMA+0x156>
2400c5f2:	68fb      	ldr	r3, [r7, #12]
2400c5f4:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400c5f6:	681b      	ldr	r3, [r3, #0]
2400c5f8:	4a7b      	ldr	r2, [pc, #492]	; (2400c7e8 <I2C_Slave_ISR_DMA+0x2f8>)
2400c5fa:	4293      	cmp	r3, r2
2400c5fc:	d023      	beq.n	2400c646 <I2C_Slave_ISR_DMA+0x156>
2400c5fe:	68fb      	ldr	r3, [r7, #12]
2400c600:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400c602:	681b      	ldr	r3, [r3, #0]
2400c604:	4a79      	ldr	r2, [pc, #484]	; (2400c7ec <I2C_Slave_ISR_DMA+0x2fc>)
2400c606:	4293      	cmp	r3, r2
2400c608:	d01d      	beq.n	2400c646 <I2C_Slave_ISR_DMA+0x156>
2400c60a:	68fb      	ldr	r3, [r7, #12]
2400c60c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400c60e:	681b      	ldr	r3, [r3, #0]
2400c610:	4a77      	ldr	r2, [pc, #476]	; (2400c7f0 <I2C_Slave_ISR_DMA+0x300>)
2400c612:	4293      	cmp	r3, r2
2400c614:	d017      	beq.n	2400c646 <I2C_Slave_ISR_DMA+0x156>
2400c616:	68fb      	ldr	r3, [r7, #12]
2400c618:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400c61a:	681b      	ldr	r3, [r3, #0]
2400c61c:	4a75      	ldr	r2, [pc, #468]	; (2400c7f4 <I2C_Slave_ISR_DMA+0x304>)
2400c61e:	4293      	cmp	r3, r2
2400c620:	d011      	beq.n	2400c646 <I2C_Slave_ISR_DMA+0x156>
2400c622:	68fb      	ldr	r3, [r7, #12]
2400c624:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400c626:	681b      	ldr	r3, [r3, #0]
2400c628:	4a73      	ldr	r2, [pc, #460]	; (2400c7f8 <I2C_Slave_ISR_DMA+0x308>)
2400c62a:	4293      	cmp	r3, r2
2400c62c:	d00b      	beq.n	2400c646 <I2C_Slave_ISR_DMA+0x156>
2400c62e:	68fb      	ldr	r3, [r7, #12]
2400c630:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400c632:	681b      	ldr	r3, [r3, #0]
2400c634:	4a71      	ldr	r2, [pc, #452]	; (2400c7fc <I2C_Slave_ISR_DMA+0x30c>)
2400c636:	4293      	cmp	r3, r2
2400c638:	d005      	beq.n	2400c646 <I2C_Slave_ISR_DMA+0x156>
2400c63a:	68fb      	ldr	r3, [r7, #12]
2400c63c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400c63e:	681b      	ldr	r3, [r3, #0]
2400c640:	4a6f      	ldr	r2, [pc, #444]	; (2400c800 <I2C_Slave_ISR_DMA+0x310>)
2400c642:	4293      	cmp	r3, r2
2400c644:	d109      	bne.n	2400c65a <I2C_Slave_ISR_DMA+0x16a>
2400c646:	68fb      	ldr	r3, [r7, #12]
2400c648:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400c64a:	681b      	ldr	r3, [r3, #0]
2400c64c:	685b      	ldr	r3, [r3, #4]
2400c64e:	2b00      	cmp	r3, #0
2400c650:	bf0c      	ite	eq
2400c652:	2301      	moveq	r3, #1
2400c654:	2300      	movne	r3, #0
2400c656:	b2db      	uxtb	r3, r3
2400c658:	e008      	b.n	2400c66c <I2C_Slave_ISR_DMA+0x17c>
2400c65a:	68fb      	ldr	r3, [r7, #12]
2400c65c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400c65e:	681b      	ldr	r3, [r3, #0]
2400c660:	685b      	ldr	r3, [r3, #4]
2400c662:	2b00      	cmp	r3, #0
2400c664:	bf0c      	ite	eq
2400c666:	2301      	moveq	r3, #1
2400c668:	2300      	movne	r3, #0
2400c66a:	b2db      	uxtb	r3, r3
2400c66c:	2b00      	cmp	r3, #0
2400c66e:	d001      	beq.n	2400c674 <I2C_Slave_ISR_DMA+0x184>
          {
            treatdmanack = 1U;
2400c670:	2301      	movs	r3, #1
2400c672:	61fb      	str	r3, [r7, #28]
          }
        }
      }

      /* Split check of hdmatx, for MISRA compliance  */
      if (hi2c->hdmatx != NULL)
2400c674:	68fb      	ldr	r3, [r7, #12]
2400c676:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400c678:	2b00      	cmp	r3, #0
2400c67a:	d07c      	beq.n	2400c776 <I2C_Slave_ISR_DMA+0x286>
      {
        if (I2C_CHECK_IT_SOURCE(ITSources, I2C_CR1_TXDMAEN) != RESET)
2400c67c:	687b      	ldr	r3, [r7, #4]
2400c67e:	0b9b      	lsrs	r3, r3, #14
2400c680:	f003 0301 	and.w	r3, r3, #1
2400c684:	2b00      	cmp	r3, #0
2400c686:	d076      	beq.n	2400c776 <I2C_Slave_ISR_DMA+0x286>
        {
          if (__HAL_DMA_GET_COUNTER(hi2c->hdmatx) == 0U)
2400c688:	68fb      	ldr	r3, [r7, #12]
2400c68a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400c68c:	681b      	ldr	r3, [r3, #0]
2400c68e:	4a4d      	ldr	r2, [pc, #308]	; (2400c7c4 <I2C_Slave_ISR_DMA+0x2d4>)
2400c690:	4293      	cmp	r3, r2
2400c692:	d059      	beq.n	2400c748 <I2C_Slave_ISR_DMA+0x258>
2400c694:	68fb      	ldr	r3, [r7, #12]
2400c696:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400c698:	681b      	ldr	r3, [r3, #0]
2400c69a:	4a4b      	ldr	r2, [pc, #300]	; (2400c7c8 <I2C_Slave_ISR_DMA+0x2d8>)
2400c69c:	4293      	cmp	r3, r2
2400c69e:	d053      	beq.n	2400c748 <I2C_Slave_ISR_DMA+0x258>
2400c6a0:	68fb      	ldr	r3, [r7, #12]
2400c6a2:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400c6a4:	681b      	ldr	r3, [r3, #0]
2400c6a6:	4a49      	ldr	r2, [pc, #292]	; (2400c7cc <I2C_Slave_ISR_DMA+0x2dc>)
2400c6a8:	4293      	cmp	r3, r2
2400c6aa:	d04d      	beq.n	2400c748 <I2C_Slave_ISR_DMA+0x258>
2400c6ac:	68fb      	ldr	r3, [r7, #12]
2400c6ae:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400c6b0:	681b      	ldr	r3, [r3, #0]
2400c6b2:	4a47      	ldr	r2, [pc, #284]	; (2400c7d0 <I2C_Slave_ISR_DMA+0x2e0>)
2400c6b4:	4293      	cmp	r3, r2
2400c6b6:	d047      	beq.n	2400c748 <I2C_Slave_ISR_DMA+0x258>
2400c6b8:	68fb      	ldr	r3, [r7, #12]
2400c6ba:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400c6bc:	681b      	ldr	r3, [r3, #0]
2400c6be:	4a45      	ldr	r2, [pc, #276]	; (2400c7d4 <I2C_Slave_ISR_DMA+0x2e4>)
2400c6c0:	4293      	cmp	r3, r2
2400c6c2:	d041      	beq.n	2400c748 <I2C_Slave_ISR_DMA+0x258>
2400c6c4:	68fb      	ldr	r3, [r7, #12]
2400c6c6:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400c6c8:	681b      	ldr	r3, [r3, #0]
2400c6ca:	4a43      	ldr	r2, [pc, #268]	; (2400c7d8 <I2C_Slave_ISR_DMA+0x2e8>)
2400c6cc:	4293      	cmp	r3, r2
2400c6ce:	d03b      	beq.n	2400c748 <I2C_Slave_ISR_DMA+0x258>
2400c6d0:	68fb      	ldr	r3, [r7, #12]
2400c6d2:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400c6d4:	681b      	ldr	r3, [r3, #0]
2400c6d6:	4a41      	ldr	r2, [pc, #260]	; (2400c7dc <I2C_Slave_ISR_DMA+0x2ec>)
2400c6d8:	4293      	cmp	r3, r2
2400c6da:	d035      	beq.n	2400c748 <I2C_Slave_ISR_DMA+0x258>
2400c6dc:	68fb      	ldr	r3, [r7, #12]
2400c6de:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400c6e0:	681b      	ldr	r3, [r3, #0]
2400c6e2:	4a3f      	ldr	r2, [pc, #252]	; (2400c7e0 <I2C_Slave_ISR_DMA+0x2f0>)
2400c6e4:	4293      	cmp	r3, r2
2400c6e6:	d02f      	beq.n	2400c748 <I2C_Slave_ISR_DMA+0x258>
2400c6e8:	68fb      	ldr	r3, [r7, #12]
2400c6ea:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400c6ec:	681b      	ldr	r3, [r3, #0]
2400c6ee:	4a3d      	ldr	r2, [pc, #244]	; (2400c7e4 <I2C_Slave_ISR_DMA+0x2f4>)
2400c6f0:	4293      	cmp	r3, r2
2400c6f2:	d029      	beq.n	2400c748 <I2C_Slave_ISR_DMA+0x258>
2400c6f4:	68fb      	ldr	r3, [r7, #12]
2400c6f6:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400c6f8:	681b      	ldr	r3, [r3, #0]
2400c6fa:	4a3b      	ldr	r2, [pc, #236]	; (2400c7e8 <I2C_Slave_ISR_DMA+0x2f8>)
2400c6fc:	4293      	cmp	r3, r2
2400c6fe:	d023      	beq.n	2400c748 <I2C_Slave_ISR_DMA+0x258>
2400c700:	68fb      	ldr	r3, [r7, #12]
2400c702:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400c704:	681b      	ldr	r3, [r3, #0]
2400c706:	4a39      	ldr	r2, [pc, #228]	; (2400c7ec <I2C_Slave_ISR_DMA+0x2fc>)
2400c708:	4293      	cmp	r3, r2
2400c70a:	d01d      	beq.n	2400c748 <I2C_Slave_ISR_DMA+0x258>
2400c70c:	68fb      	ldr	r3, [r7, #12]
2400c70e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400c710:	681b      	ldr	r3, [r3, #0]
2400c712:	4a37      	ldr	r2, [pc, #220]	; (2400c7f0 <I2C_Slave_ISR_DMA+0x300>)
2400c714:	4293      	cmp	r3, r2
2400c716:	d017      	beq.n	2400c748 <I2C_Slave_ISR_DMA+0x258>
2400c718:	68fb      	ldr	r3, [r7, #12]
2400c71a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400c71c:	681b      	ldr	r3, [r3, #0]
2400c71e:	4a35      	ldr	r2, [pc, #212]	; (2400c7f4 <I2C_Slave_ISR_DMA+0x304>)
2400c720:	4293      	cmp	r3, r2
2400c722:	d011      	beq.n	2400c748 <I2C_Slave_ISR_DMA+0x258>
2400c724:	68fb      	ldr	r3, [r7, #12]
2400c726:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400c728:	681b      	ldr	r3, [r3, #0]
2400c72a:	4a33      	ldr	r2, [pc, #204]	; (2400c7f8 <I2C_Slave_ISR_DMA+0x308>)
2400c72c:	4293      	cmp	r3, r2
2400c72e:	d00b      	beq.n	2400c748 <I2C_Slave_ISR_DMA+0x258>
2400c730:	68fb      	ldr	r3, [r7, #12]
2400c732:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400c734:	681b      	ldr	r3, [r3, #0]
2400c736:	4a31      	ldr	r2, [pc, #196]	; (2400c7fc <I2C_Slave_ISR_DMA+0x30c>)
2400c738:	4293      	cmp	r3, r2
2400c73a:	d005      	beq.n	2400c748 <I2C_Slave_ISR_DMA+0x258>
2400c73c:	68fb      	ldr	r3, [r7, #12]
2400c73e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400c740:	681b      	ldr	r3, [r3, #0]
2400c742:	4a2f      	ldr	r2, [pc, #188]	; (2400c800 <I2C_Slave_ISR_DMA+0x310>)
2400c744:	4293      	cmp	r3, r2
2400c746:	d109      	bne.n	2400c75c <I2C_Slave_ISR_DMA+0x26c>
2400c748:	68fb      	ldr	r3, [r7, #12]
2400c74a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400c74c:	681b      	ldr	r3, [r3, #0]
2400c74e:	685b      	ldr	r3, [r3, #4]
2400c750:	2b00      	cmp	r3, #0
2400c752:	bf0c      	ite	eq
2400c754:	2301      	moveq	r3, #1
2400c756:	2300      	movne	r3, #0
2400c758:	b2db      	uxtb	r3, r3
2400c75a:	e008      	b.n	2400c76e <I2C_Slave_ISR_DMA+0x27e>
2400c75c:	68fb      	ldr	r3, [r7, #12]
2400c75e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400c760:	681b      	ldr	r3, [r3, #0]
2400c762:	685b      	ldr	r3, [r3, #4]
2400c764:	2b00      	cmp	r3, #0
2400c766:	bf0c      	ite	eq
2400c768:	2301      	moveq	r3, #1
2400c76a:	2300      	movne	r3, #0
2400c76c:	b2db      	uxtb	r3, r3
2400c76e:	2b00      	cmp	r3, #0
2400c770:	d001      	beq.n	2400c776 <I2C_Slave_ISR_DMA+0x286>
          {
            treatdmanack = 1U;
2400c772:	2301      	movs	r3, #1
2400c774:	61fb      	str	r3, [r7, #28]
          }
        }
      }

      if (treatdmanack == 1U)
2400c776:	69fb      	ldr	r3, [r7, #28]
2400c778:	2b01      	cmp	r3, #1
2400c77a:	d148      	bne.n	2400c80e <I2C_Slave_ISR_DMA+0x31e>
      {
        if ((hi2c->State == HAL_I2C_STATE_LISTEN) && (tmpoptions == I2C_FIRST_AND_LAST_FRAME)) /* Same action must be done for (tmpoptions == I2C_LAST_FRAME) which removed for Warning[Pa134]: left and right operands are identical */
2400c77c:	68fb      	ldr	r3, [r7, #12]
2400c77e:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400c782:	b2db      	uxtb	r3, r3
2400c784:	2b28      	cmp	r3, #40	; 0x28
2400c786:	d108      	bne.n	2400c79a <I2C_Slave_ISR_DMA+0x2aa>
2400c788:	69bb      	ldr	r3, [r7, #24]
2400c78a:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
2400c78e:	d104      	bne.n	2400c79a <I2C_Slave_ISR_DMA+0x2aa>
        {
          /* Call I2C Listen complete process */
          I2C_ITListenCplt(hi2c, ITFlags);
2400c790:	68b9      	ldr	r1, [r7, #8]
2400c792:	68f8      	ldr	r0, [r7, #12]
2400c794:	f000 fd14 	bl	2400d1c0 <I2C_ITListenCplt>
2400c798:	e068      	b.n	2400c86c <I2C_Slave_ISR_DMA+0x37c>
        }
        else if ((hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN) && (tmpoptions != I2C_NO_OPTION_FRAME))
2400c79a:	68fb      	ldr	r3, [r7, #12]
2400c79c:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400c7a0:	b2db      	uxtb	r3, r3
2400c7a2:	2b29      	cmp	r3, #41	; 0x29
2400c7a4:	d12e      	bne.n	2400c804 <I2C_Slave_ISR_DMA+0x314>
2400c7a6:	69bb      	ldr	r3, [r7, #24]
2400c7a8:	f513 3f80 	cmn.w	r3, #65536	; 0x10000
2400c7ac:	d02a      	beq.n	2400c804 <I2C_Slave_ISR_DMA+0x314>
        {
          /* Clear NACK Flag */
          __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
2400c7ae:	68fb      	ldr	r3, [r7, #12]
2400c7b0:	681b      	ldr	r3, [r3, #0]
2400c7b2:	2210      	movs	r2, #16
2400c7b4:	61da      	str	r2, [r3, #28]

          /* Flush TX register */
          I2C_Flush_TXDR(hi2c);
2400c7b6:	68f8      	ldr	r0, [r7, #12]
2400c7b8:	f000 fe4f 	bl	2400d45a <I2C_Flush_TXDR>

          /* Last Byte is Transmitted */
          /* Call I2C Slave Sequential complete process */
          I2C_ITSlaveSeqCplt(hi2c);
2400c7bc:	68f8      	ldr	r0, [r7, #12]
2400c7be:	f000 f9e0 	bl	2400cb82 <I2C_ITSlaveSeqCplt>
2400c7c2:	e053      	b.n	2400c86c <I2C_Slave_ISR_DMA+0x37c>
2400c7c4:	40020010 	.word	0x40020010
2400c7c8:	40020028 	.word	0x40020028
2400c7cc:	40020040 	.word	0x40020040
2400c7d0:	40020058 	.word	0x40020058
2400c7d4:	40020070 	.word	0x40020070
2400c7d8:	40020088 	.word	0x40020088
2400c7dc:	400200a0 	.word	0x400200a0
2400c7e0:	400200b8 	.word	0x400200b8
2400c7e4:	40020410 	.word	0x40020410
2400c7e8:	40020428 	.word	0x40020428
2400c7ec:	40020440 	.word	0x40020440
2400c7f0:	40020458 	.word	0x40020458
2400c7f4:	40020470 	.word	0x40020470
2400c7f8:	40020488 	.word	0x40020488
2400c7fc:	400204a0 	.word	0x400204a0
2400c800:	400204b8 	.word	0x400204b8
        }
        else
        {
          /* Clear NACK Flag */
          __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
2400c804:	68fb      	ldr	r3, [r7, #12]
2400c806:	681b      	ldr	r3, [r3, #0]
2400c808:	2210      	movs	r2, #16
2400c80a:	61da      	str	r2, [r3, #28]
      if (treatdmanack == 1U)
2400c80c:	e034      	b.n	2400c878 <I2C_Slave_ISR_DMA+0x388>
      }
      else
      {
        /* if no, error use case, a Non-Acknowledge of last Data is generated by the MASTER*/
        /* Clear NACK Flag */
        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
2400c80e:	68fb      	ldr	r3, [r7, #12]
2400c810:	681b      	ldr	r3, [r3, #0]
2400c812:	2210      	movs	r2, #16
2400c814:	61da      	str	r2, [r3, #28]

        /* Set ErrorCode corresponding to a Non-Acknowledge */
        hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
2400c816:	68fb      	ldr	r3, [r7, #12]
2400c818:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400c81a:	f043 0204 	orr.w	r2, r3, #4
2400c81e:	68fb      	ldr	r3, [r7, #12]
2400c820:	645a      	str	r2, [r3, #68]	; 0x44

        /* Store current hi2c->State, solve MISRA2012-Rule-13.5 */
        tmpstate = hi2c->State;
2400c822:	68fb      	ldr	r3, [r7, #12]
2400c824:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400c828:	75fb      	strb	r3, [r7, #23]

        if ((tmpoptions == I2C_FIRST_FRAME) || (tmpoptions == I2C_NEXT_FRAME))
2400c82a:	69bb      	ldr	r3, [r7, #24]
2400c82c:	2b00      	cmp	r3, #0
2400c82e:	d003      	beq.n	2400c838 <I2C_Slave_ISR_DMA+0x348>
2400c830:	69bb      	ldr	r3, [r7, #24]
2400c832:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
2400c836:	d11f      	bne.n	2400c878 <I2C_Slave_ISR_DMA+0x388>
        {
          if ((tmpstate == HAL_I2C_STATE_BUSY_TX) || (tmpstate == HAL_I2C_STATE_BUSY_TX_LISTEN))
2400c838:	7dfb      	ldrb	r3, [r7, #23]
2400c83a:	2b21      	cmp	r3, #33	; 0x21
2400c83c:	d002      	beq.n	2400c844 <I2C_Slave_ISR_DMA+0x354>
2400c83e:	7dfb      	ldrb	r3, [r7, #23]
2400c840:	2b29      	cmp	r3, #41	; 0x29
2400c842:	d103      	bne.n	2400c84c <I2C_Slave_ISR_DMA+0x35c>
          {
            hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_TX;
2400c844:	68fb      	ldr	r3, [r7, #12]
2400c846:	2221      	movs	r2, #33	; 0x21
2400c848:	631a      	str	r2, [r3, #48]	; 0x30
2400c84a:	e008      	b.n	2400c85e <I2C_Slave_ISR_DMA+0x36e>
          }
          else if ((tmpstate == HAL_I2C_STATE_BUSY_RX) || (tmpstate == HAL_I2C_STATE_BUSY_RX_LISTEN))
2400c84c:	7dfb      	ldrb	r3, [r7, #23]
2400c84e:	2b22      	cmp	r3, #34	; 0x22
2400c850:	d002      	beq.n	2400c858 <I2C_Slave_ISR_DMA+0x368>
2400c852:	7dfb      	ldrb	r3, [r7, #23]
2400c854:	2b2a      	cmp	r3, #42	; 0x2a
2400c856:	d102      	bne.n	2400c85e <I2C_Slave_ISR_DMA+0x36e>
          {
            hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_RX;
2400c858:	68fb      	ldr	r3, [r7, #12]
2400c85a:	2222      	movs	r2, #34	; 0x22
2400c85c:	631a      	str	r2, [r3, #48]	; 0x30
          {
            /* Do nothing */
          }

          /* Call the corresponding callback to inform upper layer of End of Transfer */
          I2C_ITError(hi2c, hi2c->ErrorCode);
2400c85e:	68fb      	ldr	r3, [r7, #12]
2400c860:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400c862:	4619      	mov	r1, r3
2400c864:	68f8      	ldr	r0, [r7, #12]
2400c866:	f000 fd01 	bl	2400d26c <I2C_ITError>
      if (treatdmanack == 1U)
2400c86a:	e005      	b.n	2400c878 <I2C_Slave_ISR_DMA+0x388>
2400c86c:	e004      	b.n	2400c878 <I2C_Slave_ISR_DMA+0x388>
      }
    }
    else
    {
      /* Only Clear NACK Flag, no DMA treatment is pending */
      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
2400c86e:	68fb      	ldr	r3, [r7, #12]
2400c870:	681b      	ldr	r3, [r3, #0]
2400c872:	2210      	movs	r2, #16
2400c874:	61da      	str	r2, [r3, #28]
    if ((I2C_CHECK_IT_SOURCE(ITSources, I2C_CR1_TXDMAEN) != RESET) ||
2400c876:	e011      	b.n	2400c89c <I2C_Slave_ISR_DMA+0x3ac>
      if (treatdmanack == 1U)
2400c878:	bf00      	nop
    if ((I2C_CHECK_IT_SOURCE(ITSources, I2C_CR1_TXDMAEN) != RESET) ||
2400c87a:	e00f      	b.n	2400c89c <I2C_Slave_ISR_DMA+0x3ac>
    }
  }
  else if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_ADDR) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_ADDRI) != RESET))
2400c87c:	68bb      	ldr	r3, [r7, #8]
2400c87e:	08db      	lsrs	r3, r3, #3
2400c880:	f003 0301 	and.w	r3, r3, #1
2400c884:	2b00      	cmp	r3, #0
2400c886:	d009      	beq.n	2400c89c <I2C_Slave_ISR_DMA+0x3ac>
2400c888:	687b      	ldr	r3, [r7, #4]
2400c88a:	08db      	lsrs	r3, r3, #3
2400c88c:	f003 0301 	and.w	r3, r3, #1
2400c890:	2b00      	cmp	r3, #0
2400c892:	d003      	beq.n	2400c89c <I2C_Slave_ISR_DMA+0x3ac>
  {
    I2C_ITAddrCplt(hi2c, ITFlags);
2400c894:	68b9      	ldr	r1, [r7, #8]
2400c896:	68f8      	ldr	r0, [r7, #12]
2400c898:	f000 f8b2 	bl	2400ca00 <I2C_ITAddrCplt>
  {
    /* Nothing to do */
  }

  /* Process Unlocked */
  __HAL_UNLOCK(hi2c);
2400c89c:	68fb      	ldr	r3, [r7, #12]
2400c89e:	2200      	movs	r2, #0
2400c8a0:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  return HAL_OK;
2400c8a4:	2300      	movs	r3, #0
}
2400c8a6:	4618      	mov	r0, r3
2400c8a8:	3720      	adds	r7, #32
2400c8aa:	46bd      	mov	sp, r7
2400c8ac:	bd80      	pop	{r7, pc}
2400c8ae:	bf00      	nop

2400c8b0 <I2C_RequestMemoryWrite>:
  * @param  Timeout Timeout duration
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_RequestMemoryWrite(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint32_t Timeout, uint32_t Tickstart)
{
2400c8b0:	b580      	push	{r7, lr}
2400c8b2:	b086      	sub	sp, #24
2400c8b4:	af02      	add	r7, sp, #8
2400c8b6:	60f8      	str	r0, [r7, #12]
2400c8b8:	4608      	mov	r0, r1
2400c8ba:	4611      	mov	r1, r2
2400c8bc:	461a      	mov	r2, r3
2400c8be:	4603      	mov	r3, r0
2400c8c0:	817b      	strh	r3, [r7, #10]
2400c8c2:	460b      	mov	r3, r1
2400c8c4:	813b      	strh	r3, [r7, #8]
2400c8c6:	4613      	mov	r3, r2
2400c8c8:	80fb      	strh	r3, [r7, #6]
  I2C_TransferConfig(hi2c, DevAddress, (uint8_t)MemAddSize, I2C_RELOAD_MODE, I2C_GENERATE_START_WRITE);
2400c8ca:	88fb      	ldrh	r3, [r7, #6]
2400c8cc:	b2da      	uxtb	r2, r3
2400c8ce:	8979      	ldrh	r1, [r7, #10]
2400c8d0:	4b20      	ldr	r3, [pc, #128]	; (2400c954 <I2C_RequestMemoryWrite+0xa4>)
2400c8d2:	9300      	str	r3, [sp, #0]
2400c8d4:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
2400c8d8:	68f8      	ldr	r0, [r7, #12]
2400c8da:	f001 fa2f 	bl	2400dd3c <I2C_TransferConfig>

  /* Wait until TXIS flag is set */
  if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
2400c8de:	69fa      	ldr	r2, [r7, #28]
2400c8e0:	69b9      	ldr	r1, [r7, #24]
2400c8e2:	68f8      	ldr	r0, [r7, #12]
2400c8e4:	f001 f8dc 	bl	2400daa0 <I2C_WaitOnTXISFlagUntilTimeout>
2400c8e8:	4603      	mov	r3, r0
2400c8ea:	2b00      	cmp	r3, #0
2400c8ec:	d001      	beq.n	2400c8f2 <I2C_RequestMemoryWrite+0x42>
  {
    return HAL_ERROR;
2400c8ee:	2301      	movs	r3, #1
2400c8f0:	e02c      	b.n	2400c94c <I2C_RequestMemoryWrite+0x9c>
  }

  /* If Memory address size is 8Bit */
  if (MemAddSize == I2C_MEMADD_SIZE_8BIT)
2400c8f2:	88fb      	ldrh	r3, [r7, #6]
2400c8f4:	2b01      	cmp	r3, #1
2400c8f6:	d105      	bne.n	2400c904 <I2C_RequestMemoryWrite+0x54>
  {
    /* Send Memory Address */
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
2400c8f8:	893b      	ldrh	r3, [r7, #8]
2400c8fa:	b2da      	uxtb	r2, r3
2400c8fc:	68fb      	ldr	r3, [r7, #12]
2400c8fe:	681b      	ldr	r3, [r3, #0]
2400c900:	629a      	str	r2, [r3, #40]	; 0x28
2400c902:	e015      	b.n	2400c930 <I2C_RequestMemoryWrite+0x80>
  }
  /* If Memory address size is 16Bit */
  else
  {
    /* Send MSB of Memory Address */
    hi2c->Instance->TXDR = I2C_MEM_ADD_MSB(MemAddress);
2400c904:	893b      	ldrh	r3, [r7, #8]
2400c906:	0a1b      	lsrs	r3, r3, #8
2400c908:	b29b      	uxth	r3, r3
2400c90a:	b2da      	uxtb	r2, r3
2400c90c:	68fb      	ldr	r3, [r7, #12]
2400c90e:	681b      	ldr	r3, [r3, #0]
2400c910:	629a      	str	r2, [r3, #40]	; 0x28

    /* Wait until TXIS flag is set */
    if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
2400c912:	69fa      	ldr	r2, [r7, #28]
2400c914:	69b9      	ldr	r1, [r7, #24]
2400c916:	68f8      	ldr	r0, [r7, #12]
2400c918:	f001 f8c2 	bl	2400daa0 <I2C_WaitOnTXISFlagUntilTimeout>
2400c91c:	4603      	mov	r3, r0
2400c91e:	2b00      	cmp	r3, #0
2400c920:	d001      	beq.n	2400c926 <I2C_RequestMemoryWrite+0x76>
    {
      return HAL_ERROR;
2400c922:	2301      	movs	r3, #1
2400c924:	e012      	b.n	2400c94c <I2C_RequestMemoryWrite+0x9c>
    }

    /* Send LSB of Memory Address */
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
2400c926:	893b      	ldrh	r3, [r7, #8]
2400c928:	b2da      	uxtb	r2, r3
2400c92a:	68fb      	ldr	r3, [r7, #12]
2400c92c:	681b      	ldr	r3, [r3, #0]
2400c92e:	629a      	str	r2, [r3, #40]	; 0x28
  }

  /* Wait until TCR flag is set */
  if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, Tickstart) != HAL_OK)
2400c930:	69fb      	ldr	r3, [r7, #28]
2400c932:	9300      	str	r3, [sp, #0]
2400c934:	69bb      	ldr	r3, [r7, #24]
2400c936:	2200      	movs	r2, #0
2400c938:	2180      	movs	r1, #128	; 0x80
2400c93a:	68f8      	ldr	r0, [r7, #12]
2400c93c:	f001 f870 	bl	2400da20 <I2C_WaitOnFlagUntilTimeout>
2400c940:	4603      	mov	r3, r0
2400c942:	2b00      	cmp	r3, #0
2400c944:	d001      	beq.n	2400c94a <I2C_RequestMemoryWrite+0x9a>
  {
    return HAL_ERROR;
2400c946:	2301      	movs	r3, #1
2400c948:	e000      	b.n	2400c94c <I2C_RequestMemoryWrite+0x9c>
  }

  return HAL_OK;
2400c94a:	2300      	movs	r3, #0
}
2400c94c:	4618      	mov	r0, r3
2400c94e:	3710      	adds	r7, #16
2400c950:	46bd      	mov	sp, r7
2400c952:	bd80      	pop	{r7, pc}
2400c954:	80002000 	.word	0x80002000

2400c958 <I2C_RequestMemoryRead>:
  * @param  Timeout Timeout duration
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_RequestMemoryRead(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint32_t Timeout, uint32_t Tickstart)
{
2400c958:	b580      	push	{r7, lr}
2400c95a:	b086      	sub	sp, #24
2400c95c:	af02      	add	r7, sp, #8
2400c95e:	60f8      	str	r0, [r7, #12]
2400c960:	4608      	mov	r0, r1
2400c962:	4611      	mov	r1, r2
2400c964:	461a      	mov	r2, r3
2400c966:	4603      	mov	r3, r0
2400c968:	817b      	strh	r3, [r7, #10]
2400c96a:	460b      	mov	r3, r1
2400c96c:	813b      	strh	r3, [r7, #8]
2400c96e:	4613      	mov	r3, r2
2400c970:	80fb      	strh	r3, [r7, #6]
  I2C_TransferConfig(hi2c, DevAddress, (uint8_t)MemAddSize, I2C_SOFTEND_MODE, I2C_GENERATE_START_WRITE);
2400c972:	88fb      	ldrh	r3, [r7, #6]
2400c974:	b2da      	uxtb	r2, r3
2400c976:	8979      	ldrh	r1, [r7, #10]
2400c978:	4b20      	ldr	r3, [pc, #128]	; (2400c9fc <I2C_RequestMemoryRead+0xa4>)
2400c97a:	9300      	str	r3, [sp, #0]
2400c97c:	2300      	movs	r3, #0
2400c97e:	68f8      	ldr	r0, [r7, #12]
2400c980:	f001 f9dc 	bl	2400dd3c <I2C_TransferConfig>

  /* Wait until TXIS flag is set */
  if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
2400c984:	69fa      	ldr	r2, [r7, #28]
2400c986:	69b9      	ldr	r1, [r7, #24]
2400c988:	68f8      	ldr	r0, [r7, #12]
2400c98a:	f001 f889 	bl	2400daa0 <I2C_WaitOnTXISFlagUntilTimeout>
2400c98e:	4603      	mov	r3, r0
2400c990:	2b00      	cmp	r3, #0
2400c992:	d001      	beq.n	2400c998 <I2C_RequestMemoryRead+0x40>
  {
    return HAL_ERROR;
2400c994:	2301      	movs	r3, #1
2400c996:	e02c      	b.n	2400c9f2 <I2C_RequestMemoryRead+0x9a>
  }

  /* If Memory address size is 8Bit */
  if (MemAddSize == I2C_MEMADD_SIZE_8BIT)
2400c998:	88fb      	ldrh	r3, [r7, #6]
2400c99a:	2b01      	cmp	r3, #1
2400c99c:	d105      	bne.n	2400c9aa <I2C_RequestMemoryRead+0x52>
  {
    /* Send Memory Address */
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
2400c99e:	893b      	ldrh	r3, [r7, #8]
2400c9a0:	b2da      	uxtb	r2, r3
2400c9a2:	68fb      	ldr	r3, [r7, #12]
2400c9a4:	681b      	ldr	r3, [r3, #0]
2400c9a6:	629a      	str	r2, [r3, #40]	; 0x28
2400c9a8:	e015      	b.n	2400c9d6 <I2C_RequestMemoryRead+0x7e>
  }
  /* If Memory address size is 16Bit */
  else
  {
    /* Send MSB of Memory Address */
    hi2c->Instance->TXDR = I2C_MEM_ADD_MSB(MemAddress);
2400c9aa:	893b      	ldrh	r3, [r7, #8]
2400c9ac:	0a1b      	lsrs	r3, r3, #8
2400c9ae:	b29b      	uxth	r3, r3
2400c9b0:	b2da      	uxtb	r2, r3
2400c9b2:	68fb      	ldr	r3, [r7, #12]
2400c9b4:	681b      	ldr	r3, [r3, #0]
2400c9b6:	629a      	str	r2, [r3, #40]	; 0x28

    /* Wait until TXIS flag is set */
    if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
2400c9b8:	69fa      	ldr	r2, [r7, #28]
2400c9ba:	69b9      	ldr	r1, [r7, #24]
2400c9bc:	68f8      	ldr	r0, [r7, #12]
2400c9be:	f001 f86f 	bl	2400daa0 <I2C_WaitOnTXISFlagUntilTimeout>
2400c9c2:	4603      	mov	r3, r0
2400c9c4:	2b00      	cmp	r3, #0
2400c9c6:	d001      	beq.n	2400c9cc <I2C_RequestMemoryRead+0x74>
    {
      return HAL_ERROR;
2400c9c8:	2301      	movs	r3, #1
2400c9ca:	e012      	b.n	2400c9f2 <I2C_RequestMemoryRead+0x9a>
    }

    /* Send LSB of Memory Address */
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
2400c9cc:	893b      	ldrh	r3, [r7, #8]
2400c9ce:	b2da      	uxtb	r2, r3
2400c9d0:	68fb      	ldr	r3, [r7, #12]
2400c9d2:	681b      	ldr	r3, [r3, #0]
2400c9d4:	629a      	str	r2, [r3, #40]	; 0x28
  }

  /* Wait until TC flag is set */
  if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TC, RESET, Timeout, Tickstart) != HAL_OK)
2400c9d6:	69fb      	ldr	r3, [r7, #28]
2400c9d8:	9300      	str	r3, [sp, #0]
2400c9da:	69bb      	ldr	r3, [r7, #24]
2400c9dc:	2200      	movs	r2, #0
2400c9de:	2140      	movs	r1, #64	; 0x40
2400c9e0:	68f8      	ldr	r0, [r7, #12]
2400c9e2:	f001 f81d 	bl	2400da20 <I2C_WaitOnFlagUntilTimeout>
2400c9e6:	4603      	mov	r3, r0
2400c9e8:	2b00      	cmp	r3, #0
2400c9ea:	d001      	beq.n	2400c9f0 <I2C_RequestMemoryRead+0x98>
  {
    return HAL_ERROR;
2400c9ec:	2301      	movs	r3, #1
2400c9ee:	e000      	b.n	2400c9f2 <I2C_RequestMemoryRead+0x9a>
  }

  return HAL_OK;
2400c9f0:	2300      	movs	r3, #0
}
2400c9f2:	4618      	mov	r0, r3
2400c9f4:	3710      	adds	r7, #16
2400c9f6:	46bd      	mov	sp, r7
2400c9f8:	bd80      	pop	{r7, pc}
2400c9fa:	bf00      	nop
2400c9fc:	80002000 	.word	0x80002000

2400ca00 <I2C_ITAddrCplt>:
  * @param  hi2c I2C handle.
  * @param  ITFlags Interrupt flags to handle.
  * @retval None
  */
static void I2C_ITAddrCplt(I2C_HandleTypeDef *hi2c, uint32_t ITFlags)
{
2400ca00:	b580      	push	{r7, lr}
2400ca02:	b084      	sub	sp, #16
2400ca04:	af00      	add	r7, sp, #0
2400ca06:	6078      	str	r0, [r7, #4]
2400ca08:	6039      	str	r1, [r7, #0]

  /* Prevent unused argument(s) compilation warning */
  UNUSED(ITFlags);

  /* In case of Listen state, need to inform upper layer of address match code event */
  if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) == (uint32_t)HAL_I2C_STATE_LISTEN)
2400ca0a:	687b      	ldr	r3, [r7, #4]
2400ca0c:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400ca10:	b2db      	uxtb	r3, r3
2400ca12:	f003 0328 	and.w	r3, r3, #40	; 0x28
2400ca16:	2b28      	cmp	r3, #40	; 0x28
2400ca18:	d16a      	bne.n	2400caf0 <I2C_ITAddrCplt+0xf0>
  {
    transferdirection = I2C_GET_DIR(hi2c);
2400ca1a:	687b      	ldr	r3, [r7, #4]
2400ca1c:	681b      	ldr	r3, [r3, #0]
2400ca1e:	699b      	ldr	r3, [r3, #24]
2400ca20:	0c1b      	lsrs	r3, r3, #16
2400ca22:	b2db      	uxtb	r3, r3
2400ca24:	f003 0301 	and.w	r3, r3, #1
2400ca28:	73fb      	strb	r3, [r7, #15]
    slaveaddrcode     = I2C_GET_ADDR_MATCH(hi2c);
2400ca2a:	687b      	ldr	r3, [r7, #4]
2400ca2c:	681b      	ldr	r3, [r3, #0]
2400ca2e:	699b      	ldr	r3, [r3, #24]
2400ca30:	0c1b      	lsrs	r3, r3, #16
2400ca32:	b29b      	uxth	r3, r3
2400ca34:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
2400ca38:	81bb      	strh	r3, [r7, #12]
    ownadd1code       = I2C_GET_OWN_ADDRESS1(hi2c);
2400ca3a:	687b      	ldr	r3, [r7, #4]
2400ca3c:	681b      	ldr	r3, [r3, #0]
2400ca3e:	689b      	ldr	r3, [r3, #8]
2400ca40:	b29b      	uxth	r3, r3
2400ca42:	f3c3 0309 	ubfx	r3, r3, #0, #10
2400ca46:	817b      	strh	r3, [r7, #10]
    ownadd2code       = I2C_GET_OWN_ADDRESS2(hi2c);
2400ca48:	687b      	ldr	r3, [r7, #4]
2400ca4a:	681b      	ldr	r3, [r3, #0]
2400ca4c:	68db      	ldr	r3, [r3, #12]
2400ca4e:	b29b      	uxth	r3, r3
2400ca50:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
2400ca54:	813b      	strh	r3, [r7, #8]

    /* If 10bits addressing mode is selected */
    if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
2400ca56:	687b      	ldr	r3, [r7, #4]
2400ca58:	68db      	ldr	r3, [r3, #12]
2400ca5a:	2b02      	cmp	r3, #2
2400ca5c:	d138      	bne.n	2400cad0 <I2C_ITAddrCplt+0xd0>
    {
      if ((slaveaddrcode & SlaveAddr_MSK) == ((ownadd1code >> SlaveAddr_SHIFT) & SlaveAddr_MSK))
2400ca5e:	897b      	ldrh	r3, [r7, #10]
2400ca60:	09db      	lsrs	r3, r3, #7
2400ca62:	b29a      	uxth	r2, r3
2400ca64:	89bb      	ldrh	r3, [r7, #12]
2400ca66:	4053      	eors	r3, r2
2400ca68:	b29b      	uxth	r3, r3
2400ca6a:	f003 0306 	and.w	r3, r3, #6
2400ca6e:	2b00      	cmp	r3, #0
2400ca70:	d11c      	bne.n	2400caac <I2C_ITAddrCplt+0xac>
      {
        slaveaddrcode = ownadd1code;
2400ca72:	897b      	ldrh	r3, [r7, #10]
2400ca74:	81bb      	strh	r3, [r7, #12]
        hi2c->AddrEventCount++;
2400ca76:	687b      	ldr	r3, [r7, #4]
2400ca78:	6c9b      	ldr	r3, [r3, #72]	; 0x48
2400ca7a:	1c5a      	adds	r2, r3, #1
2400ca7c:	687b      	ldr	r3, [r7, #4]
2400ca7e:	649a      	str	r2, [r3, #72]	; 0x48
        if (hi2c->AddrEventCount == 2U)
2400ca80:	687b      	ldr	r3, [r7, #4]
2400ca82:	6c9b      	ldr	r3, [r3, #72]	; 0x48
2400ca84:	2b02      	cmp	r3, #2
2400ca86:	d13b      	bne.n	2400cb00 <I2C_ITAddrCplt+0x100>
        {
          /* Reset Address Event counter */
          hi2c->AddrEventCount = 0U;
2400ca88:	687b      	ldr	r3, [r7, #4]
2400ca8a:	2200      	movs	r2, #0
2400ca8c:	649a      	str	r2, [r3, #72]	; 0x48

          /* Clear ADDR flag */
          __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
2400ca8e:	687b      	ldr	r3, [r7, #4]
2400ca90:	681b      	ldr	r3, [r3, #0]
2400ca92:	2208      	movs	r2, #8
2400ca94:	61da      	str	r2, [r3, #28]

          /* Process Unlocked */
          __HAL_UNLOCK(hi2c);
2400ca96:	687b      	ldr	r3, [r7, #4]
2400ca98:	2200      	movs	r2, #0
2400ca9a:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

          /* Call Slave Addr callback */
#if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
          hi2c->AddrCallback(hi2c, transferdirection, slaveaddrcode);
#else
          HAL_I2C_AddrCallback(hi2c, transferdirection, slaveaddrcode);
2400ca9e:	89ba      	ldrh	r2, [r7, #12]
2400caa0:	7bfb      	ldrb	r3, [r7, #15]
2400caa2:	4619      	mov	r1, r3
2400caa4:	6878      	ldr	r0, [r7, #4]
2400caa6:	f7ff f99c 	bl	2400bde2 <HAL_I2C_AddrCallback>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
  }
}
2400caaa:	e029      	b.n	2400cb00 <I2C_ITAddrCplt+0x100>
        slaveaddrcode = ownadd2code;
2400caac:	893b      	ldrh	r3, [r7, #8]
2400caae:	81bb      	strh	r3, [r7, #12]
        I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT);
2400cab0:	f44f 4100 	mov.w	r1, #32768	; 0x8000
2400cab4:	6878      	ldr	r0, [r7, #4]
2400cab6:	f001 f9d3 	bl	2400de60 <I2C_Disable_IRQ>
        __HAL_UNLOCK(hi2c);
2400caba:	687b      	ldr	r3, [r7, #4]
2400cabc:	2200      	movs	r2, #0
2400cabe:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
        HAL_I2C_AddrCallback(hi2c, transferdirection, slaveaddrcode);
2400cac2:	89ba      	ldrh	r2, [r7, #12]
2400cac4:	7bfb      	ldrb	r3, [r7, #15]
2400cac6:	4619      	mov	r1, r3
2400cac8:	6878      	ldr	r0, [r7, #4]
2400caca:	f7ff f98a 	bl	2400bde2 <HAL_I2C_AddrCallback>
}
2400cace:	e017      	b.n	2400cb00 <I2C_ITAddrCplt+0x100>
      I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT);
2400cad0:	f44f 4100 	mov.w	r1, #32768	; 0x8000
2400cad4:	6878      	ldr	r0, [r7, #4]
2400cad6:	f001 f9c3 	bl	2400de60 <I2C_Disable_IRQ>
      __HAL_UNLOCK(hi2c);
2400cada:	687b      	ldr	r3, [r7, #4]
2400cadc:	2200      	movs	r2, #0
2400cade:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      HAL_I2C_AddrCallback(hi2c, transferdirection, slaveaddrcode);
2400cae2:	89ba      	ldrh	r2, [r7, #12]
2400cae4:	7bfb      	ldrb	r3, [r7, #15]
2400cae6:	4619      	mov	r1, r3
2400cae8:	6878      	ldr	r0, [r7, #4]
2400caea:	f7ff f97a 	bl	2400bde2 <HAL_I2C_AddrCallback>
}
2400caee:	e007      	b.n	2400cb00 <I2C_ITAddrCplt+0x100>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
2400caf0:	687b      	ldr	r3, [r7, #4]
2400caf2:	681b      	ldr	r3, [r3, #0]
2400caf4:	2208      	movs	r2, #8
2400caf6:	61da      	str	r2, [r3, #28]
    __HAL_UNLOCK(hi2c);
2400caf8:	687b      	ldr	r3, [r7, #4]
2400cafa:	2200      	movs	r2, #0
2400cafc:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
}
2400cb00:	bf00      	nop
2400cb02:	3710      	adds	r7, #16
2400cb04:	46bd      	mov	sp, r7
2400cb06:	bd80      	pop	{r7, pc}

2400cb08 <I2C_ITMasterSeqCplt>:
  * @brief  I2C Master sequential complete process.
  * @param  hi2c I2C handle.
  * @retval None
  */
static void I2C_ITMasterSeqCplt(I2C_HandleTypeDef *hi2c)
{
2400cb08:	b580      	push	{r7, lr}
2400cb0a:	b082      	sub	sp, #8
2400cb0c:	af00      	add	r7, sp, #0
2400cb0e:	6078      	str	r0, [r7, #4]
  /* Reset I2C handle mode */
  hi2c->Mode = HAL_I2C_MODE_NONE;
2400cb10:	687b      	ldr	r3, [r7, #4]
2400cb12:	2200      	movs	r2, #0
2400cb14:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

  /* No Generate Stop, to permit restart mode */
  /* The stop will be done at the end of transfer, when I2C_AUTOEND_MODE enable */
  if (hi2c->State == HAL_I2C_STATE_BUSY_TX)
2400cb18:	687b      	ldr	r3, [r7, #4]
2400cb1a:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400cb1e:	b2db      	uxtb	r3, r3
2400cb20:	2b21      	cmp	r3, #33	; 0x21
2400cb22:	d115      	bne.n	2400cb50 <I2C_ITMasterSeqCplt+0x48>
  {
    hi2c->State         = HAL_I2C_STATE_READY;
2400cb24:	687b      	ldr	r3, [r7, #4]
2400cb26:	2220      	movs	r2, #32
2400cb28:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->PreviousState = I2C_STATE_MASTER_BUSY_TX;
2400cb2c:	687b      	ldr	r3, [r7, #4]
2400cb2e:	2211      	movs	r2, #17
2400cb30:	631a      	str	r2, [r3, #48]	; 0x30
    hi2c->XferISR       = NULL;
2400cb32:	687b      	ldr	r3, [r7, #4]
2400cb34:	2200      	movs	r2, #0
2400cb36:	635a      	str	r2, [r3, #52]	; 0x34

    /* Disable Interrupts */
    I2C_Disable_IRQ(hi2c, I2C_XFER_TX_IT);
2400cb38:	2101      	movs	r1, #1
2400cb3a:	6878      	ldr	r0, [r7, #4]
2400cb3c:	f001 f990 	bl	2400de60 <I2C_Disable_IRQ>

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
2400cb40:	687b      	ldr	r3, [r7, #4]
2400cb42:	2200      	movs	r2, #0
2400cb44:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Call the corresponding callback to inform upper layer of End of Transfer */
#if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
    hi2c->MasterTxCpltCallback(hi2c);
#else
    HAL_I2C_MasterTxCpltCallback(hi2c);
2400cb48:	6878      	ldr	r0, [r7, #4]
2400cb4a:	f7ff f922 	bl	2400bd92 <HAL_I2C_MasterTxCpltCallback>
    hi2c->MasterRxCpltCallback(hi2c);
#else
    HAL_I2C_MasterRxCpltCallback(hi2c);
#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
  }
}
2400cb4e:	e014      	b.n	2400cb7a <I2C_ITMasterSeqCplt+0x72>
    hi2c->State         = HAL_I2C_STATE_READY;
2400cb50:	687b      	ldr	r3, [r7, #4]
2400cb52:	2220      	movs	r2, #32
2400cb54:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->PreviousState = I2C_STATE_MASTER_BUSY_RX;
2400cb58:	687b      	ldr	r3, [r7, #4]
2400cb5a:	2212      	movs	r2, #18
2400cb5c:	631a      	str	r2, [r3, #48]	; 0x30
    hi2c->XferISR       = NULL;
2400cb5e:	687b      	ldr	r3, [r7, #4]
2400cb60:	2200      	movs	r2, #0
2400cb62:	635a      	str	r2, [r3, #52]	; 0x34
    I2C_Disable_IRQ(hi2c, I2C_XFER_RX_IT);
2400cb64:	2102      	movs	r1, #2
2400cb66:	6878      	ldr	r0, [r7, #4]
2400cb68:	f001 f97a 	bl	2400de60 <I2C_Disable_IRQ>
    __HAL_UNLOCK(hi2c);
2400cb6c:	687b      	ldr	r3, [r7, #4]
2400cb6e:	2200      	movs	r2, #0
2400cb70:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
    HAL_I2C_MasterRxCpltCallback(hi2c);
2400cb74:	6878      	ldr	r0, [r7, #4]
2400cb76:	f7ff f916 	bl	2400bda6 <HAL_I2C_MasterRxCpltCallback>
}
2400cb7a:	bf00      	nop
2400cb7c:	3708      	adds	r7, #8
2400cb7e:	46bd      	mov	sp, r7
2400cb80:	bd80      	pop	{r7, pc}

2400cb82 <I2C_ITSlaveSeqCplt>:
  * @brief  I2C Slave sequential complete process.
  * @param  hi2c I2C handle.
  * @retval None
  */
static void I2C_ITSlaveSeqCplt(I2C_HandleTypeDef *hi2c)
{
2400cb82:	b580      	push	{r7, lr}
2400cb84:	b084      	sub	sp, #16
2400cb86:	af00      	add	r7, sp, #0
2400cb88:	6078      	str	r0, [r7, #4]
  uint32_t tmpcr1value = READ_REG(hi2c->Instance->CR1);
2400cb8a:	687b      	ldr	r3, [r7, #4]
2400cb8c:	681b      	ldr	r3, [r3, #0]
2400cb8e:	681b      	ldr	r3, [r3, #0]
2400cb90:	60fb      	str	r3, [r7, #12]

  /* Reset I2C handle mode */
  hi2c->Mode = HAL_I2C_MODE_NONE;
2400cb92:	687b      	ldr	r3, [r7, #4]
2400cb94:	2200      	movs	r2, #0
2400cb96:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

  /* If a DMA is ongoing, Update handle size context */
  if (I2C_CHECK_IT_SOURCE(tmpcr1value, I2C_CR1_TXDMAEN) != RESET)
2400cb9a:	68fb      	ldr	r3, [r7, #12]
2400cb9c:	0b9b      	lsrs	r3, r3, #14
2400cb9e:	f003 0301 	and.w	r3, r3, #1
2400cba2:	2b00      	cmp	r3, #0
2400cba4:	d008      	beq.n	2400cbb8 <I2C_ITSlaveSeqCplt+0x36>
  {
    /* Disable DMA Request */
    hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;
2400cba6:	687b      	ldr	r3, [r7, #4]
2400cba8:	681b      	ldr	r3, [r3, #0]
2400cbaa:	681a      	ldr	r2, [r3, #0]
2400cbac:	687b      	ldr	r3, [r7, #4]
2400cbae:	681b      	ldr	r3, [r3, #0]
2400cbb0:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
2400cbb4:	601a      	str	r2, [r3, #0]
2400cbb6:	e00d      	b.n	2400cbd4 <I2C_ITSlaveSeqCplt+0x52>
  }
  else if (I2C_CHECK_IT_SOURCE(tmpcr1value, I2C_CR1_RXDMAEN) != RESET)
2400cbb8:	68fb      	ldr	r3, [r7, #12]
2400cbba:	0bdb      	lsrs	r3, r3, #15
2400cbbc:	f003 0301 	and.w	r3, r3, #1
2400cbc0:	2b00      	cmp	r3, #0
2400cbc2:	d007      	beq.n	2400cbd4 <I2C_ITSlaveSeqCplt+0x52>
  {
    /* Disable DMA Request */
    hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN;
2400cbc4:	687b      	ldr	r3, [r7, #4]
2400cbc6:	681b      	ldr	r3, [r3, #0]
2400cbc8:	681a      	ldr	r2, [r3, #0]
2400cbca:	687b      	ldr	r3, [r7, #4]
2400cbcc:	681b      	ldr	r3, [r3, #0]
2400cbce:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
2400cbd2:	601a      	str	r2, [r3, #0]
  else
  {
    /* Do nothing */
  }

  if (hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN)
2400cbd4:	687b      	ldr	r3, [r7, #4]
2400cbd6:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400cbda:	b2db      	uxtb	r3, r3
2400cbdc:	2b29      	cmp	r3, #41	; 0x29
2400cbde:	d112      	bne.n	2400cc06 <I2C_ITSlaveSeqCplt+0x84>
  {
    /* Remove HAL_I2C_STATE_SLAVE_BUSY_TX, keep only HAL_I2C_STATE_LISTEN */
    hi2c->State         = HAL_I2C_STATE_LISTEN;
2400cbe0:	687b      	ldr	r3, [r7, #4]
2400cbe2:	2228      	movs	r2, #40	; 0x28
2400cbe4:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_TX;
2400cbe8:	687b      	ldr	r3, [r7, #4]
2400cbea:	2221      	movs	r2, #33	; 0x21
2400cbec:	631a      	str	r2, [r3, #48]	; 0x30

    /* Disable Interrupts */
    I2C_Disable_IRQ(hi2c, I2C_XFER_TX_IT);
2400cbee:	2101      	movs	r1, #1
2400cbf0:	6878      	ldr	r0, [r7, #4]
2400cbf2:	f001 f935 	bl	2400de60 <I2C_Disable_IRQ>

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
2400cbf6:	687b      	ldr	r3, [r7, #4]
2400cbf8:	2200      	movs	r2, #0
2400cbfa:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Call the corresponding callback to inform upper layer of End of Transfer */
#if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
    hi2c->SlaveTxCpltCallback(hi2c);
#else
    HAL_I2C_SlaveTxCpltCallback(hi2c);
2400cbfe:	6878      	ldr	r0, [r7, #4]
2400cc00:	f7ff f8db 	bl	2400bdba <HAL_I2C_SlaveTxCpltCallback>
  }
  else
  {
    /* Nothing to do */
  }
}
2400cc04:	e017      	b.n	2400cc36 <I2C_ITSlaveSeqCplt+0xb4>
  else if (hi2c->State == HAL_I2C_STATE_BUSY_RX_LISTEN)
2400cc06:	687b      	ldr	r3, [r7, #4]
2400cc08:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400cc0c:	b2db      	uxtb	r3, r3
2400cc0e:	2b2a      	cmp	r3, #42	; 0x2a
2400cc10:	d111      	bne.n	2400cc36 <I2C_ITSlaveSeqCplt+0xb4>
    hi2c->State         = HAL_I2C_STATE_LISTEN;
2400cc12:	687b      	ldr	r3, [r7, #4]
2400cc14:	2228      	movs	r2, #40	; 0x28
2400cc16:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_RX;
2400cc1a:	687b      	ldr	r3, [r7, #4]
2400cc1c:	2222      	movs	r2, #34	; 0x22
2400cc1e:	631a      	str	r2, [r3, #48]	; 0x30
    I2C_Disable_IRQ(hi2c, I2C_XFER_RX_IT);
2400cc20:	2102      	movs	r1, #2
2400cc22:	6878      	ldr	r0, [r7, #4]
2400cc24:	f001 f91c 	bl	2400de60 <I2C_Disable_IRQ>
    __HAL_UNLOCK(hi2c);
2400cc28:	687b      	ldr	r3, [r7, #4]
2400cc2a:	2200      	movs	r2, #0
2400cc2c:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
    HAL_I2C_SlaveRxCpltCallback(hi2c);
2400cc30:	6878      	ldr	r0, [r7, #4]
2400cc32:	f7ff f8cc 	bl	2400bdce <HAL_I2C_SlaveRxCpltCallback>
}
2400cc36:	bf00      	nop
2400cc38:	3710      	adds	r7, #16
2400cc3a:	46bd      	mov	sp, r7
2400cc3c:	bd80      	pop	{r7, pc}
	...

2400cc40 <I2C_ITMasterCplt>:
  * @param  hi2c I2C handle.
  * @param  ITFlags Interrupt flags to handle.
  * @retval None
  */
static void I2C_ITMasterCplt(I2C_HandleTypeDef *hi2c, uint32_t ITFlags)
{
2400cc40:	b580      	push	{r7, lr}
2400cc42:	b086      	sub	sp, #24
2400cc44:	af00      	add	r7, sp, #0
2400cc46:	6078      	str	r0, [r7, #4]
2400cc48:	6039      	str	r1, [r7, #0]
  uint32_t tmperror;
  uint32_t tmpITFlags = ITFlags;
2400cc4a:	683b      	ldr	r3, [r7, #0]
2400cc4c:	617b      	str	r3, [r7, #20]
  uint32_t tmp;

  /* Clear STOP Flag */
  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
2400cc4e:	687b      	ldr	r3, [r7, #4]
2400cc50:	681b      	ldr	r3, [r3, #0]
2400cc52:	2220      	movs	r2, #32
2400cc54:	61da      	str	r2, [r3, #28]

  /* Disable Interrupts and Store Previous state */
  if (hi2c->State == HAL_I2C_STATE_BUSY_TX)
2400cc56:	687b      	ldr	r3, [r7, #4]
2400cc58:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400cc5c:	b2db      	uxtb	r3, r3
2400cc5e:	2b21      	cmp	r3, #33	; 0x21
2400cc60:	d107      	bne.n	2400cc72 <I2C_ITMasterCplt+0x32>
  {
    I2C_Disable_IRQ(hi2c, I2C_XFER_TX_IT);
2400cc62:	2101      	movs	r1, #1
2400cc64:	6878      	ldr	r0, [r7, #4]
2400cc66:	f001 f8fb 	bl	2400de60 <I2C_Disable_IRQ>
    hi2c->PreviousState = I2C_STATE_MASTER_BUSY_TX;
2400cc6a:	687b      	ldr	r3, [r7, #4]
2400cc6c:	2211      	movs	r2, #17
2400cc6e:	631a      	str	r2, [r3, #48]	; 0x30
2400cc70:	e00c      	b.n	2400cc8c <I2C_ITMasterCplt+0x4c>
  }
  else if (hi2c->State == HAL_I2C_STATE_BUSY_RX)
2400cc72:	687b      	ldr	r3, [r7, #4]
2400cc74:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400cc78:	b2db      	uxtb	r3, r3
2400cc7a:	2b22      	cmp	r3, #34	; 0x22
2400cc7c:	d106      	bne.n	2400cc8c <I2C_ITMasterCplt+0x4c>
  {
    I2C_Disable_IRQ(hi2c, I2C_XFER_RX_IT);
2400cc7e:	2102      	movs	r1, #2
2400cc80:	6878      	ldr	r0, [r7, #4]
2400cc82:	f001 f8ed 	bl	2400de60 <I2C_Disable_IRQ>
    hi2c->PreviousState = I2C_STATE_MASTER_BUSY_RX;
2400cc86:	687b      	ldr	r3, [r7, #4]
2400cc88:	2212      	movs	r2, #18
2400cc8a:	631a      	str	r2, [r3, #48]	; 0x30
  {
    /* Do nothing */
  }

  /* Clear Configuration Register 2 */
  I2C_RESET_CR2(hi2c);
2400cc8c:	687b      	ldr	r3, [r7, #4]
2400cc8e:	681b      	ldr	r3, [r3, #0]
2400cc90:	6859      	ldr	r1, [r3, #4]
2400cc92:	687b      	ldr	r3, [r7, #4]
2400cc94:	681a      	ldr	r2, [r3, #0]
2400cc96:	4b4c      	ldr	r3, [pc, #304]	; (2400cdc8 <I2C_ITMasterCplt+0x188>)
2400cc98:	400b      	ands	r3, r1
2400cc9a:	6053      	str	r3, [r2, #4]

  /* Reset handle parameters */
  hi2c->XferISR       = NULL;
2400cc9c:	687b      	ldr	r3, [r7, #4]
2400cc9e:	2200      	movs	r2, #0
2400cca0:	635a      	str	r2, [r3, #52]	; 0x34
  hi2c->XferOptions   = I2C_NO_OPTION_FRAME;
2400cca2:	687b      	ldr	r3, [r7, #4]
2400cca4:	4a49      	ldr	r2, [pc, #292]	; (2400cdcc <I2C_ITMasterCplt+0x18c>)
2400cca6:	62da      	str	r2, [r3, #44]	; 0x2c

  if (I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_AF) != RESET)
2400cca8:	697b      	ldr	r3, [r7, #20]
2400ccaa:	091b      	lsrs	r3, r3, #4
2400ccac:	f003 0301 	and.w	r3, r3, #1
2400ccb0:	2b00      	cmp	r3, #0
2400ccb2:	d009      	beq.n	2400ccc8 <I2C_ITMasterCplt+0x88>
  {
    /* Clear NACK Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
2400ccb4:	687b      	ldr	r3, [r7, #4]
2400ccb6:	681b      	ldr	r3, [r3, #0]
2400ccb8:	2210      	movs	r2, #16
2400ccba:	61da      	str	r2, [r3, #28]

    /* Set acknowledge error code */
    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
2400ccbc:	687b      	ldr	r3, [r7, #4]
2400ccbe:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400ccc0:	f043 0204 	orr.w	r2, r3, #4
2400ccc4:	687b      	ldr	r3, [r7, #4]
2400ccc6:	645a      	str	r2, [r3, #68]	; 0x44
  }

  /* Fetch Last receive data if any */
  if ((hi2c->State == HAL_I2C_STATE_ABORT) && (I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_RXNE) != RESET))
2400ccc8:	687b      	ldr	r3, [r7, #4]
2400ccca:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400ccce:	b2db      	uxtb	r3, r3
2400ccd0:	2b60      	cmp	r3, #96	; 0x60
2400ccd2:	d10a      	bne.n	2400ccea <I2C_ITMasterCplt+0xaa>
2400ccd4:	697b      	ldr	r3, [r7, #20]
2400ccd6:	089b      	lsrs	r3, r3, #2
2400ccd8:	f003 0301 	and.w	r3, r3, #1
2400ccdc:	2b00      	cmp	r3, #0
2400ccde:	d004      	beq.n	2400ccea <I2C_ITMasterCplt+0xaa>
  {
    /* Read data from RXDR */
    tmp = (uint8_t)hi2c->Instance->RXDR;
2400cce0:	687b      	ldr	r3, [r7, #4]
2400cce2:	681b      	ldr	r3, [r3, #0]
2400cce4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2400cce6:	b2db      	uxtb	r3, r3
2400cce8:	613b      	str	r3, [r7, #16]

    UNUSED(tmp);
  }

  /* Flush TX register */
  I2C_Flush_TXDR(hi2c);
2400ccea:	6878      	ldr	r0, [r7, #4]
2400ccec:	f000 fbb5 	bl	2400d45a <I2C_Flush_TXDR>

  /* Store current volatile hi2c->ErrorCode, misra rule */
  tmperror = hi2c->ErrorCode;
2400ccf0:	687b      	ldr	r3, [r7, #4]
2400ccf2:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400ccf4:	60fb      	str	r3, [r7, #12]

  /* Call the corresponding callback to inform upper layer of End of Transfer */
  if ((hi2c->State == HAL_I2C_STATE_ABORT) || (tmperror != HAL_I2C_ERROR_NONE))
2400ccf6:	687b      	ldr	r3, [r7, #4]
2400ccf8:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400ccfc:	b2db      	uxtb	r3, r3
2400ccfe:	2b60      	cmp	r3, #96	; 0x60
2400cd00:	d002      	beq.n	2400cd08 <I2C_ITMasterCplt+0xc8>
2400cd02:	68fb      	ldr	r3, [r7, #12]
2400cd04:	2b00      	cmp	r3, #0
2400cd06:	d006      	beq.n	2400cd16 <I2C_ITMasterCplt+0xd6>
  {
    /* Call the corresponding callback to inform upper layer of End of Transfer */
    I2C_ITError(hi2c, hi2c->ErrorCode);
2400cd08:	687b      	ldr	r3, [r7, #4]
2400cd0a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400cd0c:	4619      	mov	r1, r3
2400cd0e:	6878      	ldr	r0, [r7, #4]
2400cd10:	f000 faac 	bl	2400d26c <I2C_ITError>
  }
  else
  {
    /* Nothing to do */
  }
}
2400cd14:	e054      	b.n	2400cdc0 <I2C_ITMasterCplt+0x180>
  else if (hi2c->State == HAL_I2C_STATE_BUSY_TX)
2400cd16:	687b      	ldr	r3, [r7, #4]
2400cd18:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400cd1c:	b2db      	uxtb	r3, r3
2400cd1e:	2b21      	cmp	r3, #33	; 0x21
2400cd20:	d124      	bne.n	2400cd6c <I2C_ITMasterCplt+0x12c>
    hi2c->State = HAL_I2C_STATE_READY;
2400cd22:	687b      	ldr	r3, [r7, #4]
2400cd24:	2220      	movs	r2, #32
2400cd26:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->PreviousState = I2C_STATE_NONE;
2400cd2a:	687b      	ldr	r3, [r7, #4]
2400cd2c:	2200      	movs	r2, #0
2400cd2e:	631a      	str	r2, [r3, #48]	; 0x30
    if (hi2c->Mode == HAL_I2C_MODE_MEM)
2400cd30:	687b      	ldr	r3, [r7, #4]
2400cd32:	f893 3042 	ldrb.w	r3, [r3, #66]	; 0x42
2400cd36:	b2db      	uxtb	r3, r3
2400cd38:	2b40      	cmp	r3, #64	; 0x40
2400cd3a:	d10b      	bne.n	2400cd54 <I2C_ITMasterCplt+0x114>
      hi2c->Mode = HAL_I2C_MODE_NONE;
2400cd3c:	687b      	ldr	r3, [r7, #4]
2400cd3e:	2200      	movs	r2, #0
2400cd40:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
      __HAL_UNLOCK(hi2c);
2400cd44:	687b      	ldr	r3, [r7, #4]
2400cd46:	2200      	movs	r2, #0
2400cd48:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      HAL_I2C_MemTxCpltCallback(hi2c);
2400cd4c:	6878      	ldr	r0, [r7, #4]
2400cd4e:	f7ff f860 	bl	2400be12 <HAL_I2C_MemTxCpltCallback>
}
2400cd52:	e035      	b.n	2400cdc0 <I2C_ITMasterCplt+0x180>
      hi2c->Mode = HAL_I2C_MODE_NONE;
2400cd54:	687b      	ldr	r3, [r7, #4]
2400cd56:	2200      	movs	r2, #0
2400cd58:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
      __HAL_UNLOCK(hi2c);
2400cd5c:	687b      	ldr	r3, [r7, #4]
2400cd5e:	2200      	movs	r2, #0
2400cd60:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      HAL_I2C_MasterTxCpltCallback(hi2c);
2400cd64:	6878      	ldr	r0, [r7, #4]
2400cd66:	f7ff f814 	bl	2400bd92 <HAL_I2C_MasterTxCpltCallback>
}
2400cd6a:	e029      	b.n	2400cdc0 <I2C_ITMasterCplt+0x180>
  else if (hi2c->State == HAL_I2C_STATE_BUSY_RX)
2400cd6c:	687b      	ldr	r3, [r7, #4]
2400cd6e:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400cd72:	b2db      	uxtb	r3, r3
2400cd74:	2b22      	cmp	r3, #34	; 0x22
2400cd76:	d123      	bne.n	2400cdc0 <I2C_ITMasterCplt+0x180>
    hi2c->State = HAL_I2C_STATE_READY;
2400cd78:	687b      	ldr	r3, [r7, #4]
2400cd7a:	2220      	movs	r2, #32
2400cd7c:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->PreviousState = I2C_STATE_NONE;
2400cd80:	687b      	ldr	r3, [r7, #4]
2400cd82:	2200      	movs	r2, #0
2400cd84:	631a      	str	r2, [r3, #48]	; 0x30
    if (hi2c->Mode == HAL_I2C_MODE_MEM)
2400cd86:	687b      	ldr	r3, [r7, #4]
2400cd88:	f893 3042 	ldrb.w	r3, [r3, #66]	; 0x42
2400cd8c:	b2db      	uxtb	r3, r3
2400cd8e:	2b40      	cmp	r3, #64	; 0x40
2400cd90:	d10b      	bne.n	2400cdaa <I2C_ITMasterCplt+0x16a>
      hi2c->Mode = HAL_I2C_MODE_NONE;
2400cd92:	687b      	ldr	r3, [r7, #4]
2400cd94:	2200      	movs	r2, #0
2400cd96:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
      __HAL_UNLOCK(hi2c);
2400cd9a:	687b      	ldr	r3, [r7, #4]
2400cd9c:	2200      	movs	r2, #0
2400cd9e:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      HAL_I2C_MemRxCpltCallback(hi2c);
2400cda2:	6878      	ldr	r0, [r7, #4]
2400cda4:	f7ff f83f 	bl	2400be26 <HAL_I2C_MemRxCpltCallback>
}
2400cda8:	e00a      	b.n	2400cdc0 <I2C_ITMasterCplt+0x180>
      hi2c->Mode = HAL_I2C_MODE_NONE;
2400cdaa:	687b      	ldr	r3, [r7, #4]
2400cdac:	2200      	movs	r2, #0
2400cdae:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
      __HAL_UNLOCK(hi2c);
2400cdb2:	687b      	ldr	r3, [r7, #4]
2400cdb4:	2200      	movs	r2, #0
2400cdb6:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      HAL_I2C_MasterRxCpltCallback(hi2c);
2400cdba:	6878      	ldr	r0, [r7, #4]
2400cdbc:	f7fe fff3 	bl	2400bda6 <HAL_I2C_MasterRxCpltCallback>
}
2400cdc0:	bf00      	nop
2400cdc2:	3718      	adds	r7, #24
2400cdc4:	46bd      	mov	sp, r7
2400cdc6:	bd80      	pop	{r7, pc}
2400cdc8:	fe00e800 	.word	0xfe00e800
2400cdcc:	ffff0000 	.word	0xffff0000

2400cdd0 <I2C_ITSlaveCplt>:
  * @param  hi2c I2C handle.
  * @param  ITFlags Interrupt flags to handle.
  * @retval None
  */
static void I2C_ITSlaveCplt(I2C_HandleTypeDef *hi2c, uint32_t ITFlags)
{
2400cdd0:	b580      	push	{r7, lr}
2400cdd2:	b086      	sub	sp, #24
2400cdd4:	af00      	add	r7, sp, #0
2400cdd6:	6078      	str	r0, [r7, #4]
2400cdd8:	6039      	str	r1, [r7, #0]
  uint32_t tmpcr1value = READ_REG(hi2c->Instance->CR1);
2400cdda:	687b      	ldr	r3, [r7, #4]
2400cddc:	681b      	ldr	r3, [r3, #0]
2400cdde:	681b      	ldr	r3, [r3, #0]
2400cde0:	613b      	str	r3, [r7, #16]
  uint32_t tmpITFlags = ITFlags;
2400cde2:	683b      	ldr	r3, [r7, #0]
2400cde4:	617b      	str	r3, [r7, #20]
  HAL_I2C_StateTypeDef tmpstate = hi2c->State;
2400cde6:	687b      	ldr	r3, [r7, #4]
2400cde8:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400cdec:	73fb      	strb	r3, [r7, #15]

  /* Clear STOP Flag */
  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
2400cdee:	687b      	ldr	r3, [r7, #4]
2400cdf0:	681b      	ldr	r3, [r3, #0]
2400cdf2:	2220      	movs	r2, #32
2400cdf4:	61da      	str	r2, [r3, #28]

  /* Disable Interrupts and Store Previous state */
  if ((tmpstate == HAL_I2C_STATE_BUSY_TX) || (tmpstate == HAL_I2C_STATE_BUSY_TX_LISTEN))
2400cdf6:	7bfb      	ldrb	r3, [r7, #15]
2400cdf8:	2b21      	cmp	r3, #33	; 0x21
2400cdfa:	d002      	beq.n	2400ce02 <I2C_ITSlaveCplt+0x32>
2400cdfc:	7bfb      	ldrb	r3, [r7, #15]
2400cdfe:	2b29      	cmp	r3, #41	; 0x29
2400ce00:	d108      	bne.n	2400ce14 <I2C_ITSlaveCplt+0x44>
  {
    I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT | I2C_XFER_TX_IT);
2400ce02:	f248 0101 	movw	r1, #32769	; 0x8001
2400ce06:	6878      	ldr	r0, [r7, #4]
2400ce08:	f001 f82a 	bl	2400de60 <I2C_Disable_IRQ>
    hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_TX;
2400ce0c:	687b      	ldr	r3, [r7, #4]
2400ce0e:	2221      	movs	r2, #33	; 0x21
2400ce10:	631a      	str	r2, [r3, #48]	; 0x30
2400ce12:	e00d      	b.n	2400ce30 <I2C_ITSlaveCplt+0x60>
  }
  else if ((tmpstate == HAL_I2C_STATE_BUSY_RX) || (tmpstate == HAL_I2C_STATE_BUSY_RX_LISTEN))
2400ce14:	7bfb      	ldrb	r3, [r7, #15]
2400ce16:	2b22      	cmp	r3, #34	; 0x22
2400ce18:	d002      	beq.n	2400ce20 <I2C_ITSlaveCplt+0x50>
2400ce1a:	7bfb      	ldrb	r3, [r7, #15]
2400ce1c:	2b2a      	cmp	r3, #42	; 0x2a
2400ce1e:	d107      	bne.n	2400ce30 <I2C_ITSlaveCplt+0x60>
  {
    I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT | I2C_XFER_RX_IT);
2400ce20:	f248 0102 	movw	r1, #32770	; 0x8002
2400ce24:	6878      	ldr	r0, [r7, #4]
2400ce26:	f001 f81b 	bl	2400de60 <I2C_Disable_IRQ>
    hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_RX;
2400ce2a:	687b      	ldr	r3, [r7, #4]
2400ce2c:	2222      	movs	r2, #34	; 0x22
2400ce2e:	631a      	str	r2, [r3, #48]	; 0x30
  {
    /* Do nothing */
  }

  /* Disable Address Acknowledge */
  hi2c->Instance->CR2 |= I2C_CR2_NACK;
2400ce30:	687b      	ldr	r3, [r7, #4]
2400ce32:	681b      	ldr	r3, [r3, #0]
2400ce34:	685a      	ldr	r2, [r3, #4]
2400ce36:	687b      	ldr	r3, [r7, #4]
2400ce38:	681b      	ldr	r3, [r3, #0]
2400ce3a:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
2400ce3e:	605a      	str	r2, [r3, #4]

  /* Clear Configuration Register 2 */
  I2C_RESET_CR2(hi2c);
2400ce40:	687b      	ldr	r3, [r7, #4]
2400ce42:	681b      	ldr	r3, [r3, #0]
2400ce44:	6859      	ldr	r1, [r3, #4]
2400ce46:	687b      	ldr	r3, [r7, #4]
2400ce48:	681a      	ldr	r2, [r3, #0]
2400ce4a:	4b80      	ldr	r3, [pc, #512]	; (2400d04c <I2C_ITSlaveCplt+0x27c>)
2400ce4c:	400b      	ands	r3, r1
2400ce4e:	6053      	str	r3, [r2, #4]

  /* Flush TX register */
  I2C_Flush_TXDR(hi2c);
2400ce50:	6878      	ldr	r0, [r7, #4]
2400ce52:	f000 fb02 	bl	2400d45a <I2C_Flush_TXDR>

  /* If a DMA is ongoing, Update handle size context */
  if (I2C_CHECK_IT_SOURCE(tmpcr1value, I2C_CR1_TXDMAEN) != RESET)
2400ce56:	693b      	ldr	r3, [r7, #16]
2400ce58:	0b9b      	lsrs	r3, r3, #14
2400ce5a:	f003 0301 	and.w	r3, r3, #1
2400ce5e:	2b00      	cmp	r3, #0
2400ce60:	d07a      	beq.n	2400cf58 <I2C_ITSlaveCplt+0x188>
  {
    /* Disable DMA Request */
    hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;
2400ce62:	687b      	ldr	r3, [r7, #4]
2400ce64:	681b      	ldr	r3, [r3, #0]
2400ce66:	681a      	ldr	r2, [r3, #0]
2400ce68:	687b      	ldr	r3, [r7, #4]
2400ce6a:	681b      	ldr	r3, [r3, #0]
2400ce6c:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
2400ce70:	601a      	str	r2, [r3, #0]

    if (hi2c->hdmatx != NULL)
2400ce72:	687b      	ldr	r3, [r7, #4]
2400ce74:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400ce76:	2b00      	cmp	r3, #0
2400ce78:	f000 8111 	beq.w	2400d09e <I2C_ITSlaveCplt+0x2ce>
    {
      hi2c->XferCount = (uint16_t)__HAL_DMA_GET_COUNTER(hi2c->hdmatx);
2400ce7c:	687b      	ldr	r3, [r7, #4]
2400ce7e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400ce80:	681b      	ldr	r3, [r3, #0]
2400ce82:	4a73      	ldr	r2, [pc, #460]	; (2400d050 <I2C_ITSlaveCplt+0x280>)
2400ce84:	4293      	cmp	r3, r2
2400ce86:	d059      	beq.n	2400cf3c <I2C_ITSlaveCplt+0x16c>
2400ce88:	687b      	ldr	r3, [r7, #4]
2400ce8a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400ce8c:	681b      	ldr	r3, [r3, #0]
2400ce8e:	4a71      	ldr	r2, [pc, #452]	; (2400d054 <I2C_ITSlaveCplt+0x284>)
2400ce90:	4293      	cmp	r3, r2
2400ce92:	d053      	beq.n	2400cf3c <I2C_ITSlaveCplt+0x16c>
2400ce94:	687b      	ldr	r3, [r7, #4]
2400ce96:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400ce98:	681b      	ldr	r3, [r3, #0]
2400ce9a:	4a6f      	ldr	r2, [pc, #444]	; (2400d058 <I2C_ITSlaveCplt+0x288>)
2400ce9c:	4293      	cmp	r3, r2
2400ce9e:	d04d      	beq.n	2400cf3c <I2C_ITSlaveCplt+0x16c>
2400cea0:	687b      	ldr	r3, [r7, #4]
2400cea2:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400cea4:	681b      	ldr	r3, [r3, #0]
2400cea6:	4a6d      	ldr	r2, [pc, #436]	; (2400d05c <I2C_ITSlaveCplt+0x28c>)
2400cea8:	4293      	cmp	r3, r2
2400ceaa:	d047      	beq.n	2400cf3c <I2C_ITSlaveCplt+0x16c>
2400ceac:	687b      	ldr	r3, [r7, #4]
2400ceae:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400ceb0:	681b      	ldr	r3, [r3, #0]
2400ceb2:	4a6b      	ldr	r2, [pc, #428]	; (2400d060 <I2C_ITSlaveCplt+0x290>)
2400ceb4:	4293      	cmp	r3, r2
2400ceb6:	d041      	beq.n	2400cf3c <I2C_ITSlaveCplt+0x16c>
2400ceb8:	687b      	ldr	r3, [r7, #4]
2400ceba:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400cebc:	681b      	ldr	r3, [r3, #0]
2400cebe:	4a69      	ldr	r2, [pc, #420]	; (2400d064 <I2C_ITSlaveCplt+0x294>)
2400cec0:	4293      	cmp	r3, r2
2400cec2:	d03b      	beq.n	2400cf3c <I2C_ITSlaveCplt+0x16c>
2400cec4:	687b      	ldr	r3, [r7, #4]
2400cec6:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400cec8:	681b      	ldr	r3, [r3, #0]
2400ceca:	4a67      	ldr	r2, [pc, #412]	; (2400d068 <I2C_ITSlaveCplt+0x298>)
2400cecc:	4293      	cmp	r3, r2
2400cece:	d035      	beq.n	2400cf3c <I2C_ITSlaveCplt+0x16c>
2400ced0:	687b      	ldr	r3, [r7, #4]
2400ced2:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400ced4:	681b      	ldr	r3, [r3, #0]
2400ced6:	4a65      	ldr	r2, [pc, #404]	; (2400d06c <I2C_ITSlaveCplt+0x29c>)
2400ced8:	4293      	cmp	r3, r2
2400ceda:	d02f      	beq.n	2400cf3c <I2C_ITSlaveCplt+0x16c>
2400cedc:	687b      	ldr	r3, [r7, #4]
2400cede:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400cee0:	681b      	ldr	r3, [r3, #0]
2400cee2:	4a63      	ldr	r2, [pc, #396]	; (2400d070 <I2C_ITSlaveCplt+0x2a0>)
2400cee4:	4293      	cmp	r3, r2
2400cee6:	d029      	beq.n	2400cf3c <I2C_ITSlaveCplt+0x16c>
2400cee8:	687b      	ldr	r3, [r7, #4]
2400ceea:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400ceec:	681b      	ldr	r3, [r3, #0]
2400ceee:	4a61      	ldr	r2, [pc, #388]	; (2400d074 <I2C_ITSlaveCplt+0x2a4>)
2400cef0:	4293      	cmp	r3, r2
2400cef2:	d023      	beq.n	2400cf3c <I2C_ITSlaveCplt+0x16c>
2400cef4:	687b      	ldr	r3, [r7, #4]
2400cef6:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400cef8:	681b      	ldr	r3, [r3, #0]
2400cefa:	4a5f      	ldr	r2, [pc, #380]	; (2400d078 <I2C_ITSlaveCplt+0x2a8>)
2400cefc:	4293      	cmp	r3, r2
2400cefe:	d01d      	beq.n	2400cf3c <I2C_ITSlaveCplt+0x16c>
2400cf00:	687b      	ldr	r3, [r7, #4]
2400cf02:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400cf04:	681b      	ldr	r3, [r3, #0]
2400cf06:	4a5d      	ldr	r2, [pc, #372]	; (2400d07c <I2C_ITSlaveCplt+0x2ac>)
2400cf08:	4293      	cmp	r3, r2
2400cf0a:	d017      	beq.n	2400cf3c <I2C_ITSlaveCplt+0x16c>
2400cf0c:	687b      	ldr	r3, [r7, #4]
2400cf0e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400cf10:	681b      	ldr	r3, [r3, #0]
2400cf12:	4a5b      	ldr	r2, [pc, #364]	; (2400d080 <I2C_ITSlaveCplt+0x2b0>)
2400cf14:	4293      	cmp	r3, r2
2400cf16:	d011      	beq.n	2400cf3c <I2C_ITSlaveCplt+0x16c>
2400cf18:	687b      	ldr	r3, [r7, #4]
2400cf1a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400cf1c:	681b      	ldr	r3, [r3, #0]
2400cf1e:	4a59      	ldr	r2, [pc, #356]	; (2400d084 <I2C_ITSlaveCplt+0x2b4>)
2400cf20:	4293      	cmp	r3, r2
2400cf22:	d00b      	beq.n	2400cf3c <I2C_ITSlaveCplt+0x16c>
2400cf24:	687b      	ldr	r3, [r7, #4]
2400cf26:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400cf28:	681b      	ldr	r3, [r3, #0]
2400cf2a:	4a57      	ldr	r2, [pc, #348]	; (2400d088 <I2C_ITSlaveCplt+0x2b8>)
2400cf2c:	4293      	cmp	r3, r2
2400cf2e:	d005      	beq.n	2400cf3c <I2C_ITSlaveCplt+0x16c>
2400cf30:	687b      	ldr	r3, [r7, #4]
2400cf32:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400cf34:	681b      	ldr	r3, [r3, #0]
2400cf36:	4a55      	ldr	r2, [pc, #340]	; (2400d08c <I2C_ITSlaveCplt+0x2bc>)
2400cf38:	4293      	cmp	r3, r2
2400cf3a:	d105      	bne.n	2400cf48 <I2C_ITSlaveCplt+0x178>
2400cf3c:	687b      	ldr	r3, [r7, #4]
2400cf3e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400cf40:	681b      	ldr	r3, [r3, #0]
2400cf42:	685b      	ldr	r3, [r3, #4]
2400cf44:	b29b      	uxth	r3, r3
2400cf46:	e004      	b.n	2400cf52 <I2C_ITSlaveCplt+0x182>
2400cf48:	687b      	ldr	r3, [r7, #4]
2400cf4a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400cf4c:	681b      	ldr	r3, [r3, #0]
2400cf4e:	685b      	ldr	r3, [r3, #4]
2400cf50:	b29b      	uxth	r3, r3
2400cf52:	687a      	ldr	r2, [r7, #4]
2400cf54:	8553      	strh	r3, [r2, #42]	; 0x2a
2400cf56:	e0a2      	b.n	2400d09e <I2C_ITSlaveCplt+0x2ce>
    }
  }
  else if (I2C_CHECK_IT_SOURCE(tmpcr1value, I2C_CR1_RXDMAEN) != RESET)
2400cf58:	693b      	ldr	r3, [r7, #16]
2400cf5a:	0bdb      	lsrs	r3, r3, #15
2400cf5c:	f003 0301 	and.w	r3, r3, #1
2400cf60:	2b00      	cmp	r3, #0
2400cf62:	f000 809c 	beq.w	2400d09e <I2C_ITSlaveCplt+0x2ce>
  {
    /* Disable DMA Request */
    hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN;
2400cf66:	687b      	ldr	r3, [r7, #4]
2400cf68:	681b      	ldr	r3, [r3, #0]
2400cf6a:	681a      	ldr	r2, [r3, #0]
2400cf6c:	687b      	ldr	r3, [r7, #4]
2400cf6e:	681b      	ldr	r3, [r3, #0]
2400cf70:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
2400cf74:	601a      	str	r2, [r3, #0]

    if (hi2c->hdmarx != NULL)
2400cf76:	687b      	ldr	r3, [r7, #4]
2400cf78:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400cf7a:	2b00      	cmp	r3, #0
2400cf7c:	f000 808f 	beq.w	2400d09e <I2C_ITSlaveCplt+0x2ce>
    {
      hi2c->XferCount = (uint16_t)__HAL_DMA_GET_COUNTER(hi2c->hdmarx);
2400cf80:	687b      	ldr	r3, [r7, #4]
2400cf82:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400cf84:	681b      	ldr	r3, [r3, #0]
2400cf86:	4a32      	ldr	r2, [pc, #200]	; (2400d050 <I2C_ITSlaveCplt+0x280>)
2400cf88:	4293      	cmp	r3, r2
2400cf8a:	d059      	beq.n	2400d040 <I2C_ITSlaveCplt+0x270>
2400cf8c:	687b      	ldr	r3, [r7, #4]
2400cf8e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400cf90:	681b      	ldr	r3, [r3, #0]
2400cf92:	4a30      	ldr	r2, [pc, #192]	; (2400d054 <I2C_ITSlaveCplt+0x284>)
2400cf94:	4293      	cmp	r3, r2
2400cf96:	d053      	beq.n	2400d040 <I2C_ITSlaveCplt+0x270>
2400cf98:	687b      	ldr	r3, [r7, #4]
2400cf9a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400cf9c:	681b      	ldr	r3, [r3, #0]
2400cf9e:	4a2e      	ldr	r2, [pc, #184]	; (2400d058 <I2C_ITSlaveCplt+0x288>)
2400cfa0:	4293      	cmp	r3, r2
2400cfa2:	d04d      	beq.n	2400d040 <I2C_ITSlaveCplt+0x270>
2400cfa4:	687b      	ldr	r3, [r7, #4]
2400cfa6:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400cfa8:	681b      	ldr	r3, [r3, #0]
2400cfaa:	4a2c      	ldr	r2, [pc, #176]	; (2400d05c <I2C_ITSlaveCplt+0x28c>)
2400cfac:	4293      	cmp	r3, r2
2400cfae:	d047      	beq.n	2400d040 <I2C_ITSlaveCplt+0x270>
2400cfb0:	687b      	ldr	r3, [r7, #4]
2400cfb2:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400cfb4:	681b      	ldr	r3, [r3, #0]
2400cfb6:	4a2a      	ldr	r2, [pc, #168]	; (2400d060 <I2C_ITSlaveCplt+0x290>)
2400cfb8:	4293      	cmp	r3, r2
2400cfba:	d041      	beq.n	2400d040 <I2C_ITSlaveCplt+0x270>
2400cfbc:	687b      	ldr	r3, [r7, #4]
2400cfbe:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400cfc0:	681b      	ldr	r3, [r3, #0]
2400cfc2:	4a28      	ldr	r2, [pc, #160]	; (2400d064 <I2C_ITSlaveCplt+0x294>)
2400cfc4:	4293      	cmp	r3, r2
2400cfc6:	d03b      	beq.n	2400d040 <I2C_ITSlaveCplt+0x270>
2400cfc8:	687b      	ldr	r3, [r7, #4]
2400cfca:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400cfcc:	681b      	ldr	r3, [r3, #0]
2400cfce:	4a26      	ldr	r2, [pc, #152]	; (2400d068 <I2C_ITSlaveCplt+0x298>)
2400cfd0:	4293      	cmp	r3, r2
2400cfd2:	d035      	beq.n	2400d040 <I2C_ITSlaveCplt+0x270>
2400cfd4:	687b      	ldr	r3, [r7, #4]
2400cfd6:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400cfd8:	681b      	ldr	r3, [r3, #0]
2400cfda:	4a24      	ldr	r2, [pc, #144]	; (2400d06c <I2C_ITSlaveCplt+0x29c>)
2400cfdc:	4293      	cmp	r3, r2
2400cfde:	d02f      	beq.n	2400d040 <I2C_ITSlaveCplt+0x270>
2400cfe0:	687b      	ldr	r3, [r7, #4]
2400cfe2:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400cfe4:	681b      	ldr	r3, [r3, #0]
2400cfe6:	4a22      	ldr	r2, [pc, #136]	; (2400d070 <I2C_ITSlaveCplt+0x2a0>)
2400cfe8:	4293      	cmp	r3, r2
2400cfea:	d029      	beq.n	2400d040 <I2C_ITSlaveCplt+0x270>
2400cfec:	687b      	ldr	r3, [r7, #4]
2400cfee:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400cff0:	681b      	ldr	r3, [r3, #0]
2400cff2:	4a20      	ldr	r2, [pc, #128]	; (2400d074 <I2C_ITSlaveCplt+0x2a4>)
2400cff4:	4293      	cmp	r3, r2
2400cff6:	d023      	beq.n	2400d040 <I2C_ITSlaveCplt+0x270>
2400cff8:	687b      	ldr	r3, [r7, #4]
2400cffa:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400cffc:	681b      	ldr	r3, [r3, #0]
2400cffe:	4a1e      	ldr	r2, [pc, #120]	; (2400d078 <I2C_ITSlaveCplt+0x2a8>)
2400d000:	4293      	cmp	r3, r2
2400d002:	d01d      	beq.n	2400d040 <I2C_ITSlaveCplt+0x270>
2400d004:	687b      	ldr	r3, [r7, #4]
2400d006:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400d008:	681b      	ldr	r3, [r3, #0]
2400d00a:	4a1c      	ldr	r2, [pc, #112]	; (2400d07c <I2C_ITSlaveCplt+0x2ac>)
2400d00c:	4293      	cmp	r3, r2
2400d00e:	d017      	beq.n	2400d040 <I2C_ITSlaveCplt+0x270>
2400d010:	687b      	ldr	r3, [r7, #4]
2400d012:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400d014:	681b      	ldr	r3, [r3, #0]
2400d016:	4a1a      	ldr	r2, [pc, #104]	; (2400d080 <I2C_ITSlaveCplt+0x2b0>)
2400d018:	4293      	cmp	r3, r2
2400d01a:	d011      	beq.n	2400d040 <I2C_ITSlaveCplt+0x270>
2400d01c:	687b      	ldr	r3, [r7, #4]
2400d01e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400d020:	681b      	ldr	r3, [r3, #0]
2400d022:	4a18      	ldr	r2, [pc, #96]	; (2400d084 <I2C_ITSlaveCplt+0x2b4>)
2400d024:	4293      	cmp	r3, r2
2400d026:	d00b      	beq.n	2400d040 <I2C_ITSlaveCplt+0x270>
2400d028:	687b      	ldr	r3, [r7, #4]
2400d02a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400d02c:	681b      	ldr	r3, [r3, #0]
2400d02e:	4a16      	ldr	r2, [pc, #88]	; (2400d088 <I2C_ITSlaveCplt+0x2b8>)
2400d030:	4293      	cmp	r3, r2
2400d032:	d005      	beq.n	2400d040 <I2C_ITSlaveCplt+0x270>
2400d034:	687b      	ldr	r3, [r7, #4]
2400d036:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400d038:	681b      	ldr	r3, [r3, #0]
2400d03a:	4a14      	ldr	r2, [pc, #80]	; (2400d08c <I2C_ITSlaveCplt+0x2bc>)
2400d03c:	4293      	cmp	r3, r2
2400d03e:	d127      	bne.n	2400d090 <I2C_ITSlaveCplt+0x2c0>
2400d040:	687b      	ldr	r3, [r7, #4]
2400d042:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400d044:	681b      	ldr	r3, [r3, #0]
2400d046:	685b      	ldr	r3, [r3, #4]
2400d048:	b29b      	uxth	r3, r3
2400d04a:	e026      	b.n	2400d09a <I2C_ITSlaveCplt+0x2ca>
2400d04c:	fe00e800 	.word	0xfe00e800
2400d050:	40020010 	.word	0x40020010
2400d054:	40020028 	.word	0x40020028
2400d058:	40020040 	.word	0x40020040
2400d05c:	40020058 	.word	0x40020058
2400d060:	40020070 	.word	0x40020070
2400d064:	40020088 	.word	0x40020088
2400d068:	400200a0 	.word	0x400200a0
2400d06c:	400200b8 	.word	0x400200b8
2400d070:	40020410 	.word	0x40020410
2400d074:	40020428 	.word	0x40020428
2400d078:	40020440 	.word	0x40020440
2400d07c:	40020458 	.word	0x40020458
2400d080:	40020470 	.word	0x40020470
2400d084:	40020488 	.word	0x40020488
2400d088:	400204a0 	.word	0x400204a0
2400d08c:	400204b8 	.word	0x400204b8
2400d090:	687b      	ldr	r3, [r7, #4]
2400d092:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400d094:	681b      	ldr	r3, [r3, #0]
2400d096:	685b      	ldr	r3, [r3, #4]
2400d098:	b29b      	uxth	r3, r3
2400d09a:	687a      	ldr	r2, [r7, #4]
2400d09c:	8553      	strh	r3, [r2, #42]	; 0x2a
  {
    /* Do nothing */
  }

  /* Store Last receive data if any */
  if (I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_RXNE) != RESET)
2400d09e:	697b      	ldr	r3, [r7, #20]
2400d0a0:	089b      	lsrs	r3, r3, #2
2400d0a2:	f003 0301 	and.w	r3, r3, #1
2400d0a6:	2b00      	cmp	r3, #0
2400d0a8:	d020      	beq.n	2400d0ec <I2C_ITSlaveCplt+0x31c>
  {
    /* Remove RXNE flag on temporary variable as read done */
    tmpITFlags &= ~I2C_FLAG_RXNE;
2400d0aa:	697b      	ldr	r3, [r7, #20]
2400d0ac:	f023 0304 	bic.w	r3, r3, #4
2400d0b0:	617b      	str	r3, [r7, #20]

    /* Read data from RXDR */
    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
2400d0b2:	687b      	ldr	r3, [r7, #4]
2400d0b4:	681b      	ldr	r3, [r3, #0]
2400d0b6:	6a5a      	ldr	r2, [r3, #36]	; 0x24
2400d0b8:	687b      	ldr	r3, [r7, #4]
2400d0ba:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2400d0bc:	b2d2      	uxtb	r2, r2
2400d0be:	701a      	strb	r2, [r3, #0]

    /* Increment Buffer pointer */
    hi2c->pBuffPtr++;
2400d0c0:	687b      	ldr	r3, [r7, #4]
2400d0c2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2400d0c4:	1c5a      	adds	r2, r3, #1
2400d0c6:	687b      	ldr	r3, [r7, #4]
2400d0c8:	625a      	str	r2, [r3, #36]	; 0x24

    if ((hi2c->XferSize > 0U))
2400d0ca:	687b      	ldr	r3, [r7, #4]
2400d0cc:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400d0ce:	2b00      	cmp	r3, #0
2400d0d0:	d00c      	beq.n	2400d0ec <I2C_ITSlaveCplt+0x31c>
    {
      hi2c->XferSize--;
2400d0d2:	687b      	ldr	r3, [r7, #4]
2400d0d4:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400d0d6:	3b01      	subs	r3, #1
2400d0d8:	b29a      	uxth	r2, r3
2400d0da:	687b      	ldr	r3, [r7, #4]
2400d0dc:	851a      	strh	r2, [r3, #40]	; 0x28
      hi2c->XferCount--;
2400d0de:	687b      	ldr	r3, [r7, #4]
2400d0e0:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400d0e2:	b29b      	uxth	r3, r3
2400d0e4:	3b01      	subs	r3, #1
2400d0e6:	b29a      	uxth	r2, r3
2400d0e8:	687b      	ldr	r3, [r7, #4]
2400d0ea:	855a      	strh	r2, [r3, #42]	; 0x2a
    }
  }

  /* All data are not transferred, so set error code accordingly */
  if (hi2c->XferCount != 0U)
2400d0ec:	687b      	ldr	r3, [r7, #4]
2400d0ee:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400d0f0:	b29b      	uxth	r3, r3
2400d0f2:	2b00      	cmp	r3, #0
2400d0f4:	d005      	beq.n	2400d102 <I2C_ITSlaveCplt+0x332>
  {
    /* Set ErrorCode corresponding to a Non-Acknowledge */
    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
2400d0f6:	687b      	ldr	r3, [r7, #4]
2400d0f8:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400d0fa:	f043 0204 	orr.w	r2, r3, #4
2400d0fe:	687b      	ldr	r3, [r7, #4]
2400d100:	645a      	str	r2, [r3, #68]	; 0x44
  }

  hi2c->Mode = HAL_I2C_MODE_NONE;
2400d102:	687b      	ldr	r3, [r7, #4]
2400d104:	2200      	movs	r2, #0
2400d106:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
  hi2c->XferISR = NULL;
2400d10a:	687b      	ldr	r3, [r7, #4]
2400d10c:	2200      	movs	r2, #0
2400d10e:	635a      	str	r2, [r3, #52]	; 0x34

  if (hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
2400d110:	687b      	ldr	r3, [r7, #4]
2400d112:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400d114:	2b00      	cmp	r3, #0
2400d116:	d010      	beq.n	2400d13a <I2C_ITSlaveCplt+0x36a>
  {
    /* Call the corresponding callback to inform upper layer of End of Transfer */
    I2C_ITError(hi2c, hi2c->ErrorCode);
2400d118:	687b      	ldr	r3, [r7, #4]
2400d11a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400d11c:	4619      	mov	r1, r3
2400d11e:	6878      	ldr	r0, [r7, #4]
2400d120:	f000 f8a4 	bl	2400d26c <I2C_ITError>

    /* Call the Listen Complete callback, to inform upper layer of the end of Listen usecase */
    if (hi2c->State == HAL_I2C_STATE_LISTEN)
2400d124:	687b      	ldr	r3, [r7, #4]
2400d126:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400d12a:	b2db      	uxtb	r3, r3
2400d12c:	2b28      	cmp	r3, #40	; 0x28
2400d12e:	d141      	bne.n	2400d1b4 <I2C_ITSlaveCplt+0x3e4>
    {
      /* Call I2C Listen complete process */
      I2C_ITListenCplt(hi2c, tmpITFlags);
2400d130:	6979      	ldr	r1, [r7, #20]
2400d132:	6878      	ldr	r0, [r7, #4]
2400d134:	f000 f844 	bl	2400d1c0 <I2C_ITListenCplt>
    hi2c->SlaveTxCpltCallback(hi2c);
#else
    HAL_I2C_SlaveTxCpltCallback(hi2c);
#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
  }
}
2400d138:	e03c      	b.n	2400d1b4 <I2C_ITSlaveCplt+0x3e4>
  else if (hi2c->XferOptions != I2C_NO_OPTION_FRAME)
2400d13a:	687b      	ldr	r3, [r7, #4]
2400d13c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2400d13e:	f513 3f80 	cmn.w	r3, #65536	; 0x10000
2400d142:	d014      	beq.n	2400d16e <I2C_ITSlaveCplt+0x39e>
    I2C_ITSlaveSeqCplt(hi2c);
2400d144:	6878      	ldr	r0, [r7, #4]
2400d146:	f7ff fd1c 	bl	2400cb82 <I2C_ITSlaveSeqCplt>
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
2400d14a:	687b      	ldr	r3, [r7, #4]
2400d14c:	4a1b      	ldr	r2, [pc, #108]	; (2400d1bc <I2C_ITSlaveCplt+0x3ec>)
2400d14e:	62da      	str	r2, [r3, #44]	; 0x2c
    hi2c->State = HAL_I2C_STATE_READY;
2400d150:	687b      	ldr	r3, [r7, #4]
2400d152:	2220      	movs	r2, #32
2400d154:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->PreviousState = I2C_STATE_NONE;
2400d158:	687b      	ldr	r3, [r7, #4]
2400d15a:	2200      	movs	r2, #0
2400d15c:	631a      	str	r2, [r3, #48]	; 0x30
    __HAL_UNLOCK(hi2c);
2400d15e:	687b      	ldr	r3, [r7, #4]
2400d160:	2200      	movs	r2, #0
2400d162:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
    HAL_I2C_ListenCpltCallback(hi2c);
2400d166:	6878      	ldr	r0, [r7, #4]
2400d168:	f7fe fe49 	bl	2400bdfe <HAL_I2C_ListenCpltCallback>
}
2400d16c:	e022      	b.n	2400d1b4 <I2C_ITSlaveCplt+0x3e4>
  else if (hi2c->State == HAL_I2C_STATE_BUSY_RX)
2400d16e:	687b      	ldr	r3, [r7, #4]
2400d170:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400d174:	b2db      	uxtb	r3, r3
2400d176:	2b22      	cmp	r3, #34	; 0x22
2400d178:	d10e      	bne.n	2400d198 <I2C_ITSlaveCplt+0x3c8>
    hi2c->State = HAL_I2C_STATE_READY;
2400d17a:	687b      	ldr	r3, [r7, #4]
2400d17c:	2220      	movs	r2, #32
2400d17e:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->PreviousState = I2C_STATE_NONE;
2400d182:	687b      	ldr	r3, [r7, #4]
2400d184:	2200      	movs	r2, #0
2400d186:	631a      	str	r2, [r3, #48]	; 0x30
    __HAL_UNLOCK(hi2c);
2400d188:	687b      	ldr	r3, [r7, #4]
2400d18a:	2200      	movs	r2, #0
2400d18c:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
    HAL_I2C_SlaveRxCpltCallback(hi2c);
2400d190:	6878      	ldr	r0, [r7, #4]
2400d192:	f7fe fe1c 	bl	2400bdce <HAL_I2C_SlaveRxCpltCallback>
}
2400d196:	e00d      	b.n	2400d1b4 <I2C_ITSlaveCplt+0x3e4>
    hi2c->State = HAL_I2C_STATE_READY;
2400d198:	687b      	ldr	r3, [r7, #4]
2400d19a:	2220      	movs	r2, #32
2400d19c:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->PreviousState = I2C_STATE_NONE;
2400d1a0:	687b      	ldr	r3, [r7, #4]
2400d1a2:	2200      	movs	r2, #0
2400d1a4:	631a      	str	r2, [r3, #48]	; 0x30
    __HAL_UNLOCK(hi2c);
2400d1a6:	687b      	ldr	r3, [r7, #4]
2400d1a8:	2200      	movs	r2, #0
2400d1aa:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
    HAL_I2C_SlaveTxCpltCallback(hi2c);
2400d1ae:	6878      	ldr	r0, [r7, #4]
2400d1b0:	f7fe fe03 	bl	2400bdba <HAL_I2C_SlaveTxCpltCallback>
}
2400d1b4:	bf00      	nop
2400d1b6:	3718      	adds	r7, #24
2400d1b8:	46bd      	mov	sp, r7
2400d1ba:	bd80      	pop	{r7, pc}
2400d1bc:	ffff0000 	.word	0xffff0000

2400d1c0 <I2C_ITListenCplt>:
  * @param  hi2c I2C handle.
  * @param  ITFlags Interrupt flags to handle.
  * @retval None
  */
static void I2C_ITListenCplt(I2C_HandleTypeDef *hi2c, uint32_t ITFlags)
{
2400d1c0:	b580      	push	{r7, lr}
2400d1c2:	b082      	sub	sp, #8
2400d1c4:	af00      	add	r7, sp, #0
2400d1c6:	6078      	str	r0, [r7, #4]
2400d1c8:	6039      	str	r1, [r7, #0]
  /* Reset handle parameters */
  hi2c->XferOptions = I2C_NO_OPTION_FRAME;
2400d1ca:	687b      	ldr	r3, [r7, #4]
2400d1cc:	4a26      	ldr	r2, [pc, #152]	; (2400d268 <I2C_ITListenCplt+0xa8>)
2400d1ce:	62da      	str	r2, [r3, #44]	; 0x2c
  hi2c->PreviousState = I2C_STATE_NONE;
2400d1d0:	687b      	ldr	r3, [r7, #4]
2400d1d2:	2200      	movs	r2, #0
2400d1d4:	631a      	str	r2, [r3, #48]	; 0x30
  hi2c->State = HAL_I2C_STATE_READY;
2400d1d6:	687b      	ldr	r3, [r7, #4]
2400d1d8:	2220      	movs	r2, #32
2400d1da:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
  hi2c->Mode = HAL_I2C_MODE_NONE;
2400d1de:	687b      	ldr	r3, [r7, #4]
2400d1e0:	2200      	movs	r2, #0
2400d1e2:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
  hi2c->XferISR = NULL;
2400d1e6:	687b      	ldr	r3, [r7, #4]
2400d1e8:	2200      	movs	r2, #0
2400d1ea:	635a      	str	r2, [r3, #52]	; 0x34

  /* Store Last receive data if any */
  if (I2C_CHECK_FLAG(ITFlags, I2C_FLAG_RXNE) != RESET)
2400d1ec:	683b      	ldr	r3, [r7, #0]
2400d1ee:	089b      	lsrs	r3, r3, #2
2400d1f0:	f003 0301 	and.w	r3, r3, #1
2400d1f4:	2b00      	cmp	r3, #0
2400d1f6:	d022      	beq.n	2400d23e <I2C_ITListenCplt+0x7e>
  {
    /* Read data from RXDR */
    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
2400d1f8:	687b      	ldr	r3, [r7, #4]
2400d1fa:	681b      	ldr	r3, [r3, #0]
2400d1fc:	6a5a      	ldr	r2, [r3, #36]	; 0x24
2400d1fe:	687b      	ldr	r3, [r7, #4]
2400d200:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2400d202:	b2d2      	uxtb	r2, r2
2400d204:	701a      	strb	r2, [r3, #0]

    /* Increment Buffer pointer */
    hi2c->pBuffPtr++;
2400d206:	687b      	ldr	r3, [r7, #4]
2400d208:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2400d20a:	1c5a      	adds	r2, r3, #1
2400d20c:	687b      	ldr	r3, [r7, #4]
2400d20e:	625a      	str	r2, [r3, #36]	; 0x24

    if ((hi2c->XferSize > 0U))
2400d210:	687b      	ldr	r3, [r7, #4]
2400d212:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400d214:	2b00      	cmp	r3, #0
2400d216:	d012      	beq.n	2400d23e <I2C_ITListenCplt+0x7e>
    {
      hi2c->XferSize--;
2400d218:	687b      	ldr	r3, [r7, #4]
2400d21a:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400d21c:	3b01      	subs	r3, #1
2400d21e:	b29a      	uxth	r2, r3
2400d220:	687b      	ldr	r3, [r7, #4]
2400d222:	851a      	strh	r2, [r3, #40]	; 0x28
      hi2c->XferCount--;
2400d224:	687b      	ldr	r3, [r7, #4]
2400d226:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400d228:	b29b      	uxth	r3, r3
2400d22a:	3b01      	subs	r3, #1
2400d22c:	b29a      	uxth	r2, r3
2400d22e:	687b      	ldr	r3, [r7, #4]
2400d230:	855a      	strh	r2, [r3, #42]	; 0x2a

      /* Set ErrorCode corresponding to a Non-Acknowledge */
      hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
2400d232:	687b      	ldr	r3, [r7, #4]
2400d234:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400d236:	f043 0204 	orr.w	r2, r3, #4
2400d23a:	687b      	ldr	r3, [r7, #4]
2400d23c:	645a      	str	r2, [r3, #68]	; 0x44
    }
  }

  /* Disable all Interrupts*/
  I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT | I2C_XFER_RX_IT | I2C_XFER_TX_IT);
2400d23e:	f248 0103 	movw	r1, #32771	; 0x8003
2400d242:	6878      	ldr	r0, [r7, #4]
2400d244:	f000 fe0c 	bl	2400de60 <I2C_Disable_IRQ>

  /* Clear NACK Flag */
  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
2400d248:	687b      	ldr	r3, [r7, #4]
2400d24a:	681b      	ldr	r3, [r3, #0]
2400d24c:	2210      	movs	r2, #16
2400d24e:	61da      	str	r2, [r3, #28]

  /* Process Unlocked */
  __HAL_UNLOCK(hi2c);
2400d250:	687b      	ldr	r3, [r7, #4]
2400d252:	2200      	movs	r2, #0
2400d254:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  /* Call the Listen Complete callback, to inform upper layer of the end of Listen usecase */
#if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
  hi2c->ListenCpltCallback(hi2c);
#else
  HAL_I2C_ListenCpltCallback(hi2c);
2400d258:	6878      	ldr	r0, [r7, #4]
2400d25a:	f7fe fdd0 	bl	2400bdfe <HAL_I2C_ListenCpltCallback>
#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
}
2400d25e:	bf00      	nop
2400d260:	3708      	adds	r7, #8
2400d262:	46bd      	mov	sp, r7
2400d264:	bd80      	pop	{r7, pc}
2400d266:	bf00      	nop
2400d268:	ffff0000 	.word	0xffff0000

2400d26c <I2C_ITError>:
  * @param  hi2c I2C handle.
  * @param  ErrorCode Error code to handle.
  * @retval None
  */
static void I2C_ITError(I2C_HandleTypeDef *hi2c, uint32_t ErrorCode)
{
2400d26c:	b580      	push	{r7, lr}
2400d26e:	b084      	sub	sp, #16
2400d270:	af00      	add	r7, sp, #0
2400d272:	6078      	str	r0, [r7, #4]
2400d274:	6039      	str	r1, [r7, #0]
  HAL_I2C_StateTypeDef tmpstate = hi2c->State;
2400d276:	687b      	ldr	r3, [r7, #4]
2400d278:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400d27c:	73fb      	strb	r3, [r7, #15]
  uint32_t tmppreviousstate;

  /* Reset handle parameters */
  hi2c->Mode          = HAL_I2C_MODE_NONE;
2400d27e:	687b      	ldr	r3, [r7, #4]
2400d280:	2200      	movs	r2, #0
2400d282:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
  hi2c->XferOptions   = I2C_NO_OPTION_FRAME;
2400d286:	687b      	ldr	r3, [r7, #4]
2400d288:	4a5d      	ldr	r2, [pc, #372]	; (2400d400 <I2C_ITError+0x194>)
2400d28a:	62da      	str	r2, [r3, #44]	; 0x2c
  hi2c->XferCount     = 0U;
2400d28c:	687b      	ldr	r3, [r7, #4]
2400d28e:	2200      	movs	r2, #0
2400d290:	855a      	strh	r2, [r3, #42]	; 0x2a

  /* Set new error code */
  hi2c->ErrorCode |= ErrorCode;
2400d292:	687b      	ldr	r3, [r7, #4]
2400d294:	6c5a      	ldr	r2, [r3, #68]	; 0x44
2400d296:	683b      	ldr	r3, [r7, #0]
2400d298:	431a      	orrs	r2, r3
2400d29a:	687b      	ldr	r3, [r7, #4]
2400d29c:	645a      	str	r2, [r3, #68]	; 0x44

  /* Disable Interrupts */
  if ((tmpstate == HAL_I2C_STATE_LISTEN)         ||
2400d29e:	7bfb      	ldrb	r3, [r7, #15]
2400d2a0:	2b28      	cmp	r3, #40	; 0x28
2400d2a2:	d005      	beq.n	2400d2b0 <I2C_ITError+0x44>
2400d2a4:	7bfb      	ldrb	r3, [r7, #15]
2400d2a6:	2b29      	cmp	r3, #41	; 0x29
2400d2a8:	d002      	beq.n	2400d2b0 <I2C_ITError+0x44>
      (tmpstate == HAL_I2C_STATE_BUSY_TX_LISTEN) ||
2400d2aa:	7bfb      	ldrb	r3, [r7, #15]
2400d2ac:	2b2a      	cmp	r3, #42	; 0x2a
2400d2ae:	d10b      	bne.n	2400d2c8 <I2C_ITError+0x5c>
      (tmpstate == HAL_I2C_STATE_BUSY_RX_LISTEN))
  {
    /* Disable all interrupts, except interrupts related to LISTEN state */
    I2C_Disable_IRQ(hi2c, I2C_XFER_RX_IT | I2C_XFER_TX_IT);
2400d2b0:	2103      	movs	r1, #3
2400d2b2:	6878      	ldr	r0, [r7, #4]
2400d2b4:	f000 fdd4 	bl	2400de60 <I2C_Disable_IRQ>

    /* keep HAL_I2C_STATE_LISTEN if set */
    hi2c->State         = HAL_I2C_STATE_LISTEN;
2400d2b8:	687b      	ldr	r3, [r7, #4]
2400d2ba:	2228      	movs	r2, #40	; 0x28
2400d2bc:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->XferISR       = I2C_Slave_ISR_IT;
2400d2c0:	687b      	ldr	r3, [r7, #4]
2400d2c2:	4a50      	ldr	r2, [pc, #320]	; (2400d404 <I2C_ITError+0x198>)
2400d2c4:	635a      	str	r2, [r3, #52]	; 0x34
2400d2c6:	e011      	b.n	2400d2ec <I2C_ITError+0x80>
  }
  else
  {
    /* Disable all interrupts */
    I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT | I2C_XFER_RX_IT | I2C_XFER_TX_IT);
2400d2c8:	f248 0103 	movw	r1, #32771	; 0x8003
2400d2cc:	6878      	ldr	r0, [r7, #4]
2400d2ce:	f000 fdc7 	bl	2400de60 <I2C_Disable_IRQ>

    /* If state is an abort treatment on goind, don't change state */
    /* This change will be do later */
    if (hi2c->State != HAL_I2C_STATE_ABORT)
2400d2d2:	687b      	ldr	r3, [r7, #4]
2400d2d4:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400d2d8:	b2db      	uxtb	r3, r3
2400d2da:	2b60      	cmp	r3, #96	; 0x60
2400d2dc:	d003      	beq.n	2400d2e6 <I2C_ITError+0x7a>
    {
      /* Set HAL_I2C_STATE_READY */
      hi2c->State         = HAL_I2C_STATE_READY;
2400d2de:	687b      	ldr	r3, [r7, #4]
2400d2e0:	2220      	movs	r2, #32
2400d2e2:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    }
    hi2c->XferISR       = NULL;
2400d2e6:	687b      	ldr	r3, [r7, #4]
2400d2e8:	2200      	movs	r2, #0
2400d2ea:	635a      	str	r2, [r3, #52]	; 0x34
  }

  /* Abort DMA TX transfer if any */
  tmppreviousstate = hi2c->PreviousState;
2400d2ec:	687b      	ldr	r3, [r7, #4]
2400d2ee:	6b1b      	ldr	r3, [r3, #48]	; 0x30
2400d2f0:	60bb      	str	r3, [r7, #8]
  if ((hi2c->hdmatx != NULL) && ((tmppreviousstate == I2C_STATE_MASTER_BUSY_TX) || (tmppreviousstate == I2C_STATE_SLAVE_BUSY_TX)))
2400d2f2:	687b      	ldr	r3, [r7, #4]
2400d2f4:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400d2f6:	2b00      	cmp	r3, #0
2400d2f8:	d039      	beq.n	2400d36e <I2C_ITError+0x102>
2400d2fa:	68bb      	ldr	r3, [r7, #8]
2400d2fc:	2b11      	cmp	r3, #17
2400d2fe:	d002      	beq.n	2400d306 <I2C_ITError+0x9a>
2400d300:	68bb      	ldr	r3, [r7, #8]
2400d302:	2b21      	cmp	r3, #33	; 0x21
2400d304:	d133      	bne.n	2400d36e <I2C_ITError+0x102>
  {
    if ((hi2c->Instance->CR1 & I2C_CR1_TXDMAEN) == I2C_CR1_TXDMAEN)
2400d306:	687b      	ldr	r3, [r7, #4]
2400d308:	681b      	ldr	r3, [r3, #0]
2400d30a:	681b      	ldr	r3, [r3, #0]
2400d30c:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
2400d310:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
2400d314:	d107      	bne.n	2400d326 <I2C_ITError+0xba>
    {
      hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;
2400d316:	687b      	ldr	r3, [r7, #4]
2400d318:	681b      	ldr	r3, [r3, #0]
2400d31a:	681a      	ldr	r2, [r3, #0]
2400d31c:	687b      	ldr	r3, [r7, #4]
2400d31e:	681b      	ldr	r3, [r3, #0]
2400d320:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
2400d324:	601a      	str	r2, [r3, #0]
    }

    if (HAL_DMA_GetState(hi2c->hdmatx) != HAL_DMA_STATE_READY)
2400d326:	687b      	ldr	r3, [r7, #4]
2400d328:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400d32a:	4618      	mov	r0, r3
2400d32c:	f7f7 fc78 	bl	24004c20 <HAL_DMA_GetState>
2400d330:	4603      	mov	r3, r0
2400d332:	2b01      	cmp	r3, #1
2400d334:	d017      	beq.n	2400d366 <I2C_ITError+0xfa>
    {
      /* Set the I2C DMA Abort callback :
       will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */
      hi2c->hdmatx->XferAbortCallback = I2C_DMAAbort;
2400d336:	687b      	ldr	r3, [r7, #4]
2400d338:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400d33a:	4a33      	ldr	r2, [pc, #204]	; (2400d408 <I2C_ITError+0x19c>)
2400d33c:	651a      	str	r2, [r3, #80]	; 0x50

      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
2400d33e:	687b      	ldr	r3, [r7, #4]
2400d340:	2200      	movs	r2, #0
2400d342:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

      /* Abort DMA TX */
      if (HAL_DMA_Abort_IT(hi2c->hdmatx) != HAL_OK)
2400d346:	687b      	ldr	r3, [r7, #4]
2400d348:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400d34a:	4618      	mov	r0, r3
2400d34c:	f7f5 fe88 	bl	24003060 <HAL_DMA_Abort_IT>
2400d350:	4603      	mov	r3, r0
2400d352:	2b00      	cmp	r3, #0
2400d354:	d04d      	beq.n	2400d3f2 <I2C_ITError+0x186>
      {
        /* Call Directly XferAbortCallback function in case of error */
        hi2c->hdmatx->XferAbortCallback(hi2c->hdmatx);
2400d356:	687b      	ldr	r3, [r7, #4]
2400d358:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400d35a:	6d1b      	ldr	r3, [r3, #80]	; 0x50
2400d35c:	687a      	ldr	r2, [r7, #4]
2400d35e:	6b92      	ldr	r2, [r2, #56]	; 0x38
2400d360:	4610      	mov	r0, r2
2400d362:	4798      	blx	r3
    if (HAL_DMA_GetState(hi2c->hdmatx) != HAL_DMA_STATE_READY)
2400d364:	e045      	b.n	2400d3f2 <I2C_ITError+0x186>
      }
    }
    else
    {
      I2C_TreatErrorCallback(hi2c);
2400d366:	6878      	ldr	r0, [r7, #4]
2400d368:	f000 f850 	bl	2400d40c <I2C_TreatErrorCallback>
    if (HAL_DMA_GetState(hi2c->hdmatx) != HAL_DMA_STATE_READY)
2400d36c:	e041      	b.n	2400d3f2 <I2C_ITError+0x186>
    }
  }
  /* Abort DMA RX transfer if any */
  else if ((hi2c->hdmarx != NULL) && ((tmppreviousstate == I2C_STATE_MASTER_BUSY_RX) || (tmppreviousstate == I2C_STATE_SLAVE_BUSY_RX)))
2400d36e:	687b      	ldr	r3, [r7, #4]
2400d370:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400d372:	2b00      	cmp	r3, #0
2400d374:	d039      	beq.n	2400d3ea <I2C_ITError+0x17e>
2400d376:	68bb      	ldr	r3, [r7, #8]
2400d378:	2b12      	cmp	r3, #18
2400d37a:	d002      	beq.n	2400d382 <I2C_ITError+0x116>
2400d37c:	68bb      	ldr	r3, [r7, #8]
2400d37e:	2b22      	cmp	r3, #34	; 0x22
2400d380:	d133      	bne.n	2400d3ea <I2C_ITError+0x17e>
  {
    if ((hi2c->Instance->CR1 & I2C_CR1_RXDMAEN) == I2C_CR1_RXDMAEN)
2400d382:	687b      	ldr	r3, [r7, #4]
2400d384:	681b      	ldr	r3, [r3, #0]
2400d386:	681b      	ldr	r3, [r3, #0]
2400d388:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
2400d38c:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
2400d390:	d107      	bne.n	2400d3a2 <I2C_ITError+0x136>
    {
      hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN;
2400d392:	687b      	ldr	r3, [r7, #4]
2400d394:	681b      	ldr	r3, [r3, #0]
2400d396:	681a      	ldr	r2, [r3, #0]
2400d398:	687b      	ldr	r3, [r7, #4]
2400d39a:	681b      	ldr	r3, [r3, #0]
2400d39c:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
2400d3a0:	601a      	str	r2, [r3, #0]
    }

    if (HAL_DMA_GetState(hi2c->hdmarx) != HAL_DMA_STATE_READY)
2400d3a2:	687b      	ldr	r3, [r7, #4]
2400d3a4:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400d3a6:	4618      	mov	r0, r3
2400d3a8:	f7f7 fc3a 	bl	24004c20 <HAL_DMA_GetState>
2400d3ac:	4603      	mov	r3, r0
2400d3ae:	2b01      	cmp	r3, #1
2400d3b0:	d017      	beq.n	2400d3e2 <I2C_ITError+0x176>
    {
      /* Set the I2C DMA Abort callback :
        will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */
      hi2c->hdmarx->XferAbortCallback = I2C_DMAAbort;
2400d3b2:	687b      	ldr	r3, [r7, #4]
2400d3b4:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400d3b6:	4a14      	ldr	r2, [pc, #80]	; (2400d408 <I2C_ITError+0x19c>)
2400d3b8:	651a      	str	r2, [r3, #80]	; 0x50

      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
2400d3ba:	687b      	ldr	r3, [r7, #4]
2400d3bc:	2200      	movs	r2, #0
2400d3be:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

      /* Abort DMA RX */
      if (HAL_DMA_Abort_IT(hi2c->hdmarx) != HAL_OK)
2400d3c2:	687b      	ldr	r3, [r7, #4]
2400d3c4:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400d3c6:	4618      	mov	r0, r3
2400d3c8:	f7f5 fe4a 	bl	24003060 <HAL_DMA_Abort_IT>
2400d3cc:	4603      	mov	r3, r0
2400d3ce:	2b00      	cmp	r3, #0
2400d3d0:	d011      	beq.n	2400d3f6 <I2C_ITError+0x18a>
      {
        /* Call Directly hi2c->hdmarx->XferAbortCallback function in case of error */
        hi2c->hdmarx->XferAbortCallback(hi2c->hdmarx);
2400d3d2:	687b      	ldr	r3, [r7, #4]
2400d3d4:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400d3d6:	6d1b      	ldr	r3, [r3, #80]	; 0x50
2400d3d8:	687a      	ldr	r2, [r7, #4]
2400d3da:	6bd2      	ldr	r2, [r2, #60]	; 0x3c
2400d3dc:	4610      	mov	r0, r2
2400d3de:	4798      	blx	r3
    if (HAL_DMA_GetState(hi2c->hdmarx) != HAL_DMA_STATE_READY)
2400d3e0:	e009      	b.n	2400d3f6 <I2C_ITError+0x18a>
      }
    }
    else
    {
      I2C_TreatErrorCallback(hi2c);
2400d3e2:	6878      	ldr	r0, [r7, #4]
2400d3e4:	f000 f812 	bl	2400d40c <I2C_TreatErrorCallback>
    if (HAL_DMA_GetState(hi2c->hdmarx) != HAL_DMA_STATE_READY)
2400d3e8:	e005      	b.n	2400d3f6 <I2C_ITError+0x18a>
    }
  }
  else
  {
    I2C_TreatErrorCallback(hi2c);
2400d3ea:	6878      	ldr	r0, [r7, #4]
2400d3ec:	f000 f80e 	bl	2400d40c <I2C_TreatErrorCallback>
  }
}
2400d3f0:	e002      	b.n	2400d3f8 <I2C_ITError+0x18c>
    if (HAL_DMA_GetState(hi2c->hdmatx) != HAL_DMA_STATE_READY)
2400d3f2:	bf00      	nop
2400d3f4:	e000      	b.n	2400d3f8 <I2C_ITError+0x18c>
    if (HAL_DMA_GetState(hi2c->hdmarx) != HAL_DMA_STATE_READY)
2400d3f6:	bf00      	nop
}
2400d3f8:	bf00      	nop
2400d3fa:	3710      	adds	r7, #16
2400d3fc:	46bd      	mov	sp, r7
2400d3fe:	bd80      	pop	{r7, pc}
2400d400:	ffff0000 	.word	0xffff0000
2400d404:	2400c105 	.word	0x2400c105
2400d408:	2400d9e5 	.word	0x2400d9e5

2400d40c <I2C_TreatErrorCallback>:
  * @brief  I2C Error callback treatment.
  * @param  hi2c I2C handle.
  * @retval None
  */
static void I2C_TreatErrorCallback(I2C_HandleTypeDef *hi2c)
{
2400d40c:	b580      	push	{r7, lr}
2400d40e:	b082      	sub	sp, #8
2400d410:	af00      	add	r7, sp, #0
2400d412:	6078      	str	r0, [r7, #4]
  if (hi2c->State == HAL_I2C_STATE_ABORT)
2400d414:	687b      	ldr	r3, [r7, #4]
2400d416:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400d41a:	b2db      	uxtb	r3, r3
2400d41c:	2b60      	cmp	r3, #96	; 0x60
2400d41e:	d10e      	bne.n	2400d43e <I2C_TreatErrorCallback+0x32>
  {
    hi2c->State = HAL_I2C_STATE_READY;
2400d420:	687b      	ldr	r3, [r7, #4]
2400d422:	2220      	movs	r2, #32
2400d424:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->PreviousState = I2C_STATE_NONE;
2400d428:	687b      	ldr	r3, [r7, #4]
2400d42a:	2200      	movs	r2, #0
2400d42c:	631a      	str	r2, [r3, #48]	; 0x30

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
2400d42e:	687b      	ldr	r3, [r7, #4]
2400d430:	2200      	movs	r2, #0
2400d432:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Call the corresponding callback to inform upper layer of End of Transfer */
#if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
    hi2c->AbortCpltCallback(hi2c);
#else
    HAL_I2C_AbortCpltCallback(hi2c);
2400d436:	6878      	ldr	r0, [r7, #4]
2400d438:	f7fe fd09 	bl	2400be4e <HAL_I2C_AbortCpltCallback>
    hi2c->ErrorCallback(hi2c);
#else
    HAL_I2C_ErrorCallback(hi2c);
#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
  }
}
2400d43c:	e009      	b.n	2400d452 <I2C_TreatErrorCallback+0x46>
    hi2c->PreviousState = I2C_STATE_NONE;
2400d43e:	687b      	ldr	r3, [r7, #4]
2400d440:	2200      	movs	r2, #0
2400d442:	631a      	str	r2, [r3, #48]	; 0x30
    __HAL_UNLOCK(hi2c);
2400d444:	687b      	ldr	r3, [r7, #4]
2400d446:	2200      	movs	r2, #0
2400d448:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
    HAL_I2C_ErrorCallback(hi2c);
2400d44c:	6878      	ldr	r0, [r7, #4]
2400d44e:	f7fe fcf4 	bl	2400be3a <HAL_I2C_ErrorCallback>
}
2400d452:	bf00      	nop
2400d454:	3708      	adds	r7, #8
2400d456:	46bd      	mov	sp, r7
2400d458:	bd80      	pop	{r7, pc}

2400d45a <I2C_Flush_TXDR>:
  * @brief  I2C Tx data register flush process.
  * @param  hi2c I2C handle.
  * @retval None
  */
static void I2C_Flush_TXDR(I2C_HandleTypeDef *hi2c)
{
2400d45a:	b480      	push	{r7}
2400d45c:	b083      	sub	sp, #12
2400d45e:	af00      	add	r7, sp, #0
2400d460:	6078      	str	r0, [r7, #4]
  /* If a pending TXIS flag is set */
  /* Write a dummy data in TXDR to clear it */
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) != RESET)
2400d462:	687b      	ldr	r3, [r7, #4]
2400d464:	681b      	ldr	r3, [r3, #0]
2400d466:	699b      	ldr	r3, [r3, #24]
2400d468:	f003 0302 	and.w	r3, r3, #2
2400d46c:	2b02      	cmp	r3, #2
2400d46e:	d103      	bne.n	2400d478 <I2C_Flush_TXDR+0x1e>
  {
    hi2c->Instance->TXDR = 0x00U;
2400d470:	687b      	ldr	r3, [r7, #4]
2400d472:	681b      	ldr	r3, [r3, #0]
2400d474:	2200      	movs	r2, #0
2400d476:	629a      	str	r2, [r3, #40]	; 0x28
  }

  /* Flush TX register if not empty */
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
2400d478:	687b      	ldr	r3, [r7, #4]
2400d47a:	681b      	ldr	r3, [r3, #0]
2400d47c:	699b      	ldr	r3, [r3, #24]
2400d47e:	f003 0301 	and.w	r3, r3, #1
2400d482:	2b01      	cmp	r3, #1
2400d484:	d007      	beq.n	2400d496 <I2C_Flush_TXDR+0x3c>
  {
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_TXE);
2400d486:	687b      	ldr	r3, [r7, #4]
2400d488:	681b      	ldr	r3, [r3, #0]
2400d48a:	699a      	ldr	r2, [r3, #24]
2400d48c:	687b      	ldr	r3, [r7, #4]
2400d48e:	681b      	ldr	r3, [r3, #0]
2400d490:	f042 0201 	orr.w	r2, r2, #1
2400d494:	619a      	str	r2, [r3, #24]
  }
}
2400d496:	bf00      	nop
2400d498:	370c      	adds	r7, #12
2400d49a:	46bd      	mov	sp, r7
2400d49c:	f85d 7b04 	ldr.w	r7, [sp], #4
2400d4a0:	4770      	bx	lr

2400d4a2 <I2C_DMAMasterTransmitCplt>:
  * @brief  DMA I2C master transmit process complete callback.
  * @param  hdma DMA handle
  * @retval None
  */
static void I2C_DMAMasterTransmitCplt(DMA_HandleTypeDef *hdma)
{
2400d4a2:	b580      	push	{r7, lr}
2400d4a4:	b084      	sub	sp, #16
2400d4a6:	af00      	add	r7, sp, #0
2400d4a8:	6078      	str	r0, [r7, #4]
  I2C_HandleTypeDef *hi2c = (I2C_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
2400d4aa:	687b      	ldr	r3, [r7, #4]
2400d4ac:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400d4ae:	60fb      	str	r3, [r7, #12]

  /* Disable DMA Request */
  hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;
2400d4b0:	68fb      	ldr	r3, [r7, #12]
2400d4b2:	681b      	ldr	r3, [r3, #0]
2400d4b4:	681a      	ldr	r2, [r3, #0]
2400d4b6:	68fb      	ldr	r3, [r7, #12]
2400d4b8:	681b      	ldr	r3, [r3, #0]
2400d4ba:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
2400d4be:	601a      	str	r2, [r3, #0]

  /* If last transfer, enable STOP interrupt */
  if (hi2c->XferCount == 0U)
2400d4c0:	68fb      	ldr	r3, [r7, #12]
2400d4c2:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400d4c4:	b29b      	uxth	r3, r3
2400d4c6:	2b00      	cmp	r3, #0
2400d4c8:	d104      	bne.n	2400d4d4 <I2C_DMAMasterTransmitCplt+0x32>
  {
    /* Enable STOP interrupt */
    I2C_Enable_IRQ(hi2c, I2C_XFER_CPLT_IT);
2400d4ca:	2120      	movs	r1, #32
2400d4cc:	68f8      	ldr	r0, [r7, #12]
2400d4ce:	f000 fc63 	bl	2400dd98 <I2C_Enable_IRQ>
    {
      /* Enable TC interrupts */
      I2C_Enable_IRQ(hi2c, I2C_XFER_RELOAD_IT);
    }
  }
}
2400d4d2:	e02d      	b.n	2400d530 <I2C_DMAMasterTransmitCplt+0x8e>
    hi2c->pBuffPtr += hi2c->XferSize;
2400d4d4:	68fb      	ldr	r3, [r7, #12]
2400d4d6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2400d4d8:	68fa      	ldr	r2, [r7, #12]
2400d4da:	8d12      	ldrh	r2, [r2, #40]	; 0x28
2400d4dc:	441a      	add	r2, r3
2400d4de:	68fb      	ldr	r3, [r7, #12]
2400d4e0:	625a      	str	r2, [r3, #36]	; 0x24
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
2400d4e2:	68fb      	ldr	r3, [r7, #12]
2400d4e4:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400d4e6:	b29b      	uxth	r3, r3
2400d4e8:	2bff      	cmp	r3, #255	; 0xff
2400d4ea:	d903      	bls.n	2400d4f4 <I2C_DMAMasterTransmitCplt+0x52>
      hi2c->XferSize = MAX_NBYTE_SIZE;
2400d4ec:	68fb      	ldr	r3, [r7, #12]
2400d4ee:	22ff      	movs	r2, #255	; 0xff
2400d4f0:	851a      	strh	r2, [r3, #40]	; 0x28
2400d4f2:	e004      	b.n	2400d4fe <I2C_DMAMasterTransmitCplt+0x5c>
      hi2c->XferSize = hi2c->XferCount;
2400d4f4:	68fb      	ldr	r3, [r7, #12]
2400d4f6:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400d4f8:	b29a      	uxth	r2, r3
2400d4fa:	68fb      	ldr	r3, [r7, #12]
2400d4fc:	851a      	strh	r2, [r3, #40]	; 0x28
    if (HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)hi2c->pBuffPtr, (uint32_t)&hi2c->Instance->TXDR, hi2c->XferSize) != HAL_OK)
2400d4fe:	68fb      	ldr	r3, [r7, #12]
2400d500:	6b98      	ldr	r0, [r3, #56]	; 0x38
2400d502:	68fb      	ldr	r3, [r7, #12]
2400d504:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2400d506:	4619      	mov	r1, r3
2400d508:	68fb      	ldr	r3, [r7, #12]
2400d50a:	681b      	ldr	r3, [r3, #0]
2400d50c:	3328      	adds	r3, #40	; 0x28
2400d50e:	461a      	mov	r2, r3
2400d510:	68fb      	ldr	r3, [r7, #12]
2400d512:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400d514:	f7f5 f81c 	bl	24002550 <HAL_DMA_Start_IT>
2400d518:	4603      	mov	r3, r0
2400d51a:	2b00      	cmp	r3, #0
2400d51c:	d004      	beq.n	2400d528 <I2C_DMAMasterTransmitCplt+0x86>
      I2C_ITError(hi2c, HAL_I2C_ERROR_DMA);
2400d51e:	2110      	movs	r1, #16
2400d520:	68f8      	ldr	r0, [r7, #12]
2400d522:	f7ff fea3 	bl	2400d26c <I2C_ITError>
}
2400d526:	e003      	b.n	2400d530 <I2C_DMAMasterTransmitCplt+0x8e>
      I2C_Enable_IRQ(hi2c, I2C_XFER_RELOAD_IT);
2400d528:	2140      	movs	r1, #64	; 0x40
2400d52a:	68f8      	ldr	r0, [r7, #12]
2400d52c:	f000 fc34 	bl	2400dd98 <I2C_Enable_IRQ>
}
2400d530:	bf00      	nop
2400d532:	3710      	adds	r7, #16
2400d534:	46bd      	mov	sp, r7
2400d536:	bd80      	pop	{r7, pc}

2400d538 <I2C_DMASlaveTransmitCplt>:
  * @brief  DMA I2C slave transmit process complete callback.
  * @param  hdma DMA handle
  * @retval None
  */
static void I2C_DMASlaveTransmitCplt(DMA_HandleTypeDef *hdma)
{
2400d538:	b580      	push	{r7, lr}
2400d53a:	b084      	sub	sp, #16
2400d53c:	af00      	add	r7, sp, #0
2400d53e:	6078      	str	r0, [r7, #4]
  I2C_HandleTypeDef *hi2c = (I2C_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
2400d540:	687b      	ldr	r3, [r7, #4]
2400d542:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400d544:	60fb      	str	r3, [r7, #12]
  uint32_t tmpoptions = hi2c->XferOptions;
2400d546:	68fb      	ldr	r3, [r7, #12]
2400d548:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2400d54a:	60bb      	str	r3, [r7, #8]

  if ((tmpoptions == I2C_NEXT_FRAME) || (tmpoptions == I2C_FIRST_FRAME))
2400d54c:	68bb      	ldr	r3, [r7, #8]
2400d54e:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
2400d552:	d002      	beq.n	2400d55a <I2C_DMASlaveTransmitCplt+0x22>
2400d554:	68bb      	ldr	r3, [r7, #8]
2400d556:	2b00      	cmp	r3, #0
2400d558:	d10a      	bne.n	2400d570 <I2C_DMASlaveTransmitCplt+0x38>
  {
    /* Disable DMA Request */
    hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;
2400d55a:	68fb      	ldr	r3, [r7, #12]
2400d55c:	681b      	ldr	r3, [r3, #0]
2400d55e:	681a      	ldr	r2, [r3, #0]
2400d560:	68fb      	ldr	r3, [r7, #12]
2400d562:	681b      	ldr	r3, [r3, #0]
2400d564:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
2400d568:	601a      	str	r2, [r3, #0]

    /* Last Byte is Transmitted */
    /* Call I2C Slave Sequential complete process */
    I2C_ITSlaveSeqCplt(hi2c);
2400d56a:	68f8      	ldr	r0, [r7, #12]
2400d56c:	f7ff fb09 	bl	2400cb82 <I2C_ITSlaveSeqCplt>
  {
    /* No specific action, Master fully manage the generation of STOP condition */
    /* Mean that this generation can arrive at any time, at the end or during DMA process */
    /* So STOP condition should be manage through Interrupt treatment */
  }
}
2400d570:	bf00      	nop
2400d572:	3710      	adds	r7, #16
2400d574:	46bd      	mov	sp, r7
2400d576:	bd80      	pop	{r7, pc}

2400d578 <I2C_DMAMasterReceiveCplt>:
  * @brief DMA I2C master receive process complete callback.
  * @param  hdma DMA handle
  * @retval None
  */
static void I2C_DMAMasterReceiveCplt(DMA_HandleTypeDef *hdma)
{
2400d578:	b580      	push	{r7, lr}
2400d57a:	b084      	sub	sp, #16
2400d57c:	af00      	add	r7, sp, #0
2400d57e:	6078      	str	r0, [r7, #4]
  I2C_HandleTypeDef *hi2c = (I2C_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
2400d580:	687b      	ldr	r3, [r7, #4]
2400d582:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400d584:	60fb      	str	r3, [r7, #12]

  /* Disable DMA Request */
  hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN;
2400d586:	68fb      	ldr	r3, [r7, #12]
2400d588:	681b      	ldr	r3, [r3, #0]
2400d58a:	681a      	ldr	r2, [r3, #0]
2400d58c:	68fb      	ldr	r3, [r7, #12]
2400d58e:	681b      	ldr	r3, [r3, #0]
2400d590:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
2400d594:	601a      	str	r2, [r3, #0]

  /* If last transfer, enable STOP interrupt */
  if (hi2c->XferCount == 0U)
2400d596:	68fb      	ldr	r3, [r7, #12]
2400d598:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400d59a:	b29b      	uxth	r3, r3
2400d59c:	2b00      	cmp	r3, #0
2400d59e:	d104      	bne.n	2400d5aa <I2C_DMAMasterReceiveCplt+0x32>
  {
    /* Enable STOP interrupt */
    I2C_Enable_IRQ(hi2c, I2C_XFER_CPLT_IT);
2400d5a0:	2120      	movs	r1, #32
2400d5a2:	68f8      	ldr	r0, [r7, #12]
2400d5a4:	f000 fbf8 	bl	2400dd98 <I2C_Enable_IRQ>
    {
      /* Enable TC interrupts */
      I2C_Enable_IRQ(hi2c, I2C_XFER_RELOAD_IT);
    }
  }
}
2400d5a8:	e02d      	b.n	2400d606 <I2C_DMAMasterReceiveCplt+0x8e>
    hi2c->pBuffPtr += hi2c->XferSize;
2400d5aa:	68fb      	ldr	r3, [r7, #12]
2400d5ac:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2400d5ae:	68fa      	ldr	r2, [r7, #12]
2400d5b0:	8d12      	ldrh	r2, [r2, #40]	; 0x28
2400d5b2:	441a      	add	r2, r3
2400d5b4:	68fb      	ldr	r3, [r7, #12]
2400d5b6:	625a      	str	r2, [r3, #36]	; 0x24
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
2400d5b8:	68fb      	ldr	r3, [r7, #12]
2400d5ba:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400d5bc:	b29b      	uxth	r3, r3
2400d5be:	2bff      	cmp	r3, #255	; 0xff
2400d5c0:	d903      	bls.n	2400d5ca <I2C_DMAMasterReceiveCplt+0x52>
      hi2c->XferSize = MAX_NBYTE_SIZE;
2400d5c2:	68fb      	ldr	r3, [r7, #12]
2400d5c4:	22ff      	movs	r2, #255	; 0xff
2400d5c6:	851a      	strh	r2, [r3, #40]	; 0x28
2400d5c8:	e004      	b.n	2400d5d4 <I2C_DMAMasterReceiveCplt+0x5c>
      hi2c->XferSize = hi2c->XferCount;
2400d5ca:	68fb      	ldr	r3, [r7, #12]
2400d5cc:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400d5ce:	b29a      	uxth	r2, r3
2400d5d0:	68fb      	ldr	r3, [r7, #12]
2400d5d2:	851a      	strh	r2, [r3, #40]	; 0x28
    if (HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->RXDR, (uint32_t)hi2c->pBuffPtr, hi2c->XferSize) != HAL_OK)
2400d5d4:	68fb      	ldr	r3, [r7, #12]
2400d5d6:	6bd8      	ldr	r0, [r3, #60]	; 0x3c
2400d5d8:	68fb      	ldr	r3, [r7, #12]
2400d5da:	681b      	ldr	r3, [r3, #0]
2400d5dc:	3324      	adds	r3, #36	; 0x24
2400d5de:	4619      	mov	r1, r3
2400d5e0:	68fb      	ldr	r3, [r7, #12]
2400d5e2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2400d5e4:	461a      	mov	r2, r3
2400d5e6:	68fb      	ldr	r3, [r7, #12]
2400d5e8:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400d5ea:	f7f4 ffb1 	bl	24002550 <HAL_DMA_Start_IT>
2400d5ee:	4603      	mov	r3, r0
2400d5f0:	2b00      	cmp	r3, #0
2400d5f2:	d004      	beq.n	2400d5fe <I2C_DMAMasterReceiveCplt+0x86>
      I2C_ITError(hi2c, HAL_I2C_ERROR_DMA);
2400d5f4:	2110      	movs	r1, #16
2400d5f6:	68f8      	ldr	r0, [r7, #12]
2400d5f8:	f7ff fe38 	bl	2400d26c <I2C_ITError>
}
2400d5fc:	e003      	b.n	2400d606 <I2C_DMAMasterReceiveCplt+0x8e>
      I2C_Enable_IRQ(hi2c, I2C_XFER_RELOAD_IT);
2400d5fe:	2140      	movs	r1, #64	; 0x40
2400d600:	68f8      	ldr	r0, [r7, #12]
2400d602:	f000 fbc9 	bl	2400dd98 <I2C_Enable_IRQ>
}
2400d606:	bf00      	nop
2400d608:	3710      	adds	r7, #16
2400d60a:	46bd      	mov	sp, r7
2400d60c:	bd80      	pop	{r7, pc}
	...

2400d610 <I2C_DMASlaveReceiveCplt>:
  * @brief  DMA I2C slave receive process complete callback.
  * @param  hdma DMA handle
  * @retval None
  */
static void I2C_DMASlaveReceiveCplt(DMA_HandleTypeDef *hdma)
{
2400d610:	b580      	push	{r7, lr}
2400d612:	b084      	sub	sp, #16
2400d614:	af00      	add	r7, sp, #0
2400d616:	6078      	str	r0, [r7, #4]
  I2C_HandleTypeDef *hi2c = (I2C_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
2400d618:	687b      	ldr	r3, [r7, #4]
2400d61a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400d61c:	60fb      	str	r3, [r7, #12]
  uint32_t tmpoptions = hi2c->XferOptions;
2400d61e:	68fb      	ldr	r3, [r7, #12]
2400d620:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2400d622:	60bb      	str	r3, [r7, #8]

  if ((__HAL_DMA_GET_COUNTER(hi2c->hdmarx) == 0U) && \
2400d624:	68fb      	ldr	r3, [r7, #12]
2400d626:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400d628:	681b      	ldr	r3, [r3, #0]
2400d62a:	4a42      	ldr	r2, [pc, #264]	; (2400d734 <I2C_DMASlaveReceiveCplt+0x124>)
2400d62c:	4293      	cmp	r3, r2
2400d62e:	d059      	beq.n	2400d6e4 <I2C_DMASlaveReceiveCplt+0xd4>
2400d630:	68fb      	ldr	r3, [r7, #12]
2400d632:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400d634:	681b      	ldr	r3, [r3, #0]
2400d636:	4a40      	ldr	r2, [pc, #256]	; (2400d738 <I2C_DMASlaveReceiveCplt+0x128>)
2400d638:	4293      	cmp	r3, r2
2400d63a:	d053      	beq.n	2400d6e4 <I2C_DMASlaveReceiveCplt+0xd4>
2400d63c:	68fb      	ldr	r3, [r7, #12]
2400d63e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400d640:	681b      	ldr	r3, [r3, #0]
2400d642:	4a3e      	ldr	r2, [pc, #248]	; (2400d73c <I2C_DMASlaveReceiveCplt+0x12c>)
2400d644:	4293      	cmp	r3, r2
2400d646:	d04d      	beq.n	2400d6e4 <I2C_DMASlaveReceiveCplt+0xd4>
2400d648:	68fb      	ldr	r3, [r7, #12]
2400d64a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400d64c:	681b      	ldr	r3, [r3, #0]
2400d64e:	4a3c      	ldr	r2, [pc, #240]	; (2400d740 <I2C_DMASlaveReceiveCplt+0x130>)
2400d650:	4293      	cmp	r3, r2
2400d652:	d047      	beq.n	2400d6e4 <I2C_DMASlaveReceiveCplt+0xd4>
2400d654:	68fb      	ldr	r3, [r7, #12]
2400d656:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400d658:	681b      	ldr	r3, [r3, #0]
2400d65a:	4a3a      	ldr	r2, [pc, #232]	; (2400d744 <I2C_DMASlaveReceiveCplt+0x134>)
2400d65c:	4293      	cmp	r3, r2
2400d65e:	d041      	beq.n	2400d6e4 <I2C_DMASlaveReceiveCplt+0xd4>
2400d660:	68fb      	ldr	r3, [r7, #12]
2400d662:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400d664:	681b      	ldr	r3, [r3, #0]
2400d666:	4a38      	ldr	r2, [pc, #224]	; (2400d748 <I2C_DMASlaveReceiveCplt+0x138>)
2400d668:	4293      	cmp	r3, r2
2400d66a:	d03b      	beq.n	2400d6e4 <I2C_DMASlaveReceiveCplt+0xd4>
2400d66c:	68fb      	ldr	r3, [r7, #12]
2400d66e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400d670:	681b      	ldr	r3, [r3, #0]
2400d672:	4a36      	ldr	r2, [pc, #216]	; (2400d74c <I2C_DMASlaveReceiveCplt+0x13c>)
2400d674:	4293      	cmp	r3, r2
2400d676:	d035      	beq.n	2400d6e4 <I2C_DMASlaveReceiveCplt+0xd4>
2400d678:	68fb      	ldr	r3, [r7, #12]
2400d67a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400d67c:	681b      	ldr	r3, [r3, #0]
2400d67e:	4a34      	ldr	r2, [pc, #208]	; (2400d750 <I2C_DMASlaveReceiveCplt+0x140>)
2400d680:	4293      	cmp	r3, r2
2400d682:	d02f      	beq.n	2400d6e4 <I2C_DMASlaveReceiveCplt+0xd4>
2400d684:	68fb      	ldr	r3, [r7, #12]
2400d686:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400d688:	681b      	ldr	r3, [r3, #0]
2400d68a:	4a32      	ldr	r2, [pc, #200]	; (2400d754 <I2C_DMASlaveReceiveCplt+0x144>)
2400d68c:	4293      	cmp	r3, r2
2400d68e:	d029      	beq.n	2400d6e4 <I2C_DMASlaveReceiveCplt+0xd4>
2400d690:	68fb      	ldr	r3, [r7, #12]
2400d692:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400d694:	681b      	ldr	r3, [r3, #0]
2400d696:	4a30      	ldr	r2, [pc, #192]	; (2400d758 <I2C_DMASlaveReceiveCplt+0x148>)
2400d698:	4293      	cmp	r3, r2
2400d69a:	d023      	beq.n	2400d6e4 <I2C_DMASlaveReceiveCplt+0xd4>
2400d69c:	68fb      	ldr	r3, [r7, #12]
2400d69e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400d6a0:	681b      	ldr	r3, [r3, #0]
2400d6a2:	4a2e      	ldr	r2, [pc, #184]	; (2400d75c <I2C_DMASlaveReceiveCplt+0x14c>)
2400d6a4:	4293      	cmp	r3, r2
2400d6a6:	d01d      	beq.n	2400d6e4 <I2C_DMASlaveReceiveCplt+0xd4>
2400d6a8:	68fb      	ldr	r3, [r7, #12]
2400d6aa:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400d6ac:	681b      	ldr	r3, [r3, #0]
2400d6ae:	4a2c      	ldr	r2, [pc, #176]	; (2400d760 <I2C_DMASlaveReceiveCplt+0x150>)
2400d6b0:	4293      	cmp	r3, r2
2400d6b2:	d017      	beq.n	2400d6e4 <I2C_DMASlaveReceiveCplt+0xd4>
2400d6b4:	68fb      	ldr	r3, [r7, #12]
2400d6b6:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400d6b8:	681b      	ldr	r3, [r3, #0]
2400d6ba:	4a2a      	ldr	r2, [pc, #168]	; (2400d764 <I2C_DMASlaveReceiveCplt+0x154>)
2400d6bc:	4293      	cmp	r3, r2
2400d6be:	d011      	beq.n	2400d6e4 <I2C_DMASlaveReceiveCplt+0xd4>
2400d6c0:	68fb      	ldr	r3, [r7, #12]
2400d6c2:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400d6c4:	681b      	ldr	r3, [r3, #0]
2400d6c6:	4a28      	ldr	r2, [pc, #160]	; (2400d768 <I2C_DMASlaveReceiveCplt+0x158>)
2400d6c8:	4293      	cmp	r3, r2
2400d6ca:	d00b      	beq.n	2400d6e4 <I2C_DMASlaveReceiveCplt+0xd4>
2400d6cc:	68fb      	ldr	r3, [r7, #12]
2400d6ce:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400d6d0:	681b      	ldr	r3, [r3, #0]
2400d6d2:	4a26      	ldr	r2, [pc, #152]	; (2400d76c <I2C_DMASlaveReceiveCplt+0x15c>)
2400d6d4:	4293      	cmp	r3, r2
2400d6d6:	d005      	beq.n	2400d6e4 <I2C_DMASlaveReceiveCplt+0xd4>
2400d6d8:	68fb      	ldr	r3, [r7, #12]
2400d6da:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400d6dc:	681b      	ldr	r3, [r3, #0]
2400d6de:	4a24      	ldr	r2, [pc, #144]	; (2400d770 <I2C_DMASlaveReceiveCplt+0x160>)
2400d6e0:	4293      	cmp	r3, r2
2400d6e2:	d109      	bne.n	2400d6f8 <I2C_DMASlaveReceiveCplt+0xe8>
2400d6e4:	68fb      	ldr	r3, [r7, #12]
2400d6e6:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400d6e8:	681b      	ldr	r3, [r3, #0]
2400d6ea:	685b      	ldr	r3, [r3, #4]
2400d6ec:	2b00      	cmp	r3, #0
2400d6ee:	bf0c      	ite	eq
2400d6f0:	2301      	moveq	r3, #1
2400d6f2:	2300      	movne	r3, #0
2400d6f4:	b2db      	uxtb	r3, r3
2400d6f6:	e008      	b.n	2400d70a <I2C_DMASlaveReceiveCplt+0xfa>
2400d6f8:	68fb      	ldr	r3, [r7, #12]
2400d6fa:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400d6fc:	681b      	ldr	r3, [r3, #0]
2400d6fe:	685b      	ldr	r3, [r3, #4]
2400d700:	2b00      	cmp	r3, #0
2400d702:	bf0c      	ite	eq
2400d704:	2301      	moveq	r3, #1
2400d706:	2300      	movne	r3, #0
2400d708:	b2db      	uxtb	r3, r3
2400d70a:	2b00      	cmp	r3, #0
2400d70c:	d00e      	beq.n	2400d72c <I2C_DMASlaveReceiveCplt+0x11c>
2400d70e:	68bb      	ldr	r3, [r7, #8]
2400d710:	f513 3f80 	cmn.w	r3, #65536	; 0x10000
2400d714:	d00a      	beq.n	2400d72c <I2C_DMASlaveReceiveCplt+0x11c>
      (tmpoptions != I2C_NO_OPTION_FRAME))
  {
    /* Disable DMA Request */
    hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN;
2400d716:	68fb      	ldr	r3, [r7, #12]
2400d718:	681b      	ldr	r3, [r3, #0]
2400d71a:	681a      	ldr	r2, [r3, #0]
2400d71c:	68fb      	ldr	r3, [r7, #12]
2400d71e:	681b      	ldr	r3, [r3, #0]
2400d720:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
2400d724:	601a      	str	r2, [r3, #0]

    /* Call I2C Slave Sequential complete process */
    I2C_ITSlaveSeqCplt(hi2c);
2400d726:	68f8      	ldr	r0, [r7, #12]
2400d728:	f7ff fa2b 	bl	2400cb82 <I2C_ITSlaveSeqCplt>
  {
    /* No specific action, Master fully manage the generation of STOP condition */
    /* Mean that this generation can arrive at any time, at the end or during DMA process */
    /* So STOP condition should be manage through Interrupt treatment */
  }
}
2400d72c:	bf00      	nop
2400d72e:	3710      	adds	r7, #16
2400d730:	46bd      	mov	sp, r7
2400d732:	bd80      	pop	{r7, pc}
2400d734:	40020010 	.word	0x40020010
2400d738:	40020028 	.word	0x40020028
2400d73c:	40020040 	.word	0x40020040
2400d740:	40020058 	.word	0x40020058
2400d744:	40020070 	.word	0x40020070
2400d748:	40020088 	.word	0x40020088
2400d74c:	400200a0 	.word	0x400200a0
2400d750:	400200b8 	.word	0x400200b8
2400d754:	40020410 	.word	0x40020410
2400d758:	40020428 	.word	0x40020428
2400d75c:	40020440 	.word	0x40020440
2400d760:	40020458 	.word	0x40020458
2400d764:	40020470 	.word	0x40020470
2400d768:	40020488 	.word	0x40020488
2400d76c:	400204a0 	.word	0x400204a0
2400d770:	400204b8 	.word	0x400204b8

2400d774 <I2C_DMAError>:
  * @brief  DMA I2C communication error callback.
  * @param hdma DMA handle
  * @retval None
  */
static void I2C_DMAError(DMA_HandleTypeDef *hdma)
{
2400d774:	b580      	push	{r7, lr}
2400d776:	b084      	sub	sp, #16
2400d778:	af00      	add	r7, sp, #0
2400d77a:	6078      	str	r0, [r7, #4]
  uint32_t treatdmaerror = 0U;
2400d77c:	2300      	movs	r3, #0
2400d77e:	60fb      	str	r3, [r7, #12]
  I2C_HandleTypeDef *hi2c = (I2C_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
2400d780:	687b      	ldr	r3, [r7, #4]
2400d782:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400d784:	60bb      	str	r3, [r7, #8]

  if (hi2c->hdmatx != NULL)
2400d786:	68bb      	ldr	r3, [r7, #8]
2400d788:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400d78a:	2b00      	cmp	r3, #0
2400d78c:	d076      	beq.n	2400d87c <I2C_DMAError+0x108>
  {
    if (__HAL_DMA_GET_COUNTER(hi2c->hdmatx) == 0U)
2400d78e:	68bb      	ldr	r3, [r7, #8]
2400d790:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400d792:	681b      	ldr	r3, [r3, #0]
2400d794:	4a83      	ldr	r2, [pc, #524]	; (2400d9a4 <I2C_DMAError+0x230>)
2400d796:	4293      	cmp	r3, r2
2400d798:	d059      	beq.n	2400d84e <I2C_DMAError+0xda>
2400d79a:	68bb      	ldr	r3, [r7, #8]
2400d79c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400d79e:	681b      	ldr	r3, [r3, #0]
2400d7a0:	4a81      	ldr	r2, [pc, #516]	; (2400d9a8 <I2C_DMAError+0x234>)
2400d7a2:	4293      	cmp	r3, r2
2400d7a4:	d053      	beq.n	2400d84e <I2C_DMAError+0xda>
2400d7a6:	68bb      	ldr	r3, [r7, #8]
2400d7a8:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400d7aa:	681b      	ldr	r3, [r3, #0]
2400d7ac:	4a7f      	ldr	r2, [pc, #508]	; (2400d9ac <I2C_DMAError+0x238>)
2400d7ae:	4293      	cmp	r3, r2
2400d7b0:	d04d      	beq.n	2400d84e <I2C_DMAError+0xda>
2400d7b2:	68bb      	ldr	r3, [r7, #8]
2400d7b4:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400d7b6:	681b      	ldr	r3, [r3, #0]
2400d7b8:	4a7d      	ldr	r2, [pc, #500]	; (2400d9b0 <I2C_DMAError+0x23c>)
2400d7ba:	4293      	cmp	r3, r2
2400d7bc:	d047      	beq.n	2400d84e <I2C_DMAError+0xda>
2400d7be:	68bb      	ldr	r3, [r7, #8]
2400d7c0:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400d7c2:	681b      	ldr	r3, [r3, #0]
2400d7c4:	4a7b      	ldr	r2, [pc, #492]	; (2400d9b4 <I2C_DMAError+0x240>)
2400d7c6:	4293      	cmp	r3, r2
2400d7c8:	d041      	beq.n	2400d84e <I2C_DMAError+0xda>
2400d7ca:	68bb      	ldr	r3, [r7, #8]
2400d7cc:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400d7ce:	681b      	ldr	r3, [r3, #0]
2400d7d0:	4a79      	ldr	r2, [pc, #484]	; (2400d9b8 <I2C_DMAError+0x244>)
2400d7d2:	4293      	cmp	r3, r2
2400d7d4:	d03b      	beq.n	2400d84e <I2C_DMAError+0xda>
2400d7d6:	68bb      	ldr	r3, [r7, #8]
2400d7d8:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400d7da:	681b      	ldr	r3, [r3, #0]
2400d7dc:	4a77      	ldr	r2, [pc, #476]	; (2400d9bc <I2C_DMAError+0x248>)
2400d7de:	4293      	cmp	r3, r2
2400d7e0:	d035      	beq.n	2400d84e <I2C_DMAError+0xda>
2400d7e2:	68bb      	ldr	r3, [r7, #8]
2400d7e4:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400d7e6:	681b      	ldr	r3, [r3, #0]
2400d7e8:	4a75      	ldr	r2, [pc, #468]	; (2400d9c0 <I2C_DMAError+0x24c>)
2400d7ea:	4293      	cmp	r3, r2
2400d7ec:	d02f      	beq.n	2400d84e <I2C_DMAError+0xda>
2400d7ee:	68bb      	ldr	r3, [r7, #8]
2400d7f0:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400d7f2:	681b      	ldr	r3, [r3, #0]
2400d7f4:	4a73      	ldr	r2, [pc, #460]	; (2400d9c4 <I2C_DMAError+0x250>)
2400d7f6:	4293      	cmp	r3, r2
2400d7f8:	d029      	beq.n	2400d84e <I2C_DMAError+0xda>
2400d7fa:	68bb      	ldr	r3, [r7, #8]
2400d7fc:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400d7fe:	681b      	ldr	r3, [r3, #0]
2400d800:	4a71      	ldr	r2, [pc, #452]	; (2400d9c8 <I2C_DMAError+0x254>)
2400d802:	4293      	cmp	r3, r2
2400d804:	d023      	beq.n	2400d84e <I2C_DMAError+0xda>
2400d806:	68bb      	ldr	r3, [r7, #8]
2400d808:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400d80a:	681b      	ldr	r3, [r3, #0]
2400d80c:	4a6f      	ldr	r2, [pc, #444]	; (2400d9cc <I2C_DMAError+0x258>)
2400d80e:	4293      	cmp	r3, r2
2400d810:	d01d      	beq.n	2400d84e <I2C_DMAError+0xda>
2400d812:	68bb      	ldr	r3, [r7, #8]
2400d814:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400d816:	681b      	ldr	r3, [r3, #0]
2400d818:	4a6d      	ldr	r2, [pc, #436]	; (2400d9d0 <I2C_DMAError+0x25c>)
2400d81a:	4293      	cmp	r3, r2
2400d81c:	d017      	beq.n	2400d84e <I2C_DMAError+0xda>
2400d81e:	68bb      	ldr	r3, [r7, #8]
2400d820:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400d822:	681b      	ldr	r3, [r3, #0]
2400d824:	4a6b      	ldr	r2, [pc, #428]	; (2400d9d4 <I2C_DMAError+0x260>)
2400d826:	4293      	cmp	r3, r2
2400d828:	d011      	beq.n	2400d84e <I2C_DMAError+0xda>
2400d82a:	68bb      	ldr	r3, [r7, #8]
2400d82c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400d82e:	681b      	ldr	r3, [r3, #0]
2400d830:	4a69      	ldr	r2, [pc, #420]	; (2400d9d8 <I2C_DMAError+0x264>)
2400d832:	4293      	cmp	r3, r2
2400d834:	d00b      	beq.n	2400d84e <I2C_DMAError+0xda>
2400d836:	68bb      	ldr	r3, [r7, #8]
2400d838:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400d83a:	681b      	ldr	r3, [r3, #0]
2400d83c:	4a67      	ldr	r2, [pc, #412]	; (2400d9dc <I2C_DMAError+0x268>)
2400d83e:	4293      	cmp	r3, r2
2400d840:	d005      	beq.n	2400d84e <I2C_DMAError+0xda>
2400d842:	68bb      	ldr	r3, [r7, #8]
2400d844:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400d846:	681b      	ldr	r3, [r3, #0]
2400d848:	4a65      	ldr	r2, [pc, #404]	; (2400d9e0 <I2C_DMAError+0x26c>)
2400d84a:	4293      	cmp	r3, r2
2400d84c:	d109      	bne.n	2400d862 <I2C_DMAError+0xee>
2400d84e:	68bb      	ldr	r3, [r7, #8]
2400d850:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400d852:	681b      	ldr	r3, [r3, #0]
2400d854:	685b      	ldr	r3, [r3, #4]
2400d856:	2b00      	cmp	r3, #0
2400d858:	bf0c      	ite	eq
2400d85a:	2301      	moveq	r3, #1
2400d85c:	2300      	movne	r3, #0
2400d85e:	b2db      	uxtb	r3, r3
2400d860:	e008      	b.n	2400d874 <I2C_DMAError+0x100>
2400d862:	68bb      	ldr	r3, [r7, #8]
2400d864:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400d866:	681b      	ldr	r3, [r3, #0]
2400d868:	685b      	ldr	r3, [r3, #4]
2400d86a:	2b00      	cmp	r3, #0
2400d86c:	bf0c      	ite	eq
2400d86e:	2301      	moveq	r3, #1
2400d870:	2300      	movne	r3, #0
2400d872:	b2db      	uxtb	r3, r3
2400d874:	2b00      	cmp	r3, #0
2400d876:	d001      	beq.n	2400d87c <I2C_DMAError+0x108>
    {
      treatdmaerror = 1U;
2400d878:	2301      	movs	r3, #1
2400d87a:	60fb      	str	r3, [r7, #12]
    }
  }

  if (hi2c->hdmarx != NULL)
2400d87c:	68bb      	ldr	r3, [r7, #8]
2400d87e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400d880:	2b00      	cmp	r3, #0
2400d882:	d076      	beq.n	2400d972 <I2C_DMAError+0x1fe>
  {
    if (__HAL_DMA_GET_COUNTER(hi2c->hdmarx) == 0U)
2400d884:	68bb      	ldr	r3, [r7, #8]
2400d886:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400d888:	681b      	ldr	r3, [r3, #0]
2400d88a:	4a46      	ldr	r2, [pc, #280]	; (2400d9a4 <I2C_DMAError+0x230>)
2400d88c:	4293      	cmp	r3, r2
2400d88e:	d059      	beq.n	2400d944 <I2C_DMAError+0x1d0>
2400d890:	68bb      	ldr	r3, [r7, #8]
2400d892:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400d894:	681b      	ldr	r3, [r3, #0]
2400d896:	4a44      	ldr	r2, [pc, #272]	; (2400d9a8 <I2C_DMAError+0x234>)
2400d898:	4293      	cmp	r3, r2
2400d89a:	d053      	beq.n	2400d944 <I2C_DMAError+0x1d0>
2400d89c:	68bb      	ldr	r3, [r7, #8]
2400d89e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400d8a0:	681b      	ldr	r3, [r3, #0]
2400d8a2:	4a42      	ldr	r2, [pc, #264]	; (2400d9ac <I2C_DMAError+0x238>)
2400d8a4:	4293      	cmp	r3, r2
2400d8a6:	d04d      	beq.n	2400d944 <I2C_DMAError+0x1d0>
2400d8a8:	68bb      	ldr	r3, [r7, #8]
2400d8aa:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400d8ac:	681b      	ldr	r3, [r3, #0]
2400d8ae:	4a40      	ldr	r2, [pc, #256]	; (2400d9b0 <I2C_DMAError+0x23c>)
2400d8b0:	4293      	cmp	r3, r2
2400d8b2:	d047      	beq.n	2400d944 <I2C_DMAError+0x1d0>
2400d8b4:	68bb      	ldr	r3, [r7, #8]
2400d8b6:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400d8b8:	681b      	ldr	r3, [r3, #0]
2400d8ba:	4a3e      	ldr	r2, [pc, #248]	; (2400d9b4 <I2C_DMAError+0x240>)
2400d8bc:	4293      	cmp	r3, r2
2400d8be:	d041      	beq.n	2400d944 <I2C_DMAError+0x1d0>
2400d8c0:	68bb      	ldr	r3, [r7, #8]
2400d8c2:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400d8c4:	681b      	ldr	r3, [r3, #0]
2400d8c6:	4a3c      	ldr	r2, [pc, #240]	; (2400d9b8 <I2C_DMAError+0x244>)
2400d8c8:	4293      	cmp	r3, r2
2400d8ca:	d03b      	beq.n	2400d944 <I2C_DMAError+0x1d0>
2400d8cc:	68bb      	ldr	r3, [r7, #8]
2400d8ce:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400d8d0:	681b      	ldr	r3, [r3, #0]
2400d8d2:	4a3a      	ldr	r2, [pc, #232]	; (2400d9bc <I2C_DMAError+0x248>)
2400d8d4:	4293      	cmp	r3, r2
2400d8d6:	d035      	beq.n	2400d944 <I2C_DMAError+0x1d0>
2400d8d8:	68bb      	ldr	r3, [r7, #8]
2400d8da:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400d8dc:	681b      	ldr	r3, [r3, #0]
2400d8de:	4a38      	ldr	r2, [pc, #224]	; (2400d9c0 <I2C_DMAError+0x24c>)
2400d8e0:	4293      	cmp	r3, r2
2400d8e2:	d02f      	beq.n	2400d944 <I2C_DMAError+0x1d0>
2400d8e4:	68bb      	ldr	r3, [r7, #8]
2400d8e6:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400d8e8:	681b      	ldr	r3, [r3, #0]
2400d8ea:	4a36      	ldr	r2, [pc, #216]	; (2400d9c4 <I2C_DMAError+0x250>)
2400d8ec:	4293      	cmp	r3, r2
2400d8ee:	d029      	beq.n	2400d944 <I2C_DMAError+0x1d0>
2400d8f0:	68bb      	ldr	r3, [r7, #8]
2400d8f2:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400d8f4:	681b      	ldr	r3, [r3, #0]
2400d8f6:	4a34      	ldr	r2, [pc, #208]	; (2400d9c8 <I2C_DMAError+0x254>)
2400d8f8:	4293      	cmp	r3, r2
2400d8fa:	d023      	beq.n	2400d944 <I2C_DMAError+0x1d0>
2400d8fc:	68bb      	ldr	r3, [r7, #8]
2400d8fe:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400d900:	681b      	ldr	r3, [r3, #0]
2400d902:	4a32      	ldr	r2, [pc, #200]	; (2400d9cc <I2C_DMAError+0x258>)
2400d904:	4293      	cmp	r3, r2
2400d906:	d01d      	beq.n	2400d944 <I2C_DMAError+0x1d0>
2400d908:	68bb      	ldr	r3, [r7, #8]
2400d90a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400d90c:	681b      	ldr	r3, [r3, #0]
2400d90e:	4a30      	ldr	r2, [pc, #192]	; (2400d9d0 <I2C_DMAError+0x25c>)
2400d910:	4293      	cmp	r3, r2
2400d912:	d017      	beq.n	2400d944 <I2C_DMAError+0x1d0>
2400d914:	68bb      	ldr	r3, [r7, #8]
2400d916:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400d918:	681b      	ldr	r3, [r3, #0]
2400d91a:	4a2e      	ldr	r2, [pc, #184]	; (2400d9d4 <I2C_DMAError+0x260>)
2400d91c:	4293      	cmp	r3, r2
2400d91e:	d011      	beq.n	2400d944 <I2C_DMAError+0x1d0>
2400d920:	68bb      	ldr	r3, [r7, #8]
2400d922:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400d924:	681b      	ldr	r3, [r3, #0]
2400d926:	4a2c      	ldr	r2, [pc, #176]	; (2400d9d8 <I2C_DMAError+0x264>)
2400d928:	4293      	cmp	r3, r2
2400d92a:	d00b      	beq.n	2400d944 <I2C_DMAError+0x1d0>
2400d92c:	68bb      	ldr	r3, [r7, #8]
2400d92e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400d930:	681b      	ldr	r3, [r3, #0]
2400d932:	4a2a      	ldr	r2, [pc, #168]	; (2400d9dc <I2C_DMAError+0x268>)
2400d934:	4293      	cmp	r3, r2
2400d936:	d005      	beq.n	2400d944 <I2C_DMAError+0x1d0>
2400d938:	68bb      	ldr	r3, [r7, #8]
2400d93a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400d93c:	681b      	ldr	r3, [r3, #0]
2400d93e:	4a28      	ldr	r2, [pc, #160]	; (2400d9e0 <I2C_DMAError+0x26c>)
2400d940:	4293      	cmp	r3, r2
2400d942:	d109      	bne.n	2400d958 <I2C_DMAError+0x1e4>
2400d944:	68bb      	ldr	r3, [r7, #8]
2400d946:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400d948:	681b      	ldr	r3, [r3, #0]
2400d94a:	685b      	ldr	r3, [r3, #4]
2400d94c:	2b00      	cmp	r3, #0
2400d94e:	bf0c      	ite	eq
2400d950:	2301      	moveq	r3, #1
2400d952:	2300      	movne	r3, #0
2400d954:	b2db      	uxtb	r3, r3
2400d956:	e008      	b.n	2400d96a <I2C_DMAError+0x1f6>
2400d958:	68bb      	ldr	r3, [r7, #8]
2400d95a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400d95c:	681b      	ldr	r3, [r3, #0]
2400d95e:	685b      	ldr	r3, [r3, #4]
2400d960:	2b00      	cmp	r3, #0
2400d962:	bf0c      	ite	eq
2400d964:	2301      	moveq	r3, #1
2400d966:	2300      	movne	r3, #0
2400d968:	b2db      	uxtb	r3, r3
2400d96a:	2b00      	cmp	r3, #0
2400d96c:	d001      	beq.n	2400d972 <I2C_DMAError+0x1fe>
    {
      treatdmaerror = 1U;
2400d96e:	2301      	movs	r3, #1
2400d970:	60fb      	str	r3, [r7, #12]
    }
  }

  /* Check if a FIFO error is detected, if true normal use case, so no specific action to perform */
  if (!((HAL_DMA_GetError(hdma) == HAL_DMA_ERROR_FE)) && (treatdmaerror != 0U))
2400d972:	6878      	ldr	r0, [r7, #4]
2400d974:	f7f7 f962 	bl	24004c3c <HAL_DMA_GetError>
2400d978:	4603      	mov	r3, r0
2400d97a:	2b02      	cmp	r3, #2
2400d97c:	d00e      	beq.n	2400d99c <I2C_DMAError+0x228>
2400d97e:	68fb      	ldr	r3, [r7, #12]
2400d980:	2b00      	cmp	r3, #0
2400d982:	d00b      	beq.n	2400d99c <I2C_DMAError+0x228>
  {
    /* Disable Acknowledge */
    hi2c->Instance->CR2 |= I2C_CR2_NACK;
2400d984:	68bb      	ldr	r3, [r7, #8]
2400d986:	681b      	ldr	r3, [r3, #0]
2400d988:	685a      	ldr	r2, [r3, #4]
2400d98a:	68bb      	ldr	r3, [r7, #8]
2400d98c:	681b      	ldr	r3, [r3, #0]
2400d98e:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
2400d992:	605a      	str	r2, [r3, #4]

    /* Call the corresponding callback to inform upper layer of End of Transfer */
    I2C_ITError(hi2c, HAL_I2C_ERROR_DMA);
2400d994:	2110      	movs	r1, #16
2400d996:	68b8      	ldr	r0, [r7, #8]
2400d998:	f7ff fc68 	bl	2400d26c <I2C_ITError>
  }
}
2400d99c:	bf00      	nop
2400d99e:	3710      	adds	r7, #16
2400d9a0:	46bd      	mov	sp, r7
2400d9a2:	bd80      	pop	{r7, pc}
2400d9a4:	40020010 	.word	0x40020010
2400d9a8:	40020028 	.word	0x40020028
2400d9ac:	40020040 	.word	0x40020040
2400d9b0:	40020058 	.word	0x40020058
2400d9b4:	40020070 	.word	0x40020070
2400d9b8:	40020088 	.word	0x40020088
2400d9bc:	400200a0 	.word	0x400200a0
2400d9c0:	400200b8 	.word	0x400200b8
2400d9c4:	40020410 	.word	0x40020410
2400d9c8:	40020428 	.word	0x40020428
2400d9cc:	40020440 	.word	0x40020440
2400d9d0:	40020458 	.word	0x40020458
2400d9d4:	40020470 	.word	0x40020470
2400d9d8:	40020488 	.word	0x40020488
2400d9dc:	400204a0 	.word	0x400204a0
2400d9e0:	400204b8 	.word	0x400204b8

2400d9e4 <I2C_DMAAbort>:
  *        (To be called at end of DMA Abort procedure).
  * @param hdma DMA handle.
  * @retval None
  */
static void I2C_DMAAbort(DMA_HandleTypeDef *hdma)
{
2400d9e4:	b580      	push	{r7, lr}
2400d9e6:	b084      	sub	sp, #16
2400d9e8:	af00      	add	r7, sp, #0
2400d9ea:	6078      	str	r0, [r7, #4]
  I2C_HandleTypeDef *hi2c = (I2C_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
2400d9ec:	687b      	ldr	r3, [r7, #4]
2400d9ee:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400d9f0:	60fb      	str	r3, [r7, #12]

  /* Reset AbortCpltCallback */
  if (hi2c->hdmatx != NULL)
2400d9f2:	68fb      	ldr	r3, [r7, #12]
2400d9f4:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400d9f6:	2b00      	cmp	r3, #0
2400d9f8:	d003      	beq.n	2400da02 <I2C_DMAAbort+0x1e>
  {
    hi2c->hdmatx->XferAbortCallback = NULL;
2400d9fa:	68fb      	ldr	r3, [r7, #12]
2400d9fc:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400d9fe:	2200      	movs	r2, #0
2400da00:	651a      	str	r2, [r3, #80]	; 0x50
  }
  if (hi2c->hdmarx != NULL)
2400da02:	68fb      	ldr	r3, [r7, #12]
2400da04:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400da06:	2b00      	cmp	r3, #0
2400da08:	d003      	beq.n	2400da12 <I2C_DMAAbort+0x2e>
  {
    hi2c->hdmarx->XferAbortCallback = NULL;
2400da0a:	68fb      	ldr	r3, [r7, #12]
2400da0c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400da0e:	2200      	movs	r2, #0
2400da10:	651a      	str	r2, [r3, #80]	; 0x50
  }

  I2C_TreatErrorCallback(hi2c);
2400da12:	68f8      	ldr	r0, [r7, #12]
2400da14:	f7ff fcfa 	bl	2400d40c <I2C_TreatErrorCallback>
}
2400da18:	bf00      	nop
2400da1a:	3710      	adds	r7, #16
2400da1c:	46bd      	mov	sp, r7
2400da1e:	bd80      	pop	{r7, pc}

2400da20 <I2C_WaitOnFlagUntilTimeout>:
  * @param  Timeout Timeout duration
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_WaitOnFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Flag, FlagStatus Status, uint32_t Timeout, uint32_t Tickstart)
{
2400da20:	b580      	push	{r7, lr}
2400da22:	b084      	sub	sp, #16
2400da24:	af00      	add	r7, sp, #0
2400da26:	60f8      	str	r0, [r7, #12]
2400da28:	60b9      	str	r1, [r7, #8]
2400da2a:	603b      	str	r3, [r7, #0]
2400da2c:	4613      	mov	r3, r2
2400da2e:	71fb      	strb	r3, [r7, #7]
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
2400da30:	e022      	b.n	2400da78 <I2C_WaitOnFlagUntilTimeout+0x58>
  {
    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
2400da32:	683b      	ldr	r3, [r7, #0]
2400da34:	f1b3 3fff 	cmp.w	r3, #4294967295
2400da38:	d01e      	beq.n	2400da78 <I2C_WaitOnFlagUntilTimeout+0x58>
    {
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
2400da3a:	f7f2 ff0b 	bl	24000854 <HAL_GetTick>
2400da3e:	4602      	mov	r2, r0
2400da40:	69bb      	ldr	r3, [r7, #24]
2400da42:	1ad3      	subs	r3, r2, r3
2400da44:	683a      	ldr	r2, [r7, #0]
2400da46:	429a      	cmp	r2, r3
2400da48:	d302      	bcc.n	2400da50 <I2C_WaitOnFlagUntilTimeout+0x30>
2400da4a:	683b      	ldr	r3, [r7, #0]
2400da4c:	2b00      	cmp	r3, #0
2400da4e:	d113      	bne.n	2400da78 <I2C_WaitOnFlagUntilTimeout+0x58>
      {
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
2400da50:	68fb      	ldr	r3, [r7, #12]
2400da52:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400da54:	f043 0220 	orr.w	r2, r3, #32
2400da58:	68fb      	ldr	r3, [r7, #12]
2400da5a:	645a      	str	r2, [r3, #68]	; 0x44
        hi2c->State = HAL_I2C_STATE_READY;
2400da5c:	68fb      	ldr	r3, [r7, #12]
2400da5e:	2220      	movs	r2, #32
2400da60:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
        hi2c->Mode = HAL_I2C_MODE_NONE;
2400da64:	68fb      	ldr	r3, [r7, #12]
2400da66:	2200      	movs	r2, #0
2400da68:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

        /* Process Unlocked */
        __HAL_UNLOCK(hi2c);
2400da6c:	68fb      	ldr	r3, [r7, #12]
2400da6e:	2200      	movs	r2, #0
2400da70:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
        return HAL_ERROR;
2400da74:	2301      	movs	r3, #1
2400da76:	e00f      	b.n	2400da98 <I2C_WaitOnFlagUntilTimeout+0x78>
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
2400da78:	68fb      	ldr	r3, [r7, #12]
2400da7a:	681b      	ldr	r3, [r3, #0]
2400da7c:	699a      	ldr	r2, [r3, #24]
2400da7e:	68bb      	ldr	r3, [r7, #8]
2400da80:	4013      	ands	r3, r2
2400da82:	68ba      	ldr	r2, [r7, #8]
2400da84:	429a      	cmp	r2, r3
2400da86:	bf0c      	ite	eq
2400da88:	2301      	moveq	r3, #1
2400da8a:	2300      	movne	r3, #0
2400da8c:	b2db      	uxtb	r3, r3
2400da8e:	461a      	mov	r2, r3
2400da90:	79fb      	ldrb	r3, [r7, #7]
2400da92:	429a      	cmp	r2, r3
2400da94:	d0cd      	beq.n	2400da32 <I2C_WaitOnFlagUntilTimeout+0x12>
      }
    }
  }
  return HAL_OK;
2400da96:	2300      	movs	r3, #0
}
2400da98:	4618      	mov	r0, r3
2400da9a:	3710      	adds	r7, #16
2400da9c:	46bd      	mov	sp, r7
2400da9e:	bd80      	pop	{r7, pc}

2400daa0 <I2C_WaitOnTXISFlagUntilTimeout>:
  * @param  Timeout Timeout duration
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_WaitOnTXISFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart)
{
2400daa0:	b580      	push	{r7, lr}
2400daa2:	b084      	sub	sp, #16
2400daa4:	af00      	add	r7, sp, #0
2400daa6:	60f8      	str	r0, [r7, #12]
2400daa8:	60b9      	str	r1, [r7, #8]
2400daaa:	607a      	str	r2, [r7, #4]
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == RESET)
2400daac:	e02c      	b.n	2400db08 <I2C_WaitOnTXISFlagUntilTimeout+0x68>
  {
    /* Check if a NACK is detected */
    if (I2C_IsAcknowledgeFailed(hi2c, Timeout, Tickstart) != HAL_OK)
2400daae:	687a      	ldr	r2, [r7, #4]
2400dab0:	68b9      	ldr	r1, [r7, #8]
2400dab2:	68f8      	ldr	r0, [r7, #12]
2400dab4:	f000 f8dc 	bl	2400dc70 <I2C_IsAcknowledgeFailed>
2400dab8:	4603      	mov	r3, r0
2400daba:	2b00      	cmp	r3, #0
2400dabc:	d001      	beq.n	2400dac2 <I2C_WaitOnTXISFlagUntilTimeout+0x22>
    {
      return HAL_ERROR;
2400dabe:	2301      	movs	r3, #1
2400dac0:	e02a      	b.n	2400db18 <I2C_WaitOnTXISFlagUntilTimeout+0x78>
    }

    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
2400dac2:	68bb      	ldr	r3, [r7, #8]
2400dac4:	f1b3 3fff 	cmp.w	r3, #4294967295
2400dac8:	d01e      	beq.n	2400db08 <I2C_WaitOnTXISFlagUntilTimeout+0x68>
    {
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
2400daca:	f7f2 fec3 	bl	24000854 <HAL_GetTick>
2400dace:	4602      	mov	r2, r0
2400dad0:	687b      	ldr	r3, [r7, #4]
2400dad2:	1ad3      	subs	r3, r2, r3
2400dad4:	68ba      	ldr	r2, [r7, #8]
2400dad6:	429a      	cmp	r2, r3
2400dad8:	d302      	bcc.n	2400dae0 <I2C_WaitOnTXISFlagUntilTimeout+0x40>
2400dada:	68bb      	ldr	r3, [r7, #8]
2400dadc:	2b00      	cmp	r3, #0
2400dade:	d113      	bne.n	2400db08 <I2C_WaitOnTXISFlagUntilTimeout+0x68>
      {
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
2400dae0:	68fb      	ldr	r3, [r7, #12]
2400dae2:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400dae4:	f043 0220 	orr.w	r2, r3, #32
2400dae8:	68fb      	ldr	r3, [r7, #12]
2400daea:	645a      	str	r2, [r3, #68]	; 0x44
        hi2c->State = HAL_I2C_STATE_READY;
2400daec:	68fb      	ldr	r3, [r7, #12]
2400daee:	2220      	movs	r2, #32
2400daf0:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
        hi2c->Mode = HAL_I2C_MODE_NONE;
2400daf4:	68fb      	ldr	r3, [r7, #12]
2400daf6:	2200      	movs	r2, #0
2400daf8:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

        /* Process Unlocked */
        __HAL_UNLOCK(hi2c);
2400dafc:	68fb      	ldr	r3, [r7, #12]
2400dafe:	2200      	movs	r2, #0
2400db00:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

        return HAL_ERROR;
2400db04:	2301      	movs	r3, #1
2400db06:	e007      	b.n	2400db18 <I2C_WaitOnTXISFlagUntilTimeout+0x78>
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == RESET)
2400db08:	68fb      	ldr	r3, [r7, #12]
2400db0a:	681b      	ldr	r3, [r3, #0]
2400db0c:	699b      	ldr	r3, [r3, #24]
2400db0e:	f003 0302 	and.w	r3, r3, #2
2400db12:	2b02      	cmp	r3, #2
2400db14:	d1cb      	bne.n	2400daae <I2C_WaitOnTXISFlagUntilTimeout+0xe>
      }
    }
  }
  return HAL_OK;
2400db16:	2300      	movs	r3, #0
}
2400db18:	4618      	mov	r0, r3
2400db1a:	3710      	adds	r7, #16
2400db1c:	46bd      	mov	sp, r7
2400db1e:	bd80      	pop	{r7, pc}

2400db20 <I2C_WaitOnSTOPFlagUntilTimeout>:
  * @param  Timeout Timeout duration
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_WaitOnSTOPFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart)
{
2400db20:	b580      	push	{r7, lr}
2400db22:	b084      	sub	sp, #16
2400db24:	af00      	add	r7, sp, #0
2400db26:	60f8      	str	r0, [r7, #12]
2400db28:	60b9      	str	r1, [r7, #8]
2400db2a:	607a      	str	r2, [r7, #4]
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
2400db2c:	e028      	b.n	2400db80 <I2C_WaitOnSTOPFlagUntilTimeout+0x60>
  {
    /* Check if a NACK is detected */
    if (I2C_IsAcknowledgeFailed(hi2c, Timeout, Tickstart) != HAL_OK)
2400db2e:	687a      	ldr	r2, [r7, #4]
2400db30:	68b9      	ldr	r1, [r7, #8]
2400db32:	68f8      	ldr	r0, [r7, #12]
2400db34:	f000 f89c 	bl	2400dc70 <I2C_IsAcknowledgeFailed>
2400db38:	4603      	mov	r3, r0
2400db3a:	2b00      	cmp	r3, #0
2400db3c:	d001      	beq.n	2400db42 <I2C_WaitOnSTOPFlagUntilTimeout+0x22>
    {
      return HAL_ERROR;
2400db3e:	2301      	movs	r3, #1
2400db40:	e026      	b.n	2400db90 <I2C_WaitOnSTOPFlagUntilTimeout+0x70>
    }

    /* Check for the Timeout */
    if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
2400db42:	f7f2 fe87 	bl	24000854 <HAL_GetTick>
2400db46:	4602      	mov	r2, r0
2400db48:	687b      	ldr	r3, [r7, #4]
2400db4a:	1ad3      	subs	r3, r2, r3
2400db4c:	68ba      	ldr	r2, [r7, #8]
2400db4e:	429a      	cmp	r2, r3
2400db50:	d302      	bcc.n	2400db58 <I2C_WaitOnSTOPFlagUntilTimeout+0x38>
2400db52:	68bb      	ldr	r3, [r7, #8]
2400db54:	2b00      	cmp	r3, #0
2400db56:	d113      	bne.n	2400db80 <I2C_WaitOnSTOPFlagUntilTimeout+0x60>
    {
      hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
2400db58:	68fb      	ldr	r3, [r7, #12]
2400db5a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400db5c:	f043 0220 	orr.w	r2, r3, #32
2400db60:	68fb      	ldr	r3, [r7, #12]
2400db62:	645a      	str	r2, [r3, #68]	; 0x44
      hi2c->State = HAL_I2C_STATE_READY;
2400db64:	68fb      	ldr	r3, [r7, #12]
2400db66:	2220      	movs	r2, #32
2400db68:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
      hi2c->Mode = HAL_I2C_MODE_NONE;
2400db6c:	68fb      	ldr	r3, [r7, #12]
2400db6e:	2200      	movs	r2, #0
2400db70:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
2400db74:	68fb      	ldr	r3, [r7, #12]
2400db76:	2200      	movs	r2, #0
2400db78:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

      return HAL_ERROR;
2400db7c:	2301      	movs	r3, #1
2400db7e:	e007      	b.n	2400db90 <I2C_WaitOnSTOPFlagUntilTimeout+0x70>
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
2400db80:	68fb      	ldr	r3, [r7, #12]
2400db82:	681b      	ldr	r3, [r3, #0]
2400db84:	699b      	ldr	r3, [r3, #24]
2400db86:	f003 0320 	and.w	r3, r3, #32
2400db8a:	2b20      	cmp	r3, #32
2400db8c:	d1cf      	bne.n	2400db2e <I2C_WaitOnSTOPFlagUntilTimeout+0xe>
    }
  }
  return HAL_OK;
2400db8e:	2300      	movs	r3, #0
}
2400db90:	4618      	mov	r0, r3
2400db92:	3710      	adds	r7, #16
2400db94:	46bd      	mov	sp, r7
2400db96:	bd80      	pop	{r7, pc}

2400db98 <I2C_WaitOnRXNEFlagUntilTimeout>:
  * @param  Timeout Timeout duration
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_WaitOnRXNEFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart)
{
2400db98:	b580      	push	{r7, lr}
2400db9a:	b084      	sub	sp, #16
2400db9c:	af00      	add	r7, sp, #0
2400db9e:	60f8      	str	r0, [r7, #12]
2400dba0:	60b9      	str	r1, [r7, #8]
2400dba2:	607a      	str	r2, [r7, #4]
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == RESET)
2400dba4:	e055      	b.n	2400dc52 <I2C_WaitOnRXNEFlagUntilTimeout+0xba>
  {
    /* Check if a NACK is detected */
    if (I2C_IsAcknowledgeFailed(hi2c, Timeout, Tickstart) != HAL_OK)
2400dba6:	687a      	ldr	r2, [r7, #4]
2400dba8:	68b9      	ldr	r1, [r7, #8]
2400dbaa:	68f8      	ldr	r0, [r7, #12]
2400dbac:	f000 f860 	bl	2400dc70 <I2C_IsAcknowledgeFailed>
2400dbb0:	4603      	mov	r3, r0
2400dbb2:	2b00      	cmp	r3, #0
2400dbb4:	d001      	beq.n	2400dbba <I2C_WaitOnRXNEFlagUntilTimeout+0x22>
    {
      return HAL_ERROR;
2400dbb6:	2301      	movs	r3, #1
2400dbb8:	e053      	b.n	2400dc62 <I2C_WaitOnRXNEFlagUntilTimeout+0xca>
    }

    /* Check if a STOPF is detected */
    if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == SET)
2400dbba:	68fb      	ldr	r3, [r7, #12]
2400dbbc:	681b      	ldr	r3, [r3, #0]
2400dbbe:	699b      	ldr	r3, [r3, #24]
2400dbc0:	f003 0320 	and.w	r3, r3, #32
2400dbc4:	2b20      	cmp	r3, #32
2400dbc6:	d129      	bne.n	2400dc1c <I2C_WaitOnRXNEFlagUntilTimeout+0x84>
    {
      /* Check if an RXNE is pending */
      /* Store Last receive data if any */
      if ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == SET) && (hi2c->XferSize > 0U))
2400dbc8:	68fb      	ldr	r3, [r7, #12]
2400dbca:	681b      	ldr	r3, [r3, #0]
2400dbcc:	699b      	ldr	r3, [r3, #24]
2400dbce:	f003 0304 	and.w	r3, r3, #4
2400dbd2:	2b04      	cmp	r3, #4
2400dbd4:	d105      	bne.n	2400dbe2 <I2C_WaitOnRXNEFlagUntilTimeout+0x4a>
2400dbd6:	68fb      	ldr	r3, [r7, #12]
2400dbd8:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400dbda:	2b00      	cmp	r3, #0
2400dbdc:	d001      	beq.n	2400dbe2 <I2C_WaitOnRXNEFlagUntilTimeout+0x4a>
      {
        /* Return HAL_OK */
        /* The Reading of data from RXDR will be done in caller function */
        return HAL_OK;
2400dbde:	2300      	movs	r3, #0
2400dbe0:	e03f      	b.n	2400dc62 <I2C_WaitOnRXNEFlagUntilTimeout+0xca>
      }
      else
      {
        /* Clear STOP Flag */
        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
2400dbe2:	68fb      	ldr	r3, [r7, #12]
2400dbe4:	681b      	ldr	r3, [r3, #0]
2400dbe6:	2220      	movs	r2, #32
2400dbe8:	61da      	str	r2, [r3, #28]

        /* Clear Configuration Register 2 */
        I2C_RESET_CR2(hi2c);
2400dbea:	68fb      	ldr	r3, [r7, #12]
2400dbec:	681b      	ldr	r3, [r3, #0]
2400dbee:	6859      	ldr	r1, [r3, #4]
2400dbf0:	68fb      	ldr	r3, [r7, #12]
2400dbf2:	681a      	ldr	r2, [r3, #0]
2400dbf4:	4b1d      	ldr	r3, [pc, #116]	; (2400dc6c <I2C_WaitOnRXNEFlagUntilTimeout+0xd4>)
2400dbf6:	400b      	ands	r3, r1
2400dbf8:	6053      	str	r3, [r2, #4]

        hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
2400dbfa:	68fb      	ldr	r3, [r7, #12]
2400dbfc:	2200      	movs	r2, #0
2400dbfe:	645a      	str	r2, [r3, #68]	; 0x44
        hi2c->State = HAL_I2C_STATE_READY;
2400dc00:	68fb      	ldr	r3, [r7, #12]
2400dc02:	2220      	movs	r2, #32
2400dc04:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
        hi2c->Mode = HAL_I2C_MODE_NONE;
2400dc08:	68fb      	ldr	r3, [r7, #12]
2400dc0a:	2200      	movs	r2, #0
2400dc0c:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

        /* Process Unlocked */
        __HAL_UNLOCK(hi2c);
2400dc10:	68fb      	ldr	r3, [r7, #12]
2400dc12:	2200      	movs	r2, #0
2400dc14:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

        return HAL_ERROR;
2400dc18:	2301      	movs	r3, #1
2400dc1a:	e022      	b.n	2400dc62 <I2C_WaitOnRXNEFlagUntilTimeout+0xca>
      }
    }

    /* Check for the Timeout */
    if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
2400dc1c:	f7f2 fe1a 	bl	24000854 <HAL_GetTick>
2400dc20:	4602      	mov	r2, r0
2400dc22:	687b      	ldr	r3, [r7, #4]
2400dc24:	1ad3      	subs	r3, r2, r3
2400dc26:	68ba      	ldr	r2, [r7, #8]
2400dc28:	429a      	cmp	r2, r3
2400dc2a:	d302      	bcc.n	2400dc32 <I2C_WaitOnRXNEFlagUntilTimeout+0x9a>
2400dc2c:	68bb      	ldr	r3, [r7, #8]
2400dc2e:	2b00      	cmp	r3, #0
2400dc30:	d10f      	bne.n	2400dc52 <I2C_WaitOnRXNEFlagUntilTimeout+0xba>
    {
      hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
2400dc32:	68fb      	ldr	r3, [r7, #12]
2400dc34:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400dc36:	f043 0220 	orr.w	r2, r3, #32
2400dc3a:	68fb      	ldr	r3, [r7, #12]
2400dc3c:	645a      	str	r2, [r3, #68]	; 0x44
      hi2c->State = HAL_I2C_STATE_READY;
2400dc3e:	68fb      	ldr	r3, [r7, #12]
2400dc40:	2220      	movs	r2, #32
2400dc42:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
2400dc46:	68fb      	ldr	r3, [r7, #12]
2400dc48:	2200      	movs	r2, #0
2400dc4a:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

      return HAL_ERROR;
2400dc4e:	2301      	movs	r3, #1
2400dc50:	e007      	b.n	2400dc62 <I2C_WaitOnRXNEFlagUntilTimeout+0xca>
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == RESET)
2400dc52:	68fb      	ldr	r3, [r7, #12]
2400dc54:	681b      	ldr	r3, [r3, #0]
2400dc56:	699b      	ldr	r3, [r3, #24]
2400dc58:	f003 0304 	and.w	r3, r3, #4
2400dc5c:	2b04      	cmp	r3, #4
2400dc5e:	d1a2      	bne.n	2400dba6 <I2C_WaitOnRXNEFlagUntilTimeout+0xe>
    }
  }
  return HAL_OK;
2400dc60:	2300      	movs	r3, #0
}
2400dc62:	4618      	mov	r0, r3
2400dc64:	3710      	adds	r7, #16
2400dc66:	46bd      	mov	sp, r7
2400dc68:	bd80      	pop	{r7, pc}
2400dc6a:	bf00      	nop
2400dc6c:	fe00e800 	.word	0xfe00e800

2400dc70 <I2C_IsAcknowledgeFailed>:
  * @param  Timeout Timeout duration
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_IsAcknowledgeFailed(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart)
{
2400dc70:	b580      	push	{r7, lr}
2400dc72:	b084      	sub	sp, #16
2400dc74:	af00      	add	r7, sp, #0
2400dc76:	60f8      	str	r0, [r7, #12]
2400dc78:	60b9      	str	r1, [r7, #8]
2400dc7a:	607a      	str	r2, [r7, #4]
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
2400dc7c:	68fb      	ldr	r3, [r7, #12]
2400dc7e:	681b      	ldr	r3, [r3, #0]
2400dc80:	699b      	ldr	r3, [r3, #24]
2400dc82:	f003 0310 	and.w	r3, r3, #16
2400dc86:	2b10      	cmp	r3, #16
2400dc88:	d151      	bne.n	2400dd2e <I2C_IsAcknowledgeFailed+0xbe>
  {
    /* Wait until STOP Flag is reset */
    /* AutoEnd should be initiate after AF */
    while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
2400dc8a:	e022      	b.n	2400dcd2 <I2C_IsAcknowledgeFailed+0x62>
    {
      /* Check for the Timeout */
      if (Timeout != HAL_MAX_DELAY)
2400dc8c:	68bb      	ldr	r3, [r7, #8]
2400dc8e:	f1b3 3fff 	cmp.w	r3, #4294967295
2400dc92:	d01e      	beq.n	2400dcd2 <I2C_IsAcknowledgeFailed+0x62>
      {
        if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
2400dc94:	f7f2 fdde 	bl	24000854 <HAL_GetTick>
2400dc98:	4602      	mov	r2, r0
2400dc9a:	687b      	ldr	r3, [r7, #4]
2400dc9c:	1ad3      	subs	r3, r2, r3
2400dc9e:	68ba      	ldr	r2, [r7, #8]
2400dca0:	429a      	cmp	r2, r3
2400dca2:	d302      	bcc.n	2400dcaa <I2C_IsAcknowledgeFailed+0x3a>
2400dca4:	68bb      	ldr	r3, [r7, #8]
2400dca6:	2b00      	cmp	r3, #0
2400dca8:	d113      	bne.n	2400dcd2 <I2C_IsAcknowledgeFailed+0x62>
        {
          hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
2400dcaa:	68fb      	ldr	r3, [r7, #12]
2400dcac:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400dcae:	f043 0220 	orr.w	r2, r3, #32
2400dcb2:	68fb      	ldr	r3, [r7, #12]
2400dcb4:	645a      	str	r2, [r3, #68]	; 0x44
          hi2c->State = HAL_I2C_STATE_READY;
2400dcb6:	68fb      	ldr	r3, [r7, #12]
2400dcb8:	2220      	movs	r2, #32
2400dcba:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
          hi2c->Mode = HAL_I2C_MODE_NONE;
2400dcbe:	68fb      	ldr	r3, [r7, #12]
2400dcc0:	2200      	movs	r2, #0
2400dcc2:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

          /* Process Unlocked */
          __HAL_UNLOCK(hi2c);
2400dcc6:	68fb      	ldr	r3, [r7, #12]
2400dcc8:	2200      	movs	r2, #0
2400dcca:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

          return HAL_ERROR;
2400dcce:	2301      	movs	r3, #1
2400dcd0:	e02e      	b.n	2400dd30 <I2C_IsAcknowledgeFailed+0xc0>
    while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
2400dcd2:	68fb      	ldr	r3, [r7, #12]
2400dcd4:	681b      	ldr	r3, [r3, #0]
2400dcd6:	699b      	ldr	r3, [r3, #24]
2400dcd8:	f003 0320 	and.w	r3, r3, #32
2400dcdc:	2b20      	cmp	r3, #32
2400dcde:	d1d5      	bne.n	2400dc8c <I2C_IsAcknowledgeFailed+0x1c>
        }
      }
    }

    /* Clear NACKF Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
2400dce0:	68fb      	ldr	r3, [r7, #12]
2400dce2:	681b      	ldr	r3, [r3, #0]
2400dce4:	2210      	movs	r2, #16
2400dce6:	61da      	str	r2, [r3, #28]

    /* Clear STOP Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
2400dce8:	68fb      	ldr	r3, [r7, #12]
2400dcea:	681b      	ldr	r3, [r3, #0]
2400dcec:	2220      	movs	r2, #32
2400dcee:	61da      	str	r2, [r3, #28]

    /* Flush TX register */
    I2C_Flush_TXDR(hi2c);
2400dcf0:	68f8      	ldr	r0, [r7, #12]
2400dcf2:	f7ff fbb2 	bl	2400d45a <I2C_Flush_TXDR>

    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);
2400dcf6:	68fb      	ldr	r3, [r7, #12]
2400dcf8:	681b      	ldr	r3, [r3, #0]
2400dcfa:	6859      	ldr	r1, [r3, #4]
2400dcfc:	68fb      	ldr	r3, [r7, #12]
2400dcfe:	681a      	ldr	r2, [r3, #0]
2400dd00:	4b0d      	ldr	r3, [pc, #52]	; (2400dd38 <I2C_IsAcknowledgeFailed+0xc8>)
2400dd02:	400b      	ands	r3, r1
2400dd04:	6053      	str	r3, [r2, #4]

    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
2400dd06:	68fb      	ldr	r3, [r7, #12]
2400dd08:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400dd0a:	f043 0204 	orr.w	r2, r3, #4
2400dd0e:	68fb      	ldr	r3, [r7, #12]
2400dd10:	645a      	str	r2, [r3, #68]	; 0x44
    hi2c->State = HAL_I2C_STATE_READY;
2400dd12:	68fb      	ldr	r3, [r7, #12]
2400dd14:	2220      	movs	r2, #32
2400dd16:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode = HAL_I2C_MODE_NONE;
2400dd1a:	68fb      	ldr	r3, [r7, #12]
2400dd1c:	2200      	movs	r2, #0
2400dd1e:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
2400dd22:	68fb      	ldr	r3, [r7, #12]
2400dd24:	2200      	movs	r2, #0
2400dd26:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    return HAL_ERROR;
2400dd2a:	2301      	movs	r3, #1
2400dd2c:	e000      	b.n	2400dd30 <I2C_IsAcknowledgeFailed+0xc0>
  }
  return HAL_OK;
2400dd2e:	2300      	movs	r3, #0
}
2400dd30:	4618      	mov	r0, r3
2400dd32:	3710      	adds	r7, #16
2400dd34:	46bd      	mov	sp, r7
2400dd36:	bd80      	pop	{r7, pc}
2400dd38:	fe00e800 	.word	0xfe00e800

2400dd3c <I2C_TransferConfig>:
  *     @arg @ref I2C_GENERATE_START_READ Generate Restart for read request.
  *     @arg @ref I2C_GENERATE_START_WRITE Generate Restart for write request.
  * @retval None
  */
static void I2C_TransferConfig(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t Size, uint32_t Mode, uint32_t Request)
{
2400dd3c:	b480      	push	{r7}
2400dd3e:	b085      	sub	sp, #20
2400dd40:	af00      	add	r7, sp, #0
2400dd42:	60f8      	str	r0, [r7, #12]
2400dd44:	607b      	str	r3, [r7, #4]
2400dd46:	460b      	mov	r3, r1
2400dd48:	817b      	strh	r3, [r7, #10]
2400dd4a:	4613      	mov	r3, r2
2400dd4c:	727b      	strb	r3, [r7, #9]
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_TRANSFER_MODE(Mode));
  assert_param(IS_TRANSFER_REQUEST(Request));

  /* update CR2 register */
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
2400dd4e:	68fb      	ldr	r3, [r7, #12]
2400dd50:	681b      	ldr	r3, [r3, #0]
2400dd52:	685a      	ldr	r2, [r3, #4]
2400dd54:	69bb      	ldr	r3, [r7, #24]
2400dd56:	0d5b      	lsrs	r3, r3, #21
2400dd58:	f403 6180 	and.w	r1, r3, #1024	; 0x400
2400dd5c:	4b0d      	ldr	r3, [pc, #52]	; (2400dd94 <I2C_TransferConfig+0x58>)
2400dd5e:	430b      	orrs	r3, r1
2400dd60:	43db      	mvns	r3, r3
2400dd62:	ea02 0103 	and.w	r1, r2, r3
2400dd66:	897b      	ldrh	r3, [r7, #10]
2400dd68:	f3c3 0209 	ubfx	r2, r3, #0, #10
2400dd6c:	7a7b      	ldrb	r3, [r7, #9]
2400dd6e:	041b      	lsls	r3, r3, #16
2400dd70:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
2400dd74:	431a      	orrs	r2, r3
2400dd76:	687b      	ldr	r3, [r7, #4]
2400dd78:	431a      	orrs	r2, r3
2400dd7a:	69bb      	ldr	r3, [r7, #24]
2400dd7c:	431a      	orrs	r2, r3
2400dd7e:	68fb      	ldr	r3, [r7, #12]
2400dd80:	681b      	ldr	r3, [r3, #0]
2400dd82:	430a      	orrs	r2, r1
2400dd84:	605a      	str	r2, [r3, #4]
             (uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | (((uint32_t)Size << I2C_CR2_NBYTES_Pos) & I2C_CR2_NBYTES) | (uint32_t)Mode | (uint32_t)Request));
}
2400dd86:	bf00      	nop
2400dd88:	3714      	adds	r7, #20
2400dd8a:	46bd      	mov	sp, r7
2400dd8c:	f85d 7b04 	ldr.w	r7, [sp], #4
2400dd90:	4770      	bx	lr
2400dd92:	bf00      	nop
2400dd94:	03ff63ff 	.word	0x03ff63ff

2400dd98 <I2C_Enable_IRQ>:
  *                the configuration information for the specified I2C.
  * @param  InterruptRequest Value of @ref I2C_Interrupt_configuration_definition.
  * @retval None
  */
static void I2C_Enable_IRQ(I2C_HandleTypeDef *hi2c, uint16_t InterruptRequest)
{
2400dd98:	b480      	push	{r7}
2400dd9a:	b085      	sub	sp, #20
2400dd9c:	af00      	add	r7, sp, #0
2400dd9e:	6078      	str	r0, [r7, #4]
2400dda0:	460b      	mov	r3, r1
2400dda2:	807b      	strh	r3, [r7, #2]
  uint32_t tmpisr = 0U;
2400dda4:	2300      	movs	r3, #0
2400dda6:	60fb      	str	r3, [r7, #12]

  if ((hi2c->XferISR == I2C_Master_ISR_DMA) || \
2400dda8:	687b      	ldr	r3, [r7, #4]
2400ddaa:	6b5b      	ldr	r3, [r3, #52]	; 0x34
2400ddac:	4a2a      	ldr	r2, [pc, #168]	; (2400de58 <I2C_Enable_IRQ+0xc0>)
2400ddae:	4293      	cmp	r3, r2
2400ddb0:	d004      	beq.n	2400ddbc <I2C_Enable_IRQ+0x24>
      (hi2c->XferISR == I2C_Slave_ISR_DMA))
2400ddb2:	687b      	ldr	r3, [r7, #4]
2400ddb4:	6b5b      	ldr	r3, [r3, #52]	; 0x34
  if ((hi2c->XferISR == I2C_Master_ISR_DMA) || \
2400ddb6:	4a29      	ldr	r2, [pc, #164]	; (2400de5c <I2C_Enable_IRQ+0xc4>)
2400ddb8:	4293      	cmp	r3, r2
2400ddba:	d11d      	bne.n	2400ddf8 <I2C_Enable_IRQ+0x60>
  {
    if ((InterruptRequest & I2C_XFER_LISTEN_IT) == I2C_XFER_LISTEN_IT)
2400ddbc:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
2400ddc0:	2b00      	cmp	r3, #0
2400ddc2:	da03      	bge.n	2400ddcc <I2C_Enable_IRQ+0x34>
    {
      /* Enable ERR, STOP, NACK and ADDR interrupts */
      tmpisr |= I2C_IT_ADDRI | I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_ERRI;
2400ddc4:	68fb      	ldr	r3, [r7, #12]
2400ddc6:	f043 03b8 	orr.w	r3, r3, #184	; 0xb8
2400ddca:	60fb      	str	r3, [r7, #12]
    }

    if (InterruptRequest == I2C_XFER_ERROR_IT)
2400ddcc:	887b      	ldrh	r3, [r7, #2]
2400ddce:	2b10      	cmp	r3, #16
2400ddd0:	d103      	bne.n	2400ddda <I2C_Enable_IRQ+0x42>
    {
      /* Enable ERR and NACK interrupts */
      tmpisr |= I2C_IT_ERRI | I2C_IT_NACKI;
2400ddd2:	68fb      	ldr	r3, [r7, #12]
2400ddd4:	f043 0390 	orr.w	r3, r3, #144	; 0x90
2400ddd8:	60fb      	str	r3, [r7, #12]
    }

    if (InterruptRequest == I2C_XFER_CPLT_IT)
2400ddda:	887b      	ldrh	r3, [r7, #2]
2400dddc:	2b20      	cmp	r3, #32
2400ddde:	d103      	bne.n	2400dde8 <I2C_Enable_IRQ+0x50>
    {
      /* Enable STOP interrupts */
      tmpisr |= (I2C_IT_STOPI | I2C_IT_TCI);
2400dde0:	68fb      	ldr	r3, [r7, #12]
2400dde2:	f043 0360 	orr.w	r3, r3, #96	; 0x60
2400dde6:	60fb      	str	r3, [r7, #12]
    }

    if (InterruptRequest == I2C_XFER_RELOAD_IT)
2400dde8:	887b      	ldrh	r3, [r7, #2]
2400ddea:	2b40      	cmp	r3, #64	; 0x40
2400ddec:	d125      	bne.n	2400de3a <I2C_Enable_IRQ+0xa2>
    {
      /* Enable TC interrupts */
      tmpisr |= I2C_IT_TCI;
2400ddee:	68fb      	ldr	r3, [r7, #12]
2400ddf0:	f043 0340 	orr.w	r3, r3, #64	; 0x40
2400ddf4:	60fb      	str	r3, [r7, #12]
    if (InterruptRequest == I2C_XFER_RELOAD_IT)
2400ddf6:	e020      	b.n	2400de3a <I2C_Enable_IRQ+0xa2>
    }
  }
  else
  {
    if ((InterruptRequest & I2C_XFER_LISTEN_IT) == I2C_XFER_LISTEN_IT)
2400ddf8:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
2400ddfc:	2b00      	cmp	r3, #0
2400ddfe:	da03      	bge.n	2400de08 <I2C_Enable_IRQ+0x70>
    {
      /* Enable ERR, STOP, NACK, and ADDR interrupts */
      tmpisr |= I2C_IT_ADDRI | I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_ERRI;
2400de00:	68fb      	ldr	r3, [r7, #12]
2400de02:	f043 03b8 	orr.w	r3, r3, #184	; 0xb8
2400de06:	60fb      	str	r3, [r7, #12]
    }

    if ((InterruptRequest & I2C_XFER_TX_IT) == I2C_XFER_TX_IT)
2400de08:	887b      	ldrh	r3, [r7, #2]
2400de0a:	f003 0301 	and.w	r3, r3, #1
2400de0e:	2b00      	cmp	r3, #0
2400de10:	d003      	beq.n	2400de1a <I2C_Enable_IRQ+0x82>
    {
      /* Enable ERR, TC, STOP, NACK and RXI interrupts */
      tmpisr |= I2C_IT_ERRI | I2C_IT_TCI | I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_TXI;
2400de12:	68fb      	ldr	r3, [r7, #12]
2400de14:	f043 03f2 	orr.w	r3, r3, #242	; 0xf2
2400de18:	60fb      	str	r3, [r7, #12]
    }

    if ((InterruptRequest & I2C_XFER_RX_IT) == I2C_XFER_RX_IT)
2400de1a:	887b      	ldrh	r3, [r7, #2]
2400de1c:	f003 0302 	and.w	r3, r3, #2
2400de20:	2b00      	cmp	r3, #0
2400de22:	d003      	beq.n	2400de2c <I2C_Enable_IRQ+0x94>
    {
      /* Enable ERR, TC, STOP, NACK and TXI interrupts */
      tmpisr |= I2C_IT_ERRI | I2C_IT_TCI | I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_RXI;
2400de24:	68fb      	ldr	r3, [r7, #12]
2400de26:	f043 03f4 	orr.w	r3, r3, #244	; 0xf4
2400de2a:	60fb      	str	r3, [r7, #12]
    }

    if (InterruptRequest == I2C_XFER_CPLT_IT)
2400de2c:	887b      	ldrh	r3, [r7, #2]
2400de2e:	2b20      	cmp	r3, #32
2400de30:	d103      	bne.n	2400de3a <I2C_Enable_IRQ+0xa2>
    {
      /* Enable STOP interrupts */
      tmpisr |= I2C_IT_STOPI;
2400de32:	68fb      	ldr	r3, [r7, #12]
2400de34:	f043 0320 	orr.w	r3, r3, #32
2400de38:	60fb      	str	r3, [r7, #12]
  }

  /* Enable interrupts only at the end */
  /* to avoid the risk of I2C interrupt handle execution before */
  /* all interrupts requested done */
  __HAL_I2C_ENABLE_IT(hi2c, tmpisr);
2400de3a:	687b      	ldr	r3, [r7, #4]
2400de3c:	681b      	ldr	r3, [r3, #0]
2400de3e:	6819      	ldr	r1, [r3, #0]
2400de40:	687b      	ldr	r3, [r7, #4]
2400de42:	681b      	ldr	r3, [r3, #0]
2400de44:	68fa      	ldr	r2, [r7, #12]
2400de46:	430a      	orrs	r2, r1
2400de48:	601a      	str	r2, [r3, #0]
}
2400de4a:	bf00      	nop
2400de4c:	3714      	adds	r7, #20
2400de4e:	46bd      	mov	sp, r7
2400de50:	f85d 7b04 	ldr.w	r7, [sp], #4
2400de54:	4770      	bx	lr
2400de56:	bf00      	nop
2400de58:	2400c30b 	.word	0x2400c30b
2400de5c:	2400c4f1 	.word	0x2400c4f1

2400de60 <I2C_Disable_IRQ>:
  *                the configuration information for the specified I2C.
  * @param  InterruptRequest Value of @ref I2C_Interrupt_configuration_definition.
  * @retval None
  */
static void I2C_Disable_IRQ(I2C_HandleTypeDef *hi2c, uint16_t InterruptRequest)
{
2400de60:	b480      	push	{r7}
2400de62:	b085      	sub	sp, #20
2400de64:	af00      	add	r7, sp, #0
2400de66:	6078      	str	r0, [r7, #4]
2400de68:	460b      	mov	r3, r1
2400de6a:	807b      	strh	r3, [r7, #2]
  uint32_t tmpisr = 0U;
2400de6c:	2300      	movs	r3, #0
2400de6e:	60fb      	str	r3, [r7, #12]

  if ((InterruptRequest & I2C_XFER_TX_IT) == I2C_XFER_TX_IT)
2400de70:	887b      	ldrh	r3, [r7, #2]
2400de72:	f003 0301 	and.w	r3, r3, #1
2400de76:	2b00      	cmp	r3, #0
2400de78:	d00f      	beq.n	2400de9a <I2C_Disable_IRQ+0x3a>
  {
    /* Disable TC and TXI interrupts */
    tmpisr |= I2C_IT_TCI | I2C_IT_TXI;
2400de7a:	68fb      	ldr	r3, [r7, #12]
2400de7c:	f043 0342 	orr.w	r3, r3, #66	; 0x42
2400de80:	60fb      	str	r3, [r7, #12]

    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
2400de82:	687b      	ldr	r3, [r7, #4]
2400de84:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400de88:	b2db      	uxtb	r3, r3
2400de8a:	f003 0328 	and.w	r3, r3, #40	; 0x28
2400de8e:	2b28      	cmp	r3, #40	; 0x28
2400de90:	d003      	beq.n	2400de9a <I2C_Disable_IRQ+0x3a>
    {
      /* Disable NACK and STOP interrupts */
      tmpisr |= I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_ERRI;
2400de92:	68fb      	ldr	r3, [r7, #12]
2400de94:	f043 03b0 	orr.w	r3, r3, #176	; 0xb0
2400de98:	60fb      	str	r3, [r7, #12]
    }
  }

  if ((InterruptRequest & I2C_XFER_RX_IT) == I2C_XFER_RX_IT)
2400de9a:	887b      	ldrh	r3, [r7, #2]
2400de9c:	f003 0302 	and.w	r3, r3, #2
2400dea0:	2b00      	cmp	r3, #0
2400dea2:	d00f      	beq.n	2400dec4 <I2C_Disable_IRQ+0x64>
  {
    /* Disable TC and RXI interrupts */
    tmpisr |= I2C_IT_TCI | I2C_IT_RXI;
2400dea4:	68fb      	ldr	r3, [r7, #12]
2400dea6:	f043 0344 	orr.w	r3, r3, #68	; 0x44
2400deaa:	60fb      	str	r3, [r7, #12]

    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
2400deac:	687b      	ldr	r3, [r7, #4]
2400deae:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400deb2:	b2db      	uxtb	r3, r3
2400deb4:	f003 0328 	and.w	r3, r3, #40	; 0x28
2400deb8:	2b28      	cmp	r3, #40	; 0x28
2400deba:	d003      	beq.n	2400dec4 <I2C_Disable_IRQ+0x64>
    {
      /* Disable NACK and STOP interrupts */
      tmpisr |= I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_ERRI;
2400debc:	68fb      	ldr	r3, [r7, #12]
2400debe:	f043 03b0 	orr.w	r3, r3, #176	; 0xb0
2400dec2:	60fb      	str	r3, [r7, #12]
    }
  }

  if ((InterruptRequest & I2C_XFER_LISTEN_IT) == I2C_XFER_LISTEN_IT)
2400dec4:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
2400dec8:	2b00      	cmp	r3, #0
2400deca:	da03      	bge.n	2400ded4 <I2C_Disable_IRQ+0x74>
  {
    /* Disable ADDR, NACK and STOP interrupts */
    tmpisr |= I2C_IT_ADDRI | I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_ERRI;
2400decc:	68fb      	ldr	r3, [r7, #12]
2400dece:	f043 03b8 	orr.w	r3, r3, #184	; 0xb8
2400ded2:	60fb      	str	r3, [r7, #12]
  }

  if (InterruptRequest == I2C_XFER_ERROR_IT)
2400ded4:	887b      	ldrh	r3, [r7, #2]
2400ded6:	2b10      	cmp	r3, #16
2400ded8:	d103      	bne.n	2400dee2 <I2C_Disable_IRQ+0x82>
  {
    /* Enable ERR and NACK interrupts */
    tmpisr |= I2C_IT_ERRI | I2C_IT_NACKI;
2400deda:	68fb      	ldr	r3, [r7, #12]
2400dedc:	f043 0390 	orr.w	r3, r3, #144	; 0x90
2400dee0:	60fb      	str	r3, [r7, #12]
  }

  if (InterruptRequest == I2C_XFER_CPLT_IT)
2400dee2:	887b      	ldrh	r3, [r7, #2]
2400dee4:	2b20      	cmp	r3, #32
2400dee6:	d103      	bne.n	2400def0 <I2C_Disable_IRQ+0x90>
  {
    /* Enable STOP interrupts */
    tmpisr |= I2C_IT_STOPI;
2400dee8:	68fb      	ldr	r3, [r7, #12]
2400deea:	f043 0320 	orr.w	r3, r3, #32
2400deee:	60fb      	str	r3, [r7, #12]
  }

  if (InterruptRequest == I2C_XFER_RELOAD_IT)
2400def0:	887b      	ldrh	r3, [r7, #2]
2400def2:	2b40      	cmp	r3, #64	; 0x40
2400def4:	d103      	bne.n	2400defe <I2C_Disable_IRQ+0x9e>
  {
    /* Enable TC interrupts */
    tmpisr |= I2C_IT_TCI;
2400def6:	68fb      	ldr	r3, [r7, #12]
2400def8:	f043 0340 	orr.w	r3, r3, #64	; 0x40
2400defc:	60fb      	str	r3, [r7, #12]
  }

  /* Disable interrupts only at the end */
  /* to avoid a breaking situation like at "t" time */
  /* all disable interrupts request are not done */
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
2400defe:	687b      	ldr	r3, [r7, #4]
2400df00:	681b      	ldr	r3, [r3, #0]
2400df02:	6819      	ldr	r1, [r3, #0]
2400df04:	68fb      	ldr	r3, [r7, #12]
2400df06:	43da      	mvns	r2, r3
2400df08:	687b      	ldr	r3, [r7, #4]
2400df0a:	681b      	ldr	r3, [r3, #0]
2400df0c:	400a      	ands	r2, r1
2400df0e:	601a      	str	r2, [r3, #0]
}
2400df10:	bf00      	nop
2400df12:	3714      	adds	r7, #20
2400df14:	46bd      	mov	sp, r7
2400df16:	f85d 7b04 	ldr.w	r7, [sp], #4
2400df1a:	4770      	bx	lr

2400df1c <I2C_ConvertOtherXferOptions>:
  * @brief  Convert I2Cx OTHER_xxx XferOptions to functionnal XferOptions.
  * @param  hi2c I2C handle.
  * @retval None
  */
static void I2C_ConvertOtherXferOptions(I2C_HandleTypeDef *hi2c)
{
2400df1c:	b480      	push	{r7}
2400df1e:	b083      	sub	sp, #12
2400df20:	af00      	add	r7, sp, #0
2400df22:	6078      	str	r0, [r7, #4]
  /* if user set XferOptions to I2C_OTHER_FRAME            */
  /* it request implicitly to generate a restart condition */
  /* set XferOptions to I2C_FIRST_FRAME                    */
  if (hi2c->XferOptions == I2C_OTHER_FRAME)
2400df24:	687b      	ldr	r3, [r7, #4]
2400df26:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2400df28:	2baa      	cmp	r3, #170	; 0xaa
2400df2a:	d103      	bne.n	2400df34 <I2C_ConvertOtherXferOptions+0x18>
  {
    hi2c->XferOptions = I2C_FIRST_FRAME;
2400df2c:	687b      	ldr	r3, [r7, #4]
2400df2e:	2200      	movs	r2, #0
2400df30:	62da      	str	r2, [r3, #44]	; 0x2c
  }
  else
  {
    /* Nothing to do */
  }
}
2400df32:	e008      	b.n	2400df46 <I2C_ConvertOtherXferOptions+0x2a>
  else if (hi2c->XferOptions == I2C_OTHER_AND_LAST_FRAME)
2400df34:	687b      	ldr	r3, [r7, #4]
2400df36:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2400df38:	f5b3 4f2a 	cmp.w	r3, #43520	; 0xaa00
2400df3c:	d103      	bne.n	2400df46 <I2C_ConvertOtherXferOptions+0x2a>
    hi2c->XferOptions = I2C_FIRST_AND_LAST_FRAME;
2400df3e:	687b      	ldr	r3, [r7, #4]
2400df40:	f04f 7200 	mov.w	r2, #33554432	; 0x2000000
2400df44:	62da      	str	r2, [r3, #44]	; 0x2c
}
2400df46:	bf00      	nop
2400df48:	370c      	adds	r7, #12
2400df4a:	46bd      	mov	sp, r7
2400df4c:	f85d 7b04 	ldr.w	r7, [sp], #4
2400df50:	4770      	bx	lr

2400df52 <HAL_I2CEx_ConfigAnalogFilter>:
  *                the configuration information for the specified I2Cx peripheral.
  * @param  AnalogFilter New state of the Analog filter.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2CEx_ConfigAnalogFilter(I2C_HandleTypeDef *hi2c, uint32_t AnalogFilter)
{
2400df52:	b480      	push	{r7}
2400df54:	b083      	sub	sp, #12
2400df56:	af00      	add	r7, sp, #0
2400df58:	6078      	str	r0, [r7, #4]
2400df5a:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_I2C_ANALOG_FILTER(AnalogFilter));

  if (hi2c->State == HAL_I2C_STATE_READY)
2400df5c:	687b      	ldr	r3, [r7, #4]
2400df5e:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400df62:	b2db      	uxtb	r3, r3
2400df64:	2b20      	cmp	r3, #32
2400df66:	d138      	bne.n	2400dfda <HAL_I2CEx_ConfigAnalogFilter+0x88>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
2400df68:	687b      	ldr	r3, [r7, #4]
2400df6a:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2400df6e:	2b01      	cmp	r3, #1
2400df70:	d101      	bne.n	2400df76 <HAL_I2CEx_ConfigAnalogFilter+0x24>
2400df72:	2302      	movs	r3, #2
2400df74:	e032      	b.n	2400dfdc <HAL_I2CEx_ConfigAnalogFilter+0x8a>
2400df76:	687b      	ldr	r3, [r7, #4]
2400df78:	2201      	movs	r2, #1
2400df7a:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    hi2c->State = HAL_I2C_STATE_BUSY;
2400df7e:	687b      	ldr	r3, [r7, #4]
2400df80:	2224      	movs	r2, #36	; 0x24
2400df82:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

    /* Disable the selected I2C peripheral */
    __HAL_I2C_DISABLE(hi2c);
2400df86:	687b      	ldr	r3, [r7, #4]
2400df88:	681b      	ldr	r3, [r3, #0]
2400df8a:	681a      	ldr	r2, [r3, #0]
2400df8c:	687b      	ldr	r3, [r7, #4]
2400df8e:	681b      	ldr	r3, [r3, #0]
2400df90:	f022 0201 	bic.w	r2, r2, #1
2400df94:	601a      	str	r2, [r3, #0]

    /* Reset I2Cx ANOFF bit */
    hi2c->Instance->CR1 &= ~(I2C_CR1_ANFOFF);
2400df96:	687b      	ldr	r3, [r7, #4]
2400df98:	681b      	ldr	r3, [r3, #0]
2400df9a:	681a      	ldr	r2, [r3, #0]
2400df9c:	687b      	ldr	r3, [r7, #4]
2400df9e:	681b      	ldr	r3, [r3, #0]
2400dfa0:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
2400dfa4:	601a      	str	r2, [r3, #0]

    /* Set analog filter bit*/
    hi2c->Instance->CR1 |= AnalogFilter;
2400dfa6:	687b      	ldr	r3, [r7, #4]
2400dfa8:	681b      	ldr	r3, [r3, #0]
2400dfaa:	6819      	ldr	r1, [r3, #0]
2400dfac:	687b      	ldr	r3, [r7, #4]
2400dfae:	681b      	ldr	r3, [r3, #0]
2400dfb0:	683a      	ldr	r2, [r7, #0]
2400dfb2:	430a      	orrs	r2, r1
2400dfb4:	601a      	str	r2, [r3, #0]

    __HAL_I2C_ENABLE(hi2c);
2400dfb6:	687b      	ldr	r3, [r7, #4]
2400dfb8:	681b      	ldr	r3, [r3, #0]
2400dfba:	681a      	ldr	r2, [r3, #0]
2400dfbc:	687b      	ldr	r3, [r7, #4]
2400dfbe:	681b      	ldr	r3, [r3, #0]
2400dfc0:	f042 0201 	orr.w	r2, r2, #1
2400dfc4:	601a      	str	r2, [r3, #0]

    hi2c->State = HAL_I2C_STATE_READY;
2400dfc6:	687b      	ldr	r3, [r7, #4]
2400dfc8:	2220      	movs	r2, #32
2400dfca:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
2400dfce:	687b      	ldr	r3, [r7, #4]
2400dfd0:	2200      	movs	r2, #0
2400dfd2:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    return HAL_OK;
2400dfd6:	2300      	movs	r3, #0
2400dfd8:	e000      	b.n	2400dfdc <HAL_I2CEx_ConfigAnalogFilter+0x8a>
  }
  else
  {
    return HAL_BUSY;
2400dfda:	2302      	movs	r3, #2
  }
}
2400dfdc:	4618      	mov	r0, r3
2400dfde:	370c      	adds	r7, #12
2400dfe0:	46bd      	mov	sp, r7
2400dfe2:	f85d 7b04 	ldr.w	r7, [sp], #4
2400dfe6:	4770      	bx	lr

2400dfe8 <HAL_I2CEx_ConfigDigitalFilter>:
  *                the configuration information for the specified I2Cx peripheral.
  * @param  DigitalFilter Coefficient of digital noise filter between Min_Data=0x00 and Max_Data=0x0F.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2CEx_ConfigDigitalFilter(I2C_HandleTypeDef *hi2c, uint32_t DigitalFilter)
{
2400dfe8:	b480      	push	{r7}
2400dfea:	b085      	sub	sp, #20
2400dfec:	af00      	add	r7, sp, #0
2400dfee:	6078      	str	r0, [r7, #4]
2400dff0:	6039      	str	r1, [r7, #0]

  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_I2C_DIGITAL_FILTER(DigitalFilter));

  if (hi2c->State == HAL_I2C_STATE_READY)
2400dff2:	687b      	ldr	r3, [r7, #4]
2400dff4:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400dff8:	b2db      	uxtb	r3, r3
2400dffa:	2b20      	cmp	r3, #32
2400dffc:	d139      	bne.n	2400e072 <HAL_I2CEx_ConfigDigitalFilter+0x8a>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
2400dffe:	687b      	ldr	r3, [r7, #4]
2400e000:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2400e004:	2b01      	cmp	r3, #1
2400e006:	d101      	bne.n	2400e00c <HAL_I2CEx_ConfigDigitalFilter+0x24>
2400e008:	2302      	movs	r3, #2
2400e00a:	e033      	b.n	2400e074 <HAL_I2CEx_ConfigDigitalFilter+0x8c>
2400e00c:	687b      	ldr	r3, [r7, #4]
2400e00e:	2201      	movs	r2, #1
2400e010:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    hi2c->State = HAL_I2C_STATE_BUSY;
2400e014:	687b      	ldr	r3, [r7, #4]
2400e016:	2224      	movs	r2, #36	; 0x24
2400e018:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

    /* Disable the selected I2C peripheral */
    __HAL_I2C_DISABLE(hi2c);
2400e01c:	687b      	ldr	r3, [r7, #4]
2400e01e:	681b      	ldr	r3, [r3, #0]
2400e020:	681a      	ldr	r2, [r3, #0]
2400e022:	687b      	ldr	r3, [r7, #4]
2400e024:	681b      	ldr	r3, [r3, #0]
2400e026:	f022 0201 	bic.w	r2, r2, #1
2400e02a:	601a      	str	r2, [r3, #0]

    /* Get the old register value */
    tmpreg = hi2c->Instance->CR1;
2400e02c:	687b      	ldr	r3, [r7, #4]
2400e02e:	681b      	ldr	r3, [r3, #0]
2400e030:	681b      	ldr	r3, [r3, #0]
2400e032:	60fb      	str	r3, [r7, #12]

    /* Reset I2Cx DNF bits [11:8] */
    tmpreg &= ~(I2C_CR1_DNF);
2400e034:	68fb      	ldr	r3, [r7, #12]
2400e036:	f423 6370 	bic.w	r3, r3, #3840	; 0xf00
2400e03a:	60fb      	str	r3, [r7, #12]

    /* Set I2Cx DNF coefficient */
    tmpreg |= DigitalFilter << 8U;
2400e03c:	683b      	ldr	r3, [r7, #0]
2400e03e:	021b      	lsls	r3, r3, #8
2400e040:	68fa      	ldr	r2, [r7, #12]
2400e042:	4313      	orrs	r3, r2
2400e044:	60fb      	str	r3, [r7, #12]

    /* Store the new register value */
    hi2c->Instance->CR1 = tmpreg;
2400e046:	687b      	ldr	r3, [r7, #4]
2400e048:	681b      	ldr	r3, [r3, #0]
2400e04a:	68fa      	ldr	r2, [r7, #12]
2400e04c:	601a      	str	r2, [r3, #0]

    __HAL_I2C_ENABLE(hi2c);
2400e04e:	687b      	ldr	r3, [r7, #4]
2400e050:	681b      	ldr	r3, [r3, #0]
2400e052:	681a      	ldr	r2, [r3, #0]
2400e054:	687b      	ldr	r3, [r7, #4]
2400e056:	681b      	ldr	r3, [r3, #0]
2400e058:	f042 0201 	orr.w	r2, r2, #1
2400e05c:	601a      	str	r2, [r3, #0]

    hi2c->State = HAL_I2C_STATE_READY;
2400e05e:	687b      	ldr	r3, [r7, #4]
2400e060:	2220      	movs	r2, #32
2400e062:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
2400e066:	687b      	ldr	r3, [r7, #4]
2400e068:	2200      	movs	r2, #0
2400e06a:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    return HAL_OK;
2400e06e:	2300      	movs	r3, #0
2400e070:	e000      	b.n	2400e074 <HAL_I2CEx_ConfigDigitalFilter+0x8c>
  }
  else
  {
    return HAL_BUSY;
2400e072:	2302      	movs	r3, #2
  }
}
2400e074:	4618      	mov	r0, r3
2400e076:	3714      	adds	r7, #20
2400e078:	46bd      	mov	sp, r7
2400e07a:	f85d 7b04 	ldr.w	r7, [sp], #4
2400e07e:	4770      	bx	lr

2400e080 <HAL_I2CEx_EnableWakeUp>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2Cx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2CEx_EnableWakeUp(I2C_HandleTypeDef *hi2c)
{
2400e080:	b480      	push	{r7}
2400e082:	b083      	sub	sp, #12
2400e084:	af00      	add	r7, sp, #0
2400e086:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_I2C_WAKEUP_FROMSTOP_INSTANCE(hi2c->Instance));

  if (hi2c->State == HAL_I2C_STATE_READY)
2400e088:	687b      	ldr	r3, [r7, #4]
2400e08a:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400e08e:	b2db      	uxtb	r3, r3
2400e090:	2b20      	cmp	r3, #32
2400e092:	d130      	bne.n	2400e0f6 <HAL_I2CEx_EnableWakeUp+0x76>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
2400e094:	687b      	ldr	r3, [r7, #4]
2400e096:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2400e09a:	2b01      	cmp	r3, #1
2400e09c:	d101      	bne.n	2400e0a2 <HAL_I2CEx_EnableWakeUp+0x22>
2400e09e:	2302      	movs	r3, #2
2400e0a0:	e02a      	b.n	2400e0f8 <HAL_I2CEx_EnableWakeUp+0x78>
2400e0a2:	687b      	ldr	r3, [r7, #4]
2400e0a4:	2201      	movs	r2, #1
2400e0a6:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    hi2c->State = HAL_I2C_STATE_BUSY;
2400e0aa:	687b      	ldr	r3, [r7, #4]
2400e0ac:	2224      	movs	r2, #36	; 0x24
2400e0ae:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

    /* Disable the selected I2C peripheral */
    __HAL_I2C_DISABLE(hi2c);
2400e0b2:	687b      	ldr	r3, [r7, #4]
2400e0b4:	681b      	ldr	r3, [r3, #0]
2400e0b6:	681a      	ldr	r2, [r3, #0]
2400e0b8:	687b      	ldr	r3, [r7, #4]
2400e0ba:	681b      	ldr	r3, [r3, #0]
2400e0bc:	f022 0201 	bic.w	r2, r2, #1
2400e0c0:	601a      	str	r2, [r3, #0]

    /* Enable wakeup from stop mode */
    hi2c->Instance->CR1 |= I2C_CR1_WUPEN;
2400e0c2:	687b      	ldr	r3, [r7, #4]
2400e0c4:	681b      	ldr	r3, [r3, #0]
2400e0c6:	681a      	ldr	r2, [r3, #0]
2400e0c8:	687b      	ldr	r3, [r7, #4]
2400e0ca:	681b      	ldr	r3, [r3, #0]
2400e0cc:	f442 2280 	orr.w	r2, r2, #262144	; 0x40000
2400e0d0:	601a      	str	r2, [r3, #0]

    __HAL_I2C_ENABLE(hi2c);
2400e0d2:	687b      	ldr	r3, [r7, #4]
2400e0d4:	681b      	ldr	r3, [r3, #0]
2400e0d6:	681a      	ldr	r2, [r3, #0]
2400e0d8:	687b      	ldr	r3, [r7, #4]
2400e0da:	681b      	ldr	r3, [r3, #0]
2400e0dc:	f042 0201 	orr.w	r2, r2, #1
2400e0e0:	601a      	str	r2, [r3, #0]

    hi2c->State = HAL_I2C_STATE_READY;
2400e0e2:	687b      	ldr	r3, [r7, #4]
2400e0e4:	2220      	movs	r2, #32
2400e0e6:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
2400e0ea:	687b      	ldr	r3, [r7, #4]
2400e0ec:	2200      	movs	r2, #0
2400e0ee:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    return HAL_OK;
2400e0f2:	2300      	movs	r3, #0
2400e0f4:	e000      	b.n	2400e0f8 <HAL_I2CEx_EnableWakeUp+0x78>
  }
  else
  {
    return HAL_BUSY;
2400e0f6:	2302      	movs	r3, #2
  }
}
2400e0f8:	4618      	mov	r0, r3
2400e0fa:	370c      	adds	r7, #12
2400e0fc:	46bd      	mov	sp, r7
2400e0fe:	f85d 7b04 	ldr.w	r7, [sp], #4
2400e102:	4770      	bx	lr

2400e104 <HAL_I2CEx_DisableWakeUp>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2Cx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2CEx_DisableWakeUp(I2C_HandleTypeDef *hi2c)
{
2400e104:	b480      	push	{r7}
2400e106:	b083      	sub	sp, #12
2400e108:	af00      	add	r7, sp, #0
2400e10a:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_I2C_WAKEUP_FROMSTOP_INSTANCE(hi2c->Instance));

  if (hi2c->State == HAL_I2C_STATE_READY)
2400e10c:	687b      	ldr	r3, [r7, #4]
2400e10e:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400e112:	b2db      	uxtb	r3, r3
2400e114:	2b20      	cmp	r3, #32
2400e116:	d130      	bne.n	2400e17a <HAL_I2CEx_DisableWakeUp+0x76>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
2400e118:	687b      	ldr	r3, [r7, #4]
2400e11a:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2400e11e:	2b01      	cmp	r3, #1
2400e120:	d101      	bne.n	2400e126 <HAL_I2CEx_DisableWakeUp+0x22>
2400e122:	2302      	movs	r3, #2
2400e124:	e02a      	b.n	2400e17c <HAL_I2CEx_DisableWakeUp+0x78>
2400e126:	687b      	ldr	r3, [r7, #4]
2400e128:	2201      	movs	r2, #1
2400e12a:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    hi2c->State = HAL_I2C_STATE_BUSY;
2400e12e:	687b      	ldr	r3, [r7, #4]
2400e130:	2224      	movs	r2, #36	; 0x24
2400e132:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

    /* Disable the selected I2C peripheral */
    __HAL_I2C_DISABLE(hi2c);
2400e136:	687b      	ldr	r3, [r7, #4]
2400e138:	681b      	ldr	r3, [r3, #0]
2400e13a:	681a      	ldr	r2, [r3, #0]
2400e13c:	687b      	ldr	r3, [r7, #4]
2400e13e:	681b      	ldr	r3, [r3, #0]
2400e140:	f022 0201 	bic.w	r2, r2, #1
2400e144:	601a      	str	r2, [r3, #0]

    /* Enable wakeup from stop mode */
    hi2c->Instance->CR1 &= ~(I2C_CR1_WUPEN);
2400e146:	687b      	ldr	r3, [r7, #4]
2400e148:	681b      	ldr	r3, [r3, #0]
2400e14a:	681a      	ldr	r2, [r3, #0]
2400e14c:	687b      	ldr	r3, [r7, #4]
2400e14e:	681b      	ldr	r3, [r3, #0]
2400e150:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
2400e154:	601a      	str	r2, [r3, #0]

    __HAL_I2C_ENABLE(hi2c);
2400e156:	687b      	ldr	r3, [r7, #4]
2400e158:	681b      	ldr	r3, [r3, #0]
2400e15a:	681a      	ldr	r2, [r3, #0]
2400e15c:	687b      	ldr	r3, [r7, #4]
2400e15e:	681b      	ldr	r3, [r3, #0]
2400e160:	f042 0201 	orr.w	r2, r2, #1
2400e164:	601a      	str	r2, [r3, #0]

    hi2c->State = HAL_I2C_STATE_READY;
2400e166:	687b      	ldr	r3, [r7, #4]
2400e168:	2220      	movs	r2, #32
2400e16a:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
2400e16e:	687b      	ldr	r3, [r7, #4]
2400e170:	2200      	movs	r2, #0
2400e172:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    return HAL_OK;
2400e176:	2300      	movs	r3, #0
2400e178:	e000      	b.n	2400e17c <HAL_I2CEx_DisableWakeUp+0x78>
  }
  else
  {
    return HAL_BUSY;
2400e17a:	2302      	movs	r3, #2
  }
}
2400e17c:	4618      	mov	r0, r3
2400e17e:	370c      	adds	r7, #12
2400e180:	46bd      	mov	sp, r7
2400e182:	f85d 7b04 	ldr.w	r7, [sp], #4
2400e186:	4770      	bx	lr

2400e188 <HAL_I2CEx_EnableFastModePlus>:
  * @note  For all I2C4 pins fast mode plus driving capability can be enabled
  *        only by using I2C_FASTMODEPLUS_I2C4 parameter.
  * @retval None
  */
void HAL_I2CEx_EnableFastModePlus(uint32_t ConfigFastModePlus)
{
2400e188:	b480      	push	{r7}
2400e18a:	b085      	sub	sp, #20
2400e18c:	af00      	add	r7, sp, #0
2400e18e:	6078      	str	r0, [r7, #4]
  /* Check the parameter */
  assert_param(IS_I2C_FASTMODEPLUS(ConfigFastModePlus));

  /* Enable SYSCFG clock */
  __HAL_RCC_SYSCFG_CLK_ENABLE();
2400e190:	4b0d      	ldr	r3, [pc, #52]	; (2400e1c8 <HAL_I2CEx_EnableFastModePlus+0x40>)
2400e192:	f8d3 30f4 	ldr.w	r3, [r3, #244]	; 0xf4
2400e196:	4a0c      	ldr	r2, [pc, #48]	; (2400e1c8 <HAL_I2CEx_EnableFastModePlus+0x40>)
2400e198:	f043 0302 	orr.w	r3, r3, #2
2400e19c:	f8c2 30f4 	str.w	r3, [r2, #244]	; 0xf4
2400e1a0:	4b09      	ldr	r3, [pc, #36]	; (2400e1c8 <HAL_I2CEx_EnableFastModePlus+0x40>)
2400e1a2:	f8d3 30f4 	ldr.w	r3, [r3, #244]	; 0xf4
2400e1a6:	f003 0302 	and.w	r3, r3, #2
2400e1aa:	60fb      	str	r3, [r7, #12]
2400e1ac:	68fb      	ldr	r3, [r7, #12]

  /* Enable fast mode plus driving capability for selected pin */
  SET_BIT(SYSCFG->PMCR, (uint32_t)ConfigFastModePlus);
2400e1ae:	4b07      	ldr	r3, [pc, #28]	; (2400e1cc <HAL_I2CEx_EnableFastModePlus+0x44>)
2400e1b0:	685a      	ldr	r2, [r3, #4]
2400e1b2:	4906      	ldr	r1, [pc, #24]	; (2400e1cc <HAL_I2CEx_EnableFastModePlus+0x44>)
2400e1b4:	687b      	ldr	r3, [r7, #4]
2400e1b6:	4313      	orrs	r3, r2
2400e1b8:	604b      	str	r3, [r1, #4]
}
2400e1ba:	bf00      	nop
2400e1bc:	3714      	adds	r7, #20
2400e1be:	46bd      	mov	sp, r7
2400e1c0:	f85d 7b04 	ldr.w	r7, [sp], #4
2400e1c4:	4770      	bx	lr
2400e1c6:	bf00      	nop
2400e1c8:	58024400 	.word	0x58024400
2400e1cc:	58000400 	.word	0x58000400

2400e1d0 <HAL_I2CEx_DisableFastModePlus>:
  * @note  For all I2C4 pins fast mode plus driving capability can be disabled
  *        only by using I2C_FASTMODEPLUS_I2C4 parameter.
  * @retval None
  */
void HAL_I2CEx_DisableFastModePlus(uint32_t ConfigFastModePlus)
{
2400e1d0:	b480      	push	{r7}
2400e1d2:	b085      	sub	sp, #20
2400e1d4:	af00      	add	r7, sp, #0
2400e1d6:	6078      	str	r0, [r7, #4]
  /* Check the parameter */
  assert_param(IS_I2C_FASTMODEPLUS(ConfigFastModePlus));

  /* Enable SYSCFG clock */
  __HAL_RCC_SYSCFG_CLK_ENABLE();
2400e1d8:	4b0d      	ldr	r3, [pc, #52]	; (2400e210 <HAL_I2CEx_DisableFastModePlus+0x40>)
2400e1da:	f8d3 30f4 	ldr.w	r3, [r3, #244]	; 0xf4
2400e1de:	4a0c      	ldr	r2, [pc, #48]	; (2400e210 <HAL_I2CEx_DisableFastModePlus+0x40>)
2400e1e0:	f043 0302 	orr.w	r3, r3, #2
2400e1e4:	f8c2 30f4 	str.w	r3, [r2, #244]	; 0xf4
2400e1e8:	4b09      	ldr	r3, [pc, #36]	; (2400e210 <HAL_I2CEx_DisableFastModePlus+0x40>)
2400e1ea:	f8d3 30f4 	ldr.w	r3, [r3, #244]	; 0xf4
2400e1ee:	f003 0302 	and.w	r3, r3, #2
2400e1f2:	60fb      	str	r3, [r7, #12]
2400e1f4:	68fb      	ldr	r3, [r7, #12]

  /* Disable fast mode plus driving capability for selected pin */
  CLEAR_BIT(SYSCFG->PMCR, (uint32_t)ConfigFastModePlus);
2400e1f6:	4b07      	ldr	r3, [pc, #28]	; (2400e214 <HAL_I2CEx_DisableFastModePlus+0x44>)
2400e1f8:	685a      	ldr	r2, [r3, #4]
2400e1fa:	687b      	ldr	r3, [r7, #4]
2400e1fc:	43db      	mvns	r3, r3
2400e1fe:	4905      	ldr	r1, [pc, #20]	; (2400e214 <HAL_I2CEx_DisableFastModePlus+0x44>)
2400e200:	4013      	ands	r3, r2
2400e202:	604b      	str	r3, [r1, #4]
}
2400e204:	bf00      	nop
2400e206:	3714      	adds	r7, #20
2400e208:	46bd      	mov	sp, r7
2400e20a:	f85d 7b04 	ldr.w	r7, [sp], #4
2400e20e:	4770      	bx	lr
2400e210:	58024400 	.word	0x58024400
2400e214:	58000400 	.word	0x58000400

2400e218 <HAL_MDMA_Init>:
  * @param  hmdma: Pointer to a MDMA_HandleTypeDef structure that contains
  *               the configuration information for the specified MDMA Channel.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_MDMA_Init(MDMA_HandleTypeDef *hmdma)
{
2400e218:	b580      	push	{r7, lr}
2400e21a:	b084      	sub	sp, #16
2400e21c:	af00      	add	r7, sp, #0
2400e21e:	6078      	str	r0, [r7, #4]
  uint32_t tickstart = HAL_GetTick();
2400e220:	f7f2 fb18 	bl	24000854 <HAL_GetTick>
2400e224:	60f8      	str	r0, [r7, #12]

  /* Check the MDMA peripheral handle */
  if(hmdma == NULL)
2400e226:	687b      	ldr	r3, [r7, #4]
2400e228:	2b00      	cmp	r3, #0
2400e22a:	d101      	bne.n	2400e230 <HAL_MDMA_Init+0x18>
  {
    return HAL_ERROR;
2400e22c:	2301      	movs	r3, #1
2400e22e:	e03b      	b.n	2400e2a8 <HAL_MDMA_Init+0x90>
  assert_param(IS_MDMA_BLOCK_ADDR_OFFSET(hmdma->Init.SourceBlockAddressOffset));
  assert_param(IS_MDMA_BLOCK_ADDR_OFFSET(hmdma->Init.DestBlockAddressOffset));


  /* Allocate lock resource */
  __HAL_UNLOCK(hmdma);
2400e230:	687b      	ldr	r3, [r7, #4]
2400e232:	2200      	movs	r2, #0
2400e234:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  /* Change MDMA peripheral state */
  hmdma->State = HAL_MDMA_STATE_BUSY;
2400e238:	687b      	ldr	r3, [r7, #4]
2400e23a:	2202      	movs	r2, #2
2400e23c:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  /* Disable the MDMA channel */
  __HAL_MDMA_DISABLE(hmdma);
2400e240:	687b      	ldr	r3, [r7, #4]
2400e242:	681b      	ldr	r3, [r3, #0]
2400e244:	68da      	ldr	r2, [r3, #12]
2400e246:	687b      	ldr	r3, [r7, #4]
2400e248:	681b      	ldr	r3, [r3, #0]
2400e24a:	f022 0201 	bic.w	r2, r2, #1
2400e24e:	60da      	str	r2, [r3, #12]

  /* Check if the MDMA channel is effectively disabled */
  while((hmdma->Instance->CCR & MDMA_CCR_EN) != 0U)
2400e250:	e00f      	b.n	2400e272 <HAL_MDMA_Init+0x5a>
  {
    /* Check for the Timeout */
    if((HAL_GetTick() - tickstart ) > HAL_TIMEOUT_MDMA_ABORT)
2400e252:	f7f2 faff 	bl	24000854 <HAL_GetTick>
2400e256:	4602      	mov	r2, r0
2400e258:	68fb      	ldr	r3, [r7, #12]
2400e25a:	1ad3      	subs	r3, r2, r3
2400e25c:	2b05      	cmp	r3, #5
2400e25e:	d908      	bls.n	2400e272 <HAL_MDMA_Init+0x5a>
    {
      /* Update error code */
      hmdma->ErrorCode = HAL_MDMA_ERROR_TIMEOUT;
2400e260:	687b      	ldr	r3, [r7, #4]
2400e262:	2240      	movs	r2, #64	; 0x40
2400e264:	669a      	str	r2, [r3, #104]	; 0x68

      /* Change the MDMA state */
      hmdma->State = HAL_MDMA_STATE_ERROR;
2400e266:	687b      	ldr	r3, [r7, #4]
2400e268:	2203      	movs	r2, #3
2400e26a:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

      return HAL_ERROR;
2400e26e:	2301      	movs	r3, #1
2400e270:	e01a      	b.n	2400e2a8 <HAL_MDMA_Init+0x90>
  while((hmdma->Instance->CCR & MDMA_CCR_EN) != 0U)
2400e272:	687b      	ldr	r3, [r7, #4]
2400e274:	681b      	ldr	r3, [r3, #0]
2400e276:	68db      	ldr	r3, [r3, #12]
2400e278:	f003 0301 	and.w	r3, r3, #1
2400e27c:	2b00      	cmp	r3, #0
2400e27e:	d1e8      	bne.n	2400e252 <HAL_MDMA_Init+0x3a>
    }
  }

  /* Initialize the MDMA channel registers */
  MDMA_Init(hmdma);
2400e280:	6878      	ldr	r0, [r7, #4]
2400e282:	f001 f89b 	bl	2400f3bc <MDMA_Init>

  /* Reset the MDMA first/last linkedlist node addresses and node counter */
  hmdma->FirstLinkedListNodeAddress  = 0;
2400e286:	687b      	ldr	r3, [r7, #4]
2400e288:	2200      	movs	r2, #0
2400e28a:	65da      	str	r2, [r3, #92]	; 0x5c
  hmdma->LastLinkedListNodeAddress   = 0;
2400e28c:	687b      	ldr	r3, [r7, #4]
2400e28e:	2200      	movs	r2, #0
2400e290:	661a      	str	r2, [r3, #96]	; 0x60
  hmdma->LinkedListNodeCounter  = 0;
2400e292:	687b      	ldr	r3, [r7, #4]
2400e294:	2200      	movs	r2, #0
2400e296:	665a      	str	r2, [r3, #100]	; 0x64

  /* Initialize the error code */
  hmdma->ErrorCode = HAL_MDMA_ERROR_NONE;
2400e298:	687b      	ldr	r3, [r7, #4]
2400e29a:	2200      	movs	r2, #0
2400e29c:	669a      	str	r2, [r3, #104]	; 0x68

  /* Initialize the MDMA state */
  hmdma->State = HAL_MDMA_STATE_READY;
2400e29e:	687b      	ldr	r3, [r7, #4]
2400e2a0:	2201      	movs	r2, #1
2400e2a2:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  return HAL_OK;
2400e2a6:	2300      	movs	r3, #0
}
2400e2a8:	4618      	mov	r0, r3
2400e2aa:	3710      	adds	r7, #16
2400e2ac:	46bd      	mov	sp, r7
2400e2ae:	bd80      	pop	{r7, pc}

2400e2b0 <HAL_MDMA_DeInit>:
  * @param  hmdma: pointer to a MDMA_HandleTypeDef structure that contains
  *               the configuration information for the specified MDMA Channel.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_MDMA_DeInit(MDMA_HandleTypeDef *hmdma)
{
2400e2b0:	b480      	push	{r7}
2400e2b2:	b083      	sub	sp, #12
2400e2b4:	af00      	add	r7, sp, #0
2400e2b6:	6078      	str	r0, [r7, #4]

  /* Check the MDMA peripheral handle */
  if(hmdma == NULL)
2400e2b8:	687b      	ldr	r3, [r7, #4]
2400e2ba:	2b00      	cmp	r3, #0
2400e2bc:	d101      	bne.n	2400e2c2 <HAL_MDMA_DeInit+0x12>
  {
    return HAL_ERROR;
2400e2be:	2301      	movs	r3, #1
2400e2c0:	e048      	b.n	2400e354 <HAL_MDMA_DeInit+0xa4>
  }

  /* Disable the selected MDMA Channelx */
  __HAL_MDMA_DISABLE(hmdma);
2400e2c2:	687b      	ldr	r3, [r7, #4]
2400e2c4:	681b      	ldr	r3, [r3, #0]
2400e2c6:	68da      	ldr	r2, [r3, #12]
2400e2c8:	687b      	ldr	r3, [r7, #4]
2400e2ca:	681b      	ldr	r3, [r3, #0]
2400e2cc:	f022 0201 	bic.w	r2, r2, #1
2400e2d0:	60da      	str	r2, [r3, #12]

  /* Reset MDMA Channel control register */
  hmdma->Instance->CCR  = 0;
2400e2d2:	687b      	ldr	r3, [r7, #4]
2400e2d4:	681b      	ldr	r3, [r3, #0]
2400e2d6:	2200      	movs	r2, #0
2400e2d8:	60da      	str	r2, [r3, #12]
  hmdma->Instance->CTCR = 0;
2400e2da:	687b      	ldr	r3, [r7, #4]
2400e2dc:	681b      	ldr	r3, [r3, #0]
2400e2de:	2200      	movs	r2, #0
2400e2e0:	611a      	str	r2, [r3, #16]
  hmdma->Instance->CBNDTR = 0;
2400e2e2:	687b      	ldr	r3, [r7, #4]
2400e2e4:	681b      	ldr	r3, [r3, #0]
2400e2e6:	2200      	movs	r2, #0
2400e2e8:	615a      	str	r2, [r3, #20]
  hmdma->Instance->CSAR = 0;
2400e2ea:	687b      	ldr	r3, [r7, #4]
2400e2ec:	681b      	ldr	r3, [r3, #0]
2400e2ee:	2200      	movs	r2, #0
2400e2f0:	619a      	str	r2, [r3, #24]
  hmdma->Instance->CDAR = 0;
2400e2f2:	687b      	ldr	r3, [r7, #4]
2400e2f4:	681b      	ldr	r3, [r3, #0]
2400e2f6:	2200      	movs	r2, #0
2400e2f8:	61da      	str	r2, [r3, #28]
  hmdma->Instance->CBRUR = 0;
2400e2fa:	687b      	ldr	r3, [r7, #4]
2400e2fc:	681b      	ldr	r3, [r3, #0]
2400e2fe:	2200      	movs	r2, #0
2400e300:	621a      	str	r2, [r3, #32]
  hmdma->Instance->CLAR = 0;
2400e302:	687b      	ldr	r3, [r7, #4]
2400e304:	681b      	ldr	r3, [r3, #0]
2400e306:	2200      	movs	r2, #0
2400e308:	625a      	str	r2, [r3, #36]	; 0x24
  hmdma->Instance->CTBR = 0;
2400e30a:	687b      	ldr	r3, [r7, #4]
2400e30c:	681b      	ldr	r3, [r3, #0]
2400e30e:	2200      	movs	r2, #0
2400e310:	629a      	str	r2, [r3, #40]	; 0x28
  hmdma->Instance->CMAR = 0;
2400e312:	687b      	ldr	r3, [r7, #4]
2400e314:	681b      	ldr	r3, [r3, #0]
2400e316:	2200      	movs	r2, #0
2400e318:	631a      	str	r2, [r3, #48]	; 0x30
  hmdma->Instance->CMDR = 0;
2400e31a:	687b      	ldr	r3, [r7, #4]
2400e31c:	681b      	ldr	r3, [r3, #0]
2400e31e:	2200      	movs	r2, #0
2400e320:	635a      	str	r2, [r3, #52]	; 0x34

  /* Clear all flags */
  __HAL_MDMA_CLEAR_FLAG(hmdma,(MDMA_FLAG_TE | MDMA_FLAG_CTC | MDMA_FLAG_BRT | MDMA_FLAG_BT | MDMA_FLAG_BFTC));
2400e322:	687b      	ldr	r3, [r7, #4]
2400e324:	681b      	ldr	r3, [r3, #0]
2400e326:	221f      	movs	r2, #31
2400e328:	605a      	str	r2, [r3, #4]

  /* Reset the  MDMA first/last linkedlist node addresses and node counter */
  hmdma->FirstLinkedListNodeAddress  = 0;
2400e32a:	687b      	ldr	r3, [r7, #4]
2400e32c:	2200      	movs	r2, #0
2400e32e:	65da      	str	r2, [r3, #92]	; 0x5c
  hmdma->LastLinkedListNodeAddress   = 0;
2400e330:	687b      	ldr	r3, [r7, #4]
2400e332:	2200      	movs	r2, #0
2400e334:	661a      	str	r2, [r3, #96]	; 0x60
  hmdma->LinkedListNodeCounter  = 0;
2400e336:	687b      	ldr	r3, [r7, #4]
2400e338:	2200      	movs	r2, #0
2400e33a:	665a      	str	r2, [r3, #100]	; 0x64

  /* Initialize the error code */
  hmdma->ErrorCode = HAL_MDMA_ERROR_NONE;
2400e33c:	687b      	ldr	r3, [r7, #4]
2400e33e:	2200      	movs	r2, #0
2400e340:	669a      	str	r2, [r3, #104]	; 0x68

  /* Initialize the MDMA state */
  hmdma->State = HAL_MDMA_STATE_RESET;
2400e342:	687b      	ldr	r3, [r7, #4]
2400e344:	2200      	movs	r2, #0
2400e346:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  /* Release Lock */
  __HAL_UNLOCK(hmdma);
2400e34a:	687b      	ldr	r3, [r7, #4]
2400e34c:	2200      	movs	r2, #0
2400e34e:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  return HAL_OK;
2400e352:	2300      	movs	r3, #0
}
2400e354:	4618      	mov	r0, r3
2400e356:	370c      	adds	r7, #12
2400e358:	46bd      	mov	sp, r7
2400e35a:	f85d 7b04 	ldr.w	r7, [sp], #4
2400e35e:	4770      	bx	lr

2400e360 <HAL_MDMA_ConfigPostRequestMask>:
  * @param  MaskData:    specifies the value to be written to MaskAddress after a request is served.
  *                      MaskAddress and MaskData could be used to automatically clear a peripheral flag when the request is served.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_MDMA_ConfigPostRequestMask(MDMA_HandleTypeDef *hmdma, uint32_t MaskAddress, uint32_t MaskData)
{
2400e360:	b480      	push	{r7}
2400e362:	b087      	sub	sp, #28
2400e364:	af00      	add	r7, sp, #0
2400e366:	60f8      	str	r0, [r7, #12]
2400e368:	60b9      	str	r1, [r7, #8]
2400e36a:	607a      	str	r2, [r7, #4]
  HAL_StatusTypeDef  status = HAL_OK;
2400e36c:	2300      	movs	r3, #0
2400e36e:	75fb      	strb	r3, [r7, #23]

  /* Check the MDMA peripheral handle */
  if(hmdma == NULL)
2400e370:	68fb      	ldr	r3, [r7, #12]
2400e372:	2b00      	cmp	r3, #0
2400e374:	d101      	bne.n	2400e37a <HAL_MDMA_ConfigPostRequestMask+0x1a>
  {
    return HAL_ERROR;
2400e376:	2301      	movs	r3, #1
2400e378:	e03e      	b.n	2400e3f8 <HAL_MDMA_ConfigPostRequestMask+0x98>
  }

  /* Process locked */
  __HAL_LOCK(hmdma);
2400e37a:	68fb      	ldr	r3, [r7, #12]
2400e37c:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
2400e380:	2b01      	cmp	r3, #1
2400e382:	d101      	bne.n	2400e388 <HAL_MDMA_ConfigPostRequestMask+0x28>
2400e384:	2302      	movs	r3, #2
2400e386:	e037      	b.n	2400e3f8 <HAL_MDMA_ConfigPostRequestMask+0x98>
2400e388:	68fb      	ldr	r3, [r7, #12]
2400e38a:	2201      	movs	r2, #1
2400e38c:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  if(HAL_MDMA_STATE_READY == hmdma->State)
2400e390:	68fb      	ldr	r3, [r7, #12]
2400e392:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
2400e396:	b2db      	uxtb	r3, r3
2400e398:	2b01      	cmp	r3, #1
2400e39a:	d126      	bne.n	2400e3ea <HAL_MDMA_ConfigPostRequestMask+0x8a>
  {
    /* if HW request set Post Request MaskAddress and MaskData,  */
    if((hmdma->Instance->CTCR & MDMA_CTCR_SWRM) == 0U)
2400e39c:	68fb      	ldr	r3, [r7, #12]
2400e39e:	681b      	ldr	r3, [r3, #0]
2400e3a0:	691b      	ldr	r3, [r3, #16]
2400e3a2:	f003 4380 	and.w	r3, r3, #1073741824	; 0x40000000
2400e3a6:	2b00      	cmp	r3, #0
2400e3a8:	d11c      	bne.n	2400e3e4 <HAL_MDMA_ConfigPostRequestMask+0x84>
    {
      /* Set the HW request clear Mask and Data */
      hmdma->Instance->CMAR = MaskAddress;
2400e3aa:	68fb      	ldr	r3, [r7, #12]
2400e3ac:	681b      	ldr	r3, [r3, #0]
2400e3ae:	68ba      	ldr	r2, [r7, #8]
2400e3b0:	631a      	str	r2, [r3, #48]	; 0x30
      hmdma->Instance->CMDR = MaskData;
2400e3b2:	68fb      	ldr	r3, [r7, #12]
2400e3b4:	681b      	ldr	r3, [r3, #0]
2400e3b6:	687a      	ldr	r2, [r7, #4]
2400e3b8:	635a      	str	r2, [r3, #52]	; 0x34
      -If the request is done by SW : BWM could be set to 1 or 0.
      -If the request is done by a peripheral :
         If mask address not set (0) => BWM must be set to 0
         If mask address set (different than 0) => BWM could be set to 1 or 0
      */
      if(MaskAddress == 0U)
2400e3ba:	68bb      	ldr	r3, [r7, #8]
2400e3bc:	2b00      	cmp	r3, #0
2400e3be:	d108      	bne.n	2400e3d2 <HAL_MDMA_ConfigPostRequestMask+0x72>
      {
        hmdma->Instance->CTCR &=  ~MDMA_CTCR_BWM;
2400e3c0:	68fb      	ldr	r3, [r7, #12]
2400e3c2:	681b      	ldr	r3, [r3, #0]
2400e3c4:	691a      	ldr	r2, [r3, #16]
2400e3c6:	68fb      	ldr	r3, [r7, #12]
2400e3c8:	681b      	ldr	r3, [r3, #0]
2400e3ca:	f022 4200 	bic.w	r2, r2, #2147483648	; 0x80000000
2400e3ce:	611a      	str	r2, [r3, #16]
2400e3d0:	e00d      	b.n	2400e3ee <HAL_MDMA_ConfigPostRequestMask+0x8e>
      }
      else
      {
        hmdma->Instance->CTCR |=  MDMA_CTCR_BWM;
2400e3d2:	68fb      	ldr	r3, [r7, #12]
2400e3d4:	681b      	ldr	r3, [r3, #0]
2400e3d6:	691a      	ldr	r2, [r3, #16]
2400e3d8:	68fb      	ldr	r3, [r7, #12]
2400e3da:	681b      	ldr	r3, [r3, #0]
2400e3dc:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
2400e3e0:	611a      	str	r2, [r3, #16]
2400e3e2:	e004      	b.n	2400e3ee <HAL_MDMA_ConfigPostRequestMask+0x8e>
      }
    }
    else
    {
      /* Return error status */
      status =  HAL_ERROR;
2400e3e4:	2301      	movs	r3, #1
2400e3e6:	75fb      	strb	r3, [r7, #23]
2400e3e8:	e001      	b.n	2400e3ee <HAL_MDMA_ConfigPostRequestMask+0x8e>
    }
  }
  else
  {
    /* Return error status */
    status =  HAL_ERROR;
2400e3ea:	2301      	movs	r3, #1
2400e3ec:	75fb      	strb	r3, [r7, #23]
  }
  /* Release Lock */
  __HAL_UNLOCK(hmdma);
2400e3ee:	68fb      	ldr	r3, [r7, #12]
2400e3f0:	2200      	movs	r2, #0
2400e3f2:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  return status;
2400e3f6:	7dfb      	ldrb	r3, [r7, #23]
}
2400e3f8:	4618      	mov	r0, r3
2400e3fa:	371c      	adds	r7, #28
2400e3fc:	46bd      	mov	sp, r7
2400e3fe:	f85d 7b04 	ldr.w	r7, [sp], #4
2400e402:	4770      	bx	lr

2400e404 <HAL_MDMA_RegisterCallback>:
  * @param  CallbackID:           User Callback identifier
  * @param  pCallback:            pointer to callbacsk function.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_MDMA_RegisterCallback(MDMA_HandleTypeDef *hmdma, HAL_MDMA_CallbackIDTypeDef CallbackID, void (* pCallback)(MDMA_HandleTypeDef *_hmdma))
{
2400e404:	b480      	push	{r7}
2400e406:	b087      	sub	sp, #28
2400e408:	af00      	add	r7, sp, #0
2400e40a:	60f8      	str	r0, [r7, #12]
2400e40c:	460b      	mov	r3, r1
2400e40e:	607a      	str	r2, [r7, #4]
2400e410:	72fb      	strb	r3, [r7, #11]
  HAL_StatusTypeDef status = HAL_OK;
2400e412:	2300      	movs	r3, #0
2400e414:	75fb      	strb	r3, [r7, #23]

  /* Check the MDMA peripheral handle */
  if(hmdma == NULL)
2400e416:	68fb      	ldr	r3, [r7, #12]
2400e418:	2b00      	cmp	r3, #0
2400e41a:	d101      	bne.n	2400e420 <HAL_MDMA_RegisterCallback+0x1c>
  {
    return HAL_ERROR;
2400e41c:	2301      	movs	r3, #1
2400e41e:	e044      	b.n	2400e4aa <HAL_MDMA_RegisterCallback+0xa6>
  }

  /* Process locked */
  __HAL_LOCK(hmdma);
2400e420:	68fb      	ldr	r3, [r7, #12]
2400e422:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
2400e426:	2b01      	cmp	r3, #1
2400e428:	d101      	bne.n	2400e42e <HAL_MDMA_RegisterCallback+0x2a>
2400e42a:	2302      	movs	r3, #2
2400e42c:	e03d      	b.n	2400e4aa <HAL_MDMA_RegisterCallback+0xa6>
2400e42e:	68fb      	ldr	r3, [r7, #12]
2400e430:	2201      	movs	r2, #1
2400e432:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  if(HAL_MDMA_STATE_READY == hmdma->State)
2400e436:	68fb      	ldr	r3, [r7, #12]
2400e438:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
2400e43c:	b2db      	uxtb	r3, r3
2400e43e:	2b01      	cmp	r3, #1
2400e440:	d12a      	bne.n	2400e498 <HAL_MDMA_RegisterCallback+0x94>
  {
    switch (CallbackID)
2400e442:	7afb      	ldrb	r3, [r7, #11]
2400e444:	2b05      	cmp	r3, #5
2400e446:	d82a      	bhi.n	2400e49e <HAL_MDMA_RegisterCallback+0x9a>
2400e448:	a201      	add	r2, pc, #4	; (adr r2, 2400e450 <HAL_MDMA_RegisterCallback+0x4c>)
2400e44a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
2400e44e:	bf00      	nop
2400e450:	2400e469 	.word	0x2400e469
2400e454:	2400e471 	.word	0x2400e471
2400e458:	2400e479 	.word	0x2400e479
2400e45c:	2400e481 	.word	0x2400e481
2400e460:	2400e489 	.word	0x2400e489
2400e464:	2400e491 	.word	0x2400e491
    {
    case  HAL_MDMA_XFER_CPLT_CB_ID:
      hmdma->XferCpltCallback = pCallback;
2400e468:	68fb      	ldr	r3, [r7, #12]
2400e46a:	687a      	ldr	r2, [r7, #4]
2400e46c:	645a      	str	r2, [r3, #68]	; 0x44
      break;
2400e46e:	e017      	b.n	2400e4a0 <HAL_MDMA_RegisterCallback+0x9c>

    case  HAL_MDMA_XFER_BUFFERCPLT_CB_ID:
      hmdma->XferBufferCpltCallback = pCallback;
2400e470:	68fb      	ldr	r3, [r7, #12]
2400e472:	687a      	ldr	r2, [r7, #4]
2400e474:	649a      	str	r2, [r3, #72]	; 0x48
      break;
2400e476:	e013      	b.n	2400e4a0 <HAL_MDMA_RegisterCallback+0x9c>

    case  HAL_MDMA_XFER_BLOCKCPLT_CB_ID:
      hmdma->XferBlockCpltCallback = pCallback;
2400e478:	68fb      	ldr	r3, [r7, #12]
2400e47a:	687a      	ldr	r2, [r7, #4]
2400e47c:	64da      	str	r2, [r3, #76]	; 0x4c
      break;
2400e47e:	e00f      	b.n	2400e4a0 <HAL_MDMA_RegisterCallback+0x9c>

    case  HAL_MDMA_XFER_REPBLOCKCPLT_CB_ID:
      hmdma->XferRepeatBlockCpltCallback = pCallback;
2400e480:	68fb      	ldr	r3, [r7, #12]
2400e482:	687a      	ldr	r2, [r7, #4]
2400e484:	651a      	str	r2, [r3, #80]	; 0x50
      break;
2400e486:	e00b      	b.n	2400e4a0 <HAL_MDMA_RegisterCallback+0x9c>

    case  HAL_MDMA_XFER_ERROR_CB_ID:
      hmdma->XferErrorCallback = pCallback;
2400e488:	68fb      	ldr	r3, [r7, #12]
2400e48a:	687a      	ldr	r2, [r7, #4]
2400e48c:	655a      	str	r2, [r3, #84]	; 0x54
      break;
2400e48e:	e007      	b.n	2400e4a0 <HAL_MDMA_RegisterCallback+0x9c>

    case  HAL_MDMA_XFER_ABORT_CB_ID:
      hmdma->XferAbortCallback = pCallback;
2400e490:	68fb      	ldr	r3, [r7, #12]
2400e492:	687a      	ldr	r2, [r7, #4]
2400e494:	659a      	str	r2, [r3, #88]	; 0x58
      break;
2400e496:	e003      	b.n	2400e4a0 <HAL_MDMA_RegisterCallback+0x9c>
    }
  }
  else
  {
    /* Return error status */
    status =  HAL_ERROR;
2400e498:	2301      	movs	r3, #1
2400e49a:	75fb      	strb	r3, [r7, #23]
2400e49c:	e000      	b.n	2400e4a0 <HAL_MDMA_RegisterCallback+0x9c>
      break;
2400e49e:	bf00      	nop
  }

  /* Release Lock */
  __HAL_UNLOCK(hmdma);
2400e4a0:	68fb      	ldr	r3, [r7, #12]
2400e4a2:	2200      	movs	r2, #0
2400e4a4:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  return status;
2400e4a8:	7dfb      	ldrb	r3, [r7, #23]
}
2400e4aa:	4618      	mov	r0, r3
2400e4ac:	371c      	adds	r7, #28
2400e4ae:	46bd      	mov	sp, r7
2400e4b0:	f85d 7b04 	ldr.w	r7, [sp], #4
2400e4b4:	4770      	bx	lr
2400e4b6:	bf00      	nop

2400e4b8 <HAL_MDMA_UnRegisterCallback>:
  * @param  CallbackID:           User Callback identifier
  *                               a HAL_MDMA_CallbackIDTypeDef ENUM as parameter.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_MDMA_UnRegisterCallback(MDMA_HandleTypeDef *hmdma, HAL_MDMA_CallbackIDTypeDef CallbackID)
{
2400e4b8:	b480      	push	{r7}
2400e4ba:	b085      	sub	sp, #20
2400e4bc:	af00      	add	r7, sp, #0
2400e4be:	6078      	str	r0, [r7, #4]
2400e4c0:	460b      	mov	r3, r1
2400e4c2:	70fb      	strb	r3, [r7, #3]
  HAL_StatusTypeDef status = HAL_OK;
2400e4c4:	2300      	movs	r3, #0
2400e4c6:	73fb      	strb	r3, [r7, #15]

  /* Check the MDMA peripheral handle */
  if(hmdma == NULL)
2400e4c8:	687b      	ldr	r3, [r7, #4]
2400e4ca:	2b00      	cmp	r3, #0
2400e4cc:	d101      	bne.n	2400e4d2 <HAL_MDMA_UnRegisterCallback+0x1a>
  {
    return HAL_ERROR;
2400e4ce:	2301      	movs	r3, #1
2400e4d0:	e05a      	b.n	2400e588 <HAL_MDMA_UnRegisterCallback+0xd0>
  }

  /* Process locked */
  __HAL_LOCK(hmdma);
2400e4d2:	687b      	ldr	r3, [r7, #4]
2400e4d4:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
2400e4d8:	2b01      	cmp	r3, #1
2400e4da:	d101      	bne.n	2400e4e0 <HAL_MDMA_UnRegisterCallback+0x28>
2400e4dc:	2302      	movs	r3, #2
2400e4de:	e053      	b.n	2400e588 <HAL_MDMA_UnRegisterCallback+0xd0>
2400e4e0:	687b      	ldr	r3, [r7, #4]
2400e4e2:	2201      	movs	r2, #1
2400e4e4:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  if(HAL_MDMA_STATE_READY == hmdma->State)
2400e4e8:	687b      	ldr	r3, [r7, #4]
2400e4ea:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
2400e4ee:	b2db      	uxtb	r3, r3
2400e4f0:	2b01      	cmp	r3, #1
2400e4f2:	d142      	bne.n	2400e57a <HAL_MDMA_UnRegisterCallback+0xc2>
  {
    switch (CallbackID)
2400e4f4:	78fb      	ldrb	r3, [r7, #3]
2400e4f6:	2b06      	cmp	r3, #6
2400e4f8:	d83b      	bhi.n	2400e572 <HAL_MDMA_UnRegisterCallback+0xba>
2400e4fa:	a201      	add	r2, pc, #4	; (adr r2, 2400e500 <HAL_MDMA_UnRegisterCallback+0x48>)
2400e4fc:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
2400e500:	2400e51d 	.word	0x2400e51d
2400e504:	2400e525 	.word	0x2400e525
2400e508:	2400e52d 	.word	0x2400e52d
2400e50c:	2400e535 	.word	0x2400e535
2400e510:	2400e53d 	.word	0x2400e53d
2400e514:	2400e545 	.word	0x2400e545
2400e518:	2400e54d 	.word	0x2400e54d
    {
    case  HAL_MDMA_XFER_CPLT_CB_ID:
      hmdma->XferCpltCallback = NULL;
2400e51c:	687b      	ldr	r3, [r7, #4]
2400e51e:	2200      	movs	r2, #0
2400e520:	645a      	str	r2, [r3, #68]	; 0x44
      break;
2400e522:	e02c      	b.n	2400e57e <HAL_MDMA_UnRegisterCallback+0xc6>

    case  HAL_MDMA_XFER_BUFFERCPLT_CB_ID:
      hmdma->XferBufferCpltCallback = NULL;
2400e524:	687b      	ldr	r3, [r7, #4]
2400e526:	2200      	movs	r2, #0
2400e528:	649a      	str	r2, [r3, #72]	; 0x48
      break;
2400e52a:	e028      	b.n	2400e57e <HAL_MDMA_UnRegisterCallback+0xc6>

    case  HAL_MDMA_XFER_BLOCKCPLT_CB_ID:
      hmdma->XferBlockCpltCallback = NULL;
2400e52c:	687b      	ldr	r3, [r7, #4]
2400e52e:	2200      	movs	r2, #0
2400e530:	64da      	str	r2, [r3, #76]	; 0x4c
      break;
2400e532:	e024      	b.n	2400e57e <HAL_MDMA_UnRegisterCallback+0xc6>

    case  HAL_MDMA_XFER_REPBLOCKCPLT_CB_ID:
      hmdma->XferRepeatBlockCpltCallback = NULL;
2400e534:	687b      	ldr	r3, [r7, #4]
2400e536:	2200      	movs	r2, #0
2400e538:	651a      	str	r2, [r3, #80]	; 0x50
      break;
2400e53a:	e020      	b.n	2400e57e <HAL_MDMA_UnRegisterCallback+0xc6>

    case  HAL_MDMA_XFER_ERROR_CB_ID:
      hmdma->XferErrorCallback = NULL;
2400e53c:	687b      	ldr	r3, [r7, #4]
2400e53e:	2200      	movs	r2, #0
2400e540:	655a      	str	r2, [r3, #84]	; 0x54
      break;
2400e542:	e01c      	b.n	2400e57e <HAL_MDMA_UnRegisterCallback+0xc6>

    case  HAL_MDMA_XFER_ABORT_CB_ID:
      hmdma->XferAbortCallback = NULL;
2400e544:	687b      	ldr	r3, [r7, #4]
2400e546:	2200      	movs	r2, #0
2400e548:	659a      	str	r2, [r3, #88]	; 0x58
      break;
2400e54a:	e018      	b.n	2400e57e <HAL_MDMA_UnRegisterCallback+0xc6>

    case   HAL_MDMA_XFER_ALL_CB_ID:
      hmdma->XferCpltCallback = NULL;
2400e54c:	687b      	ldr	r3, [r7, #4]
2400e54e:	2200      	movs	r2, #0
2400e550:	645a      	str	r2, [r3, #68]	; 0x44
      hmdma->XferBufferCpltCallback = NULL;
2400e552:	687b      	ldr	r3, [r7, #4]
2400e554:	2200      	movs	r2, #0
2400e556:	649a      	str	r2, [r3, #72]	; 0x48
      hmdma->XferBlockCpltCallback = NULL;
2400e558:	687b      	ldr	r3, [r7, #4]
2400e55a:	2200      	movs	r2, #0
2400e55c:	64da      	str	r2, [r3, #76]	; 0x4c
      hmdma->XferRepeatBlockCpltCallback = NULL;
2400e55e:	687b      	ldr	r3, [r7, #4]
2400e560:	2200      	movs	r2, #0
2400e562:	651a      	str	r2, [r3, #80]	; 0x50
      hmdma->XferErrorCallback = NULL;
2400e564:	687b      	ldr	r3, [r7, #4]
2400e566:	2200      	movs	r2, #0
2400e568:	655a      	str	r2, [r3, #84]	; 0x54
      hmdma->XferAbortCallback = NULL;
2400e56a:	687b      	ldr	r3, [r7, #4]
2400e56c:	2200      	movs	r2, #0
2400e56e:	659a      	str	r2, [r3, #88]	; 0x58
      break;
2400e570:	e005      	b.n	2400e57e <HAL_MDMA_UnRegisterCallback+0xc6>

    default:
      status = HAL_ERROR;
2400e572:	2301      	movs	r3, #1
2400e574:	73fb      	strb	r3, [r7, #15]
      break;
2400e576:	bf00      	nop
2400e578:	e001      	b.n	2400e57e <HAL_MDMA_UnRegisterCallback+0xc6>
    }
  }
  else
  {
    status = HAL_ERROR;
2400e57a:	2301      	movs	r3, #1
2400e57c:	73fb      	strb	r3, [r7, #15]
  }

  /* Release Lock */
  __HAL_UNLOCK(hmdma);
2400e57e:	687b      	ldr	r3, [r7, #4]
2400e580:	2200      	movs	r2, #0
2400e582:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  return status;
2400e586:	7bfb      	ldrb	r3, [r7, #15]
}
2400e588:	4618      	mov	r0, r3
2400e58a:	3714      	adds	r7, #20
2400e58c:	46bd      	mov	sp, r7
2400e58e:	f85d 7b04 	ldr.w	r7, [sp], #4
2400e592:	4770      	bx	lr

2400e594 <HAL_MDMA_LinkedList_CreateNode>:
  * @param  pNodeConfig: Pointer to a MDMA_LinkNodeConfTypeDef structure that contains
  *               the configuration information for the specified MDMA Linked List Node.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_MDMA_LinkedList_CreateNode(MDMA_LinkNodeTypeDef *pNode, MDMA_LinkNodeConfTypeDef *pNodeConfig)
{
2400e594:	b480      	push	{r7}
2400e596:	b085      	sub	sp, #20
2400e598:	af00      	add	r7, sp, #0
2400e59a:	6078      	str	r0, [r7, #4]
2400e59c:	6039      	str	r1, [r7, #0]
  uint32_t addressMask;
  uint32_t blockoffset;

  /* Check the MDMA peripheral state */
  if((pNode == NULL) || (pNodeConfig == NULL))
2400e59e:	687b      	ldr	r3, [r7, #4]
2400e5a0:	2b00      	cmp	r3, #0
2400e5a2:	d002      	beq.n	2400e5aa <HAL_MDMA_LinkedList_CreateNode+0x16>
2400e5a4:	683b      	ldr	r3, [r7, #0]
2400e5a6:	2b00      	cmp	r3, #0
2400e5a8:	d101      	bne.n	2400e5ae <HAL_MDMA_LinkedList_CreateNode+0x1a>
  {
    return HAL_ERROR;
2400e5aa:	2301      	movs	r3, #1
2400e5ac:	e0c8      	b.n	2400e740 <HAL_MDMA_LinkedList_CreateNode+0x1ac>
  assert_param(IS_MDMA_TRANSFER_LENGTH(pNodeConfig->BlockDataLength));
  assert_param(IS_MDMA_BLOCK_COUNT(pNodeConfig->BlockCount));


  /* Configure next Link node Address Register to zero */
  pNode->CLAR =  0;
2400e5ae:	687b      	ldr	r3, [r7, #4]
2400e5b0:	2200      	movs	r2, #0
2400e5b2:	615a      	str	r2, [r3, #20]

  /* Configure the Link Node registers*/
  pNode->CTBR   = 0;
2400e5b4:	687b      	ldr	r3, [r7, #4]
2400e5b6:	2200      	movs	r2, #0
2400e5b8:	619a      	str	r2, [r3, #24]
  pNode->CMAR   = 0;
2400e5ba:	687b      	ldr	r3, [r7, #4]
2400e5bc:	2200      	movs	r2, #0
2400e5be:	621a      	str	r2, [r3, #32]
  pNode->CMDR   = 0;
2400e5c0:	687b      	ldr	r3, [r7, #4]
2400e5c2:	2200      	movs	r2, #0
2400e5c4:	625a      	str	r2, [r3, #36]	; 0x24
  pNode->Reserved = 0;
2400e5c6:	687b      	ldr	r3, [r7, #4]
2400e5c8:	2200      	movs	r2, #0
2400e5ca:	61da      	str	r2, [r3, #28]

  /* Write new CTCR Register value */
  pNode->CTCR =  pNodeConfig->Init.SourceInc | pNodeConfig->Init.DestinationInc | \
2400e5cc:	683b      	ldr	r3, [r7, #0]
2400e5ce:	691a      	ldr	r2, [r3, #16]
2400e5d0:	683b      	ldr	r3, [r7, #0]
2400e5d2:	695b      	ldr	r3, [r3, #20]
2400e5d4:	431a      	orrs	r2, r3
    pNodeConfig->Init.SourceDataSize | pNodeConfig->Init.DestDataSize           | \
2400e5d6:	683b      	ldr	r3, [r7, #0]
2400e5d8:	699b      	ldr	r3, [r3, #24]
  pNode->CTCR =  pNodeConfig->Init.SourceInc | pNodeConfig->Init.DestinationInc | \
2400e5da:	431a      	orrs	r2, r3
    pNodeConfig->Init.SourceDataSize | pNodeConfig->Init.DestDataSize           | \
2400e5dc:	683b      	ldr	r3, [r7, #0]
2400e5de:	69db      	ldr	r3, [r3, #28]
2400e5e0:	431a      	orrs	r2, r3
      pNodeConfig->Init.DataAlignment| pNodeConfig->Init.SourceBurst            | \
2400e5e2:	683b      	ldr	r3, [r7, #0]
2400e5e4:	6a1b      	ldr	r3, [r3, #32]
    pNodeConfig->Init.SourceDataSize | pNodeConfig->Init.DestDataSize           | \
2400e5e6:	431a      	orrs	r2, r3
      pNodeConfig->Init.DataAlignment| pNodeConfig->Init.SourceBurst            | \
2400e5e8:	683b      	ldr	r3, [r7, #0]
2400e5ea:	6a9b      	ldr	r3, [r3, #40]	; 0x28
2400e5ec:	431a      	orrs	r2, r3
        pNodeConfig->Init.DestBurst                                             | \
2400e5ee:	683b      	ldr	r3, [r7, #0]
2400e5f0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
      pNodeConfig->Init.DataAlignment| pNodeConfig->Init.SourceBurst            | \
2400e5f2:	431a      	orrs	r2, r3
          ((pNodeConfig->Init.BufferTransferLength - 1U) << MDMA_CTCR_TLEN_Pos) | \
2400e5f4:	683b      	ldr	r3, [r7, #0]
2400e5f6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2400e5f8:	3b01      	subs	r3, #1
2400e5fa:	049b      	lsls	r3, r3, #18
        pNodeConfig->Init.DestBurst                                             | \
2400e5fc:	431a      	orrs	r2, r3
            pNodeConfig->Init.TransferTriggerMode;
2400e5fe:	683b      	ldr	r3, [r7, #0]
2400e600:	685b      	ldr	r3, [r3, #4]
          ((pNodeConfig->Init.BufferTransferLength - 1U) << MDMA_CTCR_TLEN_Pos) | \
2400e602:	431a      	orrs	r2, r3
  pNode->CTCR =  pNodeConfig->Init.SourceInc | pNodeConfig->Init.DestinationInc | \
2400e604:	687b      	ldr	r3, [r7, #4]
2400e606:	601a      	str	r2, [r3, #0]

  /* If SW request set the CTCR register to SW Request Mode*/
  if(pNodeConfig->Init.Request == MDMA_REQUEST_SW)
2400e608:	683b      	ldr	r3, [r7, #0]
2400e60a:	681b      	ldr	r3, [r3, #0]
2400e60c:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
2400e610:	d105      	bne.n	2400e61e <HAL_MDMA_LinkedList_CreateNode+0x8a>
  {
    pNode->CTCR |= MDMA_CTCR_SWRM;
2400e612:	687b      	ldr	r3, [r7, #4]
2400e614:	681b      	ldr	r3, [r3, #0]
2400e616:	f043 4280 	orr.w	r2, r3, #1073741824	; 0x40000000
2400e61a:	687b      	ldr	r3, [r7, #4]
2400e61c:	601a      	str	r2, [r3, #0]
  -If the request is done by SW : BWM could be set to 1 or 0.
  -If the request is done by a peripheral :
     If mask address not set (0) => BWM must be set to 0
     If mask address set (different than 0) => BWM could be set to 1 or 0
  */
  if((pNodeConfig->Init.Request == MDMA_REQUEST_SW) || (pNodeConfig->PostRequestMaskAddress != 0U))
2400e61e:	683b      	ldr	r3, [r7, #0]
2400e620:	681b      	ldr	r3, [r3, #0]
2400e622:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
2400e626:	d003      	beq.n	2400e630 <HAL_MDMA_LinkedList_CreateNode+0x9c>
2400e628:	683b      	ldr	r3, [r7, #0]
2400e62a:	6c9b      	ldr	r3, [r3, #72]	; 0x48
2400e62c:	2b00      	cmp	r3, #0
2400e62e:	d005      	beq.n	2400e63c <HAL_MDMA_LinkedList_CreateNode+0xa8>
  {
    pNode->CTCR |=  MDMA_CTCR_BWM;
2400e630:	687b      	ldr	r3, [r7, #4]
2400e632:	681b      	ldr	r3, [r3, #0]
2400e634:	f043 4200 	orr.w	r2, r3, #2147483648	; 0x80000000
2400e638:	687b      	ldr	r3, [r7, #4]
2400e63a:	601a      	str	r2, [r3, #0]
  }

  /* Set the new CBNDTR Register value */
  pNode->CBNDTR = ((pNodeConfig->BlockCount - 1U) << MDMA_CBNDTR_BRC_Pos) & MDMA_CBNDTR_BRC;
2400e63c:	683b      	ldr	r3, [r7, #0]
2400e63e:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400e640:	3b01      	subs	r3, #1
2400e642:	051a      	lsls	r2, r3, #20
2400e644:	687b      	ldr	r3, [r7, #4]
2400e646:	605a      	str	r2, [r3, #4]

  /* if block source address offset is negative set the Block Repeat Source address Update Mode to decrement */
  if(pNodeConfig->Init.SourceBlockAddressOffset < 0)
2400e648:	683b      	ldr	r3, [r7, #0]
2400e64a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
2400e64c:	2b00      	cmp	r3, #0
2400e64e:	da0e      	bge.n	2400e66e <HAL_MDMA_LinkedList_CreateNode+0xda>
  {
    pNode->CBNDTR |= MDMA_CBNDTR_BRSUM;
2400e650:	687b      	ldr	r3, [r7, #4]
2400e652:	685b      	ldr	r3, [r3, #4]
2400e654:	f443 2280 	orr.w	r2, r3, #262144	; 0x40000
2400e658:	687b      	ldr	r3, [r7, #4]
2400e65a:	605a      	str	r2, [r3, #4]
    /*write new CBRUR Register value : source repeat block offset */
    blockoffset = (uint32_t)(- pNodeConfig->Init.SourceBlockAddressOffset);
2400e65c:	683b      	ldr	r3, [r7, #0]
2400e65e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
2400e660:	425b      	negs	r3, r3
2400e662:	60fb      	str	r3, [r7, #12]
    pNode->CBRUR = blockoffset & 0x0000FFFFU;
2400e664:	68fb      	ldr	r3, [r7, #12]
2400e666:	b29a      	uxth	r2, r3
2400e668:	687b      	ldr	r3, [r7, #4]
2400e66a:	611a      	str	r2, [r3, #16]
2400e66c:	e004      	b.n	2400e678 <HAL_MDMA_LinkedList_CreateNode+0xe4>
  }
  else
  {
    /*write new CBRUR Register value : source repeat block offset */
    pNode->CBRUR = (((uint32_t) pNodeConfig->Init.SourceBlockAddressOffset) & 0x0000FFFFU);
2400e66e:	683b      	ldr	r3, [r7, #0]
2400e670:	6b1b      	ldr	r3, [r3, #48]	; 0x30
2400e672:	b29a      	uxth	r2, r3
2400e674:	687b      	ldr	r3, [r7, #4]
2400e676:	611a      	str	r2, [r3, #16]
  }

  /* if block destination address offset is negative set the Block Repeat destination address Update Mode to decrement */
  if(pNodeConfig->Init.DestBlockAddressOffset < 0)
2400e678:	683b      	ldr	r3, [r7, #0]
2400e67a:	6b5b      	ldr	r3, [r3, #52]	; 0x34
2400e67c:	2b00      	cmp	r3, #0
2400e67e:	da11      	bge.n	2400e6a4 <HAL_MDMA_LinkedList_CreateNode+0x110>
  {
    pNode->CBNDTR |= MDMA_CBNDTR_BRDUM;
2400e680:	687b      	ldr	r3, [r7, #4]
2400e682:	685b      	ldr	r3, [r3, #4]
2400e684:	f443 2200 	orr.w	r2, r3, #524288	; 0x80000
2400e688:	687b      	ldr	r3, [r7, #4]
2400e68a:	605a      	str	r2, [r3, #4]
    /*write new CBRUR Register value : destination repeat block offset */
    blockoffset = (uint32_t)(- pNodeConfig->Init.DestBlockAddressOffset);
2400e68c:	683b      	ldr	r3, [r7, #0]
2400e68e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
2400e690:	425b      	negs	r3, r3
2400e692:	60fb      	str	r3, [r7, #12]
    pNode->CBRUR |= ((blockoffset & 0x0000FFFFU) << MDMA_CBRUR_DUV_Pos);
2400e694:	687b      	ldr	r3, [r7, #4]
2400e696:	691a      	ldr	r2, [r3, #16]
2400e698:	68fb      	ldr	r3, [r7, #12]
2400e69a:	041b      	lsls	r3, r3, #16
2400e69c:	431a      	orrs	r2, r3
2400e69e:	687b      	ldr	r3, [r7, #4]
2400e6a0:	611a      	str	r2, [r3, #16]
2400e6a2:	e007      	b.n	2400e6b4 <HAL_MDMA_LinkedList_CreateNode+0x120>
  }
  else
  {
    /*write new CBRUR Register value : destination repeat block offset */
    pNode->CBRUR |= ((((uint32_t)pNodeConfig->Init.DestBlockAddressOffset) & 0x0000FFFFU) << MDMA_CBRUR_DUV_Pos);
2400e6a4:	687b      	ldr	r3, [r7, #4]
2400e6a6:	691a      	ldr	r2, [r3, #16]
2400e6a8:	683b      	ldr	r3, [r7, #0]
2400e6aa:	6b5b      	ldr	r3, [r3, #52]	; 0x34
2400e6ac:	041b      	lsls	r3, r3, #16
2400e6ae:	431a      	orrs	r2, r3
2400e6b0:	687b      	ldr	r3, [r7, #4]
2400e6b2:	611a      	str	r2, [r3, #16]
  }

  /* Configure MDMA Link Node data length */
  pNode->CBNDTR |=  pNodeConfig->BlockDataLength;
2400e6b4:	687b      	ldr	r3, [r7, #4]
2400e6b6:	685a      	ldr	r2, [r3, #4]
2400e6b8:	683b      	ldr	r3, [r7, #0]
2400e6ba:	6c1b      	ldr	r3, [r3, #64]	; 0x40
2400e6bc:	431a      	orrs	r2, r3
2400e6be:	687b      	ldr	r3, [r7, #4]
2400e6c0:	605a      	str	r2, [r3, #4]

  /* Configure MDMA Link Node destination address */
  pNode->CDAR = pNodeConfig->DstAddress;
2400e6c2:	683b      	ldr	r3, [r7, #0]
2400e6c4:	6bda      	ldr	r2, [r3, #60]	; 0x3c
2400e6c6:	687b      	ldr	r3, [r7, #4]
2400e6c8:	60da      	str	r2, [r3, #12]

  /* Configure MDMA Link Node Source address */
  pNode->CSAR = pNodeConfig->SrcAddress;
2400e6ca:	683b      	ldr	r3, [r7, #0]
2400e6cc:	6b9a      	ldr	r2, [r3, #56]	; 0x38
2400e6ce:	687b      	ldr	r3, [r7, #4]
2400e6d0:	609a      	str	r2, [r3, #8]

  /* if HW request set the HW request and the requet CleraMask and ClearData MaskData,  */
  if(pNodeConfig->Init.Request != MDMA_REQUEST_SW)
2400e6d2:	683b      	ldr	r3, [r7, #0]
2400e6d4:	681b      	ldr	r3, [r3, #0]
2400e6d6:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
2400e6da:	d00c      	beq.n	2400e6f6 <HAL_MDMA_LinkedList_CreateNode+0x162>
  {
    /* Set the HW request in CTBR register  */
    pNode->CTBR = pNodeConfig->Init.Request & MDMA_CTBR_TSEL;
2400e6dc:	683b      	ldr	r3, [r7, #0]
2400e6de:	681b      	ldr	r3, [r3, #0]
2400e6e0:	b2da      	uxtb	r2, r3
2400e6e2:	687b      	ldr	r3, [r7, #4]
2400e6e4:	619a      	str	r2, [r3, #24]
    /* Set the HW request clear Mask and Data */
    pNode->CMAR = pNodeConfig->PostRequestMaskAddress;
2400e6e6:	683b      	ldr	r3, [r7, #0]
2400e6e8:	6c9a      	ldr	r2, [r3, #72]	; 0x48
2400e6ea:	687b      	ldr	r3, [r7, #4]
2400e6ec:	621a      	str	r2, [r3, #32]
    pNode->CMDR = pNodeConfig->PostRequestMaskData;
2400e6ee:	683b      	ldr	r3, [r7, #0]
2400e6f0:	6cda      	ldr	r2, [r3, #76]	; 0x4c
2400e6f2:	687b      	ldr	r3, [r7, #4]
2400e6f4:	625a      	str	r2, [r3, #36]	; 0x24
  }

  addressMask = pNodeConfig->SrcAddress & 0xFF000000U;
2400e6f6:	683b      	ldr	r3, [r7, #0]
2400e6f8:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400e6fa:	f003 437f 	and.w	r3, r3, #4278190080	; 0xff000000
2400e6fe:	60bb      	str	r3, [r7, #8]
  if((addressMask == 0x20000000U) || (addressMask == 0x00000000U))
2400e700:	68bb      	ldr	r3, [r7, #8]
2400e702:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
2400e706:	d002      	beq.n	2400e70e <HAL_MDMA_LinkedList_CreateNode+0x17a>
2400e708:	68bb      	ldr	r3, [r7, #8]
2400e70a:	2b00      	cmp	r3, #0
2400e70c:	d105      	bne.n	2400e71a <HAL_MDMA_LinkedList_CreateNode+0x186>
  {
    /*The AHBSbus is used as source (read operation) on channel x */
    pNode->CTBR |= MDMA_CTBR_SBUS;
2400e70e:	687b      	ldr	r3, [r7, #4]
2400e710:	699b      	ldr	r3, [r3, #24]
2400e712:	f443 3280 	orr.w	r2, r3, #65536	; 0x10000
2400e716:	687b      	ldr	r3, [r7, #4]
2400e718:	619a      	str	r2, [r3, #24]
  }

  addressMask = pNodeConfig->DstAddress & 0xFF000000U;
2400e71a:	683b      	ldr	r3, [r7, #0]
2400e71c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400e71e:	f003 437f 	and.w	r3, r3, #4278190080	; 0xff000000
2400e722:	60bb      	str	r3, [r7, #8]
  if((addressMask == 0x20000000U) || (addressMask == 0x00000000U))
2400e724:	68bb      	ldr	r3, [r7, #8]
2400e726:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
2400e72a:	d002      	beq.n	2400e732 <HAL_MDMA_LinkedList_CreateNode+0x19e>
2400e72c:	68bb      	ldr	r3, [r7, #8]
2400e72e:	2b00      	cmp	r3, #0
2400e730:	d105      	bne.n	2400e73e <HAL_MDMA_LinkedList_CreateNode+0x1aa>
  {
    /*The AHB bus is used as destination (write operation) on channel x */
    pNode->CTBR |= MDMA_CTBR_DBUS;
2400e732:	687b      	ldr	r3, [r7, #4]
2400e734:	699b      	ldr	r3, [r3, #24]
2400e736:	f443 3200 	orr.w	r2, r3, #131072	; 0x20000
2400e73a:	687b      	ldr	r3, [r7, #4]
2400e73c:	619a      	str	r2, [r3, #24]
  }

  return HAL_OK;
2400e73e:	2300      	movs	r3, #0
}
2400e740:	4618      	mov	r0, r3
2400e742:	3714      	adds	r7, #20
2400e744:	46bd      	mov	sp, r7
2400e746:	f85d 7b04 	ldr.w	r7, [sp], #4
2400e74a:	4770      	bx	lr

2400e74c <HAL_MDMA_LinkedList_AddNode>:
  *                    at the end of the list
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_MDMA_LinkedList_AddNode(MDMA_HandleTypeDef *hmdma, MDMA_LinkNodeTypeDef *pNewNode, MDMA_LinkNodeTypeDef *pPrevNode)
{
2400e74c:	b480      	push	{r7}
2400e74e:	b089      	sub	sp, #36	; 0x24
2400e750:	af00      	add	r7, sp, #0
2400e752:	60f8      	str	r0, [r7, #12]
2400e754:	60b9      	str	r1, [r7, #8]
2400e756:	607a      	str	r2, [r7, #4]
  MDMA_LinkNodeTypeDef *pNode;
  uint32_t counter = 0, nodeInserted = 0;
2400e758:	2300      	movs	r3, #0
2400e75a:	61bb      	str	r3, [r7, #24]
2400e75c:	2300      	movs	r3, #0
2400e75e:	617b      	str	r3, [r7, #20]
  HAL_StatusTypeDef hal_status = HAL_OK;
2400e760:	2300      	movs	r3, #0
2400e762:	74fb      	strb	r3, [r7, #19]

  /* Check the MDMA peripheral handle */
  if((hmdma == NULL) || (pNewNode == NULL))
2400e764:	68fb      	ldr	r3, [r7, #12]
2400e766:	2b00      	cmp	r3, #0
2400e768:	d002      	beq.n	2400e770 <HAL_MDMA_LinkedList_AddNode+0x24>
2400e76a:	68bb      	ldr	r3, [r7, #8]
2400e76c:	2b00      	cmp	r3, #0
2400e76e:	d101      	bne.n	2400e774 <HAL_MDMA_LinkedList_AddNode+0x28>
  {
    return HAL_ERROR;
2400e770:	2301      	movs	r3, #1
2400e772:	e0a9      	b.n	2400e8c8 <HAL_MDMA_LinkedList_AddNode+0x17c>
  }

  /* Process locked */
  __HAL_LOCK(hmdma);
2400e774:	68fb      	ldr	r3, [r7, #12]
2400e776:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
2400e77a:	2b01      	cmp	r3, #1
2400e77c:	d101      	bne.n	2400e782 <HAL_MDMA_LinkedList_AddNode+0x36>
2400e77e:	2302      	movs	r3, #2
2400e780:	e0a2      	b.n	2400e8c8 <HAL_MDMA_LinkedList_AddNode+0x17c>
2400e782:	68fb      	ldr	r3, [r7, #12]
2400e784:	2201      	movs	r2, #1
2400e786:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  if(HAL_MDMA_STATE_READY == hmdma->State)
2400e78a:	68fb      	ldr	r3, [r7, #12]
2400e78c:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
2400e790:	b2db      	uxtb	r3, r3
2400e792:	2b01      	cmp	r3, #1
2400e794:	f040 8093 	bne.w	2400e8be <HAL_MDMA_LinkedList_AddNode+0x172>
  {
    /* Change MDMA peripheral state */
    hmdma->State = HAL_MDMA_STATE_BUSY;
2400e798:	68fb      	ldr	r3, [r7, #12]
2400e79a:	2202      	movs	r2, #2
2400e79c:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

    /* Check if this is the first node (after the Inititlization node) */
    if((uint32_t)hmdma->FirstLinkedListNodeAddress == 0U)
2400e7a0:	68fb      	ldr	r3, [r7, #12]
2400e7a2:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
2400e7a4:	2b00      	cmp	r3, #0
2400e7a6:	d116      	bne.n	2400e7d6 <HAL_MDMA_LinkedList_AddNode+0x8a>
    {
      if(pPrevNode == NULL)
2400e7a8:	687b      	ldr	r3, [r7, #4]
2400e7aa:	2b00      	cmp	r3, #0
2400e7ac:	d110      	bne.n	2400e7d0 <HAL_MDMA_LinkedList_AddNode+0x84>
      {
        /* if this is the first node after the initialization
        connect this node to the node 0 by updating
        the MDMA channel CLAR register to this node address */
        hmdma->Instance->CLAR = (uint32_t)pNewNode;
2400e7ae:	68fb      	ldr	r3, [r7, #12]
2400e7b0:	681b      	ldr	r3, [r3, #0]
2400e7b2:	68ba      	ldr	r2, [r7, #8]
2400e7b4:	625a      	str	r2, [r3, #36]	; 0x24
        /* Set the MDMA handle First linked List node*/
        hmdma->FirstLinkedListNodeAddress = pNewNode;
2400e7b6:	68fb      	ldr	r3, [r7, #12]
2400e7b8:	68ba      	ldr	r2, [r7, #8]
2400e7ba:	65da      	str	r2, [r3, #92]	; 0x5c

        /*reset New node link */
        pNewNode->CLAR = 0;
2400e7bc:	68bb      	ldr	r3, [r7, #8]
2400e7be:	2200      	movs	r2, #0
2400e7c0:	615a      	str	r2, [r3, #20]

        /* Update the Handle last node address */
        hmdma->LastLinkedListNodeAddress = pNewNode;
2400e7c2:	68fb      	ldr	r3, [r7, #12]
2400e7c4:	68ba      	ldr	r2, [r7, #8]
2400e7c6:	661a      	str	r2, [r3, #96]	; 0x60

        hmdma->LinkedListNodeCounter = 1;
2400e7c8:	68fb      	ldr	r3, [r7, #12]
2400e7ca:	2201      	movs	r2, #1
2400e7cc:	665a      	str	r2, [r3, #100]	; 0x64
2400e7ce:	e06c      	b.n	2400e8aa <HAL_MDMA_LinkedList_AddNode+0x15e>
      }
      else
      {
        hal_status = HAL_ERROR;
2400e7d0:	2301      	movs	r3, #1
2400e7d2:	74fb      	strb	r3, [r7, #19]
2400e7d4:	e069      	b.n	2400e8aa <HAL_MDMA_LinkedList_AddNode+0x15e>
      }
    }
    else if(hmdma->FirstLinkedListNodeAddress != pNewNode)
2400e7d6:	68fb      	ldr	r3, [r7, #12]
2400e7d8:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
2400e7da:	68ba      	ldr	r2, [r7, #8]
2400e7dc:	429a      	cmp	r2, r3
2400e7de:	d062      	beq.n	2400e8a6 <HAL_MDMA_LinkedList_AddNode+0x15a>
    {
      /* Check if the node to insert already exists*/
      pNode = hmdma->FirstLinkedListNodeAddress;
2400e7e0:	68fb      	ldr	r3, [r7, #12]
2400e7e2:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
2400e7e4:	61fb      	str	r3, [r7, #28]
      while((counter < hmdma->LinkedListNodeCounter) && (hal_status == HAL_OK))
2400e7e6:	e00c      	b.n	2400e802 <HAL_MDMA_LinkedList_AddNode+0xb6>
      {
        if(pNode->CLAR == (uint32_t)pNewNode)
2400e7e8:	69fb      	ldr	r3, [r7, #28]
2400e7ea:	695a      	ldr	r2, [r3, #20]
2400e7ec:	68bb      	ldr	r3, [r7, #8]
2400e7ee:	429a      	cmp	r2, r3
2400e7f0:	d101      	bne.n	2400e7f6 <HAL_MDMA_LinkedList_AddNode+0xaa>
        {
          hal_status = HAL_ERROR; /* error this node already exist in the linked list and it is not first node */
2400e7f2:	2301      	movs	r3, #1
2400e7f4:	74fb      	strb	r3, [r7, #19]
        }
        pNode = (MDMA_LinkNodeTypeDef *)pNode->CLAR;
2400e7f6:	69fb      	ldr	r3, [r7, #28]
2400e7f8:	695b      	ldr	r3, [r3, #20]
2400e7fa:	61fb      	str	r3, [r7, #28]
        counter++;
2400e7fc:	69bb      	ldr	r3, [r7, #24]
2400e7fe:	3301      	adds	r3, #1
2400e800:	61bb      	str	r3, [r7, #24]
      while((counter < hmdma->LinkedListNodeCounter) && (hal_status == HAL_OK))
2400e802:	68fb      	ldr	r3, [r7, #12]
2400e804:	6e5b      	ldr	r3, [r3, #100]	; 0x64
2400e806:	69ba      	ldr	r2, [r7, #24]
2400e808:	429a      	cmp	r2, r3
2400e80a:	d202      	bcs.n	2400e812 <HAL_MDMA_LinkedList_AddNode+0xc6>
2400e80c:	7cfb      	ldrb	r3, [r7, #19]
2400e80e:	2b00      	cmp	r3, #0
2400e810:	d0ea      	beq.n	2400e7e8 <HAL_MDMA_LinkedList_AddNode+0x9c>
      }

      if(hal_status == HAL_OK)
2400e812:	7cfb      	ldrb	r3, [r7, #19]
2400e814:	2b00      	cmp	r3, #0
2400e816:	d148      	bne.n	2400e8aa <HAL_MDMA_LinkedList_AddNode+0x15e>
      {
        /* Check if the previous node is the last one in the current list or zero */
        if((pPrevNode == hmdma->LastLinkedListNodeAddress) || (pPrevNode == NULL))
2400e818:	68fb      	ldr	r3, [r7, #12]
2400e81a:	6e1b      	ldr	r3, [r3, #96]	; 0x60
2400e81c:	687a      	ldr	r2, [r7, #4]
2400e81e:	429a      	cmp	r2, r3
2400e820:	d002      	beq.n	2400e828 <HAL_MDMA_LinkedList_AddNode+0xdc>
2400e822:	687b      	ldr	r3, [r7, #4]
2400e824:	2b00      	cmp	r3, #0
2400e826:	d111      	bne.n	2400e84c <HAL_MDMA_LinkedList_AddNode+0x100>
        {
          /* insert the new node at the end of the list */
          pNewNode->CLAR = hmdma->LastLinkedListNodeAddress->CLAR;
2400e828:	68fb      	ldr	r3, [r7, #12]
2400e82a:	6e1b      	ldr	r3, [r3, #96]	; 0x60
2400e82c:	695a      	ldr	r2, [r3, #20]
2400e82e:	68bb      	ldr	r3, [r7, #8]
2400e830:	615a      	str	r2, [r3, #20]
          hmdma->LastLinkedListNodeAddress->CLAR = (uint32_t)pNewNode;
2400e832:	68fb      	ldr	r3, [r7, #12]
2400e834:	6e1b      	ldr	r3, [r3, #96]	; 0x60
2400e836:	68ba      	ldr	r2, [r7, #8]
2400e838:	615a      	str	r2, [r3, #20]
          /* Update the Handle last node address */
          hmdma->LastLinkedListNodeAddress = pNewNode;
2400e83a:	68fb      	ldr	r3, [r7, #12]
2400e83c:	68ba      	ldr	r2, [r7, #8]
2400e83e:	661a      	str	r2, [r3, #96]	; 0x60
          /* Increment the linked list node counter */
          hmdma->LinkedListNodeCounter++;
2400e840:	68fb      	ldr	r3, [r7, #12]
2400e842:	6e5b      	ldr	r3, [r3, #100]	; 0x64
2400e844:	1c5a      	adds	r2, r3, #1
2400e846:	68fb      	ldr	r3, [r7, #12]
2400e848:	665a      	str	r2, [r3, #100]	; 0x64
2400e84a:	e02e      	b.n	2400e8aa <HAL_MDMA_LinkedList_AddNode+0x15e>
        }
        else
        {
          /*insert the new node after the pPreviousNode node */
          pNode = hmdma->FirstLinkedListNodeAddress;
2400e84c:	68fb      	ldr	r3, [r7, #12]
2400e84e:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
2400e850:	61fb      	str	r3, [r7, #28]
          counter = 0;
2400e852:	2300      	movs	r3, #0
2400e854:	61bb      	str	r3, [r7, #24]
          while((counter < hmdma->LinkedListNodeCounter) && (nodeInserted == 0U))
2400e856:	e018      	b.n	2400e88a <HAL_MDMA_LinkedList_AddNode+0x13e>
          {
            counter++;
2400e858:	69bb      	ldr	r3, [r7, #24]
2400e85a:	3301      	adds	r3, #1
2400e85c:	61bb      	str	r3, [r7, #24]
            if(pNode == pPrevNode)
2400e85e:	69fa      	ldr	r2, [r7, #28]
2400e860:	687b      	ldr	r3, [r7, #4]
2400e862:	429a      	cmp	r2, r3
2400e864:	d10e      	bne.n	2400e884 <HAL_MDMA_LinkedList_AddNode+0x138>
            {
              /*Insert the new node after the previous one */
              pNewNode->CLAR = pNode->CLAR;
2400e866:	69fb      	ldr	r3, [r7, #28]
2400e868:	695a      	ldr	r2, [r3, #20]
2400e86a:	68bb      	ldr	r3, [r7, #8]
2400e86c:	615a      	str	r2, [r3, #20]
              pNode->CLAR = (uint32_t)pNewNode;
2400e86e:	68ba      	ldr	r2, [r7, #8]
2400e870:	69fb      	ldr	r3, [r7, #28]
2400e872:	615a      	str	r2, [r3, #20]
              /* Increment the linked list node counter */
              hmdma->LinkedListNodeCounter++;
2400e874:	68fb      	ldr	r3, [r7, #12]
2400e876:	6e5b      	ldr	r3, [r3, #100]	; 0x64
2400e878:	1c5a      	adds	r2, r3, #1
2400e87a:	68fb      	ldr	r3, [r7, #12]
2400e87c:	665a      	str	r2, [r3, #100]	; 0x64
              nodeInserted = 1;
2400e87e:	2301      	movs	r3, #1
2400e880:	617b      	str	r3, [r7, #20]
2400e882:	e002      	b.n	2400e88a <HAL_MDMA_LinkedList_AddNode+0x13e>
            }
            else
            {
              pNode = (MDMA_LinkNodeTypeDef *)pNode->CLAR;
2400e884:	69fb      	ldr	r3, [r7, #28]
2400e886:	695b      	ldr	r3, [r3, #20]
2400e888:	61fb      	str	r3, [r7, #28]
          while((counter < hmdma->LinkedListNodeCounter) && (nodeInserted == 0U))
2400e88a:	68fb      	ldr	r3, [r7, #12]
2400e88c:	6e5b      	ldr	r3, [r3, #100]	; 0x64
2400e88e:	69ba      	ldr	r2, [r7, #24]
2400e890:	429a      	cmp	r2, r3
2400e892:	d202      	bcs.n	2400e89a <HAL_MDMA_LinkedList_AddNode+0x14e>
2400e894:	697b      	ldr	r3, [r7, #20]
2400e896:	2b00      	cmp	r3, #0
2400e898:	d0de      	beq.n	2400e858 <HAL_MDMA_LinkedList_AddNode+0x10c>
            }
          }

          if(nodeInserted == 0U)
2400e89a:	697b      	ldr	r3, [r7, #20]
2400e89c:	2b00      	cmp	r3, #0
2400e89e:	d104      	bne.n	2400e8aa <HAL_MDMA_LinkedList_AddNode+0x15e>
          {
            hal_status = HAL_ERROR;
2400e8a0:	2301      	movs	r3, #1
2400e8a2:	74fb      	strb	r3, [r7, #19]
2400e8a4:	e001      	b.n	2400e8aa <HAL_MDMA_LinkedList_AddNode+0x15e>
        }
      }
    }
    else
    {
      hal_status = HAL_ERROR;
2400e8a6:	2301      	movs	r3, #1
2400e8a8:	74fb      	strb	r3, [r7, #19]
    }

    /* Process unlocked */
    __HAL_UNLOCK(hmdma);
2400e8aa:	68fb      	ldr	r3, [r7, #12]
2400e8ac:	2200      	movs	r2, #0
2400e8ae:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

    hmdma->State = HAL_MDMA_STATE_READY;
2400e8b2:	68fb      	ldr	r3, [r7, #12]
2400e8b4:	2201      	movs	r2, #1
2400e8b6:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

    return hal_status;
2400e8ba:	7cfb      	ldrb	r3, [r7, #19]
2400e8bc:	e004      	b.n	2400e8c8 <HAL_MDMA_LinkedList_AddNode+0x17c>
  }
  else
  {
    /* Process unlocked */
    __HAL_UNLOCK(hmdma);
2400e8be:	68fb      	ldr	r3, [r7, #12]
2400e8c0:	2200      	movs	r2, #0
2400e8c2:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

    /* Return error status */
    return HAL_BUSY;
2400e8c6:	2302      	movs	r3, #2
  }
}
2400e8c8:	4618      	mov	r0, r3
2400e8ca:	3724      	adds	r7, #36	; 0x24
2400e8cc:	46bd      	mov	sp, r7
2400e8ce:	f85d 7b04 	ldr.w	r7, [sp], #4
2400e8d2:	4770      	bx	lr

2400e8d4 <HAL_MDMA_LinkedList_RemoveNode>:
  *                 to be removed from the list.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_MDMA_LinkedList_RemoveNode(MDMA_HandleTypeDef *hmdma, MDMA_LinkNodeTypeDef *pNode)
{
2400e8d4:	b480      	push	{r7}
2400e8d6:	b087      	sub	sp, #28
2400e8d8:	af00      	add	r7, sp, #0
2400e8da:	6078      	str	r0, [r7, #4]
2400e8dc:	6039      	str	r1, [r7, #0]
  MDMA_LinkNodeTypeDef *ptmpNode;
  uint32_t counter = 0, nodeDeleted = 0;
2400e8de:	2300      	movs	r3, #0
2400e8e0:	613b      	str	r3, [r7, #16]
2400e8e2:	2300      	movs	r3, #0
2400e8e4:	60fb      	str	r3, [r7, #12]
  HAL_StatusTypeDef hal_status = HAL_OK;
2400e8e6:	2300      	movs	r3, #0
2400e8e8:	72fb      	strb	r3, [r7, #11]

  /* Check the MDMA peripheral handle */
  if((hmdma == NULL) || (pNode == NULL))
2400e8ea:	687b      	ldr	r3, [r7, #4]
2400e8ec:	2b00      	cmp	r3, #0
2400e8ee:	d002      	beq.n	2400e8f6 <HAL_MDMA_LinkedList_RemoveNode+0x22>
2400e8f0:	683b      	ldr	r3, [r7, #0]
2400e8f2:	2b00      	cmp	r3, #0
2400e8f4:	d101      	bne.n	2400e8fa <HAL_MDMA_LinkedList_RemoveNode+0x26>
  {
    return HAL_ERROR;
2400e8f6:	2301      	movs	r3, #1
2400e8f8:	e099      	b.n	2400ea2e <HAL_MDMA_LinkedList_RemoveNode+0x15a>
  }

  /* Process locked */
  __HAL_LOCK(hmdma);
2400e8fa:	687b      	ldr	r3, [r7, #4]
2400e8fc:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
2400e900:	2b01      	cmp	r3, #1
2400e902:	d101      	bne.n	2400e908 <HAL_MDMA_LinkedList_RemoveNode+0x34>
2400e904:	2302      	movs	r3, #2
2400e906:	e092      	b.n	2400ea2e <HAL_MDMA_LinkedList_RemoveNode+0x15a>
2400e908:	687b      	ldr	r3, [r7, #4]
2400e90a:	2201      	movs	r2, #1
2400e90c:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  if(HAL_MDMA_STATE_READY == hmdma->State)
2400e910:	687b      	ldr	r3, [r7, #4]
2400e912:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
2400e916:	b2db      	uxtb	r3, r3
2400e918:	2b01      	cmp	r3, #1
2400e91a:	f040 8083 	bne.w	2400ea24 <HAL_MDMA_LinkedList_RemoveNode+0x150>
  {
    /* Change MDMA peripheral state */
    hmdma->State = HAL_MDMA_STATE_BUSY;
2400e91e:	687b      	ldr	r3, [r7, #4]
2400e920:	2202      	movs	r2, #2
2400e922:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

    /* If first and last node are null (no nodes in the list) : return error*/
    if(((uint32_t)hmdma->FirstLinkedListNodeAddress == 0U) || ((uint32_t)hmdma->LastLinkedListNodeAddress == 0U) || (hmdma->LinkedListNodeCounter == 0U))
2400e926:	687b      	ldr	r3, [r7, #4]
2400e928:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
2400e92a:	2b00      	cmp	r3, #0
2400e92c:	d007      	beq.n	2400e93e <HAL_MDMA_LinkedList_RemoveNode+0x6a>
2400e92e:	687b      	ldr	r3, [r7, #4]
2400e930:	6e1b      	ldr	r3, [r3, #96]	; 0x60
2400e932:	2b00      	cmp	r3, #0
2400e934:	d003      	beq.n	2400e93e <HAL_MDMA_LinkedList_RemoveNode+0x6a>
2400e936:	687b      	ldr	r3, [r7, #4]
2400e938:	6e5b      	ldr	r3, [r3, #100]	; 0x64
2400e93a:	2b00      	cmp	r3, #0
2400e93c:	d102      	bne.n	2400e944 <HAL_MDMA_LinkedList_RemoveNode+0x70>
    {
      hal_status = HAL_ERROR;
2400e93e:	2301      	movs	r3, #1
2400e940:	72fb      	strb	r3, [r7, #11]
2400e942:	e065      	b.n	2400ea10 <HAL_MDMA_LinkedList_RemoveNode+0x13c>
    }
    else if(hmdma->FirstLinkedListNodeAddress == pNode) /* Deleting first node */
2400e944:	687b      	ldr	r3, [r7, #4]
2400e946:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
2400e948:	683a      	ldr	r2, [r7, #0]
2400e94a:	429a      	cmp	r2, r3
2400e94c:	d130      	bne.n	2400e9b0 <HAL_MDMA_LinkedList_RemoveNode+0xdc>
    {
      /* Delete 1st node */
      if(hmdma->LastLinkedListNodeAddress == pNode)
2400e94e:	687b      	ldr	r3, [r7, #4]
2400e950:	6e1b      	ldr	r3, [r3, #96]	; 0x60
2400e952:	683a      	ldr	r2, [r7, #0]
2400e954:	429a      	cmp	r2, r3
2400e956:	d10d      	bne.n	2400e974 <HAL_MDMA_LinkedList_RemoveNode+0xa0>
      {
        /*if the last node is at the same time the first one (1 single node after the init node 0)
        then update the last node too */

        hmdma->FirstLinkedListNodeAddress = 0;
2400e958:	687b      	ldr	r3, [r7, #4]
2400e95a:	2200      	movs	r2, #0
2400e95c:	65da      	str	r2, [r3, #92]	; 0x5c
        hmdma->LastLinkedListNodeAddress  = 0;
2400e95e:	687b      	ldr	r3, [r7, #4]
2400e960:	2200      	movs	r2, #0
2400e962:	661a      	str	r2, [r3, #96]	; 0x60
        hmdma->LinkedListNodeCounter = 0;
2400e964:	687b      	ldr	r3, [r7, #4]
2400e966:	2200      	movs	r2, #0
2400e968:	665a      	str	r2, [r3, #100]	; 0x64

        hmdma->Instance->CLAR = 0;
2400e96a:	687b      	ldr	r3, [r7, #4]
2400e96c:	681b      	ldr	r3, [r3, #0]
2400e96e:	2200      	movs	r2, #0
2400e970:	625a      	str	r2, [r3, #36]	; 0x24
2400e972:	e04d      	b.n	2400ea10 <HAL_MDMA_LinkedList_RemoveNode+0x13c>
      }
      else
      {
        if((uint32_t)hmdma->FirstLinkedListNodeAddress == hmdma->LastLinkedListNodeAddress->CLAR)
2400e974:	687b      	ldr	r3, [r7, #4]
2400e976:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
2400e978:	461a      	mov	r2, r3
2400e97a:	687b      	ldr	r3, [r7, #4]
2400e97c:	6e1b      	ldr	r3, [r3, #96]	; 0x60
2400e97e:	695b      	ldr	r3, [r3, #20]
2400e980:	429a      	cmp	r2, r3
2400e982:	d104      	bne.n	2400e98e <HAL_MDMA_LinkedList_RemoveNode+0xba>
        {
          /* if last node is looping to first (circular list) one update the last node connection */
          hmdma->LastLinkedListNodeAddress->CLAR = pNode->CLAR;
2400e984:	687b      	ldr	r3, [r7, #4]
2400e986:	6e1b      	ldr	r3, [r3, #96]	; 0x60
2400e988:	683a      	ldr	r2, [r7, #0]
2400e98a:	6952      	ldr	r2, [r2, #20]
2400e98c:	615a      	str	r2, [r3, #20]
        }

        /* if deleting the first node after the initialization
        connect the next node to the node 0 by updating
        the MDMA channel CLAR register to this node address */
        hmdma->Instance->CLAR = pNode->CLAR;
2400e98e:	687b      	ldr	r3, [r7, #4]
2400e990:	681b      	ldr	r3, [r3, #0]
2400e992:	683a      	ldr	r2, [r7, #0]
2400e994:	6952      	ldr	r2, [r2, #20]
2400e996:	625a      	str	r2, [r3, #36]	; 0x24
        hmdma->FirstLinkedListNodeAddress = (MDMA_LinkNodeTypeDef *)hmdma->Instance->CLAR;
2400e998:	687b      	ldr	r3, [r7, #4]
2400e99a:	681b      	ldr	r3, [r3, #0]
2400e99c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2400e99e:	461a      	mov	r2, r3
2400e9a0:	687b      	ldr	r3, [r7, #4]
2400e9a2:	65da      	str	r2, [r3, #92]	; 0x5c
        /* Update the Handle node counter */
        hmdma->LinkedListNodeCounter--;
2400e9a4:	687b      	ldr	r3, [r7, #4]
2400e9a6:	6e5b      	ldr	r3, [r3, #100]	; 0x64
2400e9a8:	1e5a      	subs	r2, r3, #1
2400e9aa:	687b      	ldr	r3, [r7, #4]
2400e9ac:	665a      	str	r2, [r3, #100]	; 0x64
2400e9ae:	e02f      	b.n	2400ea10 <HAL_MDMA_LinkedList_RemoveNode+0x13c>
      }
    }
    else /* Deleting any other node */
    {
      /*Deleted node is not the first one : find it  */
      ptmpNode = hmdma->FirstLinkedListNodeAddress;
2400e9b0:	687b      	ldr	r3, [r7, #4]
2400e9b2:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
2400e9b4:	617b      	str	r3, [r7, #20]
      while((counter < hmdma->LinkedListNodeCounter) && (nodeDeleted == 0U))
2400e9b6:	e01e      	b.n	2400e9f6 <HAL_MDMA_LinkedList_RemoveNode+0x122>
      {
        counter++;
2400e9b8:	693b      	ldr	r3, [r7, #16]
2400e9ba:	3301      	adds	r3, #1
2400e9bc:	613b      	str	r3, [r7, #16]
        if(ptmpNode->CLAR == ((uint32_t)pNode))
2400e9be:	697b      	ldr	r3, [r7, #20]
2400e9c0:	695a      	ldr	r2, [r3, #20]
2400e9c2:	683b      	ldr	r3, [r7, #0]
2400e9c4:	429a      	cmp	r2, r3
2400e9c6:	d113      	bne.n	2400e9f0 <HAL_MDMA_LinkedList_RemoveNode+0x11c>
        {
          /* if deleting the last node */
          if(pNode == hmdma->LastLinkedListNodeAddress)
2400e9c8:	687b      	ldr	r3, [r7, #4]
2400e9ca:	6e1b      	ldr	r3, [r3, #96]	; 0x60
2400e9cc:	683a      	ldr	r2, [r7, #0]
2400e9ce:	429a      	cmp	r2, r3
2400e9d0:	d102      	bne.n	2400e9d8 <HAL_MDMA_LinkedList_RemoveNode+0x104>
          {
            /*Update the linked list last node address in the handle*/
            hmdma->LastLinkedListNodeAddress = ptmpNode;
2400e9d2:	687b      	ldr	r3, [r7, #4]
2400e9d4:	697a      	ldr	r2, [r7, #20]
2400e9d6:	661a      	str	r2, [r3, #96]	; 0x60
          }
          /* update the next node link after deleting pMDMA_LinkedListNode */
          ptmpNode->CLAR = pNode->CLAR;
2400e9d8:	683b      	ldr	r3, [r7, #0]
2400e9da:	695a      	ldr	r2, [r3, #20]
2400e9dc:	697b      	ldr	r3, [r7, #20]
2400e9de:	615a      	str	r2, [r3, #20]
          nodeDeleted = 1;
2400e9e0:	2301      	movs	r3, #1
2400e9e2:	60fb      	str	r3, [r7, #12]
          /* Update the Handle node counter */
          hmdma->LinkedListNodeCounter--;
2400e9e4:	687b      	ldr	r3, [r7, #4]
2400e9e6:	6e5b      	ldr	r3, [r3, #100]	; 0x64
2400e9e8:	1e5a      	subs	r2, r3, #1
2400e9ea:	687b      	ldr	r3, [r7, #4]
2400e9ec:	665a      	str	r2, [r3, #100]	; 0x64
2400e9ee:	e002      	b.n	2400e9f6 <HAL_MDMA_LinkedList_RemoveNode+0x122>
        }
        else
        {
          ptmpNode = (MDMA_LinkNodeTypeDef *)ptmpNode->CLAR;
2400e9f0:	697b      	ldr	r3, [r7, #20]
2400e9f2:	695b      	ldr	r3, [r3, #20]
2400e9f4:	617b      	str	r3, [r7, #20]
      while((counter < hmdma->LinkedListNodeCounter) && (nodeDeleted == 0U))
2400e9f6:	687b      	ldr	r3, [r7, #4]
2400e9f8:	6e5b      	ldr	r3, [r3, #100]	; 0x64
2400e9fa:	693a      	ldr	r2, [r7, #16]
2400e9fc:	429a      	cmp	r2, r3
2400e9fe:	d202      	bcs.n	2400ea06 <HAL_MDMA_LinkedList_RemoveNode+0x132>
2400ea00:	68fb      	ldr	r3, [r7, #12]
2400ea02:	2b00      	cmp	r3, #0
2400ea04:	d0d8      	beq.n	2400e9b8 <HAL_MDMA_LinkedList_RemoveNode+0xe4>
        }
      }

      if(nodeDeleted == 0U)
2400ea06:	68fb      	ldr	r3, [r7, #12]
2400ea08:	2b00      	cmp	r3, #0
2400ea0a:	d101      	bne.n	2400ea10 <HAL_MDMA_LinkedList_RemoveNode+0x13c>
      {
        /* last node reashed without finding the node to delete : return error */
        hal_status = HAL_ERROR;
2400ea0c:	2301      	movs	r3, #1
2400ea0e:	72fb      	strb	r3, [r7, #11]
      }
    }

    /* Process unlocked */
    __HAL_UNLOCK(hmdma);
2400ea10:	687b      	ldr	r3, [r7, #4]
2400ea12:	2200      	movs	r2, #0
2400ea14:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

    hmdma->State = HAL_MDMA_STATE_READY;
2400ea18:	687b      	ldr	r3, [r7, #4]
2400ea1a:	2201      	movs	r2, #1
2400ea1c:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

    return hal_status;
2400ea20:	7afb      	ldrb	r3, [r7, #11]
2400ea22:	e004      	b.n	2400ea2e <HAL_MDMA_LinkedList_RemoveNode+0x15a>
  }
  else
  {
    /* Process unlocked */
    __HAL_UNLOCK(hmdma);
2400ea24:	687b      	ldr	r3, [r7, #4]
2400ea26:	2200      	movs	r2, #0
2400ea28:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

    /* Return error status */
    return HAL_BUSY;
2400ea2c:	2302      	movs	r3, #2
  }
}
2400ea2e:	4618      	mov	r0, r3
2400ea30:	371c      	adds	r7, #28
2400ea32:	46bd      	mov	sp, r7
2400ea34:	f85d 7b04 	ldr.w	r7, [sp], #4
2400ea38:	4770      	bx	lr

2400ea3a <HAL_MDMA_LinkedList_EnableCircularMode>:
  * @param  hmdma : Pointer to a MDMA_HandleTypeDef structure that contains
  *                 the configuration information for the specified MDMA Channel.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_MDMA_LinkedList_EnableCircularMode(MDMA_HandleTypeDef *hmdma)
{
2400ea3a:	b480      	push	{r7}
2400ea3c:	b085      	sub	sp, #20
2400ea3e:	af00      	add	r7, sp, #0
2400ea40:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef hal_status = HAL_OK;
2400ea42:	2300      	movs	r3, #0
2400ea44:	73fb      	strb	r3, [r7, #15]

  /* Check the MDMA peripheral handle */
  if(hmdma == NULL)
2400ea46:	687b      	ldr	r3, [r7, #4]
2400ea48:	2b00      	cmp	r3, #0
2400ea4a:	d101      	bne.n	2400ea50 <HAL_MDMA_LinkedList_EnableCircularMode+0x16>
  {
    return HAL_ERROR;
2400ea4c:	2301      	movs	r3, #1
2400ea4e:	e031      	b.n	2400eab4 <HAL_MDMA_LinkedList_EnableCircularMode+0x7a>
  }

  /* Process locked */
  __HAL_LOCK(hmdma);
2400ea50:	687b      	ldr	r3, [r7, #4]
2400ea52:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
2400ea56:	2b01      	cmp	r3, #1
2400ea58:	d101      	bne.n	2400ea5e <HAL_MDMA_LinkedList_EnableCircularMode+0x24>
2400ea5a:	2302      	movs	r3, #2
2400ea5c:	e02a      	b.n	2400eab4 <HAL_MDMA_LinkedList_EnableCircularMode+0x7a>
2400ea5e:	687b      	ldr	r3, [r7, #4]
2400ea60:	2201      	movs	r2, #1
2400ea62:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  if(HAL_MDMA_STATE_READY == hmdma->State)
2400ea66:	687b      	ldr	r3, [r7, #4]
2400ea68:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
2400ea6c:	b2db      	uxtb	r3, r3
2400ea6e:	2b01      	cmp	r3, #1
2400ea70:	d117      	bne.n	2400eaa2 <HAL_MDMA_LinkedList_EnableCircularMode+0x68>
  {
    /* Change MDMA peripheral state */
    hmdma->State = HAL_MDMA_STATE_BUSY;
2400ea72:	687b      	ldr	r3, [r7, #4]
2400ea74:	2202      	movs	r2, #2
2400ea76:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

    /* If first and last node are null (no nodes in the list) : return error*/
    if(((uint32_t)hmdma->FirstLinkedListNodeAddress == 0U) || ((uint32_t)hmdma->LastLinkedListNodeAddress == 0U) || (hmdma->LinkedListNodeCounter == 0U))
2400ea7a:	687b      	ldr	r3, [r7, #4]
2400ea7c:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
2400ea7e:	2b00      	cmp	r3, #0
2400ea80:	d007      	beq.n	2400ea92 <HAL_MDMA_LinkedList_EnableCircularMode+0x58>
2400ea82:	687b      	ldr	r3, [r7, #4]
2400ea84:	6e1b      	ldr	r3, [r3, #96]	; 0x60
2400ea86:	2b00      	cmp	r3, #0
2400ea88:	d003      	beq.n	2400ea92 <HAL_MDMA_LinkedList_EnableCircularMode+0x58>
2400ea8a:	687b      	ldr	r3, [r7, #4]
2400ea8c:	6e5b      	ldr	r3, [r3, #100]	; 0x64
2400ea8e:	2b00      	cmp	r3, #0
2400ea90:	d102      	bne.n	2400ea98 <HAL_MDMA_LinkedList_EnableCircularMode+0x5e>
    {
      hal_status = HAL_ERROR;
2400ea92:	2301      	movs	r3, #1
2400ea94:	73fb      	strb	r3, [r7, #15]
2400ea96:	e004      	b.n	2400eaa2 <HAL_MDMA_LinkedList_EnableCircularMode+0x68>
    }
    else
    {
      /* to enable circular mode Last Node should be connected to first node */
      hmdma->LastLinkedListNodeAddress->CLAR = (uint32_t)hmdma->FirstLinkedListNodeAddress;
2400ea98:	687b      	ldr	r3, [r7, #4]
2400ea9a:	6dda      	ldr	r2, [r3, #92]	; 0x5c
2400ea9c:	687b      	ldr	r3, [r7, #4]
2400ea9e:	6e1b      	ldr	r3, [r3, #96]	; 0x60
2400eaa0:	615a      	str	r2, [r3, #20]
    }

  }
  /* Process unlocked */
  __HAL_UNLOCK(hmdma);
2400eaa2:	687b      	ldr	r3, [r7, #4]
2400eaa4:	2200      	movs	r2, #0
2400eaa6:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  hmdma->State = HAL_MDMA_STATE_READY;
2400eaaa:	687b      	ldr	r3, [r7, #4]
2400eaac:	2201      	movs	r2, #1
2400eaae:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  return hal_status;
2400eab2:	7bfb      	ldrb	r3, [r7, #15]
}
2400eab4:	4618      	mov	r0, r3
2400eab6:	3714      	adds	r7, #20
2400eab8:	46bd      	mov	sp, r7
2400eaba:	f85d 7b04 	ldr.w	r7, [sp], #4
2400eabe:	4770      	bx	lr

2400eac0 <HAL_MDMA_LinkedList_DisableCircularMode>:
  * @param  hmdma : Pointer to a MDMA_HandleTypeDef structure that contains
  *                 the configuration information for the specified MDMA Channel.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_MDMA_LinkedList_DisableCircularMode(MDMA_HandleTypeDef *hmdma)
{
2400eac0:	b480      	push	{r7}
2400eac2:	b085      	sub	sp, #20
2400eac4:	af00      	add	r7, sp, #0
2400eac6:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef hal_status = HAL_OK;
2400eac8:	2300      	movs	r3, #0
2400eaca:	73fb      	strb	r3, [r7, #15]

  /* Check the MDMA peripheral handle */
  if(hmdma == NULL)
2400eacc:	687b      	ldr	r3, [r7, #4]
2400eace:	2b00      	cmp	r3, #0
2400ead0:	d101      	bne.n	2400ead6 <HAL_MDMA_LinkedList_DisableCircularMode+0x16>
  {
    return HAL_ERROR;
2400ead2:	2301      	movs	r3, #1
2400ead4:	e030      	b.n	2400eb38 <HAL_MDMA_LinkedList_DisableCircularMode+0x78>
  }

  /* Process locked */
  __HAL_LOCK(hmdma);
2400ead6:	687b      	ldr	r3, [r7, #4]
2400ead8:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
2400eadc:	2b01      	cmp	r3, #1
2400eade:	d101      	bne.n	2400eae4 <HAL_MDMA_LinkedList_DisableCircularMode+0x24>
2400eae0:	2302      	movs	r3, #2
2400eae2:	e029      	b.n	2400eb38 <HAL_MDMA_LinkedList_DisableCircularMode+0x78>
2400eae4:	687b      	ldr	r3, [r7, #4]
2400eae6:	2201      	movs	r2, #1
2400eae8:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  if(HAL_MDMA_STATE_READY == hmdma->State)
2400eaec:	687b      	ldr	r3, [r7, #4]
2400eaee:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
2400eaf2:	b2db      	uxtb	r3, r3
2400eaf4:	2b01      	cmp	r3, #1
2400eaf6:	d116      	bne.n	2400eb26 <HAL_MDMA_LinkedList_DisableCircularMode+0x66>
  {
    /* Change MDMA peripheral state */
    hmdma->State = HAL_MDMA_STATE_BUSY;
2400eaf8:	687b      	ldr	r3, [r7, #4]
2400eafa:	2202      	movs	r2, #2
2400eafc:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

    /* If first and last node are null (no nodes in the list) : return error*/
    if(((uint32_t)hmdma->FirstLinkedListNodeAddress == 0U) || ((uint32_t)hmdma->LastLinkedListNodeAddress == 0U) || (hmdma->LinkedListNodeCounter == 0U))
2400eb00:	687b      	ldr	r3, [r7, #4]
2400eb02:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
2400eb04:	2b00      	cmp	r3, #0
2400eb06:	d007      	beq.n	2400eb18 <HAL_MDMA_LinkedList_DisableCircularMode+0x58>
2400eb08:	687b      	ldr	r3, [r7, #4]
2400eb0a:	6e1b      	ldr	r3, [r3, #96]	; 0x60
2400eb0c:	2b00      	cmp	r3, #0
2400eb0e:	d003      	beq.n	2400eb18 <HAL_MDMA_LinkedList_DisableCircularMode+0x58>
2400eb10:	687b      	ldr	r3, [r7, #4]
2400eb12:	6e5b      	ldr	r3, [r3, #100]	; 0x64
2400eb14:	2b00      	cmp	r3, #0
2400eb16:	d102      	bne.n	2400eb1e <HAL_MDMA_LinkedList_DisableCircularMode+0x5e>
    {
      hal_status = HAL_ERROR;
2400eb18:	2301      	movs	r3, #1
2400eb1a:	73fb      	strb	r3, [r7, #15]
2400eb1c:	e003      	b.n	2400eb26 <HAL_MDMA_LinkedList_DisableCircularMode+0x66>
    }
    else
    {
      /* to disable circular mode Last Node should be connected to NULL */
      hmdma->LastLinkedListNodeAddress->CLAR = 0;
2400eb1e:	687b      	ldr	r3, [r7, #4]
2400eb20:	6e1b      	ldr	r3, [r3, #96]	; 0x60
2400eb22:	2200      	movs	r2, #0
2400eb24:	615a      	str	r2, [r3, #20]
    }

  }
  /* Process unlocked */
  __HAL_UNLOCK(hmdma);
2400eb26:	687b      	ldr	r3, [r7, #4]
2400eb28:	2200      	movs	r2, #0
2400eb2a:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  hmdma->State = HAL_MDMA_STATE_READY;
2400eb2e:	687b      	ldr	r3, [r7, #4]
2400eb30:	2201      	movs	r2, #1
2400eb32:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  return hal_status;
2400eb36:	7bfb      	ldrb	r3, [r7, #15]
}
2400eb38:	4618      	mov	r0, r3
2400eb3a:	3714      	adds	r7, #20
2400eb3c:	46bd      	mov	sp, r7
2400eb3e:	f85d 7b04 	ldr.w	r7, [sp], #4
2400eb42:	4770      	bx	lr

2400eb44 <HAL_MDMA_Start>:
  * @param  BlockDataLength : The length of a block transfer in bytes
  * @param  BlockCount      : The number of a blocks to be transfer
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_MDMA_Start(MDMA_HandleTypeDef *hmdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t BlockDataLength, uint32_t BlockCount)
{
2400eb44:	b580      	push	{r7, lr}
2400eb46:	b086      	sub	sp, #24
2400eb48:	af02      	add	r7, sp, #8
2400eb4a:	60f8      	str	r0, [r7, #12]
2400eb4c:	60b9      	str	r1, [r7, #8]
2400eb4e:	607a      	str	r2, [r7, #4]
2400eb50:	603b      	str	r3, [r7, #0]
  /* Check the parameters */
  assert_param(IS_MDMA_TRANSFER_LENGTH(BlockDataLength));
  assert_param(IS_MDMA_BLOCK_COUNT(BlockCount));

  /* Check the MDMA peripheral handle */
  if(hmdma == NULL)
2400eb52:	68fb      	ldr	r3, [r7, #12]
2400eb54:	2b00      	cmp	r3, #0
2400eb56:	d101      	bne.n	2400eb5c <HAL_MDMA_Start+0x18>
  {
    return HAL_ERROR;
2400eb58:	2301      	movs	r3, #1
2400eb5a:	e044      	b.n	2400ebe6 <HAL_MDMA_Start+0xa2>
  }

  /* Process locked */
  __HAL_LOCK(hmdma);
2400eb5c:	68fb      	ldr	r3, [r7, #12]
2400eb5e:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
2400eb62:	2b01      	cmp	r3, #1
2400eb64:	d101      	bne.n	2400eb6a <HAL_MDMA_Start+0x26>
2400eb66:	2302      	movs	r3, #2
2400eb68:	e03d      	b.n	2400ebe6 <HAL_MDMA_Start+0xa2>
2400eb6a:	68fb      	ldr	r3, [r7, #12]
2400eb6c:	2201      	movs	r2, #1
2400eb6e:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  if(HAL_MDMA_STATE_READY == hmdma->State)
2400eb72:	68fb      	ldr	r3, [r7, #12]
2400eb74:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
2400eb78:	b2db      	uxtb	r3, r3
2400eb7a:	2b01      	cmp	r3, #1
2400eb7c:	d12c      	bne.n	2400ebd8 <HAL_MDMA_Start+0x94>
  {
    /* Change MDMA peripheral state */
    hmdma->State = HAL_MDMA_STATE_BUSY;
2400eb7e:	68fb      	ldr	r3, [r7, #12]
2400eb80:	2202      	movs	r2, #2
2400eb82:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

    /* Initialize the error code */
    hmdma->ErrorCode = HAL_MDMA_ERROR_NONE;
2400eb86:	68fb      	ldr	r3, [r7, #12]
2400eb88:	2200      	movs	r2, #0
2400eb8a:	669a      	str	r2, [r3, #104]	; 0x68

    /* Disable the peripheral */
    __HAL_MDMA_DISABLE(hmdma);
2400eb8c:	68fb      	ldr	r3, [r7, #12]
2400eb8e:	681b      	ldr	r3, [r3, #0]
2400eb90:	68da      	ldr	r2, [r3, #12]
2400eb92:	68fb      	ldr	r3, [r7, #12]
2400eb94:	681b      	ldr	r3, [r3, #0]
2400eb96:	f022 0201 	bic.w	r2, r2, #1
2400eb9a:	60da      	str	r2, [r3, #12]

    /* Configure the source, destination address and the data length */
    MDMA_SetConfig(hmdma, SrcAddress, DstAddress, BlockDataLength, BlockCount);
2400eb9c:	69bb      	ldr	r3, [r7, #24]
2400eb9e:	9300      	str	r3, [sp, #0]
2400eba0:	683b      	ldr	r3, [r7, #0]
2400eba2:	687a      	ldr	r2, [r7, #4]
2400eba4:	68b9      	ldr	r1, [r7, #8]
2400eba6:	68f8      	ldr	r0, [r7, #12]
2400eba8:	f000 fb98 	bl	2400f2dc <MDMA_SetConfig>

    /* Enable the Peripheral */
    __HAL_MDMA_ENABLE(hmdma);
2400ebac:	68fb      	ldr	r3, [r7, #12]
2400ebae:	681b      	ldr	r3, [r3, #0]
2400ebb0:	68da      	ldr	r2, [r3, #12]
2400ebb2:	68fb      	ldr	r3, [r7, #12]
2400ebb4:	681b      	ldr	r3, [r3, #0]
2400ebb6:	f042 0201 	orr.w	r2, r2, #1
2400ebba:	60da      	str	r2, [r3, #12]

    if(hmdma->Init.Request == MDMA_REQUEST_SW)
2400ebbc:	68fb      	ldr	r3, [r7, #12]
2400ebbe:	685b      	ldr	r3, [r3, #4]
2400ebc0:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
2400ebc4:	d10e      	bne.n	2400ebe4 <HAL_MDMA_Start+0xa0>
    {
      /* activate If SW request mode*/
      hmdma->Instance->CCR |=  MDMA_CCR_SWRQ;
2400ebc6:	68fb      	ldr	r3, [r7, #12]
2400ebc8:	681b      	ldr	r3, [r3, #0]
2400ebca:	68da      	ldr	r2, [r3, #12]
2400ebcc:	68fb      	ldr	r3, [r7, #12]
2400ebce:	681b      	ldr	r3, [r3, #0]
2400ebd0:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
2400ebd4:	60da      	str	r2, [r3, #12]
2400ebd6:	e005      	b.n	2400ebe4 <HAL_MDMA_Start+0xa0>
    }
  }
  else
  {
    /* Process unlocked */
    __HAL_UNLOCK(hmdma);
2400ebd8:	68fb      	ldr	r3, [r7, #12]
2400ebda:	2200      	movs	r2, #0
2400ebdc:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

    /* Return error status */
    return HAL_BUSY;
2400ebe0:	2302      	movs	r3, #2
2400ebe2:	e000      	b.n	2400ebe6 <HAL_MDMA_Start+0xa2>
  }

  return HAL_OK;
2400ebe4:	2300      	movs	r3, #0
}
2400ebe6:	4618      	mov	r0, r3
2400ebe8:	3710      	adds	r7, #16
2400ebea:	46bd      	mov	sp, r7
2400ebec:	bd80      	pop	{r7, pc}

2400ebee <HAL_MDMA_Start_IT>:
  * @param  BlockDataLength : The length of a block transfer in bytes
  * @param  BlockCount      : The number of a blocks to be transfer
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_MDMA_Start_IT(MDMA_HandleTypeDef *hmdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t BlockDataLength, uint32_t BlockCount)
{
2400ebee:	b580      	push	{r7, lr}
2400ebf0:	b086      	sub	sp, #24
2400ebf2:	af02      	add	r7, sp, #8
2400ebf4:	60f8      	str	r0, [r7, #12]
2400ebf6:	60b9      	str	r1, [r7, #8]
2400ebf8:	607a      	str	r2, [r7, #4]
2400ebfa:	603b      	str	r3, [r7, #0]
  /* Check the parameters */
  assert_param(IS_MDMA_TRANSFER_LENGTH(BlockDataLength));
  assert_param(IS_MDMA_BLOCK_COUNT(BlockCount));

  /* Check the MDMA peripheral handle */
  if(hmdma == NULL)
2400ebfc:	68fb      	ldr	r3, [r7, #12]
2400ebfe:	2b00      	cmp	r3, #0
2400ec00:	d101      	bne.n	2400ec06 <HAL_MDMA_Start_IT+0x18>
  {
    return HAL_ERROR;
2400ec02:	2301      	movs	r3, #1
2400ec04:	e070      	b.n	2400ece8 <HAL_MDMA_Start_IT+0xfa>
  }

  /* Process locked */
  __HAL_LOCK(hmdma);
2400ec06:	68fb      	ldr	r3, [r7, #12]
2400ec08:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
2400ec0c:	2b01      	cmp	r3, #1
2400ec0e:	d101      	bne.n	2400ec14 <HAL_MDMA_Start_IT+0x26>
2400ec10:	2302      	movs	r3, #2
2400ec12:	e069      	b.n	2400ece8 <HAL_MDMA_Start_IT+0xfa>
2400ec14:	68fb      	ldr	r3, [r7, #12]
2400ec16:	2201      	movs	r2, #1
2400ec18:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  if(HAL_MDMA_STATE_READY == hmdma->State)
2400ec1c:	68fb      	ldr	r3, [r7, #12]
2400ec1e:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
2400ec22:	b2db      	uxtb	r3, r3
2400ec24:	2b01      	cmp	r3, #1
2400ec26:	d158      	bne.n	2400ecda <HAL_MDMA_Start_IT+0xec>
  {
    /* Change MDMA peripheral state */
    hmdma->State = HAL_MDMA_STATE_BUSY;
2400ec28:	68fb      	ldr	r3, [r7, #12]
2400ec2a:	2202      	movs	r2, #2
2400ec2c:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

    /* Initialize the error code */
    hmdma->ErrorCode = HAL_MDMA_ERROR_NONE;
2400ec30:	68fb      	ldr	r3, [r7, #12]
2400ec32:	2200      	movs	r2, #0
2400ec34:	669a      	str	r2, [r3, #104]	; 0x68

    /* Disable the peripheral */
    __HAL_MDMA_DISABLE(hmdma);
2400ec36:	68fb      	ldr	r3, [r7, #12]
2400ec38:	681b      	ldr	r3, [r3, #0]
2400ec3a:	68da      	ldr	r2, [r3, #12]
2400ec3c:	68fb      	ldr	r3, [r7, #12]
2400ec3e:	681b      	ldr	r3, [r3, #0]
2400ec40:	f022 0201 	bic.w	r2, r2, #1
2400ec44:	60da      	str	r2, [r3, #12]

    /* Configure the source, destination address and the data length */
    MDMA_SetConfig(hmdma, SrcAddress, DstAddress, BlockDataLength, BlockCount);
2400ec46:	69bb      	ldr	r3, [r7, #24]
2400ec48:	9300      	str	r3, [sp, #0]
2400ec4a:	683b      	ldr	r3, [r7, #0]
2400ec4c:	687a      	ldr	r2, [r7, #4]
2400ec4e:	68b9      	ldr	r1, [r7, #8]
2400ec50:	68f8      	ldr	r0, [r7, #12]
2400ec52:	f000 fb43 	bl	2400f2dc <MDMA_SetConfig>

    /* Enable Common interrupts i.e Transfer Error IT and Channel Transfer Complete IT*/
    __HAL_MDMA_ENABLE_IT(hmdma, (MDMA_IT_TE | MDMA_IT_CTC));
2400ec56:	68fb      	ldr	r3, [r7, #12]
2400ec58:	681b      	ldr	r3, [r3, #0]
2400ec5a:	68da      	ldr	r2, [r3, #12]
2400ec5c:	68fb      	ldr	r3, [r7, #12]
2400ec5e:	681b      	ldr	r3, [r3, #0]
2400ec60:	f042 0206 	orr.w	r2, r2, #6
2400ec64:	60da      	str	r2, [r3, #12]

    if(hmdma->XferBlockCpltCallback != NULL)
2400ec66:	68fb      	ldr	r3, [r7, #12]
2400ec68:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
2400ec6a:	2b00      	cmp	r3, #0
2400ec6c:	d007      	beq.n	2400ec7e <HAL_MDMA_Start_IT+0x90>
    {
      /* if Block transfer complete Callback is set enable the corresponding IT*/
      __HAL_MDMA_ENABLE_IT(hmdma, MDMA_IT_BT);
2400ec6e:	68fb      	ldr	r3, [r7, #12]
2400ec70:	681b      	ldr	r3, [r3, #0]
2400ec72:	68da      	ldr	r2, [r3, #12]
2400ec74:	68fb      	ldr	r3, [r7, #12]
2400ec76:	681b      	ldr	r3, [r3, #0]
2400ec78:	f042 0210 	orr.w	r2, r2, #16
2400ec7c:	60da      	str	r2, [r3, #12]
    }

    if(hmdma->XferRepeatBlockCpltCallback != NULL)
2400ec7e:	68fb      	ldr	r3, [r7, #12]
2400ec80:	6d1b      	ldr	r3, [r3, #80]	; 0x50
2400ec82:	2b00      	cmp	r3, #0
2400ec84:	d007      	beq.n	2400ec96 <HAL_MDMA_Start_IT+0xa8>
    {
      /* if Repeated Block transfer complete Callback is set enable the corresponding IT*/
      __HAL_MDMA_ENABLE_IT(hmdma, MDMA_IT_BRT);
2400ec86:	68fb      	ldr	r3, [r7, #12]
2400ec88:	681b      	ldr	r3, [r3, #0]
2400ec8a:	68da      	ldr	r2, [r3, #12]
2400ec8c:	68fb      	ldr	r3, [r7, #12]
2400ec8e:	681b      	ldr	r3, [r3, #0]
2400ec90:	f042 0208 	orr.w	r2, r2, #8
2400ec94:	60da      	str	r2, [r3, #12]
    }

    if(hmdma->XferBufferCpltCallback != NULL)
2400ec96:	68fb      	ldr	r3, [r7, #12]
2400ec98:	6c9b      	ldr	r3, [r3, #72]	; 0x48
2400ec9a:	2b00      	cmp	r3, #0
2400ec9c:	d007      	beq.n	2400ecae <HAL_MDMA_Start_IT+0xc0>
    {
      /* if buffer transfer complete Callback is set enable the corresponding IT*/
      __HAL_MDMA_ENABLE_IT(hmdma, MDMA_IT_BFTC);
2400ec9e:	68fb      	ldr	r3, [r7, #12]
2400eca0:	681b      	ldr	r3, [r3, #0]
2400eca2:	68da      	ldr	r2, [r3, #12]
2400eca4:	68fb      	ldr	r3, [r7, #12]
2400eca6:	681b      	ldr	r3, [r3, #0]
2400eca8:	f042 0220 	orr.w	r2, r2, #32
2400ecac:	60da      	str	r2, [r3, #12]
    }

    /* Enable the Peripheral */
    __HAL_MDMA_ENABLE(hmdma);
2400ecae:	68fb      	ldr	r3, [r7, #12]
2400ecb0:	681b      	ldr	r3, [r3, #0]
2400ecb2:	68da      	ldr	r2, [r3, #12]
2400ecb4:	68fb      	ldr	r3, [r7, #12]
2400ecb6:	681b      	ldr	r3, [r3, #0]
2400ecb8:	f042 0201 	orr.w	r2, r2, #1
2400ecbc:	60da      	str	r2, [r3, #12]

    if(hmdma->Init.Request == MDMA_REQUEST_SW)
2400ecbe:	68fb      	ldr	r3, [r7, #12]
2400ecc0:	685b      	ldr	r3, [r3, #4]
2400ecc2:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
2400ecc6:	d10e      	bne.n	2400ece6 <HAL_MDMA_Start_IT+0xf8>
    {
      /* activate If SW request mode*/
      hmdma->Instance->CCR |=  MDMA_CCR_SWRQ;
2400ecc8:	68fb      	ldr	r3, [r7, #12]
2400ecca:	681b      	ldr	r3, [r3, #0]
2400eccc:	68da      	ldr	r2, [r3, #12]
2400ecce:	68fb      	ldr	r3, [r7, #12]
2400ecd0:	681b      	ldr	r3, [r3, #0]
2400ecd2:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
2400ecd6:	60da      	str	r2, [r3, #12]
2400ecd8:	e005      	b.n	2400ece6 <HAL_MDMA_Start_IT+0xf8>
    }
  }
  else
  {
    /* Process unlocked */
    __HAL_UNLOCK(hmdma);
2400ecda:	68fb      	ldr	r3, [r7, #12]
2400ecdc:	2200      	movs	r2, #0
2400ecde:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

    /* Return error status */
    return HAL_BUSY;
2400ece2:	2302      	movs	r3, #2
2400ece4:	e000      	b.n	2400ece8 <HAL_MDMA_Start_IT+0xfa>
  }

  return HAL_OK;
2400ece6:	2300      	movs	r3, #0
}
2400ece8:	4618      	mov	r0, r3
2400ecea:	3710      	adds	r7, #16
2400ecec:	46bd      	mov	sp, r7
2400ecee:	bd80      	pop	{r7, pc}

2400ecf0 <HAL_MDMA_Abort>:
  *        and the Channel will be effectively disabled only after the transfer of
  *        this single data is finished.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_MDMA_Abort(MDMA_HandleTypeDef *hmdma)
{
2400ecf0:	b580      	push	{r7, lr}
2400ecf2:	b084      	sub	sp, #16
2400ecf4:	af00      	add	r7, sp, #0
2400ecf6:	6078      	str	r0, [r7, #4]
  uint32_t tickstart =  HAL_GetTick();
2400ecf8:	f7f1 fdac 	bl	24000854 <HAL_GetTick>
2400ecfc:	60f8      	str	r0, [r7, #12]

  /* Check the MDMA peripheral handle */
  if(hmdma == NULL)
2400ecfe:	687b      	ldr	r3, [r7, #4]
2400ed00:	2b00      	cmp	r3, #0
2400ed02:	d101      	bne.n	2400ed08 <HAL_MDMA_Abort+0x18>
  {
    return HAL_ERROR;
2400ed04:	2301      	movs	r3, #1
2400ed06:	e04a      	b.n	2400ed9e <HAL_MDMA_Abort+0xae>
  }

  if(HAL_MDMA_STATE_BUSY != hmdma->State)
2400ed08:	687b      	ldr	r3, [r7, #4]
2400ed0a:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
2400ed0e:	b2db      	uxtb	r3, r3
2400ed10:	2b02      	cmp	r3, #2
2400ed12:	d008      	beq.n	2400ed26 <HAL_MDMA_Abort+0x36>
  {
    hmdma->ErrorCode = HAL_MDMA_ERROR_NO_XFER;
2400ed14:	687b      	ldr	r3, [r7, #4]
2400ed16:	2280      	movs	r2, #128	; 0x80
2400ed18:	669a      	str	r2, [r3, #104]	; 0x68

    /* Process Unlocked */
    __HAL_UNLOCK(hmdma);
2400ed1a:	687b      	ldr	r3, [r7, #4]
2400ed1c:	2200      	movs	r2, #0
2400ed1e:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

    return HAL_ERROR;
2400ed22:	2301      	movs	r3, #1
2400ed24:	e03b      	b.n	2400ed9e <HAL_MDMA_Abort+0xae>
  }
  else
  {
    /* Disable all the transfer interrupts */
    __HAL_MDMA_DISABLE_IT(hmdma, (MDMA_IT_TE | MDMA_IT_CTC | MDMA_IT_BT | MDMA_IT_BRT | MDMA_IT_BFTC));
2400ed26:	687b      	ldr	r3, [r7, #4]
2400ed28:	681b      	ldr	r3, [r3, #0]
2400ed2a:	68da      	ldr	r2, [r3, #12]
2400ed2c:	687b      	ldr	r3, [r7, #4]
2400ed2e:	681b      	ldr	r3, [r3, #0]
2400ed30:	f022 023e 	bic.w	r2, r2, #62	; 0x3e
2400ed34:	60da      	str	r2, [r3, #12]

    /* Disable the channel */
    __HAL_MDMA_DISABLE(hmdma);
2400ed36:	687b      	ldr	r3, [r7, #4]
2400ed38:	681b      	ldr	r3, [r3, #0]
2400ed3a:	68da      	ldr	r2, [r3, #12]
2400ed3c:	687b      	ldr	r3, [r7, #4]
2400ed3e:	681b      	ldr	r3, [r3, #0]
2400ed40:	f022 0201 	bic.w	r2, r2, #1
2400ed44:	60da      	str	r2, [r3, #12]

    /* Check if the MDMA Channel is effectively disabled */
    while((hmdma->Instance->CCR & MDMA_CCR_EN) != 0U)
2400ed46:	e016      	b.n	2400ed76 <HAL_MDMA_Abort+0x86>
    {
      /* Check for the Timeout */
      if( (HAL_GetTick()  - tickstart ) > HAL_TIMEOUT_MDMA_ABORT)
2400ed48:	f7f1 fd84 	bl	24000854 <HAL_GetTick>
2400ed4c:	4602      	mov	r2, r0
2400ed4e:	68fb      	ldr	r3, [r7, #12]
2400ed50:	1ad3      	subs	r3, r2, r3
2400ed52:	2b05      	cmp	r3, #5
2400ed54:	d90f      	bls.n	2400ed76 <HAL_MDMA_Abort+0x86>
      {
        /* Update error code */
        hmdma->ErrorCode |= HAL_MDMA_ERROR_TIMEOUT;
2400ed56:	687b      	ldr	r3, [r7, #4]
2400ed58:	6e9b      	ldr	r3, [r3, #104]	; 0x68
2400ed5a:	f043 0240 	orr.w	r2, r3, #64	; 0x40
2400ed5e:	687b      	ldr	r3, [r7, #4]
2400ed60:	669a      	str	r2, [r3, #104]	; 0x68

        /* Process Unlocked */
        __HAL_UNLOCK(hmdma);
2400ed62:	687b      	ldr	r3, [r7, #4]
2400ed64:	2200      	movs	r2, #0
2400ed66:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

        /* Change the MDMA state */
        hmdma->State = HAL_MDMA_STATE_ERROR;
2400ed6a:	687b      	ldr	r3, [r7, #4]
2400ed6c:	2203      	movs	r2, #3
2400ed6e:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

        return HAL_ERROR;
2400ed72:	2301      	movs	r3, #1
2400ed74:	e013      	b.n	2400ed9e <HAL_MDMA_Abort+0xae>
    while((hmdma->Instance->CCR & MDMA_CCR_EN) != 0U)
2400ed76:	687b      	ldr	r3, [r7, #4]
2400ed78:	681b      	ldr	r3, [r3, #0]
2400ed7a:	68db      	ldr	r3, [r3, #12]
2400ed7c:	f003 0301 	and.w	r3, r3, #1
2400ed80:	2b00      	cmp	r3, #0
2400ed82:	d1e1      	bne.n	2400ed48 <HAL_MDMA_Abort+0x58>
      }
    }

    /* Clear all interrupt flags */
    __HAL_MDMA_CLEAR_FLAG(hmdma, (MDMA_FLAG_TE | MDMA_FLAG_CTC | MDMA_FLAG_BT | MDMA_FLAG_BRT | MDMA_FLAG_BFTC));
2400ed84:	687b      	ldr	r3, [r7, #4]
2400ed86:	681b      	ldr	r3, [r3, #0]
2400ed88:	221f      	movs	r2, #31
2400ed8a:	605a      	str	r2, [r3, #4]

    /* Process Unlocked */
    __HAL_UNLOCK(hmdma);
2400ed8c:	687b      	ldr	r3, [r7, #4]
2400ed8e:	2200      	movs	r2, #0
2400ed90:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

    /* Change the MDMA state*/
    hmdma->State = HAL_MDMA_STATE_READY;
2400ed94:	687b      	ldr	r3, [r7, #4]
2400ed96:	2201      	movs	r2, #1
2400ed98:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
  }

  return HAL_OK;
2400ed9c:	2300      	movs	r3, #0
}
2400ed9e:	4618      	mov	r0, r3
2400eda0:	3710      	adds	r7, #16
2400eda2:	46bd      	mov	sp, r7
2400eda4:	bd80      	pop	{r7, pc}

2400eda6 <HAL_MDMA_Abort_IT>:
  * @param  hmdma  : pointer to a MDMA_HandleTypeDef structure that contains
  *                 the configuration information for the specified MDMA Channel.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_MDMA_Abort_IT(MDMA_HandleTypeDef *hmdma)
{
2400eda6:	b480      	push	{r7}
2400eda8:	b083      	sub	sp, #12
2400edaa:	af00      	add	r7, sp, #0
2400edac:	6078      	str	r0, [r7, #4]
  /* Check the MDMA peripheral handle */
  if(hmdma == NULL)
2400edae:	687b      	ldr	r3, [r7, #4]
2400edb0:	2b00      	cmp	r3, #0
2400edb2:	d101      	bne.n	2400edb8 <HAL_MDMA_Abort_IT+0x12>
  {
    return HAL_ERROR;
2400edb4:	2301      	movs	r3, #1
2400edb6:	e017      	b.n	2400ede8 <HAL_MDMA_Abort_IT+0x42>
  }

  if(HAL_MDMA_STATE_BUSY != hmdma->State)
2400edb8:	687b      	ldr	r3, [r7, #4]
2400edba:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
2400edbe:	b2db      	uxtb	r3, r3
2400edc0:	2b02      	cmp	r3, #2
2400edc2:	d004      	beq.n	2400edce <HAL_MDMA_Abort_IT+0x28>
  {
    /* No transfer ongoing */
    hmdma->ErrorCode = HAL_MDMA_ERROR_NO_XFER;
2400edc4:	687b      	ldr	r3, [r7, #4]
2400edc6:	2280      	movs	r2, #128	; 0x80
2400edc8:	669a      	str	r2, [r3, #104]	; 0x68

    return HAL_ERROR;
2400edca:	2301      	movs	r3, #1
2400edcc:	e00c      	b.n	2400ede8 <HAL_MDMA_Abort_IT+0x42>
  }
  else
  {
    /* Set Abort State  */
    hmdma->State = HAL_MDMA_STATE_ABORT;
2400edce:	687b      	ldr	r3, [r7, #4]
2400edd0:	2204      	movs	r2, #4
2400edd2:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

    /* Disable the stream */
    __HAL_MDMA_DISABLE(hmdma);
2400edd6:	687b      	ldr	r3, [r7, #4]
2400edd8:	681b      	ldr	r3, [r3, #0]
2400edda:	68da      	ldr	r2, [r3, #12]
2400eddc:	687b      	ldr	r3, [r7, #4]
2400edde:	681b      	ldr	r3, [r3, #0]
2400ede0:	f022 0201 	bic.w	r2, r2, #1
2400ede4:	60da      	str	r2, [r3, #12]
  }

  return HAL_OK;
2400ede6:	2300      	movs	r3, #0
}
2400ede8:	4618      	mov	r0, r3
2400edea:	370c      	adds	r7, #12
2400edec:	46bd      	mov	sp, r7
2400edee:	f85d 7b04 	ldr.w	r7, [sp], #4
2400edf2:	4770      	bx	lr

2400edf4 <HAL_MDMA_PollForTransfer>:
  * @param  CompleteLevel: Specifies the MDMA level complete.
  * @param  Timeout:       Timeout duration.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_MDMA_PollForTransfer(MDMA_HandleTypeDef *hmdma, HAL_MDMA_LevelCompleteTypeDef CompleteLevel, uint32_t Timeout)
{
2400edf4:	b580      	push	{r7, lr}
2400edf6:	b088      	sub	sp, #32
2400edf8:	af00      	add	r7, sp, #0
2400edfa:	60f8      	str	r0, [r7, #12]
2400edfc:	460b      	mov	r3, r1
2400edfe:	607a      	str	r2, [r7, #4]
2400ee00:	72fb      	strb	r3, [r7, #11]

  /* Check the parameters */
  assert_param(IS_MDMA_LEVEL_COMPLETE(CompleteLevel));

  /* Check the MDMA peripheral handle */
  if(hmdma == NULL)
2400ee02:	68fb      	ldr	r3, [r7, #12]
2400ee04:	2b00      	cmp	r3, #0
2400ee06:	d101      	bne.n	2400ee0c <HAL_MDMA_PollForTransfer+0x18>
  {
    return HAL_ERROR;
2400ee08:	2301      	movs	r3, #1
2400ee0a:	e0b9      	b.n	2400ef80 <HAL_MDMA_PollForTransfer+0x18c>
  }

  if(HAL_MDMA_STATE_BUSY != hmdma->State)
2400ee0c:	68fb      	ldr	r3, [r7, #12]
2400ee0e:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
2400ee12:	b2db      	uxtb	r3, r3
2400ee14:	2b02      	cmp	r3, #2
2400ee16:	d004      	beq.n	2400ee22 <HAL_MDMA_PollForTransfer+0x2e>
  {
    /* No transfer ongoing */
    hmdma->ErrorCode = HAL_MDMA_ERROR_NO_XFER;
2400ee18:	68fb      	ldr	r3, [r7, #12]
2400ee1a:	2280      	movs	r2, #128	; 0x80
2400ee1c:	669a      	str	r2, [r3, #104]	; 0x68

    return HAL_ERROR;
2400ee1e:	2301      	movs	r3, #1
2400ee20:	e0ae      	b.n	2400ef80 <HAL_MDMA_PollForTransfer+0x18c>
  }

  /* Get the level transfer complete flag */
  levelFlag = ((CompleteLevel == HAL_MDMA_FULL_TRANSFER)  ? MDMA_FLAG_CTC  : \
2400ee22:	7afb      	ldrb	r3, [r7, #11]
2400ee24:	2b00      	cmp	r3, #0
2400ee26:	d00b      	beq.n	2400ee40 <HAL_MDMA_PollForTransfer+0x4c>
               (CompleteLevel == HAL_MDMA_BUFFER_TRANSFER)? MDMA_FLAG_BFTC : \
2400ee28:	7afb      	ldrb	r3, [r7, #11]
2400ee2a:	2b01      	cmp	r3, #1
2400ee2c:	d006      	beq.n	2400ee3c <HAL_MDMA_PollForTransfer+0x48>
               (CompleteLevel == HAL_MDMA_BLOCK_TRANSFER) ? MDMA_FLAG_BT   : \
2400ee2e:	7afb      	ldrb	r3, [r7, #11]
2400ee30:	2b02      	cmp	r3, #2
2400ee32:	d101      	bne.n	2400ee38 <HAL_MDMA_PollForTransfer+0x44>
2400ee34:	2308      	movs	r3, #8
2400ee36:	e004      	b.n	2400ee42 <HAL_MDMA_PollForTransfer+0x4e>
2400ee38:	2304      	movs	r3, #4
2400ee3a:	e002      	b.n	2400ee42 <HAL_MDMA_PollForTransfer+0x4e>
               (CompleteLevel == HAL_MDMA_BUFFER_TRANSFER)? MDMA_FLAG_BFTC : \
2400ee3c:	2310      	movs	r3, #16
2400ee3e:	e000      	b.n	2400ee42 <HAL_MDMA_PollForTransfer+0x4e>
  levelFlag = ((CompleteLevel == HAL_MDMA_FULL_TRANSFER)  ? MDMA_FLAG_CTC  : \
2400ee40:	2302      	movs	r3, #2
2400ee42:	61fb      	str	r3, [r7, #28]
               MDMA_FLAG_BRT);


  /* Get timeout */
  tickstart = HAL_GetTick();
2400ee44:	f7f1 fd06 	bl	24000854 <HAL_GetTick>
2400ee48:	61b8      	str	r0, [r7, #24]

  while(__HAL_MDMA_GET_FLAG(hmdma, levelFlag) == 0U)
2400ee4a:	e067      	b.n	2400ef1c <HAL_MDMA_PollForTransfer+0x128>
  {
    if((__HAL_MDMA_GET_FLAG(hmdma, MDMA_FLAG_TE) != 0U))
2400ee4c:	68fb      	ldr	r3, [r7, #12]
2400ee4e:	681b      	ldr	r3, [r3, #0]
2400ee50:	681b      	ldr	r3, [r3, #0]
2400ee52:	f003 0301 	and.w	r3, r3, #1
2400ee56:	2b00      	cmp	r3, #0
2400ee58:	d046      	beq.n	2400eee8 <HAL_MDMA_PollForTransfer+0xf4>
    {
      /* Get the transfer error source flag */
      errorFlag = hmdma->Instance->CESR;
2400ee5a:	68fb      	ldr	r3, [r7, #12]
2400ee5c:	681b      	ldr	r3, [r3, #0]
2400ee5e:	689b      	ldr	r3, [r3, #8]
2400ee60:	617b      	str	r3, [r7, #20]

      if((errorFlag & MDMA_CESR_TED) == 0U)
2400ee62:	697b      	ldr	r3, [r7, #20]
2400ee64:	f003 0380 	and.w	r3, r3, #128	; 0x80
2400ee68:	2b00      	cmp	r3, #0
2400ee6a:	d106      	bne.n	2400ee7a <HAL_MDMA_PollForTransfer+0x86>
      {
        /* Update error code : Read Transfer error  */
        hmdma->ErrorCode |= HAL_MDMA_ERROR_READ_XFER;
2400ee6c:	68fb      	ldr	r3, [r7, #12]
2400ee6e:	6e9b      	ldr	r3, [r3, #104]	; 0x68
2400ee70:	f043 0201 	orr.w	r2, r3, #1
2400ee74:	68fb      	ldr	r3, [r7, #12]
2400ee76:	669a      	str	r2, [r3, #104]	; 0x68
2400ee78:	e005      	b.n	2400ee86 <HAL_MDMA_PollForTransfer+0x92>
      }
      else
      {
        /* Update error code : Write Transfer error */
        hmdma->ErrorCode |= HAL_MDMA_ERROR_WRITE_XFER;
2400ee7a:	68fb      	ldr	r3, [r7, #12]
2400ee7c:	6e9b      	ldr	r3, [r3, #104]	; 0x68
2400ee7e:	f043 0202 	orr.w	r2, r3, #2
2400ee82:	68fb      	ldr	r3, [r7, #12]
2400ee84:	669a      	str	r2, [r3, #104]	; 0x68
      }

      if((errorFlag & MDMA_CESR_TEMD) != 0U)
2400ee86:	697b      	ldr	r3, [r7, #20]
2400ee88:	f403 7300 	and.w	r3, r3, #512	; 0x200
2400ee8c:	2b00      	cmp	r3, #0
2400ee8e:	d005      	beq.n	2400ee9c <HAL_MDMA_PollForTransfer+0xa8>
      {
        /* Update error code : Error Mask Data */
        hmdma->ErrorCode |= HAL_MDMA_ERROR_MASK_DATA;
2400ee90:	68fb      	ldr	r3, [r7, #12]
2400ee92:	6e9b      	ldr	r3, [r3, #104]	; 0x68
2400ee94:	f043 0204 	orr.w	r2, r3, #4
2400ee98:	68fb      	ldr	r3, [r7, #12]
2400ee9a:	669a      	str	r2, [r3, #104]	; 0x68
      }

      if((errorFlag & MDMA_CESR_TELD) != 0U)
2400ee9c:	697b      	ldr	r3, [r7, #20]
2400ee9e:	f403 7380 	and.w	r3, r3, #256	; 0x100
2400eea2:	2b00      	cmp	r3, #0
2400eea4:	d005      	beq.n	2400eeb2 <HAL_MDMA_PollForTransfer+0xbe>
      {
        /* Update error code : Error Linked list */
        hmdma->ErrorCode |= HAL_MDMA_ERROR_LINKED_LIST;
2400eea6:	68fb      	ldr	r3, [r7, #12]
2400eea8:	6e9b      	ldr	r3, [r3, #104]	; 0x68
2400eeaa:	f043 0208 	orr.w	r2, r3, #8
2400eeae:	68fb      	ldr	r3, [r7, #12]
2400eeb0:	669a      	str	r2, [r3, #104]	; 0x68
      }

      if((errorFlag & MDMA_CESR_ASE) != 0U)
2400eeb2:	697b      	ldr	r3, [r7, #20]
2400eeb4:	f403 6380 	and.w	r3, r3, #1024	; 0x400
2400eeb8:	2b00      	cmp	r3, #0
2400eeba:	d005      	beq.n	2400eec8 <HAL_MDMA_PollForTransfer+0xd4>
      {
        /* Update error code : Address/Size alignment error */
        hmdma->ErrorCode |= HAL_MDMA_ERROR_ALIGNMENT;
2400eebc:	68fb      	ldr	r3, [r7, #12]
2400eebe:	6e9b      	ldr	r3, [r3, #104]	; 0x68
2400eec0:	f043 0210 	orr.w	r2, r3, #16
2400eec4:	68fb      	ldr	r3, [r7, #12]
2400eec6:	669a      	str	r2, [r3, #104]	; 0x68
      }

      if((errorFlag & MDMA_CESR_BSE) != 0U)
2400eec8:	697b      	ldr	r3, [r7, #20]
2400eeca:	f403 6300 	and.w	r3, r3, #2048	; 0x800
2400eece:	2b00      	cmp	r3, #0
2400eed0:	d005      	beq.n	2400eede <HAL_MDMA_PollForTransfer+0xea>
      {
        /* Update error code : Block Size error */
        hmdma->ErrorCode |= HAL_MDMA_ERROR_BLOCK_SIZE;
2400eed2:	68fb      	ldr	r3, [r7, #12]
2400eed4:	6e9b      	ldr	r3, [r3, #104]	; 0x68
2400eed6:	f043 0220 	orr.w	r2, r3, #32
2400eeda:	68fb      	ldr	r3, [r7, #12]
2400eedc:	669a      	str	r2, [r3, #104]	; 0x68
      }

      (void) HAL_MDMA_Abort(hmdma); /* if error then abort the current transfer */
2400eede:	68f8      	ldr	r0, [r7, #12]
2400eee0:	f7ff ff06 	bl	2400ecf0 <HAL_MDMA_Abort>
          - Clear all transfer flags
          - Unlock
          - Set the State
      */

      return HAL_ERROR;
2400eee4:	2301      	movs	r3, #1
2400eee6:	e04b      	b.n	2400ef80 <HAL_MDMA_PollForTransfer+0x18c>

    }

    /* Check for the Timeout */
    if(Timeout != HAL_MAX_DELAY)
2400eee8:	687b      	ldr	r3, [r7, #4]
2400eeea:	f1b3 3fff 	cmp.w	r3, #4294967295
2400eeee:	d015      	beq.n	2400ef1c <HAL_MDMA_PollForTransfer+0x128>
    {
      if(((HAL_GetTick() - tickstart ) > Timeout) || (Timeout == 0U))
2400eef0:	f7f1 fcb0 	bl	24000854 <HAL_GetTick>
2400eef4:	4602      	mov	r2, r0
2400eef6:	69bb      	ldr	r3, [r7, #24]
2400eef8:	1ad3      	subs	r3, r2, r3
2400eefa:	687a      	ldr	r2, [r7, #4]
2400eefc:	429a      	cmp	r2, r3
2400eefe:	d302      	bcc.n	2400ef06 <HAL_MDMA_PollForTransfer+0x112>
2400ef00:	687b      	ldr	r3, [r7, #4]
2400ef02:	2b00      	cmp	r3, #0
2400ef04:	d10a      	bne.n	2400ef1c <HAL_MDMA_PollForTransfer+0x128>
      {
        /* Update error code */
        hmdma->ErrorCode |= HAL_MDMA_ERROR_TIMEOUT;
2400ef06:	68fb      	ldr	r3, [r7, #12]
2400ef08:	6e9b      	ldr	r3, [r3, #104]	; 0x68
2400ef0a:	f043 0240 	orr.w	r2, r3, #64	; 0x40
2400ef0e:	68fb      	ldr	r3, [r7, #12]
2400ef10:	669a      	str	r2, [r3, #104]	; 0x68

        (void) HAL_MDMA_Abort(hmdma); /* if timeout then abort the current transfer */
2400ef12:	68f8      	ldr	r0, [r7, #12]
2400ef14:	f7ff feec 	bl	2400ecf0 <HAL_MDMA_Abort>
            - Clear all transfer flags
            - Unlock
            - Set the State
        */

        return HAL_ERROR;
2400ef18:	2301      	movs	r3, #1
2400ef1a:	e031      	b.n	2400ef80 <HAL_MDMA_PollForTransfer+0x18c>
  while(__HAL_MDMA_GET_FLAG(hmdma, levelFlag) == 0U)
2400ef1c:	68fb      	ldr	r3, [r7, #12]
2400ef1e:	681b      	ldr	r3, [r3, #0]
2400ef20:	681a      	ldr	r2, [r3, #0]
2400ef22:	69fb      	ldr	r3, [r7, #28]
2400ef24:	4013      	ands	r3, r2
2400ef26:	2b00      	cmp	r3, #0
2400ef28:	d090      	beq.n	2400ee4c <HAL_MDMA_PollForTransfer+0x58>
      }
    }
  }

  /* Clear the transfer level flag */
  if(CompleteLevel == HAL_MDMA_BUFFER_TRANSFER)
2400ef2a:	7afb      	ldrb	r3, [r7, #11]
2400ef2c:	2b01      	cmp	r3, #1
2400ef2e:	d104      	bne.n	2400ef3a <HAL_MDMA_PollForTransfer+0x146>
  {
    __HAL_MDMA_CLEAR_FLAG(hmdma, MDMA_FLAG_BFTC);
2400ef30:	68fb      	ldr	r3, [r7, #12]
2400ef32:	681b      	ldr	r3, [r3, #0]
2400ef34:	2210      	movs	r2, #16
2400ef36:	605a      	str	r2, [r3, #4]
2400ef38:	e021      	b.n	2400ef7e <HAL_MDMA_PollForTransfer+0x18a>

  }
  else if(CompleteLevel == HAL_MDMA_BLOCK_TRANSFER)
2400ef3a:	7afb      	ldrb	r3, [r7, #11]
2400ef3c:	2b02      	cmp	r3, #2
2400ef3e:	d104      	bne.n	2400ef4a <HAL_MDMA_PollForTransfer+0x156>
  {
    __HAL_MDMA_CLEAR_FLAG(hmdma, (MDMA_FLAG_BFTC | MDMA_FLAG_BT));
2400ef40:	68fb      	ldr	r3, [r7, #12]
2400ef42:	681b      	ldr	r3, [r3, #0]
2400ef44:	2218      	movs	r2, #24
2400ef46:	605a      	str	r2, [r3, #4]
2400ef48:	e019      	b.n	2400ef7e <HAL_MDMA_PollForTransfer+0x18a>

  }
  else if(CompleteLevel == HAL_MDMA_REPEAT_BLOCK_TRANSFER)
2400ef4a:	7afb      	ldrb	r3, [r7, #11]
2400ef4c:	2b03      	cmp	r3, #3
2400ef4e:	d104      	bne.n	2400ef5a <HAL_MDMA_PollForTransfer+0x166>
  {
    __HAL_MDMA_CLEAR_FLAG(hmdma, (MDMA_FLAG_BFTC | MDMA_FLAG_BT | MDMA_FLAG_BRT));
2400ef50:	68fb      	ldr	r3, [r7, #12]
2400ef52:	681b      	ldr	r3, [r3, #0]
2400ef54:	221c      	movs	r2, #28
2400ef56:	605a      	str	r2, [r3, #4]
2400ef58:	e011      	b.n	2400ef7e <HAL_MDMA_PollForTransfer+0x18a>
  }
  else if(CompleteLevel == HAL_MDMA_FULL_TRANSFER)
2400ef5a:	7afb      	ldrb	r3, [r7, #11]
2400ef5c:	2b00      	cmp	r3, #0
2400ef5e:	d10c      	bne.n	2400ef7a <HAL_MDMA_PollForTransfer+0x186>
  {
    __HAL_MDMA_CLEAR_FLAG(hmdma, (MDMA_FLAG_BRT | MDMA_FLAG_BT | MDMA_FLAG_BFTC | MDMA_FLAG_CTC));
2400ef60:	68fb      	ldr	r3, [r7, #12]
2400ef62:	681b      	ldr	r3, [r3, #0]
2400ef64:	221e      	movs	r2, #30
2400ef66:	605a      	str	r2, [r3, #4]

    /* Process unlocked */
    __HAL_UNLOCK(hmdma);
2400ef68:	68fb      	ldr	r3, [r7, #12]
2400ef6a:	2200      	movs	r2, #0
2400ef6c:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

    hmdma->State = HAL_MDMA_STATE_READY;
2400ef70:	68fb      	ldr	r3, [r7, #12]
2400ef72:	2201      	movs	r2, #1
2400ef74:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
2400ef78:	e001      	b.n	2400ef7e <HAL_MDMA_PollForTransfer+0x18a>
  }
  else
  {
    return HAL_ERROR;
2400ef7a:	2301      	movs	r3, #1
2400ef7c:	e000      	b.n	2400ef80 <HAL_MDMA_PollForTransfer+0x18c>
  }

  return HAL_OK;
2400ef7e:	2300      	movs	r3, #0
}
2400ef80:	4618      	mov	r0, r3
2400ef82:	3720      	adds	r7, #32
2400ef84:	46bd      	mov	sp, r7
2400ef86:	bd80      	pop	{r7, pc}

2400ef88 <HAL_MDMA_GenerateSWRequest>:
  * @param  hmdma:       pointer to a MDMA_HandleTypeDef structure that contains
  *                     the configuration information for the specified MDMA Stream.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_MDMA_GenerateSWRequest(MDMA_HandleTypeDef *hmdma)
{
2400ef88:	b480      	push	{r7}
2400ef8a:	b085      	sub	sp, #20
2400ef8c:	af00      	add	r7, sp, #0
2400ef8e:	6078      	str	r0, [r7, #4]
  uint32_t request_mode;

  /* Check the MDMA peripheral handle */
  if(hmdma == NULL)
2400ef90:	687b      	ldr	r3, [r7, #4]
2400ef92:	2b00      	cmp	r3, #0
2400ef94:	d101      	bne.n	2400ef9a <HAL_MDMA_GenerateSWRequest+0x12>
  {
    return HAL_ERROR;
2400ef96:	2301      	movs	r3, #1
2400ef98:	e02a      	b.n	2400eff0 <HAL_MDMA_GenerateSWRequest+0x68>
  }

  /* Get the softawre request mode */
  request_mode = hmdma->Instance->CTCR & MDMA_CTCR_SWRM;
2400ef9a:	687b      	ldr	r3, [r7, #4]
2400ef9c:	681b      	ldr	r3, [r3, #0]
2400ef9e:	691b      	ldr	r3, [r3, #16]
2400efa0:	f003 4380 	and.w	r3, r3, #1073741824	; 0x40000000
2400efa4:	60fb      	str	r3, [r7, #12]

  if((hmdma->Instance->CCR &  MDMA_CCR_EN) == 0U)
2400efa6:	687b      	ldr	r3, [r7, #4]
2400efa8:	681b      	ldr	r3, [r3, #0]
2400efaa:	68db      	ldr	r3, [r3, #12]
2400efac:	f003 0301 	and.w	r3, r3, #1
2400efb0:	2b00      	cmp	r3, #0
2400efb2:	d104      	bne.n	2400efbe <HAL_MDMA_GenerateSWRequest+0x36>
  {
    /* if no Transfer on going (MDMA enable bit not set) retrun error */
    hmdma->ErrorCode = HAL_MDMA_ERROR_NO_XFER;
2400efb4:	687b      	ldr	r3, [r7, #4]
2400efb6:	2280      	movs	r2, #128	; 0x80
2400efb8:	669a      	str	r2, [r3, #104]	; 0x68

    return HAL_ERROR;
2400efba:	2301      	movs	r3, #1
2400efbc:	e018      	b.n	2400eff0 <HAL_MDMA_GenerateSWRequest+0x68>
  }
  else if(((hmdma->Instance->CISR &  MDMA_CISR_CRQA) != 0U) || (request_mode == 0U))
2400efbe:	687b      	ldr	r3, [r7, #4]
2400efc0:	681b      	ldr	r3, [r3, #0]
2400efc2:	681b      	ldr	r3, [r3, #0]
2400efc4:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
2400efc8:	2b00      	cmp	r3, #0
2400efca:	d102      	bne.n	2400efd2 <HAL_MDMA_GenerateSWRequest+0x4a>
2400efcc:	68fb      	ldr	r3, [r7, #12]
2400efce:	2b00      	cmp	r3, #0
2400efd0:	d105      	bne.n	2400efde <HAL_MDMA_GenerateSWRequest+0x56>
  {
    /* if an MDMA ongoing request has not yet end or if request mode is not SW request retrun error */
    hmdma->ErrorCode = HAL_MDMA_ERROR_BUSY;
2400efd2:	687b      	ldr	r3, [r7, #4]
2400efd4:	f44f 7280 	mov.w	r2, #256	; 0x100
2400efd8:	669a      	str	r2, [r3, #104]	; 0x68

    return HAL_ERROR;
2400efda:	2301      	movs	r3, #1
2400efdc:	e008      	b.n	2400eff0 <HAL_MDMA_GenerateSWRequest+0x68>
  }
  else
  {
    /* Set the SW request bit to activate the request on the Channel */
    hmdma->Instance->CCR |= MDMA_CCR_SWRQ;
2400efde:	687b      	ldr	r3, [r7, #4]
2400efe0:	681b      	ldr	r3, [r3, #0]
2400efe2:	68da      	ldr	r2, [r3, #12]
2400efe4:	687b      	ldr	r3, [r7, #4]
2400efe6:	681b      	ldr	r3, [r3, #0]
2400efe8:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
2400efec:	60da      	str	r2, [r3, #12]

    return HAL_OK;
2400efee:	2300      	movs	r3, #0
  }
}
2400eff0:	4618      	mov	r0, r3
2400eff2:	3714      	adds	r7, #20
2400eff4:	46bd      	mov	sp, r7
2400eff6:	f85d 7b04 	ldr.w	r7, [sp], #4
2400effa:	4770      	bx	lr

2400effc <HAL_MDMA_IRQHandler>:
  * @param  hmdma: pointer to a MDMA_HandleTypeDef structure that contains
  *               the configuration information for the specified MDMA Channel.
  * @retval None
  */
void HAL_MDMA_IRQHandler(MDMA_HandleTypeDef *hmdma)
{
2400effc:	b580      	push	{r7, lr}
2400effe:	b086      	sub	sp, #24
2400f000:	af00      	add	r7, sp, #0
2400f002:	6078      	str	r0, [r7, #4]
  __IO uint32_t count = 0;
2400f004:	2300      	movs	r3, #0
2400f006:	60bb      	str	r3, [r7, #8]
  uint32_t timeout = SystemCoreClock / 9600U;
2400f008:	4b9a      	ldr	r3, [pc, #616]	; (2400f274 <HAL_MDMA_IRQHandler+0x278>)
2400f00a:	681b      	ldr	r3, [r3, #0]
2400f00c:	4a9a      	ldr	r2, [pc, #616]	; (2400f278 <HAL_MDMA_IRQHandler+0x27c>)
2400f00e:	fba2 2303 	umull	r2, r3, r2, r3
2400f012:	0a9b      	lsrs	r3, r3, #10
2400f014:	617b      	str	r3, [r7, #20]

  uint32_t generalIntFlag, errorFlag;

  /* General Interrupt Flag management ****************************************/
  generalIntFlag =  1UL << ((((uint32_t)hmdma->Instance - (uint32_t)(MDMA_Channel0))/HAL_MDMA_CHANNEL_SIZE) & 0x1FU);
2400f016:	687b      	ldr	r3, [r7, #4]
2400f018:	681b      	ldr	r3, [r3, #0]
2400f01a:	461a      	mov	r2, r3
2400f01c:	4b97      	ldr	r3, [pc, #604]	; (2400f27c <HAL_MDMA_IRQHandler+0x280>)
2400f01e:	4413      	add	r3, r2
2400f020:	099b      	lsrs	r3, r3, #6
2400f022:	f003 031f 	and.w	r3, r3, #31
2400f026:	2201      	movs	r2, #1
2400f028:	fa02 f303 	lsl.w	r3, r2, r3
2400f02c:	613b      	str	r3, [r7, #16]
  if((MDMA->GISR0 & generalIntFlag) == 0U)
2400f02e:	f04f 43a4 	mov.w	r3, #1375731712	; 0x52000000
2400f032:	681a      	ldr	r2, [r3, #0]
2400f034:	693b      	ldr	r3, [r7, #16]
2400f036:	4013      	ands	r3, r2
2400f038:	2b00      	cmp	r3, #0
2400f03a:	f000 812e 	beq.w	2400f29a <HAL_MDMA_IRQHandler+0x29e>
  {
    return; /* the  General interrupt flag for the current channel is down , nothing to do */
  }

  /* Transfer Error Interrupt management ***************************************/
  if((__HAL_MDMA_GET_FLAG(hmdma, MDMA_FLAG_TE) != 0U))
2400f03e:	687b      	ldr	r3, [r7, #4]
2400f040:	681b      	ldr	r3, [r3, #0]
2400f042:	681b      	ldr	r3, [r3, #0]
2400f044:	f003 0301 	and.w	r3, r3, #1
2400f048:	2b00      	cmp	r3, #0
2400f04a:	d054      	beq.n	2400f0f6 <HAL_MDMA_IRQHandler+0xfa>
  {
    if(__HAL_MDMA_GET_IT_SOURCE(hmdma, MDMA_IT_TE) != 0U)
2400f04c:	687b      	ldr	r3, [r7, #4]
2400f04e:	681b      	ldr	r3, [r3, #0]
2400f050:	68db      	ldr	r3, [r3, #12]
2400f052:	f003 0302 	and.w	r3, r3, #2
2400f056:	2b00      	cmp	r3, #0
2400f058:	d04d      	beq.n	2400f0f6 <HAL_MDMA_IRQHandler+0xfa>
    {
      /* Disable the transfer error interrupt */
      __HAL_MDMA_DISABLE_IT(hmdma, MDMA_IT_TE);
2400f05a:	687b      	ldr	r3, [r7, #4]
2400f05c:	681b      	ldr	r3, [r3, #0]
2400f05e:	68da      	ldr	r2, [r3, #12]
2400f060:	687b      	ldr	r3, [r7, #4]
2400f062:	681b      	ldr	r3, [r3, #0]
2400f064:	f022 0202 	bic.w	r2, r2, #2
2400f068:	60da      	str	r2, [r3, #12]

      /* Get the transfer error source flag */
      errorFlag = hmdma->Instance->CESR;
2400f06a:	687b      	ldr	r3, [r7, #4]
2400f06c:	681b      	ldr	r3, [r3, #0]
2400f06e:	689b      	ldr	r3, [r3, #8]
2400f070:	60fb      	str	r3, [r7, #12]

      if((errorFlag & MDMA_CESR_TED) == 0U)
2400f072:	68fb      	ldr	r3, [r7, #12]
2400f074:	f003 0380 	and.w	r3, r3, #128	; 0x80
2400f078:	2b00      	cmp	r3, #0
2400f07a:	d106      	bne.n	2400f08a <HAL_MDMA_IRQHandler+0x8e>
      {
        /* Update error code : Read Transfer error  */
        hmdma->ErrorCode |= HAL_MDMA_ERROR_READ_XFER;
2400f07c:	687b      	ldr	r3, [r7, #4]
2400f07e:	6e9b      	ldr	r3, [r3, #104]	; 0x68
2400f080:	f043 0201 	orr.w	r2, r3, #1
2400f084:	687b      	ldr	r3, [r7, #4]
2400f086:	669a      	str	r2, [r3, #104]	; 0x68
2400f088:	e005      	b.n	2400f096 <HAL_MDMA_IRQHandler+0x9a>
      }
      else
      {
        /* Update error code : Write Transfer error */
        hmdma->ErrorCode |= HAL_MDMA_ERROR_WRITE_XFER;
2400f08a:	687b      	ldr	r3, [r7, #4]
2400f08c:	6e9b      	ldr	r3, [r3, #104]	; 0x68
2400f08e:	f043 0202 	orr.w	r2, r3, #2
2400f092:	687b      	ldr	r3, [r7, #4]
2400f094:	669a      	str	r2, [r3, #104]	; 0x68
      }

      if((errorFlag & MDMA_CESR_TEMD) != 0U)
2400f096:	68fb      	ldr	r3, [r7, #12]
2400f098:	f403 7300 	and.w	r3, r3, #512	; 0x200
2400f09c:	2b00      	cmp	r3, #0
2400f09e:	d005      	beq.n	2400f0ac <HAL_MDMA_IRQHandler+0xb0>
      {
        /* Update error code : Error Mask Data */
        hmdma->ErrorCode |= HAL_MDMA_ERROR_MASK_DATA;
2400f0a0:	687b      	ldr	r3, [r7, #4]
2400f0a2:	6e9b      	ldr	r3, [r3, #104]	; 0x68
2400f0a4:	f043 0204 	orr.w	r2, r3, #4
2400f0a8:	687b      	ldr	r3, [r7, #4]
2400f0aa:	669a      	str	r2, [r3, #104]	; 0x68
      }

      if((errorFlag & MDMA_CESR_TELD) != 0U)
2400f0ac:	68fb      	ldr	r3, [r7, #12]
2400f0ae:	f403 7380 	and.w	r3, r3, #256	; 0x100
2400f0b2:	2b00      	cmp	r3, #0
2400f0b4:	d005      	beq.n	2400f0c2 <HAL_MDMA_IRQHandler+0xc6>
      {
        /* Update error code : Error Linked list */
        hmdma->ErrorCode |= HAL_MDMA_ERROR_LINKED_LIST;
2400f0b6:	687b      	ldr	r3, [r7, #4]
2400f0b8:	6e9b      	ldr	r3, [r3, #104]	; 0x68
2400f0ba:	f043 0208 	orr.w	r2, r3, #8
2400f0be:	687b      	ldr	r3, [r7, #4]
2400f0c0:	669a      	str	r2, [r3, #104]	; 0x68
      }

      if((errorFlag & MDMA_CESR_ASE) != 0U)
2400f0c2:	68fb      	ldr	r3, [r7, #12]
2400f0c4:	f403 6380 	and.w	r3, r3, #1024	; 0x400
2400f0c8:	2b00      	cmp	r3, #0
2400f0ca:	d005      	beq.n	2400f0d8 <HAL_MDMA_IRQHandler+0xdc>
      {
        /* Update error code : Address/Size alignment error */
        hmdma->ErrorCode |= HAL_MDMA_ERROR_ALIGNMENT;
2400f0cc:	687b      	ldr	r3, [r7, #4]
2400f0ce:	6e9b      	ldr	r3, [r3, #104]	; 0x68
2400f0d0:	f043 0210 	orr.w	r2, r3, #16
2400f0d4:	687b      	ldr	r3, [r7, #4]
2400f0d6:	669a      	str	r2, [r3, #104]	; 0x68
      }

      if((errorFlag & MDMA_CESR_BSE) != 0U)
2400f0d8:	68fb      	ldr	r3, [r7, #12]
2400f0da:	f403 6300 	and.w	r3, r3, #2048	; 0x800
2400f0de:	2b00      	cmp	r3, #0
2400f0e0:	d005      	beq.n	2400f0ee <HAL_MDMA_IRQHandler+0xf2>
      {
        /* Update error code : Block Size error error */
        hmdma->ErrorCode |= HAL_MDMA_ERROR_BLOCK_SIZE;
2400f0e2:	687b      	ldr	r3, [r7, #4]
2400f0e4:	6e9b      	ldr	r3, [r3, #104]	; 0x68
2400f0e6:	f043 0220 	orr.w	r2, r3, #32
2400f0ea:	687b      	ldr	r3, [r7, #4]
2400f0ec:	669a      	str	r2, [r3, #104]	; 0x68
      }

      /* Clear the transfer error flags */
      __HAL_MDMA_CLEAR_FLAG(hmdma, MDMA_FLAG_TE);
2400f0ee:	687b      	ldr	r3, [r7, #4]
2400f0f0:	681b      	ldr	r3, [r3, #0]
2400f0f2:	2201      	movs	r2, #1
2400f0f4:	605a      	str	r2, [r3, #4]
    }
  }

  /* Buffer Transfer Complete Interrupt management ******************************/
  if((__HAL_MDMA_GET_FLAG(hmdma, MDMA_FLAG_BFTC) != 0U))
2400f0f6:	687b      	ldr	r3, [r7, #4]
2400f0f8:	681b      	ldr	r3, [r3, #0]
2400f0fa:	681b      	ldr	r3, [r3, #0]
2400f0fc:	f003 0310 	and.w	r3, r3, #16
2400f100:	2b00      	cmp	r3, #0
2400f102:	d012      	beq.n	2400f12a <HAL_MDMA_IRQHandler+0x12e>
  {
    if(__HAL_MDMA_GET_IT_SOURCE(hmdma, MDMA_IT_BFTC) != 0U)
2400f104:	687b      	ldr	r3, [r7, #4]
2400f106:	681b      	ldr	r3, [r3, #0]
2400f108:	68db      	ldr	r3, [r3, #12]
2400f10a:	f003 0320 	and.w	r3, r3, #32
2400f10e:	2b00      	cmp	r3, #0
2400f110:	d00b      	beq.n	2400f12a <HAL_MDMA_IRQHandler+0x12e>
    {
      /* Clear the buffer transfer complete flag */
      __HAL_MDMA_CLEAR_FLAG(hmdma, MDMA_FLAG_BFTC);
2400f112:	687b      	ldr	r3, [r7, #4]
2400f114:	681b      	ldr	r3, [r3, #0]
2400f116:	2210      	movs	r2, #16
2400f118:	605a      	str	r2, [r3, #4]

      if(hmdma->XferBufferCpltCallback != NULL)
2400f11a:	687b      	ldr	r3, [r7, #4]
2400f11c:	6c9b      	ldr	r3, [r3, #72]	; 0x48
2400f11e:	2b00      	cmp	r3, #0
2400f120:	d003      	beq.n	2400f12a <HAL_MDMA_IRQHandler+0x12e>
      {
        /* Buffer transfer callback */
        hmdma->XferBufferCpltCallback(hmdma);
2400f122:	687b      	ldr	r3, [r7, #4]
2400f124:	6c9b      	ldr	r3, [r3, #72]	; 0x48
2400f126:	6878      	ldr	r0, [r7, #4]
2400f128:	4798      	blx	r3
      }
    }
  }

  /* Block Transfer Complete Interrupt management ******************************/
  if((__HAL_MDMA_GET_FLAG(hmdma, MDMA_FLAG_BT) != 0U))
2400f12a:	687b      	ldr	r3, [r7, #4]
2400f12c:	681b      	ldr	r3, [r3, #0]
2400f12e:	681b      	ldr	r3, [r3, #0]
2400f130:	f003 0308 	and.w	r3, r3, #8
2400f134:	2b00      	cmp	r3, #0
2400f136:	d012      	beq.n	2400f15e <HAL_MDMA_IRQHandler+0x162>
  {
    if(__HAL_MDMA_GET_IT_SOURCE(hmdma, MDMA_IT_BT) != 0U)
2400f138:	687b      	ldr	r3, [r7, #4]
2400f13a:	681b      	ldr	r3, [r3, #0]
2400f13c:	68db      	ldr	r3, [r3, #12]
2400f13e:	f003 0310 	and.w	r3, r3, #16
2400f142:	2b00      	cmp	r3, #0
2400f144:	d00b      	beq.n	2400f15e <HAL_MDMA_IRQHandler+0x162>
    {
      /* Clear the block transfer complete flag */
      __HAL_MDMA_CLEAR_FLAG(hmdma, MDMA_FLAG_BT);
2400f146:	687b      	ldr	r3, [r7, #4]
2400f148:	681b      	ldr	r3, [r3, #0]
2400f14a:	2208      	movs	r2, #8
2400f14c:	605a      	str	r2, [r3, #4]

      if(hmdma->XferBlockCpltCallback != NULL)
2400f14e:	687b      	ldr	r3, [r7, #4]
2400f150:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
2400f152:	2b00      	cmp	r3, #0
2400f154:	d003      	beq.n	2400f15e <HAL_MDMA_IRQHandler+0x162>
      {
        /* Block transfer callback */
        hmdma->XferBlockCpltCallback(hmdma);
2400f156:	687b      	ldr	r3, [r7, #4]
2400f158:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
2400f15a:	6878      	ldr	r0, [r7, #4]
2400f15c:	4798      	blx	r3
      }
    }
  }

  /* Repeated Block Transfer Complete Interrupt management ******************************/
  if((__HAL_MDMA_GET_FLAG(hmdma, MDMA_FLAG_BRT) != 0U))
2400f15e:	687b      	ldr	r3, [r7, #4]
2400f160:	681b      	ldr	r3, [r3, #0]
2400f162:	681b      	ldr	r3, [r3, #0]
2400f164:	f003 0304 	and.w	r3, r3, #4
2400f168:	2b00      	cmp	r3, #0
2400f16a:	d012      	beq.n	2400f192 <HAL_MDMA_IRQHandler+0x196>
  {
    if(__HAL_MDMA_GET_IT_SOURCE(hmdma, MDMA_IT_BRT) != 0U)
2400f16c:	687b      	ldr	r3, [r7, #4]
2400f16e:	681b      	ldr	r3, [r3, #0]
2400f170:	68db      	ldr	r3, [r3, #12]
2400f172:	f003 0308 	and.w	r3, r3, #8
2400f176:	2b00      	cmp	r3, #0
2400f178:	d00b      	beq.n	2400f192 <HAL_MDMA_IRQHandler+0x196>
    {
      /* Clear the repeat block transfer complete flag */
      __HAL_MDMA_CLEAR_FLAG(hmdma, MDMA_FLAG_BRT);
2400f17a:	687b      	ldr	r3, [r7, #4]
2400f17c:	681b      	ldr	r3, [r3, #0]
2400f17e:	2204      	movs	r2, #4
2400f180:	605a      	str	r2, [r3, #4]

      if(hmdma->XferRepeatBlockCpltCallback != NULL)
2400f182:	687b      	ldr	r3, [r7, #4]
2400f184:	6d1b      	ldr	r3, [r3, #80]	; 0x50
2400f186:	2b00      	cmp	r3, #0
2400f188:	d003      	beq.n	2400f192 <HAL_MDMA_IRQHandler+0x196>
      {
        /* Repeated Block transfer callback */
        hmdma->XferRepeatBlockCpltCallback(hmdma);
2400f18a:	687b      	ldr	r3, [r7, #4]
2400f18c:	6d1b      	ldr	r3, [r3, #80]	; 0x50
2400f18e:	6878      	ldr	r0, [r7, #4]
2400f190:	4798      	blx	r3
      }
    }
  }

  /* Channel Transfer Complete Interrupt management ***********************************/
  if((__HAL_MDMA_GET_FLAG(hmdma, MDMA_FLAG_CTC) != 0U))
2400f192:	687b      	ldr	r3, [r7, #4]
2400f194:	681b      	ldr	r3, [r3, #0]
2400f196:	681b      	ldr	r3, [r3, #0]
2400f198:	f003 0302 	and.w	r3, r3, #2
2400f19c:	2b00      	cmp	r3, #0
2400f19e:	d039      	beq.n	2400f214 <HAL_MDMA_IRQHandler+0x218>
  {
    if(__HAL_MDMA_GET_IT_SOURCE(hmdma, MDMA_IT_CTC) != 0U)
2400f1a0:	687b      	ldr	r3, [r7, #4]
2400f1a2:	681b      	ldr	r3, [r3, #0]
2400f1a4:	68db      	ldr	r3, [r3, #12]
2400f1a6:	f003 0304 	and.w	r3, r3, #4
2400f1aa:	2b00      	cmp	r3, #0
2400f1ac:	d032      	beq.n	2400f214 <HAL_MDMA_IRQHandler+0x218>
    {
      /* Disable all the transfer interrupts */
      __HAL_MDMA_DISABLE_IT(hmdma, (MDMA_IT_TE | MDMA_IT_CTC | MDMA_IT_BT | MDMA_IT_BRT | MDMA_IT_BFTC));
2400f1ae:	687b      	ldr	r3, [r7, #4]
2400f1b0:	681b      	ldr	r3, [r3, #0]
2400f1b2:	68da      	ldr	r2, [r3, #12]
2400f1b4:	687b      	ldr	r3, [r7, #4]
2400f1b6:	681b      	ldr	r3, [r3, #0]
2400f1b8:	f022 023e 	bic.w	r2, r2, #62	; 0x3e
2400f1bc:	60da      	str	r2, [r3, #12]

      if(HAL_MDMA_STATE_ABORT == hmdma->State)
2400f1be:	687b      	ldr	r3, [r7, #4]
2400f1c0:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
2400f1c4:	b2db      	uxtb	r3, r3
2400f1c6:	2b04      	cmp	r3, #4
2400f1c8:	d110      	bne.n	2400f1ec <HAL_MDMA_IRQHandler+0x1f0>
      {
        /* Process Unlocked */
        __HAL_UNLOCK(hmdma);
2400f1ca:	687b      	ldr	r3, [r7, #4]
2400f1cc:	2200      	movs	r2, #0
2400f1ce:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

        /* Change the DMA state */
        hmdma->State = HAL_MDMA_STATE_READY;
2400f1d2:	687b      	ldr	r3, [r7, #4]
2400f1d4:	2201      	movs	r2, #1
2400f1d6:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

        if(hmdma->XferAbortCallback != NULL)
2400f1da:	687b      	ldr	r3, [r7, #4]
2400f1dc:	6d9b      	ldr	r3, [r3, #88]	; 0x58
2400f1de:	2b00      	cmp	r3, #0
2400f1e0:	d05d      	beq.n	2400f29e <HAL_MDMA_IRQHandler+0x2a2>
        {
          hmdma->XferAbortCallback(hmdma);
2400f1e2:	687b      	ldr	r3, [r7, #4]
2400f1e4:	6d9b      	ldr	r3, [r3, #88]	; 0x58
2400f1e6:	6878      	ldr	r0, [r7, #4]
2400f1e8:	4798      	blx	r3
        }
        return;
2400f1ea:	e058      	b.n	2400f29e <HAL_MDMA_IRQHandler+0x2a2>
      }

      /* Clear the Channel Transfer Complete flag */
      __HAL_MDMA_CLEAR_FLAG(hmdma, MDMA_FLAG_CTC);
2400f1ec:	687b      	ldr	r3, [r7, #4]
2400f1ee:	681b      	ldr	r3, [r3, #0]
2400f1f0:	2202      	movs	r2, #2
2400f1f2:	605a      	str	r2, [r3, #4]

      /* Process Unlocked */
      __HAL_UNLOCK(hmdma);
2400f1f4:	687b      	ldr	r3, [r7, #4]
2400f1f6:	2200      	movs	r2, #0
2400f1f8:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

      /* Change MDMA peripheral state */
      hmdma->State = HAL_MDMA_STATE_READY;
2400f1fc:	687b      	ldr	r3, [r7, #4]
2400f1fe:	2201      	movs	r2, #1
2400f200:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

      if(hmdma->XferCpltCallback != NULL)
2400f204:	687b      	ldr	r3, [r7, #4]
2400f206:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400f208:	2b00      	cmp	r3, #0
2400f20a:	d003      	beq.n	2400f214 <HAL_MDMA_IRQHandler+0x218>
      {
        /* Channel Transfer Complete callback */
        hmdma->XferCpltCallback(hmdma);
2400f20c:	687b      	ldr	r3, [r7, #4]
2400f20e:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400f210:	6878      	ldr	r0, [r7, #4]
2400f212:	4798      	blx	r3
      }
    }
  }

  /* manage error case */
  if(hmdma->ErrorCode != HAL_MDMA_ERROR_NONE)
2400f214:	687b      	ldr	r3, [r7, #4]
2400f216:	6e9b      	ldr	r3, [r3, #104]	; 0x68
2400f218:	2b00      	cmp	r3, #0
2400f21a:	d041      	beq.n	2400f2a0 <HAL_MDMA_IRQHandler+0x2a4>
  {
    hmdma->State = HAL_MDMA_STATE_ABORT;
2400f21c:	687b      	ldr	r3, [r7, #4]
2400f21e:	2204      	movs	r2, #4
2400f220:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

    /* Disable the channel */
    __HAL_MDMA_DISABLE(hmdma);
2400f224:	687b      	ldr	r3, [r7, #4]
2400f226:	681b      	ldr	r3, [r3, #0]
2400f228:	68da      	ldr	r2, [r3, #12]
2400f22a:	687b      	ldr	r3, [r7, #4]
2400f22c:	681b      	ldr	r3, [r3, #0]
2400f22e:	f022 0201 	bic.w	r2, r2, #1
2400f232:	60da      	str	r2, [r3, #12]

    do
    {
      if (++count > timeout)
2400f234:	68bb      	ldr	r3, [r7, #8]
2400f236:	3301      	adds	r3, #1
2400f238:	60bb      	str	r3, [r7, #8]
2400f23a:	697a      	ldr	r2, [r7, #20]
2400f23c:	429a      	cmp	r2, r3
2400f23e:	d307      	bcc.n	2400f250 <HAL_MDMA_IRQHandler+0x254>
      {
        break;
      }
    }
    while((hmdma->Instance->CCR & MDMA_CCR_EN) != 0U);
2400f240:	687b      	ldr	r3, [r7, #4]
2400f242:	681b      	ldr	r3, [r3, #0]
2400f244:	68db      	ldr	r3, [r3, #12]
2400f246:	f003 0301 	and.w	r3, r3, #1
2400f24a:	2b00      	cmp	r3, #0
2400f24c:	d1f2      	bne.n	2400f234 <HAL_MDMA_IRQHandler+0x238>
2400f24e:	e000      	b.n	2400f252 <HAL_MDMA_IRQHandler+0x256>
        break;
2400f250:	bf00      	nop

    /* Process Unlocked */
    __HAL_UNLOCK(hmdma);
2400f252:	687b      	ldr	r3, [r7, #4]
2400f254:	2200      	movs	r2, #0
2400f256:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

    if((hmdma->Instance->CCR & MDMA_CCR_EN) != 0U)
2400f25a:	687b      	ldr	r3, [r7, #4]
2400f25c:	681b      	ldr	r3, [r3, #0]
2400f25e:	68db      	ldr	r3, [r3, #12]
2400f260:	f003 0301 	and.w	r3, r3, #1
2400f264:	2b00      	cmp	r3, #0
2400f266:	d00b      	beq.n	2400f280 <HAL_MDMA_IRQHandler+0x284>
    {
      /* Change the MDMA state to error if MDMA disable fails */
      hmdma->State = HAL_MDMA_STATE_ERROR;
2400f268:	687b      	ldr	r3, [r7, #4]
2400f26a:	2203      	movs	r2, #3
2400f26c:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
2400f270:	e00a      	b.n	2400f288 <HAL_MDMA_IRQHandler+0x28c>
2400f272:	bf00      	nop
2400f274:	240004b8 	.word	0x240004b8
2400f278:	1b4e81b5 	.word	0x1b4e81b5
2400f27c:	adffffc0 	.word	0xadffffc0
    }
    else
    {
      /* Change the MDMA state to Ready if MDMA disable success */
      hmdma->State = HAL_MDMA_STATE_READY;
2400f280:	687b      	ldr	r3, [r7, #4]
2400f282:	2201      	movs	r2, #1
2400f284:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
    }


    if (hmdma->XferErrorCallback != NULL)
2400f288:	687b      	ldr	r3, [r7, #4]
2400f28a:	6d5b      	ldr	r3, [r3, #84]	; 0x54
2400f28c:	2b00      	cmp	r3, #0
2400f28e:	d007      	beq.n	2400f2a0 <HAL_MDMA_IRQHandler+0x2a4>
    {
      /* Transfer error callback */
      hmdma->XferErrorCallback(hmdma);
2400f290:	687b      	ldr	r3, [r7, #4]
2400f292:	6d5b      	ldr	r3, [r3, #84]	; 0x54
2400f294:	6878      	ldr	r0, [r7, #4]
2400f296:	4798      	blx	r3
2400f298:	e002      	b.n	2400f2a0 <HAL_MDMA_IRQHandler+0x2a4>
    return; /* the  General interrupt flag for the current channel is down , nothing to do */
2400f29a:	bf00      	nop
2400f29c:	e000      	b.n	2400f2a0 <HAL_MDMA_IRQHandler+0x2a4>
        return;
2400f29e:	bf00      	nop
    }
  }
}
2400f2a0:	3718      	adds	r7, #24
2400f2a2:	46bd      	mov	sp, r7
2400f2a4:	bd80      	pop	{r7, pc}
2400f2a6:	bf00      	nop

2400f2a8 <HAL_MDMA_GetState>:
  * @param  hmdma: pointer to a MDMA_HandleTypeDef structure that contains
  *               the configuration information for the specified MDMA Channel.
  * @retval HAL state
  */
HAL_MDMA_StateTypeDef HAL_MDMA_GetState(MDMA_HandleTypeDef *hmdma)
{
2400f2a8:	b480      	push	{r7}
2400f2aa:	b083      	sub	sp, #12
2400f2ac:	af00      	add	r7, sp, #0
2400f2ae:	6078      	str	r0, [r7, #4]
  return hmdma->State;
2400f2b0:	687b      	ldr	r3, [r7, #4]
2400f2b2:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
2400f2b6:	b2db      	uxtb	r3, r3
}
2400f2b8:	4618      	mov	r0, r3
2400f2ba:	370c      	adds	r7, #12
2400f2bc:	46bd      	mov	sp, r7
2400f2be:	f85d 7b04 	ldr.w	r7, [sp], #4
2400f2c2:	4770      	bx	lr

2400f2c4 <HAL_MDMA_GetError>:
  * @param  hmdma : pointer to a MDMA_HandleTypeDef structure that contains
  *              the configuration information for the specified MDMA Channel.
  * @retval MDMA Error Code
  */
uint32_t HAL_MDMA_GetError(MDMA_HandleTypeDef *hmdma)
{
2400f2c4:	b480      	push	{r7}
2400f2c6:	b083      	sub	sp, #12
2400f2c8:	af00      	add	r7, sp, #0
2400f2ca:	6078      	str	r0, [r7, #4]
  return hmdma->ErrorCode;
2400f2cc:	687b      	ldr	r3, [r7, #4]
2400f2ce:	6e9b      	ldr	r3, [r3, #104]	; 0x68
}
2400f2d0:	4618      	mov	r0, r3
2400f2d2:	370c      	adds	r7, #12
2400f2d4:	46bd      	mov	sp, r7
2400f2d6:	f85d 7b04 	ldr.w	r7, [sp], #4
2400f2da:	4770      	bx	lr

2400f2dc <MDMA_SetConfig>:
  * @param  BlockDataLength : The length of a block transfer in bytes
  * @param  BlockCount: The number of blocks to be transfered
  * @retval HAL status
  */
static void MDMA_SetConfig(MDMA_HandleTypeDef *hmdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t BlockDataLength, uint32_t BlockCount)
{
2400f2dc:	b480      	push	{r7}
2400f2de:	b087      	sub	sp, #28
2400f2e0:	af00      	add	r7, sp, #0
2400f2e2:	60f8      	str	r0, [r7, #12]
2400f2e4:	60b9      	str	r1, [r7, #8]
2400f2e6:	607a      	str	r2, [r7, #4]
2400f2e8:	603b      	str	r3, [r7, #0]
  uint32_t addressMask;

  /* Configure the MDMA Channel data length */
  MODIFY_REG(hmdma->Instance->CBNDTR ,MDMA_CBNDTR_BNDT, (BlockDataLength & MDMA_CBNDTR_BNDT));
2400f2ea:	68fb      	ldr	r3, [r7, #12]
2400f2ec:	681b      	ldr	r3, [r3, #0]
2400f2ee:	695a      	ldr	r2, [r3, #20]
2400f2f0:	4b31      	ldr	r3, [pc, #196]	; (2400f3b8 <MDMA_SetConfig+0xdc>)
2400f2f2:	4013      	ands	r3, r2
2400f2f4:	683a      	ldr	r2, [r7, #0]
2400f2f6:	f3c2 0110 	ubfx	r1, r2, #0, #17
2400f2fa:	68fa      	ldr	r2, [r7, #12]
2400f2fc:	6812      	ldr	r2, [r2, #0]
2400f2fe:	430b      	orrs	r3, r1
2400f300:	6153      	str	r3, [r2, #20]

  /* Configure the MDMA block repeat count */
  MODIFY_REG(hmdma->Instance->CBNDTR , MDMA_CBNDTR_BRC , ((BlockCount - 1U) << MDMA_CBNDTR_BRC_Pos) & MDMA_CBNDTR_BRC);
2400f302:	68fb      	ldr	r3, [r7, #12]
2400f304:	681b      	ldr	r3, [r3, #0]
2400f306:	695b      	ldr	r3, [r3, #20]
2400f308:	f3c3 0113 	ubfx	r1, r3, #0, #20
2400f30c:	6a3b      	ldr	r3, [r7, #32]
2400f30e:	3b01      	subs	r3, #1
2400f310:	051a      	lsls	r2, r3, #20
2400f312:	68fb      	ldr	r3, [r7, #12]
2400f314:	681b      	ldr	r3, [r3, #0]
2400f316:	430a      	orrs	r2, r1
2400f318:	615a      	str	r2, [r3, #20]

  /* Clear all interrupt flags */
  __HAL_MDMA_CLEAR_FLAG(hmdma, MDMA_FLAG_TE | MDMA_FLAG_CTC | MDMA_CISR_BRTIF | MDMA_CISR_BTIF | MDMA_CISR_TCIF);
2400f31a:	68fb      	ldr	r3, [r7, #12]
2400f31c:	681b      	ldr	r3, [r3, #0]
2400f31e:	221f      	movs	r2, #31
2400f320:	605a      	str	r2, [r3, #4]

  /* Configure MDMA Channel destination address */
  hmdma->Instance->CDAR = DstAddress;
2400f322:	68fb      	ldr	r3, [r7, #12]
2400f324:	681b      	ldr	r3, [r3, #0]
2400f326:	687a      	ldr	r2, [r7, #4]
2400f328:	61da      	str	r2, [r3, #28]

  /* Configure MDMA Channel Source address */
  hmdma->Instance->CSAR = SrcAddress;
2400f32a:	68fb      	ldr	r3, [r7, #12]
2400f32c:	681b      	ldr	r3, [r3, #0]
2400f32e:	68ba      	ldr	r2, [r7, #8]
2400f330:	619a      	str	r2, [r3, #24]

  addressMask = SrcAddress & 0xFF000000U;
2400f332:	68bb      	ldr	r3, [r7, #8]
2400f334:	f003 437f 	and.w	r3, r3, #4278190080	; 0xff000000
2400f338:	617b      	str	r3, [r7, #20]
  if((addressMask == 0x20000000U) || (addressMask == 0x00000000U))
2400f33a:	697b      	ldr	r3, [r7, #20]
2400f33c:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
2400f340:	d002      	beq.n	2400f348 <MDMA_SetConfig+0x6c>
2400f342:	697b      	ldr	r3, [r7, #20]
2400f344:	2b00      	cmp	r3, #0
2400f346:	d108      	bne.n	2400f35a <MDMA_SetConfig+0x7e>
  {
    /*The AHBSbus is used as source (read operation) on channel x */
    hmdma->Instance->CTBR |= MDMA_CTBR_SBUS;
2400f348:	68fb      	ldr	r3, [r7, #12]
2400f34a:	681b      	ldr	r3, [r3, #0]
2400f34c:	6a9a      	ldr	r2, [r3, #40]	; 0x28
2400f34e:	68fb      	ldr	r3, [r7, #12]
2400f350:	681b      	ldr	r3, [r3, #0]
2400f352:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
2400f356:	629a      	str	r2, [r3, #40]	; 0x28
2400f358:	e007      	b.n	2400f36a <MDMA_SetConfig+0x8e>
  }
  else
  {
    /*The AXI bus is used as source (read operation) on channel x */
    hmdma->Instance->CTBR &= (~MDMA_CTBR_SBUS);
2400f35a:	68fb      	ldr	r3, [r7, #12]
2400f35c:	681b      	ldr	r3, [r3, #0]
2400f35e:	6a9a      	ldr	r2, [r3, #40]	; 0x28
2400f360:	68fb      	ldr	r3, [r7, #12]
2400f362:	681b      	ldr	r3, [r3, #0]
2400f364:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
2400f368:	629a      	str	r2, [r3, #40]	; 0x28
  }

  addressMask = DstAddress & 0xFF000000U;
2400f36a:	687b      	ldr	r3, [r7, #4]
2400f36c:	f003 437f 	and.w	r3, r3, #4278190080	; 0xff000000
2400f370:	617b      	str	r3, [r7, #20]
  if((addressMask == 0x20000000U) || (addressMask == 0x00000000U))
2400f372:	697b      	ldr	r3, [r7, #20]
2400f374:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
2400f378:	d002      	beq.n	2400f380 <MDMA_SetConfig+0xa4>
2400f37a:	697b      	ldr	r3, [r7, #20]
2400f37c:	2b00      	cmp	r3, #0
2400f37e:	d108      	bne.n	2400f392 <MDMA_SetConfig+0xb6>
  {
    /*The AHB bus is used as destination (write operation) on channel x */
    hmdma->Instance->CTBR |= MDMA_CTBR_DBUS;
2400f380:	68fb      	ldr	r3, [r7, #12]
2400f382:	681b      	ldr	r3, [r3, #0]
2400f384:	6a9a      	ldr	r2, [r3, #40]	; 0x28
2400f386:	68fb      	ldr	r3, [r7, #12]
2400f388:	681b      	ldr	r3, [r3, #0]
2400f38a:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
2400f38e:	629a      	str	r2, [r3, #40]	; 0x28
2400f390:	e007      	b.n	2400f3a2 <MDMA_SetConfig+0xc6>
  }
  else
  {
    /*The AXI bus is used as destination (write operation) on channel x */
    hmdma->Instance->CTBR &= (~MDMA_CTBR_DBUS);
2400f392:	68fb      	ldr	r3, [r7, #12]
2400f394:	681b      	ldr	r3, [r3, #0]
2400f396:	6a9a      	ldr	r2, [r3, #40]	; 0x28
2400f398:	68fb      	ldr	r3, [r7, #12]
2400f39a:	681b      	ldr	r3, [r3, #0]
2400f39c:	f422 3200 	bic.w	r2, r2, #131072	; 0x20000
2400f3a0:	629a      	str	r2, [r3, #40]	; 0x28
  }

  /* Set the linked list register to the first node of the list */
  hmdma->Instance->CLAR = (uint32_t)hmdma->FirstLinkedListNodeAddress;
2400f3a2:	68fb      	ldr	r3, [r7, #12]
2400f3a4:	6dda      	ldr	r2, [r3, #92]	; 0x5c
2400f3a6:	68fb      	ldr	r3, [r7, #12]
2400f3a8:	681b      	ldr	r3, [r3, #0]
2400f3aa:	625a      	str	r2, [r3, #36]	; 0x24
}
2400f3ac:	bf00      	nop
2400f3ae:	371c      	adds	r7, #28
2400f3b0:	46bd      	mov	sp, r7
2400f3b2:	f85d 7b04 	ldr.w	r7, [sp], #4
2400f3b6:	4770      	bx	lr
2400f3b8:	fffe0000 	.word	0xfffe0000

2400f3bc <MDMA_Init>:
  * @param  hmdma:       pointer to a MDMA_HandleTypeDef structure that contains
  *                     the configuration information for the specified MDMA Channel.
  * @retval None
  */
static void MDMA_Init(MDMA_HandleTypeDef *hmdma)
{
2400f3bc:	b480      	push	{r7}
2400f3be:	b085      	sub	sp, #20
2400f3c0:	af00      	add	r7, sp, #0
2400f3c2:	6078      	str	r0, [r7, #4]
  uint32_t blockoffset;

  /* Prepare the MDMA Channel configuration */
  hmdma->Instance->CCR = hmdma->Init.Priority  | hmdma->Init.Endianness;
2400f3c4:	687b      	ldr	r3, [r7, #4]
2400f3c6:	68d9      	ldr	r1, [r3, #12]
2400f3c8:	687b      	ldr	r3, [r7, #4]
2400f3ca:	691a      	ldr	r2, [r3, #16]
2400f3cc:	687b      	ldr	r3, [r7, #4]
2400f3ce:	681b      	ldr	r3, [r3, #0]
2400f3d0:	430a      	orrs	r2, r1
2400f3d2:	60da      	str	r2, [r3, #12]

  /* Write new CTCR Register value */
  hmdma->Instance->CTCR =  hmdma->Init.SourceInc      | hmdma->Init.DestinationInc | \
2400f3d4:	687b      	ldr	r3, [r7, #4]
2400f3d6:	695a      	ldr	r2, [r3, #20]
2400f3d8:	687b      	ldr	r3, [r7, #4]
2400f3da:	699b      	ldr	r3, [r3, #24]
2400f3dc:	431a      	orrs	r2, r3
                           hmdma->Init.SourceDataSize | hmdma->Init.DestDataSize   | \
2400f3de:	687b      	ldr	r3, [r7, #4]
2400f3e0:	69db      	ldr	r3, [r3, #28]
  hmdma->Instance->CTCR =  hmdma->Init.SourceInc      | hmdma->Init.DestinationInc | \
2400f3e2:	431a      	orrs	r2, r3
                           hmdma->Init.SourceDataSize | hmdma->Init.DestDataSize   | \
2400f3e4:	687b      	ldr	r3, [r7, #4]
2400f3e6:	6a1b      	ldr	r3, [r3, #32]
2400f3e8:	431a      	orrs	r2, r3
                           hmdma->Init.DataAlignment  | hmdma->Init.SourceBurst    | \
2400f3ea:	687b      	ldr	r3, [r7, #4]
2400f3ec:	6a5b      	ldr	r3, [r3, #36]	; 0x24
                           hmdma->Init.SourceDataSize | hmdma->Init.DestDataSize   | \
2400f3ee:	431a      	orrs	r2, r3
                           hmdma->Init.DataAlignment  | hmdma->Init.SourceBurst    | \
2400f3f0:	687b      	ldr	r3, [r7, #4]
2400f3f2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2400f3f4:	431a      	orrs	r2, r3
                           hmdma->Init.DestBurst                                   | \
2400f3f6:	687b      	ldr	r3, [r7, #4]
2400f3f8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
                           hmdma->Init.DataAlignment  | hmdma->Init.SourceBurst    | \
2400f3fa:	431a      	orrs	r2, r3
                           ((hmdma->Init.BufferTransferLength - 1U) << MDMA_CTCR_TLEN_Pos) | \
2400f3fc:	687b      	ldr	r3, [r7, #4]
2400f3fe:	6a9b      	ldr	r3, [r3, #40]	; 0x28
2400f400:	3b01      	subs	r3, #1
2400f402:	049b      	lsls	r3, r3, #18
                           hmdma->Init.DestBurst                                   | \
2400f404:	ea42 0103 	orr.w	r1, r2, r3
                           hmdma->Init.TransferTriggerMode;
2400f408:	687b      	ldr	r3, [r7, #4]
2400f40a:	689a      	ldr	r2, [r3, #8]
  hmdma->Instance->CTCR =  hmdma->Init.SourceInc      | hmdma->Init.DestinationInc | \
2400f40c:	687b      	ldr	r3, [r7, #4]
2400f40e:	681b      	ldr	r3, [r3, #0]
                           ((hmdma->Init.BufferTransferLength - 1U) << MDMA_CTCR_TLEN_Pos) | \
2400f410:	430a      	orrs	r2, r1
  hmdma->Instance->CTCR =  hmdma->Init.SourceInc      | hmdma->Init.DestinationInc | \
2400f412:	611a      	str	r2, [r3, #16]

  /* If SW request set the CTCR register to SW Request Mode */
  if(hmdma->Init.Request == MDMA_REQUEST_SW)
2400f414:	687b      	ldr	r3, [r7, #4]
2400f416:	685b      	ldr	r3, [r3, #4]
2400f418:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
2400f41c:	d107      	bne.n	2400f42e <MDMA_Init+0x72>
    -If the request is done by SW : BWM could be set to 1 or 0.
    -If the request is done by a peripheral :
    If mask address not set (0) => BWM must be set to 0
    If mask address set (different than 0) => BWM could be set to 1 or 0
    */
    hmdma->Instance->CTCR |= (MDMA_CTCR_SWRM | MDMA_CTCR_BWM);
2400f41e:	687b      	ldr	r3, [r7, #4]
2400f420:	681b      	ldr	r3, [r3, #0]
2400f422:	691a      	ldr	r2, [r3, #16]
2400f424:	687b      	ldr	r3, [r7, #4]
2400f426:	681b      	ldr	r3, [r3, #0]
2400f428:	f042 4240 	orr.w	r2, r2, #3221225472	; 0xc0000000
2400f42c:	611a      	str	r2, [r3, #16]
  }

  /* Reset CBNDTR Register */
  hmdma->Instance->CBNDTR = 0;
2400f42e:	687b      	ldr	r3, [r7, #4]
2400f430:	681b      	ldr	r3, [r3, #0]
2400f432:	2200      	movs	r2, #0
2400f434:	615a      	str	r2, [r3, #20]

  /* if block source address offset is negative set the Block Repeat Source address Update Mode to decrement */
  if(hmdma->Init.SourceBlockAddressOffset < 0)
2400f436:	687b      	ldr	r3, [r7, #4]
2400f438:	6b5b      	ldr	r3, [r3, #52]	; 0x34
2400f43a:	2b00      	cmp	r3, #0
2400f43c:	da11      	bge.n	2400f462 <MDMA_Init+0xa6>
  {
    hmdma->Instance->CBNDTR |= MDMA_CBNDTR_BRSUM;
2400f43e:	687b      	ldr	r3, [r7, #4]
2400f440:	681b      	ldr	r3, [r3, #0]
2400f442:	695a      	ldr	r2, [r3, #20]
2400f444:	687b      	ldr	r3, [r7, #4]
2400f446:	681b      	ldr	r3, [r3, #0]
2400f448:	f442 2280 	orr.w	r2, r2, #262144	; 0x40000
2400f44c:	615a      	str	r2, [r3, #20]
    /* Write new CBRUR Register value : source repeat block offset */
    blockoffset = (uint32_t)(- hmdma->Init.SourceBlockAddressOffset);
2400f44e:	687b      	ldr	r3, [r7, #4]
2400f450:	6b5b      	ldr	r3, [r3, #52]	; 0x34
2400f452:	425b      	negs	r3, r3
2400f454:	60fb      	str	r3, [r7, #12]
    hmdma->Instance->CBRUR = (blockoffset & 0x0000FFFFU);
2400f456:	687b      	ldr	r3, [r7, #4]
2400f458:	681b      	ldr	r3, [r3, #0]
2400f45a:	68fa      	ldr	r2, [r7, #12]
2400f45c:	b292      	uxth	r2, r2
2400f45e:	621a      	str	r2, [r3, #32]
2400f460:	e006      	b.n	2400f470 <MDMA_Init+0xb4>
  }
  else
  {
    /* Write new CBRUR Register value : source repeat block offset */
    hmdma->Instance->CBRUR = (((uint32_t)hmdma->Init.SourceBlockAddressOffset) & 0x0000FFFFU);
2400f462:	687b      	ldr	r3, [r7, #4]
2400f464:	6b5b      	ldr	r3, [r3, #52]	; 0x34
2400f466:	461a      	mov	r2, r3
2400f468:	687b      	ldr	r3, [r7, #4]
2400f46a:	681b      	ldr	r3, [r3, #0]
2400f46c:	b292      	uxth	r2, r2
2400f46e:	621a      	str	r2, [r3, #32]
  }

  /* If block destination address offset is negative set the Block Repeat destination address Update Mode to decrement */
  if(hmdma->Init.DestBlockAddressOffset < 0)
2400f470:	687b      	ldr	r3, [r7, #4]
2400f472:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400f474:	2b00      	cmp	r3, #0
2400f476:	da15      	bge.n	2400f4a4 <MDMA_Init+0xe8>
  {
    hmdma->Instance->CBNDTR |= MDMA_CBNDTR_BRDUM;
2400f478:	687b      	ldr	r3, [r7, #4]
2400f47a:	681b      	ldr	r3, [r3, #0]
2400f47c:	695a      	ldr	r2, [r3, #20]
2400f47e:	687b      	ldr	r3, [r7, #4]
2400f480:	681b      	ldr	r3, [r3, #0]
2400f482:	f442 2200 	orr.w	r2, r2, #524288	; 0x80000
2400f486:	615a      	str	r2, [r3, #20]
    /* Write new CBRUR Register value : destination repeat block offset */
    blockoffset = (uint32_t)(- hmdma->Init.DestBlockAddressOffset);
2400f488:	687b      	ldr	r3, [r7, #4]
2400f48a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400f48c:	425b      	negs	r3, r3
2400f48e:	60fb      	str	r3, [r7, #12]
    hmdma->Instance->CBRUR |= ((blockoffset & 0x0000FFFFU) << MDMA_CBRUR_DUV_Pos);
2400f490:	687b      	ldr	r3, [r7, #4]
2400f492:	681b      	ldr	r3, [r3, #0]
2400f494:	6a19      	ldr	r1, [r3, #32]
2400f496:	68fb      	ldr	r3, [r7, #12]
2400f498:	041a      	lsls	r2, r3, #16
2400f49a:	687b      	ldr	r3, [r7, #4]
2400f49c:	681b      	ldr	r3, [r3, #0]
2400f49e:	430a      	orrs	r2, r1
2400f4a0:	621a      	str	r2, [r3, #32]
2400f4a2:	e009      	b.n	2400f4b8 <MDMA_Init+0xfc>
  }
  else
  {
    /*write new CBRUR Register value : destination repeat block offset */
    hmdma->Instance->CBRUR |= ((((uint32_t)hmdma->Init.DestBlockAddressOffset) & 0x0000FFFFU) << MDMA_CBRUR_DUV_Pos);
2400f4a4:	687b      	ldr	r3, [r7, #4]
2400f4a6:	681b      	ldr	r3, [r3, #0]
2400f4a8:	6a19      	ldr	r1, [r3, #32]
2400f4aa:	687b      	ldr	r3, [r7, #4]
2400f4ac:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400f4ae:	041a      	lsls	r2, r3, #16
2400f4b0:	687b      	ldr	r3, [r7, #4]
2400f4b2:	681b      	ldr	r3, [r3, #0]
2400f4b4:	430a      	orrs	r2, r1
2400f4b6:	621a      	str	r2, [r3, #32]
  }

  /* if HW request set the HW request and the requet CleraMask and ClearData MaskData, */
  if(hmdma->Init.Request != MDMA_REQUEST_SW)
2400f4b8:	687b      	ldr	r3, [r7, #4]
2400f4ba:	685b      	ldr	r3, [r3, #4]
2400f4bc:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
2400f4c0:	d006      	beq.n	2400f4d0 <MDMA_Init+0x114>
  {
    /* Set the HW request in CTRB register  */
    hmdma->Instance->CTBR = hmdma->Init.Request & MDMA_CTBR_TSEL;
2400f4c2:	687b      	ldr	r3, [r7, #4]
2400f4c4:	685a      	ldr	r2, [r3, #4]
2400f4c6:	687b      	ldr	r3, [r7, #4]
2400f4c8:	681b      	ldr	r3, [r3, #0]
2400f4ca:	b2d2      	uxtb	r2, r2
2400f4cc:	629a      	str	r2, [r3, #40]	; 0x28
2400f4ce:	e003      	b.n	2400f4d8 <MDMA_Init+0x11c>
  }
  else /* SW request : reset the CTBR register */
  {
    hmdma->Instance->CTBR = 0;
2400f4d0:	687b      	ldr	r3, [r7, #4]
2400f4d2:	681b      	ldr	r3, [r3, #0]
2400f4d4:	2200      	movs	r2, #0
2400f4d6:	629a      	str	r2, [r3, #40]	; 0x28
  }

  /* Write Link Address Register */
  hmdma->Instance->CLAR =  0;
2400f4d8:	687b      	ldr	r3, [r7, #4]
2400f4da:	681b      	ldr	r3, [r3, #0]
2400f4dc:	2200      	movs	r2, #0
2400f4de:	625a      	str	r2, [r3, #36]	; 0x24
}
2400f4e0:	bf00      	nop
2400f4e2:	3714      	adds	r7, #20
2400f4e4:	46bd      	mov	sp, r7
2400f4e6:	f85d 7b04 	ldr.w	r7, [sp], #4
2400f4ea:	4770      	bx	lr

2400f4ec <HAL_PWR_DeInit>:
  *         The prototype is kept just to maintain compatibility with other
  *         products.
  * @retval None.
  */
void HAL_PWR_DeInit (void)
{
2400f4ec:	b480      	push	{r7}
2400f4ee:	af00      	add	r7, sp, #0
}
2400f4f0:	bf00      	nop
2400f4f2:	46bd      	mov	sp, r7
2400f4f4:	f85d 7b04 	ldr.w	r7, [sp], #4
2400f4f8:	4770      	bx	lr
	...

2400f4fc <HAL_PWR_EnableBkUpAccess>:
  * @note   If the HSE divided by 2, 3, ..31 is used as the RTC clock, the
  *         Backup Domain Access should be kept enabled.
  * @retval None.
  */
void HAL_PWR_EnableBkUpAccess (void)
{
2400f4fc:	b480      	push	{r7}
2400f4fe:	af00      	add	r7, sp, #0
  /* Enable access to RTC and backup registers */
  SET_BIT (PWR->CR1, PWR_CR1_DBP);
2400f500:	4b05      	ldr	r3, [pc, #20]	; (2400f518 <HAL_PWR_EnableBkUpAccess+0x1c>)
2400f502:	681b      	ldr	r3, [r3, #0]
2400f504:	4a04      	ldr	r2, [pc, #16]	; (2400f518 <HAL_PWR_EnableBkUpAccess+0x1c>)
2400f506:	f443 7380 	orr.w	r3, r3, #256	; 0x100
2400f50a:	6013      	str	r3, [r2, #0]
}
2400f50c:	bf00      	nop
2400f50e:	46bd      	mov	sp, r7
2400f510:	f85d 7b04 	ldr.w	r7, [sp], #4
2400f514:	4770      	bx	lr
2400f516:	bf00      	nop
2400f518:	58024800 	.word	0x58024800

2400f51c <HAL_PWR_DisableBkUpAccess>:
  * @note   If the HSE divided by 2, 3, ..31 is used as the RTC clock, the
  *         Backup Domain Access should be kept enabled.
  * @retval None.
  */
void HAL_PWR_DisableBkUpAccess (void)
{
2400f51c:	b480      	push	{r7}
2400f51e:	af00      	add	r7, sp, #0
  /* Disable access to RTC and backup registers */
  CLEAR_BIT (PWR->CR1, PWR_CR1_DBP);
2400f520:	4b05      	ldr	r3, [pc, #20]	; (2400f538 <HAL_PWR_DisableBkUpAccess+0x1c>)
2400f522:	681b      	ldr	r3, [r3, #0]
2400f524:	4a04      	ldr	r2, [pc, #16]	; (2400f538 <HAL_PWR_DisableBkUpAccess+0x1c>)
2400f526:	f423 7380 	bic.w	r3, r3, #256	; 0x100
2400f52a:	6013      	str	r3, [r2, #0]
}
2400f52c:	bf00      	nop
2400f52e:	46bd      	mov	sp, r7
2400f530:	f85d 7b04 	ldr.w	r7, [sp], #4
2400f534:	4770      	bx	lr
2400f536:	bf00      	nop
2400f538:	58024800 	.word	0x58024800

2400f53c <HAL_PWR_ConfigPVD>:
  *         driver. All combination are allowed: wake up only Cortex-M7, wake up
  *         only Cortex-M4 or wake up Cortex-M7 and Cortex-M4.
  * @retval None.
  */
void HAL_PWR_ConfigPVD (PWR_PVDTypeDef *sConfigPVD)
{
2400f53c:	b480      	push	{r7}
2400f53e:	b083      	sub	sp, #12
2400f540:	af00      	add	r7, sp, #0
2400f542:	6078      	str	r0, [r7, #4]
  /* Check the PVD configuration parameter */
  if (sConfigPVD == NULL)
2400f544:	687b      	ldr	r3, [r7, #4]
2400f546:	2b00      	cmp	r3, #0
2400f548:	d069      	beq.n	2400f61e <HAL_PWR_ConfigPVD+0xe2>
  /* Check the parameters */
  assert_param (IS_PWR_PVD_LEVEL (sConfigPVD->PVDLevel));
  assert_param (IS_PWR_PVD_MODE (sConfigPVD->Mode));

  /* Set PLS[7:5] bits according to PVDLevel value */
  MODIFY_REG (PWR->CR1, PWR_CR1_PLS, sConfigPVD->PVDLevel);
2400f54a:	4b38      	ldr	r3, [pc, #224]	; (2400f62c <HAL_PWR_ConfigPVD+0xf0>)
2400f54c:	681b      	ldr	r3, [r3, #0]
2400f54e:	f023 02e0 	bic.w	r2, r3, #224	; 0xe0
2400f552:	687b      	ldr	r3, [r7, #4]
2400f554:	681b      	ldr	r3, [r3, #0]
2400f556:	4935      	ldr	r1, [pc, #212]	; (2400f62c <HAL_PWR_ConfigPVD+0xf0>)
2400f558:	4313      	orrs	r3, r2
2400f55a:	600b      	str	r3, [r1, #0]

  /* Clear previous config */
#if !defined (DUAL_CORE)
  __HAL_PWR_PVD_EXTI_DISABLE_EVENT ();
2400f55c:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
2400f560:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
2400f564:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
2400f568:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
2400f56c:	f8c2 3084 	str.w	r3, [r2, #132]	; 0x84
  __HAL_PWR_PVD_EXTI_DISABLE_IT ();
2400f570:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
2400f574:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
2400f578:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
2400f57c:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
2400f580:	f8c2 3080 	str.w	r3, [r2, #128]	; 0x80
#endif /* !defined (DUAL_CORE) */

  __HAL_PWR_PVD_EXTI_DISABLE_RISING_EDGE ();
2400f584:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
2400f588:	681b      	ldr	r3, [r3, #0]
2400f58a:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
2400f58e:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
2400f592:	6013      	str	r3, [r2, #0]
  __HAL_PWR_PVD_EXTI_DISABLE_FALLING_EDGE ();
2400f594:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
2400f598:	685b      	ldr	r3, [r3, #4]
2400f59a:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
2400f59e:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
2400f5a2:	6053      	str	r3, [r2, #4]

#if !defined (DUAL_CORE)
  /* Interrupt mode configuration */
  if ((sConfigPVD->Mode & PVD_MODE_IT) == PVD_MODE_IT)
2400f5a4:	687b      	ldr	r3, [r7, #4]
2400f5a6:	685b      	ldr	r3, [r3, #4]
2400f5a8:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
2400f5ac:	2b00      	cmp	r3, #0
2400f5ae:	d009      	beq.n	2400f5c4 <HAL_PWR_ConfigPVD+0x88>
  {
    __HAL_PWR_PVD_EXTI_ENABLE_IT ();
2400f5b0:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
2400f5b4:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
2400f5b8:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
2400f5bc:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
2400f5c0:	f8c2 3080 	str.w	r3, [r2, #128]	; 0x80
  }

  /* Event mode configuration */
  if ((sConfigPVD->Mode & PVD_MODE_EVT) == PVD_MODE_EVT)
2400f5c4:	687b      	ldr	r3, [r7, #4]
2400f5c6:	685b      	ldr	r3, [r3, #4]
2400f5c8:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
2400f5cc:	2b00      	cmp	r3, #0
2400f5ce:	d009      	beq.n	2400f5e4 <HAL_PWR_ConfigPVD+0xa8>
  {
    __HAL_PWR_PVD_EXTI_ENABLE_EVENT ();
2400f5d0:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
2400f5d4:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
2400f5d8:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
2400f5dc:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
2400f5e0:	f8c2 3084 	str.w	r3, [r2, #132]	; 0x84
  }
#endif /* !defined (DUAL_CORE) */

  /* Rising edge configuration */
  if ((sConfigPVD->Mode & PVD_RISING_EDGE) == PVD_RISING_EDGE)
2400f5e4:	687b      	ldr	r3, [r7, #4]
2400f5e6:	685b      	ldr	r3, [r3, #4]
2400f5e8:	f003 0301 	and.w	r3, r3, #1
2400f5ec:	2b00      	cmp	r3, #0
2400f5ee:	d007      	beq.n	2400f600 <HAL_PWR_ConfigPVD+0xc4>
  {
    __HAL_PWR_PVD_EXTI_ENABLE_RISING_EDGE ();
2400f5f0:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
2400f5f4:	681b      	ldr	r3, [r3, #0]
2400f5f6:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
2400f5fa:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
2400f5fe:	6013      	str	r3, [r2, #0]
  }

  /* Falling edge configuration */
  if ((sConfigPVD->Mode & PVD_FALLING_EDGE) == PVD_FALLING_EDGE)
2400f600:	687b      	ldr	r3, [r7, #4]
2400f602:	685b      	ldr	r3, [r3, #4]
2400f604:	f003 0302 	and.w	r3, r3, #2
2400f608:	2b00      	cmp	r3, #0
2400f60a:	d009      	beq.n	2400f620 <HAL_PWR_ConfigPVD+0xe4>
  {
    __HAL_PWR_PVD_EXTI_ENABLE_FALLING_EDGE ();
2400f60c:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
2400f610:	685b      	ldr	r3, [r3, #4]
2400f612:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
2400f616:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
2400f61a:	6053      	str	r3, [r2, #4]
2400f61c:	e000      	b.n	2400f620 <HAL_PWR_ConfigPVD+0xe4>
    return;
2400f61e:	bf00      	nop
  }
}
2400f620:	370c      	adds	r7, #12
2400f622:	46bd      	mov	sp, r7
2400f624:	f85d 7b04 	ldr.w	r7, [sp], #4
2400f628:	4770      	bx	lr
2400f62a:	bf00      	nop
2400f62c:	58024800 	.word	0x58024800

2400f630 <HAL_PWR_EnablePVD>:
/**
  * @brief Enable the Programmable Voltage Detector (PVD).
  * @retval None.
  */
void HAL_PWR_EnablePVD (void)
{
2400f630:	b480      	push	{r7}
2400f632:	af00      	add	r7, sp, #0
  /* Enable the power voltage detector */
  SET_BIT (PWR->CR1, PWR_CR1_PVDEN);
2400f634:	4b05      	ldr	r3, [pc, #20]	; (2400f64c <HAL_PWR_EnablePVD+0x1c>)
2400f636:	681b      	ldr	r3, [r3, #0]
2400f638:	4a04      	ldr	r2, [pc, #16]	; (2400f64c <HAL_PWR_EnablePVD+0x1c>)
2400f63a:	f043 0310 	orr.w	r3, r3, #16
2400f63e:	6013      	str	r3, [r2, #0]
}
2400f640:	bf00      	nop
2400f642:	46bd      	mov	sp, r7
2400f644:	f85d 7b04 	ldr.w	r7, [sp], #4
2400f648:	4770      	bx	lr
2400f64a:	bf00      	nop
2400f64c:	58024800 	.word	0x58024800

2400f650 <HAL_PWR_DisablePVD>:
/**
  * @brief Disable the Programmable Voltage Detector (PVD).
  * @retval None.
  */
void HAL_PWR_DisablePVD (void)
{
2400f650:	b480      	push	{r7}
2400f652:	af00      	add	r7, sp, #0
  /* Disable the power voltage detector */
  CLEAR_BIT (PWR->CR1, PWR_CR1_PVDEN);
2400f654:	4b05      	ldr	r3, [pc, #20]	; (2400f66c <HAL_PWR_DisablePVD+0x1c>)
2400f656:	681b      	ldr	r3, [r3, #0]
2400f658:	4a04      	ldr	r2, [pc, #16]	; (2400f66c <HAL_PWR_DisablePVD+0x1c>)
2400f65a:	f023 0310 	bic.w	r3, r3, #16
2400f65e:	6013      	str	r3, [r2, #0]
}
2400f660:	bf00      	nop
2400f662:	46bd      	mov	sp, r7
2400f664:	f85d 7b04 	ldr.w	r7, [sp], #4
2400f668:	4770      	bx	lr
2400f66a:	bf00      	nop
2400f66c:	58024800 	.word	0x58024800

2400f670 <HAL_PWR_EnableWakeUpPin>:
  *                 PWR_WAKEUP_PIN6_HIGH, PWR_WAKEUP_PIN6_LOW.
  * @note   PWR_WAKEUP_PINx and PWR_WAKEUP_PINx_HIGH are equivalent.
  * @retval None.
  */
void HAL_PWR_EnableWakeUpPin (uint32_t WakeUpPinPolarity)
{
2400f670:	b480      	push	{r7}
2400f672:	b083      	sub	sp, #12
2400f674:	af00      	add	r7, sp, #0
2400f676:	6078      	str	r0, [r7, #4]

  /*
     Enable and Specify the Wake-Up pin polarity and the pull configuration
     for the event detection (rising or falling edge).
  */
  MODIFY_REG (PWR->WKUPEPR, PWR_EWUP_MASK, WakeUpPinPolarity);
2400f678:	4b06      	ldr	r3, [pc, #24]	; (2400f694 <HAL_PWR_EnableWakeUpPin+0x24>)
2400f67a:	6a9a      	ldr	r2, [r3, #40]	; 0x28
2400f67c:	4b06      	ldr	r3, [pc, #24]	; (2400f698 <HAL_PWR_EnableWakeUpPin+0x28>)
2400f67e:	4013      	ands	r3, r2
2400f680:	4904      	ldr	r1, [pc, #16]	; (2400f694 <HAL_PWR_EnableWakeUpPin+0x24>)
2400f682:	687a      	ldr	r2, [r7, #4]
2400f684:	4313      	orrs	r3, r2
2400f686:	628b      	str	r3, [r1, #40]	; 0x28
}
2400f688:	bf00      	nop
2400f68a:	370c      	adds	r7, #12
2400f68c:	46bd      	mov	sp, r7
2400f68e:	f85d 7b04 	ldr.w	r7, [sp], #4
2400f692:	4770      	bx	lr
2400f694:	58024800 	.word	0x58024800
2400f698:	f000c0c0 	.word	0xf000c0c0

2400f69c <HAL_PWR_DisableWakeUpPin>:
  *                 PWR_WAKEUP_PIN5_HIGH, PWR_WAKEUP_PIN5_LOW,
  *                 PWR_WAKEUP_PIN6_HIGH, PWR_WAKEUP_PIN6_LOW.
  * @retval None.
  */
void HAL_PWR_DisableWakeUpPin (uint32_t WakeUpPinx)
{
2400f69c:	b480      	push	{r7}
2400f69e:	b083      	sub	sp, #12
2400f6a0:	af00      	add	r7, sp, #0
2400f6a2:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param (IS_PWR_WAKEUP_PIN (WakeUpPinx));

  /* Disable the wake up pin selected */
  CLEAR_BIT (PWR->WKUPEPR, (PWR_WKUPEPR_WKUPEN & WakeUpPinx));
2400f6a4:	4b07      	ldr	r3, [pc, #28]	; (2400f6c4 <HAL_PWR_DisableWakeUpPin+0x28>)
2400f6a6:	6a9a      	ldr	r2, [r3, #40]	; 0x28
2400f6a8:	687b      	ldr	r3, [r7, #4]
2400f6aa:	f003 033f 	and.w	r3, r3, #63	; 0x3f
2400f6ae:	43db      	mvns	r3, r3
2400f6b0:	4904      	ldr	r1, [pc, #16]	; (2400f6c4 <HAL_PWR_DisableWakeUpPin+0x28>)
2400f6b2:	4013      	ands	r3, r2
2400f6b4:	628b      	str	r3, [r1, #40]	; 0x28
}
2400f6b6:	bf00      	nop
2400f6b8:	370c      	adds	r7, #12
2400f6ba:	46bd      	mov	sp, r7
2400f6bc:	f85d 7b04 	ldr.w	r7, [sp], #4
2400f6c0:	4770      	bx	lr
2400f6c2:	bf00      	nop
2400f6c4:	58024800 	.word	0x58024800

2400f6c8 <HAL_PWR_EnterSLEEPMode>:
  * @note   Ensure to clear pending events before calling this API through
  *         HAL_PWREx_ClearPendingEvent() when the SLEEP entry is WFE.
  * @retval None.
  */
void HAL_PWR_EnterSLEEPMode (uint32_t Regulator, uint8_t SLEEPEntry)
{
2400f6c8:	b480      	push	{r7}
2400f6ca:	b083      	sub	sp, #12
2400f6cc:	af00      	add	r7, sp, #0
2400f6ce:	6078      	str	r0, [r7, #4]
2400f6d0:	460b      	mov	r3, r1
2400f6d2:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param (IS_PWR_REGULATOR (Regulator));
  assert_param (IS_PWR_SLEEP_ENTRY (SLEEPEntry));

  /* Clear SLEEPDEEP bit of Cortex System Control Register */
  CLEAR_BIT (SCB->SCR, SCB_SCR_SLEEPDEEP_Msk);
2400f6d4:	4b08      	ldr	r3, [pc, #32]	; (2400f6f8 <HAL_PWR_EnterSLEEPMode+0x30>)
2400f6d6:	691b      	ldr	r3, [r3, #16]
2400f6d8:	4a07      	ldr	r2, [pc, #28]	; (2400f6f8 <HAL_PWR_EnterSLEEPMode+0x30>)
2400f6da:	f023 0304 	bic.w	r3, r3, #4
2400f6de:	6113      	str	r3, [r2, #16]

  /* Select SLEEP mode entry */
  if (SLEEPEntry == PWR_SLEEPENTRY_WFI)
2400f6e0:	78fb      	ldrb	r3, [r7, #3]
2400f6e2:	2b01      	cmp	r3, #1
2400f6e4:	d101      	bne.n	2400f6ea <HAL_PWR_EnterSLEEPMode+0x22>
  {
    /* Request Wait For Interrupt */
    __WFI ();
2400f6e6:	bf30      	wfi
  else
  {
    /* Request Wait For Event */
    __WFE ();
  }
}
2400f6e8:	e000      	b.n	2400f6ec <HAL_PWR_EnterSLEEPMode+0x24>
    __WFE ();
2400f6ea:	bf20      	wfe
}
2400f6ec:	bf00      	nop
2400f6ee:	370c      	adds	r7, #12
2400f6f0:	46bd      	mov	sp, r7
2400f6f2:	f85d 7b04 	ldr.w	r7, [sp], #4
2400f6f6:	4770      	bx	lr
2400f6f8:	e000ed00 	.word	0xe000ed00

2400f6fc <HAL_PWR_EnterSTOPMode>:
  *         is waking up. By keeping the internal regulator ON during STOP mode,
  *         the consumption is higher although the startup time is reduced.
  * @retval None.
  */
void HAL_PWR_EnterSTOPMode (uint32_t Regulator, uint8_t STOPEntry)
{
2400f6fc:	b480      	push	{r7}
2400f6fe:	b083      	sub	sp, #12
2400f700:	af00      	add	r7, sp, #0
2400f702:	6078      	str	r0, [r7, #4]
2400f704:	460b      	mov	r3, r1
2400f706:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param (IS_PWR_REGULATOR (Regulator));
  assert_param (IS_PWR_STOP_ENTRY (STOPEntry));

  /* Select the regulator state in STOP mode */
  MODIFY_REG (PWR->CR1, PWR_CR1_LPDS, Regulator);
2400f708:	4b17      	ldr	r3, [pc, #92]	; (2400f768 <HAL_PWR_EnterSTOPMode+0x6c>)
2400f70a:	681b      	ldr	r3, [r3, #0]
2400f70c:	f023 0201 	bic.w	r2, r3, #1
2400f710:	4915      	ldr	r1, [pc, #84]	; (2400f768 <HAL_PWR_EnterSTOPMode+0x6c>)
2400f712:	687b      	ldr	r3, [r7, #4]
2400f714:	4313      	orrs	r3, r2
2400f716:	600b      	str	r3, [r1, #0]
    /* Keep DSTOP mode when Cortex-M4 enters DEEP-SLEEP */
    CLEAR_BIT (PWR->CPUCR, (PWR_CPUCR_PDDS_D2 | PWR_CPUCR_PDDS_D3));
  }
#else /* Single core devices */
  /* Keep DSTOP mode when Cortex-M7 enter in DEEP-SLEEP */
  CLEAR_BIT (PWR->CPUCR, (PWR_CPUCR_PDDS_D1 | PWR_CPUCR_PDDS_D3));
2400f718:	4b13      	ldr	r3, [pc, #76]	; (2400f768 <HAL_PWR_EnterSTOPMode+0x6c>)
2400f71a:	691b      	ldr	r3, [r3, #16]
2400f71c:	4a12      	ldr	r2, [pc, #72]	; (2400f768 <HAL_PWR_EnterSTOPMode+0x6c>)
2400f71e:	f023 0305 	bic.w	r3, r3, #5
2400f722:	6113      	str	r3, [r2, #16]

#if defined (PWR_CPUCR_PDDS_D2)
  /* Keep DSTOP mode when Cortex-M7 enter in DEEP-SLEEP */
  CLEAR_BIT (PWR->CPUCR, PWR_CPUCR_PDDS_D2);
2400f724:	4b10      	ldr	r3, [pc, #64]	; (2400f768 <HAL_PWR_EnterSTOPMode+0x6c>)
2400f726:	691b      	ldr	r3, [r3, #16]
2400f728:	4a0f      	ldr	r2, [pc, #60]	; (2400f768 <HAL_PWR_EnterSTOPMode+0x6c>)
2400f72a:	f023 0302 	bic.w	r3, r3, #2
2400f72e:	6113      	str	r3, [r2, #16]
#endif /* PWR_CPUCR_PDDS_D2 */
#endif /* defined (DUAL_CORE) */

  /* Set SLEEPDEEP bit of Cortex System Control Register */
  SET_BIT (SCB->SCR, SCB_SCR_SLEEPDEEP_Msk);
2400f730:	4b0e      	ldr	r3, [pc, #56]	; (2400f76c <HAL_PWR_EnterSTOPMode+0x70>)
2400f732:	691b      	ldr	r3, [r3, #16]
2400f734:	4a0d      	ldr	r2, [pc, #52]	; (2400f76c <HAL_PWR_EnterSTOPMode+0x70>)
2400f736:	f043 0304 	orr.w	r3, r3, #4
2400f73a:	6113      	str	r3, [r2, #16]
2400f73c:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
2400f740:	f3bf 8f6f 	isb	sy
  /* Ensure that all instructions are done before entering STOP mode */
  __DSB ();
  __ISB ();

  /* Select STOP mode entry */
  if (STOPEntry == PWR_STOPENTRY_WFI)
2400f744:	78fb      	ldrb	r3, [r7, #3]
2400f746:	2b01      	cmp	r3, #1
2400f748:	d101      	bne.n	2400f74e <HAL_PWR_EnterSTOPMode+0x52>
  {
    /* Request Wait For Interrupt */
    __WFI ();
2400f74a:	bf30      	wfi
2400f74c:	e000      	b.n	2400f750 <HAL_PWR_EnterSTOPMode+0x54>
  }
  else
  {
    /* Request Wait For Event */
    __WFE ();
2400f74e:	bf20      	wfe
  }

  /* Clear SLEEPDEEP bit of Cortex-Mx in the System Control Register */
  CLEAR_BIT (SCB->SCR, SCB_SCR_SLEEPDEEP_Msk);
2400f750:	4b06      	ldr	r3, [pc, #24]	; (2400f76c <HAL_PWR_EnterSTOPMode+0x70>)
2400f752:	691b      	ldr	r3, [r3, #16]
2400f754:	4a05      	ldr	r2, [pc, #20]	; (2400f76c <HAL_PWR_EnterSTOPMode+0x70>)
2400f756:	f023 0304 	bic.w	r3, r3, #4
2400f75a:	6113      	str	r3, [r2, #16]
}
2400f75c:	bf00      	nop
2400f75e:	370c      	adds	r7, #12
2400f760:	46bd      	mov	sp, r7
2400f762:	f85d 7b04 	ldr.w	r7, [sp], #4
2400f766:	4770      	bx	lr
2400f768:	58024800 	.word	0x58024800
2400f76c:	e000ed00 	.word	0xe000ed00

2400f770 <HAL_PWR_EnterSTANDBYMode>:
  * @note   When the System exit STANDBY mode by issuing an interrupt or a
  *         wakeup event, the HSI RC oscillator is selected as system clock.
  * @retval None.
  */
void HAL_PWR_EnterSTANDBYMode (void)
{
2400f770:	b480      	push	{r7}
2400f772:	af00      	add	r7, sp, #0
    SET_BIT (PWR->CPUCR, (PWR_CPUCR_PDDS_D2 | PWR_CPUCR_PDDS_D3));
    SET_BIT (PWR->CPU2CR, (PWR_CPU2CR_PDDS_D2 | PWR_CPU2CR_PDDS_D3));
  }
#else /* Single core devices */
  /* Enter DSTANDBY mode when Cortex-M7 enters DEEP-SLEEP */
  SET_BIT (PWR->CPUCR, (PWR_CPUCR_PDDS_D1 | PWR_CPUCR_PDDS_D3));
2400f774:	4b0d      	ldr	r3, [pc, #52]	; (2400f7ac <HAL_PWR_EnterSTANDBYMode+0x3c>)
2400f776:	691b      	ldr	r3, [r3, #16]
2400f778:	4a0c      	ldr	r2, [pc, #48]	; (2400f7ac <HAL_PWR_EnterSTANDBYMode+0x3c>)
2400f77a:	f043 0305 	orr.w	r3, r3, #5
2400f77e:	6113      	str	r3, [r2, #16]

#if defined (PWR_CPUCR_PDDS_D2)
  /* Enter DSTANDBY mode when Cortex-M7 enters DEEP-SLEEP */
  SET_BIT (PWR->CPUCR, PWR_CPUCR_PDDS_D2);
2400f780:	4b0a      	ldr	r3, [pc, #40]	; (2400f7ac <HAL_PWR_EnterSTANDBYMode+0x3c>)
2400f782:	691b      	ldr	r3, [r3, #16]
2400f784:	4a09      	ldr	r2, [pc, #36]	; (2400f7ac <HAL_PWR_EnterSTANDBYMode+0x3c>)
2400f786:	f043 0302 	orr.w	r3, r3, #2
2400f78a:	6113      	str	r3, [r2, #16]
#endif /* PWR_CPUCR_PDDS_D2 */
#endif /* defined (DUAL_CORE) */

  /* Set SLEEPDEEP bit of Cortex System Control Register */
  SET_BIT (SCB->SCR, SCB_SCR_SLEEPDEEP_Msk);
2400f78c:	4b08      	ldr	r3, [pc, #32]	; (2400f7b0 <HAL_PWR_EnterSTANDBYMode+0x40>)
2400f78e:	691b      	ldr	r3, [r3, #16]
2400f790:	4a07      	ldr	r2, [pc, #28]	; (2400f7b0 <HAL_PWR_EnterSTANDBYMode+0x40>)
2400f792:	f043 0304 	orr.w	r3, r3, #4
2400f796:	6113      	str	r3, [r2, #16]
  __ASM volatile ("dsb 0xF":::"memory");
2400f798:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
2400f79c:	f3bf 8f6f 	isb	sy
#if defined (__CC_ARM)
  __force_stores();
#endif /* defined (__CC_ARM) */

  /* Request Wait For Interrupt */
  __WFI ();
2400f7a0:	bf30      	wfi
}
2400f7a2:	bf00      	nop
2400f7a4:	46bd      	mov	sp, r7
2400f7a6:	f85d 7b04 	ldr.w	r7, [sp], #4
2400f7aa:	4770      	bx	lr
2400f7ac:	58024800 	.word	0x58024800
2400f7b0:	e000ed00 	.word	0xe000ed00

2400f7b4 <HAL_PWR_EnableSleepOnExit>:
  *         Setting this bit is useful when the processor is expected to run
  *         only on interruptions handling.
  * @retval None.
  */
void HAL_PWR_EnableSleepOnExit (void)
{
2400f7b4:	b480      	push	{r7}
2400f7b6:	af00      	add	r7, sp, #0
  /* Set SLEEPONEXIT bit of Cortex-Mx System Control Register */
  SET_BIT (SCB->SCR, SCB_SCR_SLEEPONEXIT_Msk);
2400f7b8:	4b05      	ldr	r3, [pc, #20]	; (2400f7d0 <HAL_PWR_EnableSleepOnExit+0x1c>)
2400f7ba:	691b      	ldr	r3, [r3, #16]
2400f7bc:	4a04      	ldr	r2, [pc, #16]	; (2400f7d0 <HAL_PWR_EnableSleepOnExit+0x1c>)
2400f7be:	f043 0302 	orr.w	r3, r3, #2
2400f7c2:	6113      	str	r3, [r2, #16]
}
2400f7c4:	bf00      	nop
2400f7c6:	46bd      	mov	sp, r7
2400f7c8:	f85d 7b04 	ldr.w	r7, [sp], #4
2400f7cc:	4770      	bx	lr
2400f7ce:	bf00      	nop
2400f7d0:	e000ed00 	.word	0xe000ed00

2400f7d4 <HAL_PWR_DisableSleepOnExit>:
  * @note   Clears SLEEPONEXIT bit of SCR register. When this bit is set, the
  *         processor re-enters SLEEP mode when an interruption handling is over.
  * @retval None
  */
void HAL_PWR_DisableSleepOnExit (void)
{
2400f7d4:	b480      	push	{r7}
2400f7d6:	af00      	add	r7, sp, #0
  /* Clear SLEEPONEXIT bit of Cortex-Mx System Control Register */
  CLEAR_BIT (SCB->SCR, SCB_SCR_SLEEPONEXIT_Msk);
2400f7d8:	4b05      	ldr	r3, [pc, #20]	; (2400f7f0 <HAL_PWR_DisableSleepOnExit+0x1c>)
2400f7da:	691b      	ldr	r3, [r3, #16]
2400f7dc:	4a04      	ldr	r2, [pc, #16]	; (2400f7f0 <HAL_PWR_DisableSleepOnExit+0x1c>)
2400f7de:	f023 0302 	bic.w	r3, r3, #2
2400f7e2:	6113      	str	r3, [r2, #16]
}
2400f7e4:	bf00      	nop
2400f7e6:	46bd      	mov	sp, r7
2400f7e8:	f85d 7b04 	ldr.w	r7, [sp], #4
2400f7ec:	4770      	bx	lr
2400f7ee:	bf00      	nop
2400f7f0:	e000ed00 	.word	0xe000ed00

2400f7f4 <HAL_PWR_EnableSEVOnPend>:
  *         pending event / interrupt even if it's disabled or has insufficient
  *         priority to cause exception entry wakes up the Cortex-Mx.
  * @retval None.
  */
void HAL_PWR_EnableSEVOnPend (void)
{
2400f7f4:	b480      	push	{r7}
2400f7f6:	af00      	add	r7, sp, #0
  /* Set SEVONPEND bit of Cortex-Mx System Control Register */
  SET_BIT (SCB->SCR, SCB_SCR_SEVONPEND_Msk);
2400f7f8:	4b05      	ldr	r3, [pc, #20]	; (2400f810 <HAL_PWR_EnableSEVOnPend+0x1c>)
2400f7fa:	691b      	ldr	r3, [r3, #16]
2400f7fc:	4a04      	ldr	r2, [pc, #16]	; (2400f810 <HAL_PWR_EnableSEVOnPend+0x1c>)
2400f7fe:	f043 0310 	orr.w	r3, r3, #16
2400f802:	6113      	str	r3, [r2, #16]
}
2400f804:	bf00      	nop
2400f806:	46bd      	mov	sp, r7
2400f808:	f85d 7b04 	ldr.w	r7, [sp], #4
2400f80c:	4770      	bx	lr
2400f80e:	bf00      	nop
2400f810:	e000ed00 	.word	0xe000ed00

2400f814 <HAL_PWR_DisableSEVOnPend>:
  * @note   Resets SEVONPEND bit of SCR register. When this bit is reset, only
  *         enabled pending causes exception entry wakes up the Cortex-Mx.
  * @retval None.
  */
void HAL_PWR_DisableSEVOnPend (void)
{
2400f814:	b480      	push	{r7}
2400f816:	af00      	add	r7, sp, #0
  /* Clear SEVONPEND bit of Cortex System Control Register */
  CLEAR_BIT (SCB->SCR, SCB_SCR_SEVONPEND_Msk);
2400f818:	4b05      	ldr	r3, [pc, #20]	; (2400f830 <HAL_PWR_DisableSEVOnPend+0x1c>)
2400f81a:	691b      	ldr	r3, [r3, #16]
2400f81c:	4a04      	ldr	r2, [pc, #16]	; (2400f830 <HAL_PWR_DisableSEVOnPend+0x1c>)
2400f81e:	f023 0310 	bic.w	r3, r3, #16
2400f822:	6113      	str	r3, [r2, #16]
}
2400f824:	bf00      	nop
2400f826:	46bd      	mov	sp, r7
2400f828:	f85d 7b04 	ldr.w	r7, [sp], #4
2400f82c:	4770      	bx	lr
2400f82e:	bf00      	nop
2400f830:	e000ed00 	.word	0xe000ed00

2400f834 <HAL_PWR_PVD_IRQHandler>:
  * @brief  This function handles the PWR PVD interrupt request.
  * @note   This API should be called under the PVD_AVD_IRQHandler().
  * @retval None.
  */
void HAL_PWR_PVD_IRQHandler (void)
{
2400f834:	b580      	push	{r7, lr}
2400f836:	af00      	add	r7, sp, #0
      HAL_PWR_PVDCallback ();
    }
  }
#else /* Single core devices */
  /* PVD EXTI line interrupt detected */
  if (__HAL_PWR_PVD_EXTI_GET_FLAG () != 0U)
2400f838:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
2400f83c:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
2400f840:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
2400f844:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
2400f848:	d10b      	bne.n	2400f862 <HAL_PWR_PVD_IRQHandler+0x2e>
  {
    /* Clear PWR EXTI pending bit */
    __HAL_PWR_PVD_EXTI_CLEAR_FLAG ();
2400f84a:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
2400f84e:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
2400f852:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
2400f856:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
2400f85a:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88

    /* PWR PVD interrupt user callback */
    HAL_PWR_PVDCallback ();
2400f85e:	f000 f802 	bl	2400f866 <HAL_PWR_PVDCallback>
  }
#endif /* defined (DUAL_CORE) */
}
2400f862:	bf00      	nop
2400f864:	bd80      	pop	{r7, pc}

2400f866 <HAL_PWR_PVDCallback>:
/**
  * @brief  PWR PVD interrupt callback.
  * @retval None.
  */
__weak void HAL_PWR_PVDCallback (void)
{
2400f866:	b480      	push	{r7}
2400f868:	af00      	add	r7, sp, #0
  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_PWR_PVDCallback can be implemented in the user file
  */
}
2400f86a:	bf00      	nop
2400f86c:	46bd      	mov	sp, r7
2400f86e:	f85d 7b04 	ldr.w	r7, [sp], #4
2400f872:	4770      	bx	lr

2400f874 <HAL_PWREx_ConfigSupply>:
  *         PWR_SMPS_2V5_SUPPLIES_EXT are used only for lines that supports SMPS
  *         regulator.
  * @retval HAL status.
  */
HAL_StatusTypeDef HAL_PWREx_ConfigSupply (uint32_t SupplySource)
{
2400f874:	b580      	push	{r7, lr}
2400f876:	b084      	sub	sp, #16
2400f878:	af00      	add	r7, sp, #0
2400f87a:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param (IS_PWR_SUPPLY (SupplySource));

  /* Check if supply source was configured */
#if defined (PWR_FLAG_SCUEN)
  if (__HAL_PWR_GET_FLAG (PWR_FLAG_SCUEN) == 0U)
2400f87c:	4b19      	ldr	r3, [pc, #100]	; (2400f8e4 <HAL_PWREx_ConfigSupply+0x70>)
2400f87e:	68db      	ldr	r3, [r3, #12]
2400f880:	f003 0304 	and.w	r3, r3, #4
2400f884:	2b04      	cmp	r3, #4
2400f886:	d00a      	beq.n	2400f89e <HAL_PWREx_ConfigSupply+0x2a>
#else
  if ((PWR->CR3 & (PWR_CR3_SMPSEN | PWR_CR3_LDOEN | PWR_CR3_BYPASS)) != (PWR_CR3_SMPSEN | PWR_CR3_LDOEN))
#endif /* defined (PWR_FLAG_SCUEN) */
  {
    /* Check supply configuration */
    if ((PWR->CR3 & PWR_SUPPLY_CONFIG_MASK) != SupplySource)
2400f888:	4b16      	ldr	r3, [pc, #88]	; (2400f8e4 <HAL_PWREx_ConfigSupply+0x70>)
2400f88a:	68db      	ldr	r3, [r3, #12]
2400f88c:	f003 0307 	and.w	r3, r3, #7
2400f890:	687a      	ldr	r2, [r7, #4]
2400f892:	429a      	cmp	r2, r3
2400f894:	d001      	beq.n	2400f89a <HAL_PWREx_ConfigSupply+0x26>
    {
      /* Supply configuration update locked, can't apply a new supply config */
      return HAL_ERROR;
2400f896:	2301      	movs	r3, #1
2400f898:	e01f      	b.n	2400f8da <HAL_PWREx_ConfigSupply+0x66>
    else
    {
      /* Supply configuration update locked, but new supply configuration
         matches with old supply configuration : nothing to do
      */
      return HAL_OK;
2400f89a:	2300      	movs	r3, #0
2400f89c:	e01d      	b.n	2400f8da <HAL_PWREx_ConfigSupply+0x66>
    }
  }

  /* Set the power supply configuration */
  MODIFY_REG (PWR->CR3, PWR_SUPPLY_CONFIG_MASK, SupplySource);
2400f89e:	4b11      	ldr	r3, [pc, #68]	; (2400f8e4 <HAL_PWREx_ConfigSupply+0x70>)
2400f8a0:	68db      	ldr	r3, [r3, #12]
2400f8a2:	f023 0207 	bic.w	r2, r3, #7
2400f8a6:	490f      	ldr	r1, [pc, #60]	; (2400f8e4 <HAL_PWREx_ConfigSupply+0x70>)
2400f8a8:	687b      	ldr	r3, [r7, #4]
2400f8aa:	4313      	orrs	r3, r2
2400f8ac:	60cb      	str	r3, [r1, #12]

  /* Get tick */
  tickstart = HAL_GetTick ();
2400f8ae:	f7f0 ffd1 	bl	24000854 <HAL_GetTick>
2400f8b2:	60f8      	str	r0, [r7, #12]

  /* Wait till voltage level flag is set */
  while (__HAL_PWR_GET_FLAG (PWR_FLAG_ACTVOSRDY) == 0U)
2400f8b4:	e009      	b.n	2400f8ca <HAL_PWREx_ConfigSupply+0x56>
  {
    if ((HAL_GetTick () - tickstart) > PWR_FLAG_SETTING_DELAY)
2400f8b6:	f7f0 ffcd 	bl	24000854 <HAL_GetTick>
2400f8ba:	4602      	mov	r2, r0
2400f8bc:	68fb      	ldr	r3, [r7, #12]
2400f8be:	1ad3      	subs	r3, r2, r3
2400f8c0:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
2400f8c4:	d901      	bls.n	2400f8ca <HAL_PWREx_ConfigSupply+0x56>
    {
      return HAL_ERROR;
2400f8c6:	2301      	movs	r3, #1
2400f8c8:	e007      	b.n	2400f8da <HAL_PWREx_ConfigSupply+0x66>
  while (__HAL_PWR_GET_FLAG (PWR_FLAG_ACTVOSRDY) == 0U)
2400f8ca:	4b06      	ldr	r3, [pc, #24]	; (2400f8e4 <HAL_PWREx_ConfigSupply+0x70>)
2400f8cc:	685b      	ldr	r3, [r3, #4]
2400f8ce:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
2400f8d2:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
2400f8d6:	d1ee      	bne.n	2400f8b6 <HAL_PWREx_ConfigSupply+0x42>
      }
    }
  }
#endif /* defined (SMPS) */

  return HAL_OK;
2400f8d8:	2300      	movs	r3, #0
}
2400f8da:	4618      	mov	r0, r3
2400f8dc:	3710      	adds	r7, #16
2400f8de:	46bd      	mov	sp, r7
2400f8e0:	bd80      	pop	{r7, pc}
2400f8e2:	bf00      	nop
2400f8e4:	58024800 	.word	0x58024800

2400f8e8 <HAL_PWREx_GetSupplyConfig>:
/**
  * @brief Get the power supply configuration.
  * @retval The supply configuration.
  */
uint32_t HAL_PWREx_GetSupplyConfig (void)
{
2400f8e8:	b480      	push	{r7}
2400f8ea:	af00      	add	r7, sp, #0
  return (PWR->CR3 & PWR_SUPPLY_CONFIG_MASK);
2400f8ec:	4b04      	ldr	r3, [pc, #16]	; (2400f900 <HAL_PWREx_GetSupplyConfig+0x18>)
2400f8ee:	68db      	ldr	r3, [r3, #12]
2400f8f0:	f003 0307 	and.w	r3, r3, #7
}
2400f8f4:	4618      	mov	r0, r3
2400f8f6:	46bd      	mov	sp, r7
2400f8f8:	f85d 7b04 	ldr.w	r7, [sp], #4
2400f8fc:	4770      	bx	lr
2400f8fe:	bf00      	nop
2400f900:	58024800 	.word	0x58024800

2400f904 <HAL_PWREx_ControlVoltageScaling>:
  *            @arg PWR_REGULATOR_VOLTAGE_SCALE3 : Regulator voltage output
  *                                                range 3 mode.
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_PWREx_ControlVoltageScaling (uint32_t VoltageScaling)
{
2400f904:	b580      	push	{r7, lr}
2400f906:	b084      	sub	sp, #16
2400f908:	af00      	add	r7, sp, #0
2400f90a:	6078      	str	r0, [r7, #4]

  /* Check the parameters */
  assert_param (IS_PWR_REGULATOR_VOLTAGE (VoltageScaling));

  /* Get the voltage scaling  */
  if ((PWR->CSR1 & PWR_CSR1_ACTVOS) == VoltageScaling)
2400f90c:	4b3f      	ldr	r3, [pc, #252]	; (2400fa0c <HAL_PWREx_ControlVoltageScaling+0x108>)
2400f90e:	685b      	ldr	r3, [r3, #4]
2400f910:	f403 4340 	and.w	r3, r3, #49152	; 0xc000
2400f914:	687a      	ldr	r2, [r7, #4]
2400f916:	429a      	cmp	r2, r3
2400f918:	d101      	bne.n	2400f91e <HAL_PWREx_ControlVoltageScaling+0x1a>
  {
    /* Old and new voltage scaling configuration match : nothing to do */
    return HAL_OK;
2400f91a:	2300      	movs	r3, #0
2400f91c:	e072      	b.n	2400fa04 <HAL_PWREx_ControlVoltageScaling+0x100>

#if defined (PWR_SRDCR_VOS)
  /* Set the voltage range */
  MODIFY_REG (PWR->SRDCR, PWR_SRDCR_VOS, VoltageScaling);
#else
  if (VoltageScaling == PWR_REGULATOR_VOLTAGE_SCALE0)
2400f91e:	687b      	ldr	r3, [r7, #4]
2400f920:	2b00      	cmp	r3, #0
2400f922:	d129      	bne.n	2400f978 <HAL_PWREx_ControlVoltageScaling+0x74>
  {
    if ((PWR->CR3 & PWR_CR3_LDOEN) == PWR_CR3_LDOEN)
2400f924:	4b39      	ldr	r3, [pc, #228]	; (2400fa0c <HAL_PWREx_ControlVoltageScaling+0x108>)
2400f926:	68db      	ldr	r3, [r3, #12]
2400f928:	f003 0302 	and.w	r3, r3, #2
2400f92c:	2b02      	cmp	r3, #2
2400f92e:	d121      	bne.n	2400f974 <HAL_PWREx_ControlVoltageScaling+0x70>
    {
      /* Set the voltage range */
      MODIFY_REG (PWR->D3CR, PWR_D3CR_VOS, PWR_REGULATOR_VOLTAGE_SCALE1);
2400f930:	4b36      	ldr	r3, [pc, #216]	; (2400fa0c <HAL_PWREx_ControlVoltageScaling+0x108>)
2400f932:	699b      	ldr	r3, [r3, #24]
2400f934:	4a35      	ldr	r2, [pc, #212]	; (2400fa0c <HAL_PWREx_ControlVoltageScaling+0x108>)
2400f936:	f443 4340 	orr.w	r3, r3, #49152	; 0xc000
2400f93a:	6193      	str	r3, [r2, #24]

      /* Get tick */
      tickstart = HAL_GetTick ();
2400f93c:	f7f0 ff8a 	bl	24000854 <HAL_GetTick>
2400f940:	60f8      	str	r0, [r7, #12]

      /* Wait till voltage level flag is set */
      while (__HAL_PWR_GET_FLAG (PWR_FLAG_ACTVOSRDY) == 0U)
2400f942:	e009      	b.n	2400f958 <HAL_PWREx_ControlVoltageScaling+0x54>
      {
        if ((HAL_GetTick () - tickstart) > PWR_FLAG_SETTING_DELAY)
2400f944:	f7f0 ff86 	bl	24000854 <HAL_GetTick>
2400f948:	4602      	mov	r2, r0
2400f94a:	68fb      	ldr	r3, [r7, #12]
2400f94c:	1ad3      	subs	r3, r2, r3
2400f94e:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
2400f952:	d901      	bls.n	2400f958 <HAL_PWREx_ControlVoltageScaling+0x54>
        {
          return HAL_ERROR;
2400f954:	2301      	movs	r3, #1
2400f956:	e055      	b.n	2400fa04 <HAL_PWREx_ControlVoltageScaling+0x100>
      while (__HAL_PWR_GET_FLAG (PWR_FLAG_ACTVOSRDY) == 0U)
2400f958:	4b2c      	ldr	r3, [pc, #176]	; (2400fa0c <HAL_PWREx_ControlVoltageScaling+0x108>)
2400f95a:	685b      	ldr	r3, [r3, #4]
2400f95c:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
2400f960:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
2400f964:	d1ee      	bne.n	2400f944 <HAL_PWREx_ControlVoltageScaling+0x40>
        }
      }

      /* Enable the PWR overdrive */
      SET_BIT (SYSCFG->PWRCR, SYSCFG_PWRCR_ODEN);
2400f966:	4b2a      	ldr	r3, [pc, #168]	; (2400fa10 <HAL_PWREx_ControlVoltageScaling+0x10c>)
2400f968:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2400f96a:	4a29      	ldr	r2, [pc, #164]	; (2400fa10 <HAL_PWREx_ControlVoltageScaling+0x10c>)
2400f96c:	f043 0301 	orr.w	r3, r3, #1
2400f970:	62d3      	str	r3, [r2, #44]	; 0x2c
2400f972:	e031      	b.n	2400f9d8 <HAL_PWREx_ControlVoltageScaling+0xd4>
    }
    else
    {
      /* The voltage scale 0 is only possible when LDO regulator is enabled */
      return HAL_ERROR;
2400f974:	2301      	movs	r3, #1
2400f976:	e045      	b.n	2400fa04 <HAL_PWREx_ControlVoltageScaling+0x100>
    }
  }
  else
  {
    if ((PWR->CSR1 & PWR_CSR1_ACTVOS) == PWR_REGULATOR_VOLTAGE_SCALE1)
2400f978:	4b24      	ldr	r3, [pc, #144]	; (2400fa0c <HAL_PWREx_ControlVoltageScaling+0x108>)
2400f97a:	685b      	ldr	r3, [r3, #4]
2400f97c:	f403 4340 	and.w	r3, r3, #49152	; 0xc000
2400f980:	f5b3 4f40 	cmp.w	r3, #49152	; 0xc000
2400f984:	d120      	bne.n	2400f9c8 <HAL_PWREx_ControlVoltageScaling+0xc4>
    {
      if ((SYSCFG->PWRCR & SYSCFG_PWRCR_ODEN) != 0U)
2400f986:	4b22      	ldr	r3, [pc, #136]	; (2400fa10 <HAL_PWREx_ControlVoltageScaling+0x10c>)
2400f988:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2400f98a:	f003 0301 	and.w	r3, r3, #1
2400f98e:	2b00      	cmp	r3, #0
2400f990:	d01a      	beq.n	2400f9c8 <HAL_PWREx_ControlVoltageScaling+0xc4>
      {
        /* Disable the PWR overdrive */
        CLEAR_BIT(SYSCFG->PWRCR, SYSCFG_PWRCR_ODEN);
2400f992:	4b1f      	ldr	r3, [pc, #124]	; (2400fa10 <HAL_PWREx_ControlVoltageScaling+0x10c>)
2400f994:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2400f996:	4a1e      	ldr	r2, [pc, #120]	; (2400fa10 <HAL_PWREx_ControlVoltageScaling+0x10c>)
2400f998:	f023 0301 	bic.w	r3, r3, #1
2400f99c:	62d3      	str	r3, [r2, #44]	; 0x2c

        /* Get tick */
        tickstart = HAL_GetTick ();
2400f99e:	f7f0 ff59 	bl	24000854 <HAL_GetTick>
2400f9a2:	60f8      	str	r0, [r7, #12]

        /* Wait till voltage level flag is set */
        while (__HAL_PWR_GET_FLAG (PWR_FLAG_ACTVOSRDY) == 0U)
2400f9a4:	e009      	b.n	2400f9ba <HAL_PWREx_ControlVoltageScaling+0xb6>
        {
          if ((HAL_GetTick () - tickstart) > PWR_FLAG_SETTING_DELAY)
2400f9a6:	f7f0 ff55 	bl	24000854 <HAL_GetTick>
2400f9aa:	4602      	mov	r2, r0
2400f9ac:	68fb      	ldr	r3, [r7, #12]
2400f9ae:	1ad3      	subs	r3, r2, r3
2400f9b0:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
2400f9b4:	d901      	bls.n	2400f9ba <HAL_PWREx_ControlVoltageScaling+0xb6>
          {
            return HAL_ERROR;
2400f9b6:	2301      	movs	r3, #1
2400f9b8:	e024      	b.n	2400fa04 <HAL_PWREx_ControlVoltageScaling+0x100>
        while (__HAL_PWR_GET_FLAG (PWR_FLAG_ACTVOSRDY) == 0U)
2400f9ba:	4b14      	ldr	r3, [pc, #80]	; (2400fa0c <HAL_PWREx_ControlVoltageScaling+0x108>)
2400f9bc:	685b      	ldr	r3, [r3, #4]
2400f9be:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
2400f9c2:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
2400f9c6:	d1ee      	bne.n	2400f9a6 <HAL_PWREx_ControlVoltageScaling+0xa2>
        }
      }
    }

    /* Set the voltage range */
    MODIFY_REG (PWR->D3CR, PWR_D3CR_VOS, VoltageScaling);
2400f9c8:	4b10      	ldr	r3, [pc, #64]	; (2400fa0c <HAL_PWREx_ControlVoltageScaling+0x108>)
2400f9ca:	699b      	ldr	r3, [r3, #24]
2400f9cc:	f423 4240 	bic.w	r2, r3, #49152	; 0xc000
2400f9d0:	490e      	ldr	r1, [pc, #56]	; (2400fa0c <HAL_PWREx_ControlVoltageScaling+0x108>)
2400f9d2:	687b      	ldr	r3, [r7, #4]
2400f9d4:	4313      	orrs	r3, r2
2400f9d6:	618b      	str	r3, [r1, #24]
  }
#endif /* defined (PWR_SRDCR_VOS) */

  /* Get tick */
  tickstart = HAL_GetTick ();
2400f9d8:	f7f0 ff3c 	bl	24000854 <HAL_GetTick>
2400f9dc:	60f8      	str	r0, [r7, #12]

  /* Wait till voltage level flag is set */
  while (__HAL_PWR_GET_FLAG (PWR_FLAG_ACTVOSRDY) == 0U)
2400f9de:	e009      	b.n	2400f9f4 <HAL_PWREx_ControlVoltageScaling+0xf0>
  {
    if ((HAL_GetTick() - tickstart) > PWR_FLAG_SETTING_DELAY)
2400f9e0:	f7f0 ff38 	bl	24000854 <HAL_GetTick>
2400f9e4:	4602      	mov	r2, r0
2400f9e6:	68fb      	ldr	r3, [r7, #12]
2400f9e8:	1ad3      	subs	r3, r2, r3
2400f9ea:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
2400f9ee:	d901      	bls.n	2400f9f4 <HAL_PWREx_ControlVoltageScaling+0xf0>
    {
      return HAL_ERROR;
2400f9f0:	2301      	movs	r3, #1
2400f9f2:	e007      	b.n	2400fa04 <HAL_PWREx_ControlVoltageScaling+0x100>
  while (__HAL_PWR_GET_FLAG (PWR_FLAG_ACTVOSRDY) == 0U)
2400f9f4:	4b05      	ldr	r3, [pc, #20]	; (2400fa0c <HAL_PWREx_ControlVoltageScaling+0x108>)
2400f9f6:	685b      	ldr	r3, [r3, #4]
2400f9f8:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
2400f9fc:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
2400fa00:	d1ee      	bne.n	2400f9e0 <HAL_PWREx_ControlVoltageScaling+0xdc>
    }
  }

  return HAL_OK;
2400fa02:	2300      	movs	r3, #0
}
2400fa04:	4618      	mov	r0, r3
2400fa06:	3710      	adds	r7, #16
2400fa08:	46bd      	mov	sp, r7
2400fa0a:	bd80      	pop	{r7, pc}
2400fa0c:	58024800 	.word	0x58024800
2400fa10:	58000400 	.word	0x58000400

2400fa14 <HAL_PWREx_GetVoltageRange>:
  * @brief Get the main internal regulator output voltage. Reflecting the last
  *        VOS value applied to the PMU.
  * @retval The current applied VOS selection.
  */
uint32_t HAL_PWREx_GetVoltageRange (void)
{
2400fa14:	b480      	push	{r7}
2400fa16:	af00      	add	r7, sp, #0
  /* Get the active voltage scaling */
  return (PWR->CSR1 & PWR_CSR1_ACTVOS);
2400fa18:	4b04      	ldr	r3, [pc, #16]	; (2400fa2c <HAL_PWREx_GetVoltageRange+0x18>)
2400fa1a:	685b      	ldr	r3, [r3, #4]
2400fa1c:	f403 4340 	and.w	r3, r3, #49152	; 0xc000
}
2400fa20:	4618      	mov	r0, r3
2400fa22:	46bd      	mov	sp, r7
2400fa24:	f85d 7b04 	ldr.w	r7, [sp], #4
2400fa28:	4770      	bx	lr
2400fa2a:	bf00      	nop
2400fa2c:	58024800 	.word	0x58024800

2400fa30 <HAL_PWREx_ControlStopModeVoltageScaling>:
  * @note   The selected SVOS4 and SVOS5 levels add an additional startup delay
  *         when exiting from system Stop mode.
  * @retval HAL Status.
  */
HAL_StatusTypeDef HAL_PWREx_ControlStopModeVoltageScaling (uint32_t VoltageScaling)
{
2400fa30:	b480      	push	{r7}
2400fa32:	b083      	sub	sp, #12
2400fa34:	af00      	add	r7, sp, #0
2400fa36:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param (IS_PWR_STOP_MODE_REGULATOR_VOLTAGE (VoltageScaling));

  /* Return the stop mode voltage range */
  MODIFY_REG (PWR->CR1, PWR_CR1_SVOS, VoltageScaling);
2400fa38:	4b07      	ldr	r3, [pc, #28]	; (2400fa58 <HAL_PWREx_ControlStopModeVoltageScaling+0x28>)
2400fa3a:	681b      	ldr	r3, [r3, #0]
2400fa3c:	f423 4240 	bic.w	r2, r3, #49152	; 0xc000
2400fa40:	4905      	ldr	r1, [pc, #20]	; (2400fa58 <HAL_PWREx_ControlStopModeVoltageScaling+0x28>)
2400fa42:	687b      	ldr	r3, [r7, #4]
2400fa44:	4313      	orrs	r3, r2
2400fa46:	600b      	str	r3, [r1, #0]

  return HAL_OK;
2400fa48:	2300      	movs	r3, #0
}
2400fa4a:	4618      	mov	r0, r3
2400fa4c:	370c      	adds	r7, #12
2400fa4e:	46bd      	mov	sp, r7
2400fa50:	f85d 7b04 	ldr.w	r7, [sp], #4
2400fa54:	4770      	bx	lr
2400fa56:	bf00      	nop
2400fa58:	58024800 	.word	0x58024800

2400fa5c <HAL_PWREx_GetStopModeVoltageRange>:
/**
  * @brief Get the main internal regulator output voltage in STOP mode.
  * @retval The actual applied VOS selection.
  */
uint32_t HAL_PWREx_GetStopModeVoltageRange (void)
{
2400fa5c:	b480      	push	{r7}
2400fa5e:	af00      	add	r7, sp, #0
  /* Return the stop voltage scaling */
  return (PWR->CR1 & PWR_CR1_SVOS);
2400fa60:	4b04      	ldr	r3, [pc, #16]	; (2400fa74 <HAL_PWREx_GetStopModeVoltageRange+0x18>)
2400fa62:	681b      	ldr	r3, [r3, #0]
2400fa64:	f403 4340 	and.w	r3, r3, #49152	; 0xc000
}
2400fa68:	4618      	mov	r0, r3
2400fa6a:	46bd      	mov	sp, r7
2400fa6c:	f85d 7b04 	ldr.w	r7, [sp], #4
2400fa70:	4770      	bx	lr
2400fa72:	bf00      	nop
2400fa74:	58024800 	.word	0x58024800

2400fa78 <HAL_PWREx_EnterSTOPMode>:
  *            @arg PWR_D2_DOMAIN : Enter D2 Domain to DSTOP mode.
  *            @arg PWR_D3_DOMAIN : Enter D3/SRD Domain to DSTOP mode.
  * @retval None.
  */
void HAL_PWREx_EnterSTOPMode (uint32_t Regulator, uint8_t STOPEntry, uint32_t Domain)
{
2400fa78:	b480      	push	{r7}
2400fa7a:	b085      	sub	sp, #20
2400fa7c:	af00      	add	r7, sp, #0
2400fa7e:	60f8      	str	r0, [r7, #12]
2400fa80:	460b      	mov	r3, r1
2400fa82:	607a      	str	r2, [r7, #4]
2400fa84:	72fb      	strb	r3, [r7, #11]
  assert_param (IS_PWR_REGULATOR (Regulator));
  assert_param (IS_PWR_STOP_ENTRY (STOPEntry));
  assert_param (IS_PWR_DOMAIN (Domain));

  /* Select the regulator state in Stop mode */
  MODIFY_REG (PWR->CR1, PWR_CR1_LPDS, Regulator);
2400fa86:	4b1f      	ldr	r3, [pc, #124]	; (2400fb04 <HAL_PWREx_EnterSTOPMode+0x8c>)
2400fa88:	681b      	ldr	r3, [r3, #0]
2400fa8a:	f023 0201 	bic.w	r2, r3, #1
2400fa8e:	491d      	ldr	r1, [pc, #116]	; (2400fb04 <HAL_PWREx_EnterSTOPMode+0x8c>)
2400fa90:	68fb      	ldr	r3, [r7, #12]
2400fa92:	4313      	orrs	r3, r2
2400fa94:	600b      	str	r3, [r1, #0]

  /* Select the domain Power Down DeepSleep */
  if (Domain == PWR_D1_DOMAIN)
2400fa96:	687b      	ldr	r3, [r7, #4]
2400fa98:	2b00      	cmp	r3, #0
2400fa9a:	d11c      	bne.n	2400fad6 <HAL_PWREx_EnterSTOPMode+0x5e>
      return;
    }
#endif /* defined (DUAL_CORE) */

    /* Keep DSTOP mode when D1/CD domain enters Deepsleep */
    CLEAR_BIT (PWR->CPUCR, PWR_CPUCR_PDDS_D1);
2400fa9c:	4b19      	ldr	r3, [pc, #100]	; (2400fb04 <HAL_PWREx_EnterSTOPMode+0x8c>)
2400fa9e:	691b      	ldr	r3, [r3, #16]
2400faa0:	4a18      	ldr	r2, [pc, #96]	; (2400fb04 <HAL_PWREx_EnterSTOPMode+0x8c>)
2400faa2:	f023 0301 	bic.w	r3, r3, #1
2400faa6:	6113      	str	r3, [r2, #16]

    /* Set SLEEPDEEP bit of Cortex System Control Register */
    SET_BIT (SCB->SCR, SCB_SCR_SLEEPDEEP_Msk);
2400faa8:	4b17      	ldr	r3, [pc, #92]	; (2400fb08 <HAL_PWREx_EnterSTOPMode+0x90>)
2400faaa:	691b      	ldr	r3, [r3, #16]
2400faac:	4a16      	ldr	r2, [pc, #88]	; (2400fb08 <HAL_PWREx_EnterSTOPMode+0x90>)
2400faae:	f043 0304 	orr.w	r3, r3, #4
2400fab2:	6113      	str	r3, [r2, #16]
  __ASM volatile ("dsb 0xF":::"memory");
2400fab4:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
2400fab8:	f3bf 8f6f 	isb	sy
    /* Ensure that all instructions are done before entering STOP mode */
    __DSB ();
    __ISB ();

    /* Select Stop mode entry */
    if (STOPEntry == PWR_STOPENTRY_WFI)
2400fabc:	7afb      	ldrb	r3, [r7, #11]
2400fabe:	2b01      	cmp	r3, #1
2400fac0:	d101      	bne.n	2400fac6 <HAL_PWREx_EnterSTOPMode+0x4e>
    {
      /* Request Wait For Interrupt */
      __WFI ();
2400fac2:	bf30      	wfi
2400fac4:	e000      	b.n	2400fac8 <HAL_PWREx_EnterSTOPMode+0x50>
    }
    else
    {
      /* Request Wait For Event */
      __WFE ();
2400fac6:	bf20      	wfe
    }

    /* Clear SLEEPDEEP bit of Cortex-Mx in the System Control Register */
    CLEAR_BIT (SCB->SCR, SCB_SCR_SLEEPDEEP_Msk);
2400fac8:	4b0f      	ldr	r3, [pc, #60]	; (2400fb08 <HAL_PWREx_EnterSTOPMode+0x90>)
2400faca:	691b      	ldr	r3, [r3, #16]
2400facc:	4a0e      	ldr	r2, [pc, #56]	; (2400fb08 <HAL_PWREx_EnterSTOPMode+0x90>)
2400face:	f023 0304 	bic.w	r3, r3, #4
2400fad2:	6113      	str	r3, [r2, #16]
  else
  {
    /* Keep DSTOP mode when D3/SRD domain enters Deepsleep */
    CLEAR_BIT (PWR->CPUCR, PWR_CPUCR_PDDS_D3);
  }
}
2400fad4:	e00f      	b.n	2400faf6 <HAL_PWREx_EnterSTOPMode+0x7e>
  else if (Domain == PWR_D2_DOMAIN)
2400fad6:	687b      	ldr	r3, [r7, #4]
2400fad8:	2b01      	cmp	r3, #1
2400fada:	d106      	bne.n	2400faea <HAL_PWREx_EnterSTOPMode+0x72>
    CLEAR_BIT (PWR->CPUCR, PWR_CPUCR_PDDS_D2);
2400fadc:	4b09      	ldr	r3, [pc, #36]	; (2400fb04 <HAL_PWREx_EnterSTOPMode+0x8c>)
2400fade:	691b      	ldr	r3, [r3, #16]
2400fae0:	4a08      	ldr	r2, [pc, #32]	; (2400fb04 <HAL_PWREx_EnterSTOPMode+0x8c>)
2400fae2:	f023 0302 	bic.w	r3, r3, #2
2400fae6:	6113      	str	r3, [r2, #16]
}
2400fae8:	e005      	b.n	2400faf6 <HAL_PWREx_EnterSTOPMode+0x7e>
    CLEAR_BIT (PWR->CPUCR, PWR_CPUCR_PDDS_D3);
2400faea:	4b06      	ldr	r3, [pc, #24]	; (2400fb04 <HAL_PWREx_EnterSTOPMode+0x8c>)
2400faec:	691b      	ldr	r3, [r3, #16]
2400faee:	4a05      	ldr	r2, [pc, #20]	; (2400fb04 <HAL_PWREx_EnterSTOPMode+0x8c>)
2400faf0:	f023 0304 	bic.w	r3, r3, #4
2400faf4:	6113      	str	r3, [r2, #16]
}
2400faf6:	bf00      	nop
2400faf8:	3714      	adds	r7, #20
2400fafa:	46bd      	mov	sp, r7
2400fafc:	f85d 7b04 	ldr.w	r7, [sp], #4
2400fb00:	4770      	bx	lr
2400fb02:	bf00      	nop
2400fb04:	58024800 	.word	0x58024800
2400fb08:	e000ed00 	.word	0xe000ed00

2400fb0c <HAL_PWREx_ClearPendingEvent>:
  *         to CSLEEP or CSTOP. It should be called just before APIs performing
  *         enter low power mode using Wait For Event request.
  * @retval None.
  */
void HAL_PWREx_ClearPendingEvent (void)
{
2400fb0c:	b480      	push	{r7}
2400fb0e:	af00      	add	r7, sp, #0
  {
    __SEV ();
    __WFE ();
  }
#else
  __WFE ();
2400fb10:	bf20      	wfe
#endif /* defined (DUAL_CORE) */
}
2400fb12:	bf00      	nop
2400fb14:	46bd      	mov	sp, r7
2400fb16:	f85d 7b04 	ldr.w	r7, [sp], #4
2400fb1a:	4770      	bx	lr

2400fb1c <HAL_PWREx_EnterSTANDBYMode>:
  *            @arg PWR_D2_DOMAIN: Enter D2 Domain to DSTANDBY mode.
  *            @arg PWR_D3_DOMAIN: Enter D3/SRD Domain to DSTANDBY mode.
  * @retval None
  */
void HAL_PWREx_EnterSTANDBYMode (uint32_t Domain)
{
2400fb1c:	b480      	push	{r7}
2400fb1e:	b083      	sub	sp, #12
2400fb20:	af00      	add	r7, sp, #0
2400fb22:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param (IS_PWR_DOMAIN (Domain));

  /* Select the domain Power Down DeepSleep */
  if (Domain == PWR_D1_DOMAIN)
2400fb24:	687b      	ldr	r3, [r7, #4]
2400fb26:	2b00      	cmp	r3, #0
2400fb28:	d10d      	bne.n	2400fb46 <HAL_PWREx_EnterSTANDBYMode+0x2a>
      return;
    }
#endif /* defined (DUAL_CORE) */

    /* Allow DSTANDBY mode when D1/CD domain enters Deepsleep */
    SET_BIT (PWR-> CPUCR, PWR_CPUCR_PDDS_D1);
2400fb2a:	4b12      	ldr	r3, [pc, #72]	; (2400fb74 <HAL_PWREx_EnterSTANDBYMode+0x58>)
2400fb2c:	691b      	ldr	r3, [r3, #16]
2400fb2e:	4a11      	ldr	r2, [pc, #68]	; (2400fb74 <HAL_PWREx_EnterSTANDBYMode+0x58>)
2400fb30:	f043 0301 	orr.w	r3, r3, #1
2400fb34:	6113      	str	r3, [r2, #16]
    /* Allow DSTANDBY mode when D1/CD domain enters Deepsleep */
    SET_BIT (PWR-> CPU2CR, PWR_CPU2CR_PDDS_D1);
#endif /*DUAL_CORE*/

    /* Set SLEEPDEEP bit of Cortex System Control Register */
    SET_BIT (SCB->SCR, SCB_SCR_SLEEPDEEP_Msk);
2400fb36:	4b10      	ldr	r3, [pc, #64]	; (2400fb78 <HAL_PWREx_EnterSTANDBYMode+0x5c>)
2400fb38:	691b      	ldr	r3, [r3, #16]
2400fb3a:	4a0f      	ldr	r2, [pc, #60]	; (2400fb78 <HAL_PWREx_EnterSTANDBYMode+0x5c>)
2400fb3c:	f043 0304 	orr.w	r3, r3, #4
2400fb40:	6113      	str	r3, [r2, #16]
#if defined (__CC_ARM)
    __force_stores ();
#endif /* defined (__CC_ARM) */

    /* Request Wait For Interrupt */
    __WFI ();
2400fb42:	bf30      	wfi
#if defined (DUAL_CORE)
    /* Allow DSTANDBY mode when D3/SRD domain enters Deepsleep */
    SET_BIT (PWR-> CPU2CR, PWR_CPU2CR_PDDS_D3);
#endif /* defined (DUAL_CORE) */
  }
}
2400fb44:	e00f      	b.n	2400fb66 <HAL_PWREx_EnterSTANDBYMode+0x4a>
  else if (Domain == PWR_D2_DOMAIN)
2400fb46:	687b      	ldr	r3, [r7, #4]
2400fb48:	2b01      	cmp	r3, #1
2400fb4a:	d106      	bne.n	2400fb5a <HAL_PWREx_EnterSTANDBYMode+0x3e>
    SET_BIT (PWR-> CPUCR, PWR_CPUCR_PDDS_D2);
2400fb4c:	4b09      	ldr	r3, [pc, #36]	; (2400fb74 <HAL_PWREx_EnterSTANDBYMode+0x58>)
2400fb4e:	691b      	ldr	r3, [r3, #16]
2400fb50:	4a08      	ldr	r2, [pc, #32]	; (2400fb74 <HAL_PWREx_EnterSTANDBYMode+0x58>)
2400fb52:	f043 0302 	orr.w	r3, r3, #2
2400fb56:	6113      	str	r3, [r2, #16]
}
2400fb58:	e005      	b.n	2400fb66 <HAL_PWREx_EnterSTANDBYMode+0x4a>
    SET_BIT (PWR-> CPUCR, PWR_CPUCR_PDDS_D3);
2400fb5a:	4b06      	ldr	r3, [pc, #24]	; (2400fb74 <HAL_PWREx_EnterSTANDBYMode+0x58>)
2400fb5c:	691b      	ldr	r3, [r3, #16]
2400fb5e:	4a05      	ldr	r2, [pc, #20]	; (2400fb74 <HAL_PWREx_EnterSTANDBYMode+0x58>)
2400fb60:	f043 0304 	orr.w	r3, r3, #4
2400fb64:	6113      	str	r3, [r2, #16]
}
2400fb66:	bf00      	nop
2400fb68:	370c      	adds	r7, #12
2400fb6a:	46bd      	mov	sp, r7
2400fb6c:	f85d 7b04 	ldr.w	r7, [sp], #4
2400fb70:	4770      	bx	lr
2400fb72:	bf00      	nop
2400fb74:	58024800 	.word	0x58024800
2400fb78:	e000ed00 	.word	0xe000ed00

2400fb7c <HAL_PWREx_ConfigD3Domain>:
  *                                     regardless of the CPU sub-system low
  *                                     power mode.
  * @retval None
  */
void HAL_PWREx_ConfigD3Domain (uint32_t D3State)
{
2400fb7c:	b480      	push	{r7}
2400fb7e:	b083      	sub	sp, #12
2400fb80:	af00      	add	r7, sp, #0
2400fb82:	6078      	str	r0, [r7, #4]
  /* Check the parameter */
  assert_param (IS_D3_STATE (D3State));

  /* Keep D3/SRD in run mode */
  MODIFY_REG (PWR->CPUCR, PWR_CPUCR_RUN_D3, D3State);
2400fb84:	4b06      	ldr	r3, [pc, #24]	; (2400fba0 <HAL_PWREx_ConfigD3Domain+0x24>)
2400fb86:	691b      	ldr	r3, [r3, #16]
2400fb88:	f423 6200 	bic.w	r2, r3, #2048	; 0x800
2400fb8c:	4904      	ldr	r1, [pc, #16]	; (2400fba0 <HAL_PWREx_ConfigD3Domain+0x24>)
2400fb8e:	687b      	ldr	r3, [r7, #4]
2400fb90:	4313      	orrs	r3, r2
2400fb92:	610b      	str	r3, [r1, #16]
}
2400fb94:	bf00      	nop
2400fb96:	370c      	adds	r7, #12
2400fb98:	46bd      	mov	sp, r7
2400fb9a:	f85d 7b04 	ldr.w	r7, [sp], #4
2400fb9e:	4770      	bx	lr
2400fba0:	58024800 	.word	0x58024800

2400fba4 <HAL_PWREx_EnableFlashPowerDown>:
  *         obtain the best trade-off between low-power consumption and restart
  *         time when exiting from DStop mode.
  * @retval None.
  */
void HAL_PWREx_EnableFlashPowerDown (void)
{
2400fba4:	b480      	push	{r7}
2400fba6:	af00      	add	r7, sp, #0
  /* Enable the Flash Power Down */
  SET_BIT (PWR->CR1, PWR_CR1_FLPS);
2400fba8:	4b05      	ldr	r3, [pc, #20]	; (2400fbc0 <HAL_PWREx_EnableFlashPowerDown+0x1c>)
2400fbaa:	681b      	ldr	r3, [r3, #0]
2400fbac:	4a04      	ldr	r2, [pc, #16]	; (2400fbc0 <HAL_PWREx_EnableFlashPowerDown+0x1c>)
2400fbae:	f443 7300 	orr.w	r3, r3, #512	; 0x200
2400fbb2:	6013      	str	r3, [r2, #0]
}
2400fbb4:	bf00      	nop
2400fbb6:	46bd      	mov	sp, r7
2400fbb8:	f85d 7b04 	ldr.w	r7, [sp], #4
2400fbbc:	4770      	bx	lr
2400fbbe:	bf00      	nop
2400fbc0:	58024800 	.word	0x58024800

2400fbc4 <HAL_PWREx_DisableFlashPowerDown>:
  *         to obtain the best trade-off between low-power consumption and
  *         restart time when exiting from DStop mode.
  * @retval None.
  */
void HAL_PWREx_DisableFlashPowerDown (void)
{
2400fbc4:	b480      	push	{r7}
2400fbc6:	af00      	add	r7, sp, #0
  /* Disable the Flash Power Down */
  CLEAR_BIT (PWR->CR1, PWR_CR1_FLPS);
2400fbc8:	4b05      	ldr	r3, [pc, #20]	; (2400fbe0 <HAL_PWREx_DisableFlashPowerDown+0x1c>)
2400fbca:	681b      	ldr	r3, [r3, #0]
2400fbcc:	4a04      	ldr	r2, [pc, #16]	; (2400fbe0 <HAL_PWREx_DisableFlashPowerDown+0x1c>)
2400fbce:	f423 7300 	bic.w	r3, r3, #512	; 0x200
2400fbd2:	6013      	str	r3, [r2, #0]
}
2400fbd4:	bf00      	nop
2400fbd6:	46bd      	mov	sp, r7
2400fbd8:	f85d 7b04 	ldr.w	r7, [sp], #4
2400fbdc:	4770      	bx	lr
2400fbde:	bf00      	nop
2400fbe0:	58024800 	.word	0x58024800

2400fbe4 <HAL_PWREx_EnableWakeUpPin>:
  *         Cortex-M7, wake up only Cortex-M4 and wake up Cortex-M7 and
  *         Cortex-M4.
  * @retval None.
  */
void HAL_PWREx_EnableWakeUpPin (PWREx_WakeupPinTypeDef *sPinParams)
{
2400fbe4:	b480      	push	{r7}
2400fbe6:	b08f      	sub	sp, #60	; 0x3c
2400fbe8:	af00      	add	r7, sp, #0
2400fbea:	6078      	str	r0, [r7, #4]
  uint32_t pinConfig;
  uint32_t regMask;
  const uint32_t pullMask = PWR_WKUPEPR_WKUPPUPD1;
2400fbec:	f44f 3340 	mov.w	r3, #196608	; 0x30000
2400fbf0:	637b      	str	r3, [r7, #52]	; 0x34
  /* Check the parameters */
  assert_param (IS_PWR_WAKEUP_PIN (sPinParams->WakeUpPin));
  assert_param (IS_PWR_WAKEUP_PIN_POLARITY (sPinParams->PinPolarity));
  assert_param (IS_PWR_WAKEUP_PIN_PULL (sPinParams->PinPull));

  pinConfig = sPinParams->WakeUpPin | \
2400fbf2:	687b      	ldr	r3, [r7, #4]
2400fbf4:	681a      	ldr	r2, [r3, #0]
              (sPinParams->PinPolarity << ((POSITION_VAL(sPinParams->WakeUpPin) + PWR_WKUPEPR_WKUPP1_Pos) & 0x1FU)) | \
2400fbf6:	687b      	ldr	r3, [r7, #4]
2400fbf8:	6859      	ldr	r1, [r3, #4]
2400fbfa:	687b      	ldr	r3, [r7, #4]
2400fbfc:	681b      	ldr	r3, [r3, #0]
2400fbfe:	613b      	str	r3, [r7, #16]
  uint32_t result;

#if ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \
     (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
     (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    )
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
2400fc00:	693b      	ldr	r3, [r7, #16]
2400fc02:	fa93 f3a3 	rbit	r3, r3
2400fc06:	60fb      	str	r3, [r7, #12]
    result |= value & 1U;
    s--;
  }
  result <<= s;                        /* shift when v's highest bits are zero */
#endif
  return result;
2400fc08:	68fb      	ldr	r3, [r7, #12]
2400fc0a:	fab3 f383 	clz	r3, r3
2400fc0e:	b2db      	uxtb	r3, r3
2400fc10:	3308      	adds	r3, #8
2400fc12:	f003 031f 	and.w	r3, r3, #31
2400fc16:	fa01 f303 	lsl.w	r3, r1, r3
  pinConfig = sPinParams->WakeUpPin | \
2400fc1a:	431a      	orrs	r2, r3
              (sPinParams->PinPull << (((POSITION_VAL(sPinParams->WakeUpPin) * PWR_WAKEUP_PINS_PULL_SHIFT_OFFSET) + PWR_WKUPEPR_WKUPPUPD1_Pos) & 0x1FU));
2400fc1c:	687b      	ldr	r3, [r7, #4]
2400fc1e:	6899      	ldr	r1, [r3, #8]
2400fc20:	687b      	ldr	r3, [r7, #4]
2400fc22:	681b      	ldr	r3, [r3, #0]
2400fc24:	61bb      	str	r3, [r7, #24]
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
2400fc26:	69bb      	ldr	r3, [r7, #24]
2400fc28:	fa93 f3a3 	rbit	r3, r3
2400fc2c:	617b      	str	r3, [r7, #20]
  return result;
2400fc2e:	697b      	ldr	r3, [r7, #20]
2400fc30:	fab3 f383 	clz	r3, r3
2400fc34:	b2db      	uxtb	r3, r3
2400fc36:	3308      	adds	r3, #8
2400fc38:	005b      	lsls	r3, r3, #1
2400fc3a:	f003 031e 	and.w	r3, r3, #30
2400fc3e:	fa01 f303 	lsl.w	r3, r1, r3
  pinConfig = sPinParams->WakeUpPin | \
2400fc42:	4313      	orrs	r3, r2
2400fc44:	633b      	str	r3, [r7, #48]	; 0x30

  regMask   = sPinParams->WakeUpPin | \
2400fc46:	687b      	ldr	r3, [r7, #4]
2400fc48:	681a      	ldr	r2, [r3, #0]
              (PWR_WKUPEPR_WKUPP1 << (POSITION_VAL(sPinParams->WakeUpPin) & 0x1FU)) | \
2400fc4a:	687b      	ldr	r3, [r7, #4]
2400fc4c:	681b      	ldr	r3, [r3, #0]
2400fc4e:	623b      	str	r3, [r7, #32]
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
2400fc50:	6a3b      	ldr	r3, [r7, #32]
2400fc52:	fa93 f3a3 	rbit	r3, r3
2400fc56:	61fb      	str	r3, [r7, #28]
  return result;
2400fc58:	69fb      	ldr	r3, [r7, #28]
2400fc5a:	fab3 f383 	clz	r3, r3
2400fc5e:	b2db      	uxtb	r3, r3
2400fc60:	f003 031f 	and.w	r3, r3, #31
2400fc64:	f44f 7180 	mov.w	r1, #256	; 0x100
2400fc68:	fa01 f303 	lsl.w	r3, r1, r3
  regMask   = sPinParams->WakeUpPin | \
2400fc6c:	431a      	orrs	r2, r3
              (pullMask << ((POSITION_VAL(sPinParams->WakeUpPin) * PWR_WAKEUP_PINS_PULL_SHIFT_OFFSET) & 0x1FU));
2400fc6e:	687b      	ldr	r3, [r7, #4]
2400fc70:	681b      	ldr	r3, [r3, #0]
2400fc72:	62bb      	str	r3, [r7, #40]	; 0x28
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
2400fc74:	6abb      	ldr	r3, [r7, #40]	; 0x28
2400fc76:	fa93 f3a3 	rbit	r3, r3
2400fc7a:	627b      	str	r3, [r7, #36]	; 0x24
  return result;
2400fc7c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
2400fc7e:	fab3 f383 	clz	r3, r3
2400fc82:	b2db      	uxtb	r3, r3
2400fc84:	005b      	lsls	r3, r3, #1
2400fc86:	f003 031e 	and.w	r3, r3, #30
2400fc8a:	6b79      	ldr	r1, [r7, #52]	; 0x34
2400fc8c:	fa01 f303 	lsl.w	r3, r1, r3
  regMask   = sPinParams->WakeUpPin | \
2400fc90:	4313      	orrs	r3, r2
2400fc92:	62fb      	str	r3, [r7, #44]	; 0x2c

  /* Enable and Specify the Wake-Up pin polarity and the pull configuration
     for the event detection (rising or falling edge) */
  MODIFY_REG (PWR->WKUPEPR, regMask, pinConfig);
2400fc94:	4b0e      	ldr	r3, [pc, #56]	; (2400fcd0 <HAL_PWREx_EnableWakeUpPin+0xec>)
2400fc96:	6a9a      	ldr	r2, [r3, #40]	; 0x28
2400fc98:	6afb      	ldr	r3, [r7, #44]	; 0x2c
2400fc9a:	43db      	mvns	r3, r3
2400fc9c:	401a      	ands	r2, r3
2400fc9e:	490c      	ldr	r1, [pc, #48]	; (2400fcd0 <HAL_PWREx_EnableWakeUpPin+0xec>)
2400fca0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
2400fca2:	4313      	orrs	r3, r2
2400fca4:	628b      	str	r3, [r1, #40]	; 0x28
#ifndef DUAL_CORE
  /* Configure the Wakeup Pin EXTI Line */
  MODIFY_REG (EXTI->IMR2, PWR_EXTI_WAKEUP_PINS_MASK, (sPinParams->WakeUpPin << EXTI_IMR2_IM55_Pos));
2400fca6:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
2400fcaa:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
2400fcae:	f023 52fc 	bic.w	r2, r3, #528482304	; 0x1f800000
2400fcb2:	687b      	ldr	r3, [r7, #4]
2400fcb4:	681b      	ldr	r3, [r3, #0]
2400fcb6:	05db      	lsls	r3, r3, #23
2400fcb8:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
2400fcbc:	4313      	orrs	r3, r2
2400fcbe:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
#endif /* !DUAL_CORE */
}
2400fcc2:	bf00      	nop
2400fcc4:	373c      	adds	r7, #60	; 0x3c
2400fcc6:	46bd      	mov	sp, r7
2400fcc8:	f85d 7b04 	ldr.w	r7, [sp], #4
2400fccc:	4770      	bx	lr
2400fcce:	bf00      	nop
2400fcd0:	58024800 	.word	0x58024800

2400fcd4 <HAL_PWREx_DisableWakeUpPin>:
  *           @arg PWR_WAKEUP_PIN5 : Disable PI11 wake-up PIN.
  *           @arg PWR_WAKEUP_PIN6 : Disable PC1  wake-up PIN.
  * @retval None
  */
void HAL_PWREx_DisableWakeUpPin (uint32_t WakeUpPin)
{
2400fcd4:	b480      	push	{r7}
2400fcd6:	b083      	sub	sp, #12
2400fcd8:	af00      	add	r7, sp, #0
2400fcda:	6078      	str	r0, [r7, #4]
  /* Check the parameter */
  assert_param (IS_PWR_WAKEUP_PIN (WakeUpPin));

  /* Disable the WakeUpPin */
  CLEAR_BIT (PWR->WKUPEPR, WakeUpPin);
2400fcdc:	4b06      	ldr	r3, [pc, #24]	; (2400fcf8 <HAL_PWREx_DisableWakeUpPin+0x24>)
2400fcde:	6a9a      	ldr	r2, [r3, #40]	; 0x28
2400fce0:	687b      	ldr	r3, [r7, #4]
2400fce2:	43db      	mvns	r3, r3
2400fce4:	4904      	ldr	r1, [pc, #16]	; (2400fcf8 <HAL_PWREx_DisableWakeUpPin+0x24>)
2400fce6:	4013      	ands	r3, r2
2400fce8:	628b      	str	r3, [r1, #40]	; 0x28
}
2400fcea:	bf00      	nop
2400fcec:	370c      	adds	r7, #12
2400fcee:	46bd      	mov	sp, r7
2400fcf0:	f85d 7b04 	ldr.w	r7, [sp], #4
2400fcf4:	4770      	bx	lr
2400fcf6:	bf00      	nop
2400fcf8:	58024800 	.word	0x58024800

2400fcfc <HAL_PWREx_GetWakeupFlag>:
  *            @arg PWR_WAKEUP_FLAG_ALL : Get Wakeup event received from all
  *                                      wake up pins.
  * @retval The Wake-Up pin flag.
  */
uint32_t HAL_PWREx_GetWakeupFlag (uint32_t WakeUpFlag)
{
2400fcfc:	b480      	push	{r7}
2400fcfe:	b083      	sub	sp, #12
2400fd00:	af00      	add	r7, sp, #0
2400fd02:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param (IS_PWR_WAKEUP_FLAG (WakeUpFlag));

  /* Return the wake up pin flag */
  return (PWR->WKUPFR & WakeUpFlag);
2400fd04:	4b04      	ldr	r3, [pc, #16]	; (2400fd18 <HAL_PWREx_GetWakeupFlag+0x1c>)
2400fd06:	6a5a      	ldr	r2, [r3, #36]	; 0x24
2400fd08:	687b      	ldr	r3, [r7, #4]
2400fd0a:	4013      	ands	r3, r2
}
2400fd0c:	4618      	mov	r0, r3
2400fd0e:	370c      	adds	r7, #12
2400fd10:	46bd      	mov	sp, r7
2400fd12:	f85d 7b04 	ldr.w	r7, [sp], #4
2400fd16:	4770      	bx	lr
2400fd18:	58024800 	.word	0x58024800

2400fd1c <HAL_PWREx_ClearWakeupFlag>:
  *            @arg PWR_WAKEUP_FLAG_ALL : Clear the wakeup events received from
  *                                      all wake up pins.
  * @retval HAL status.
  */
HAL_StatusTypeDef HAL_PWREx_ClearWakeupFlag (uint32_t WakeUpFlag)
{
2400fd1c:	b480      	push	{r7}
2400fd1e:	b083      	sub	sp, #12
2400fd20:	af00      	add	r7, sp, #0
2400fd22:	6078      	str	r0, [r7, #4]
  /* Check the parameter */
  assert_param (IS_PWR_WAKEUP_FLAG (WakeUpFlag));

  /* Clear the wake up event received from wake up pin x */
  SET_BIT (PWR->WKUPCR, WakeUpFlag);
2400fd24:	4b0a      	ldr	r3, [pc, #40]	; (2400fd50 <HAL_PWREx_ClearWakeupFlag+0x34>)
2400fd26:	6a1a      	ldr	r2, [r3, #32]
2400fd28:	4909      	ldr	r1, [pc, #36]	; (2400fd50 <HAL_PWREx_ClearWakeupFlag+0x34>)
2400fd2a:	687b      	ldr	r3, [r7, #4]
2400fd2c:	4313      	orrs	r3, r2
2400fd2e:	620b      	str	r3, [r1, #32]

  /* Check if the wake up event is well cleared */
  if ((PWR->WKUPFR & WakeUpFlag) != 0U)
2400fd30:	4b07      	ldr	r3, [pc, #28]	; (2400fd50 <HAL_PWREx_ClearWakeupFlag+0x34>)
2400fd32:	6a5a      	ldr	r2, [r3, #36]	; 0x24
2400fd34:	687b      	ldr	r3, [r7, #4]
2400fd36:	4013      	ands	r3, r2
2400fd38:	2b00      	cmp	r3, #0
2400fd3a:	d001      	beq.n	2400fd40 <HAL_PWREx_ClearWakeupFlag+0x24>
  {
    return HAL_ERROR;
2400fd3c:	2301      	movs	r3, #1
2400fd3e:	e000      	b.n	2400fd42 <HAL_PWREx_ClearWakeupFlag+0x26>
  }

  return HAL_OK;
2400fd40:	2300      	movs	r3, #0
}
2400fd42:	4618      	mov	r0, r3
2400fd44:	370c      	adds	r7, #12
2400fd46:	46bd      	mov	sp, r7
2400fd48:	f85d 7b04 	ldr.w	r7, [sp], #4
2400fd4c:	4770      	bx	lr
2400fd4e:	bf00      	nop
2400fd50:	58024800 	.word	0x58024800

2400fd54 <HAL_PWREx_WAKEUP_PIN_IRQHandler>:
  * @brief This function handles the PWR WAKEUP PIN interrupt request.
  * @note   This API should be called under the WAKEUP_PIN_IRQHandler().
  * @retval None.
  */
void HAL_PWREx_WAKEUP_PIN_IRQHandler (void)
{
2400fd54:	b580      	push	{r7, lr}
2400fd56:	af00      	add	r7, sp, #0
  /* Wakeup pin EXTI line interrupt detected */
  if (READ_BIT(PWR->WKUPFR, PWR_WKUPFR_WKUPF1) != 0U)
2400fd58:	4b2a      	ldr	r3, [pc, #168]	; (2400fe04 <HAL_PWREx_WAKEUP_PIN_IRQHandler+0xb0>)
2400fd5a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2400fd5c:	f003 0301 	and.w	r3, r3, #1
2400fd60:	2b00      	cmp	r3, #0
2400fd62:	d008      	beq.n	2400fd76 <HAL_PWREx_WAKEUP_PIN_IRQHandler+0x22>
  {
    /* Clear PWR WKUPF1 flag */
    __HAL_PWR_CLEAR_WAKEUPFLAG (PWR_FLAG_WKUP1);
2400fd64:	4b27      	ldr	r3, [pc, #156]	; (2400fe04 <HAL_PWREx_WAKEUP_PIN_IRQHandler+0xb0>)
2400fd66:	6a1b      	ldr	r3, [r3, #32]
2400fd68:	4a26      	ldr	r2, [pc, #152]	; (2400fe04 <HAL_PWREx_WAKEUP_PIN_IRQHandler+0xb0>)
2400fd6a:	f043 0301 	orr.w	r3, r3, #1
2400fd6e:	6213      	str	r3, [r2, #32]

    /* PWR WKUP1 interrupt user callback */
    HAL_PWREx_WKUP1_Callback ();
2400fd70:	f000 f84a 	bl	2400fe08 <HAL_PWREx_WKUP1_Callback>
    __HAL_PWR_CLEAR_WAKEUPFLAG (PWR_FLAG_WKUP6);

    /* PWR WKUP6 interrupt user callback */
    HAL_PWREx_WKUP6_Callback ();
  }
}
2400fd74:	e043      	b.n	2400fdfe <HAL_PWREx_WAKEUP_PIN_IRQHandler+0xaa>
  else if (READ_BIT (PWR->WKUPFR, PWR_WKUPFR_WKUPF2) != 0U)
2400fd76:	4b23      	ldr	r3, [pc, #140]	; (2400fe04 <HAL_PWREx_WAKEUP_PIN_IRQHandler+0xb0>)
2400fd78:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2400fd7a:	f003 0302 	and.w	r3, r3, #2
2400fd7e:	2b00      	cmp	r3, #0
2400fd80:	d008      	beq.n	2400fd94 <HAL_PWREx_WAKEUP_PIN_IRQHandler+0x40>
    __HAL_PWR_CLEAR_WAKEUPFLAG (PWR_FLAG_WKUP2);
2400fd82:	4b20      	ldr	r3, [pc, #128]	; (2400fe04 <HAL_PWREx_WAKEUP_PIN_IRQHandler+0xb0>)
2400fd84:	6a1b      	ldr	r3, [r3, #32]
2400fd86:	4a1f      	ldr	r2, [pc, #124]	; (2400fe04 <HAL_PWREx_WAKEUP_PIN_IRQHandler+0xb0>)
2400fd88:	f043 0302 	orr.w	r3, r3, #2
2400fd8c:	6213      	str	r3, [r2, #32]
    HAL_PWREx_WKUP2_Callback ();
2400fd8e:	f000 f842 	bl	2400fe16 <HAL_PWREx_WKUP2_Callback>
}
2400fd92:	e034      	b.n	2400fdfe <HAL_PWREx_WAKEUP_PIN_IRQHandler+0xaa>
  else if (READ_BIT (PWR->WKUPFR, PWR_WKUPFR_WKUPF3) != 0U)
2400fd94:	4b1b      	ldr	r3, [pc, #108]	; (2400fe04 <HAL_PWREx_WAKEUP_PIN_IRQHandler+0xb0>)
2400fd96:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2400fd98:	f003 0304 	and.w	r3, r3, #4
2400fd9c:	2b00      	cmp	r3, #0
2400fd9e:	d008      	beq.n	2400fdb2 <HAL_PWREx_WAKEUP_PIN_IRQHandler+0x5e>
    __HAL_PWR_CLEAR_WAKEUPFLAG (PWR_FLAG_WKUP3);
2400fda0:	4b18      	ldr	r3, [pc, #96]	; (2400fe04 <HAL_PWREx_WAKEUP_PIN_IRQHandler+0xb0>)
2400fda2:	6a1b      	ldr	r3, [r3, #32]
2400fda4:	4a17      	ldr	r2, [pc, #92]	; (2400fe04 <HAL_PWREx_WAKEUP_PIN_IRQHandler+0xb0>)
2400fda6:	f043 0304 	orr.w	r3, r3, #4
2400fdaa:	6213      	str	r3, [r2, #32]
    HAL_PWREx_WKUP3_Callback ();
2400fdac:	f000 f83a 	bl	2400fe24 <HAL_PWREx_WKUP3_Callback>
}
2400fdb0:	e025      	b.n	2400fdfe <HAL_PWREx_WAKEUP_PIN_IRQHandler+0xaa>
  else if (READ_BIT (PWR->WKUPFR, PWR_WKUPFR_WKUPF4) != 0U)
2400fdb2:	4b14      	ldr	r3, [pc, #80]	; (2400fe04 <HAL_PWREx_WAKEUP_PIN_IRQHandler+0xb0>)
2400fdb4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2400fdb6:	f003 0308 	and.w	r3, r3, #8
2400fdba:	2b00      	cmp	r3, #0
2400fdbc:	d008      	beq.n	2400fdd0 <HAL_PWREx_WAKEUP_PIN_IRQHandler+0x7c>
    __HAL_PWR_CLEAR_WAKEUPFLAG (PWR_FLAG_WKUP4);
2400fdbe:	4b11      	ldr	r3, [pc, #68]	; (2400fe04 <HAL_PWREx_WAKEUP_PIN_IRQHandler+0xb0>)
2400fdc0:	6a1b      	ldr	r3, [r3, #32]
2400fdc2:	4a10      	ldr	r2, [pc, #64]	; (2400fe04 <HAL_PWREx_WAKEUP_PIN_IRQHandler+0xb0>)
2400fdc4:	f043 0308 	orr.w	r3, r3, #8
2400fdc8:	6213      	str	r3, [r2, #32]
    HAL_PWREx_WKUP4_Callback ();
2400fdca:	f000 f832 	bl	2400fe32 <HAL_PWREx_WKUP4_Callback>
}
2400fdce:	e016      	b.n	2400fdfe <HAL_PWREx_WAKEUP_PIN_IRQHandler+0xaa>
  else if (READ_BIT (PWR->WKUPFR, PWR_WKUPFR_WKUPF5) != 0U)
2400fdd0:	4b0c      	ldr	r3, [pc, #48]	; (2400fe04 <HAL_PWREx_WAKEUP_PIN_IRQHandler+0xb0>)
2400fdd2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2400fdd4:	f003 0310 	and.w	r3, r3, #16
2400fdd8:	2b00      	cmp	r3, #0
2400fdda:	d008      	beq.n	2400fdee <HAL_PWREx_WAKEUP_PIN_IRQHandler+0x9a>
    __HAL_PWR_CLEAR_WAKEUPFLAG (PWR_FLAG_WKUP5);
2400fddc:	4b09      	ldr	r3, [pc, #36]	; (2400fe04 <HAL_PWREx_WAKEUP_PIN_IRQHandler+0xb0>)
2400fdde:	6a1b      	ldr	r3, [r3, #32]
2400fde0:	4a08      	ldr	r2, [pc, #32]	; (2400fe04 <HAL_PWREx_WAKEUP_PIN_IRQHandler+0xb0>)
2400fde2:	f043 0310 	orr.w	r3, r3, #16
2400fde6:	6213      	str	r3, [r2, #32]
    HAL_PWREx_WKUP5_Callback ();
2400fde8:	f000 f82a 	bl	2400fe40 <HAL_PWREx_WKUP5_Callback>
}
2400fdec:	e007      	b.n	2400fdfe <HAL_PWREx_WAKEUP_PIN_IRQHandler+0xaa>
    __HAL_PWR_CLEAR_WAKEUPFLAG (PWR_FLAG_WKUP6);
2400fdee:	4b05      	ldr	r3, [pc, #20]	; (2400fe04 <HAL_PWREx_WAKEUP_PIN_IRQHandler+0xb0>)
2400fdf0:	6a1b      	ldr	r3, [r3, #32]
2400fdf2:	4a04      	ldr	r2, [pc, #16]	; (2400fe04 <HAL_PWREx_WAKEUP_PIN_IRQHandler+0xb0>)
2400fdf4:	f043 0320 	orr.w	r3, r3, #32
2400fdf8:	6213      	str	r3, [r2, #32]
    HAL_PWREx_WKUP6_Callback ();
2400fdfa:	f000 f828 	bl	2400fe4e <HAL_PWREx_WKUP6_Callback>
}
2400fdfe:	bf00      	nop
2400fe00:	bd80      	pop	{r7, pc}
2400fe02:	bf00      	nop
2400fe04:	58024800 	.word	0x58024800

2400fe08 <HAL_PWREx_WKUP1_Callback>:
/**
  * @brief PWR WKUP1 interrupt callback.
  * @retval None.
  */
__weak void HAL_PWREx_WKUP1_Callback (void)
{
2400fe08:	b480      	push	{r7}
2400fe0a:	af00      	add	r7, sp, #0
  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_PWREx_WKUP1Callback can be implemented in the user file
  */
}
2400fe0c:	bf00      	nop
2400fe0e:	46bd      	mov	sp, r7
2400fe10:	f85d 7b04 	ldr.w	r7, [sp], #4
2400fe14:	4770      	bx	lr

2400fe16 <HAL_PWREx_WKUP2_Callback>:
/**
  * @brief PWR WKUP2 interrupt callback.
  * @retval None.
  */
__weak void HAL_PWREx_WKUP2_Callback (void)
{
2400fe16:	b480      	push	{r7}
2400fe18:	af00      	add	r7, sp, #0
  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_PWREx_WKUP2Callback can be implemented in the user file
  */
}
2400fe1a:	bf00      	nop
2400fe1c:	46bd      	mov	sp, r7
2400fe1e:	f85d 7b04 	ldr.w	r7, [sp], #4
2400fe22:	4770      	bx	lr

2400fe24 <HAL_PWREx_WKUP3_Callback>:
/**
  * @brief PWR WKUP3 interrupt callback.
  * @retval None.
  */
__weak void HAL_PWREx_WKUP3_Callback (void)
{
2400fe24:	b480      	push	{r7}
2400fe26:	af00      	add	r7, sp, #0
  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_PWREx_WKUP3Callback can be implemented in the user file
  */
}
2400fe28:	bf00      	nop
2400fe2a:	46bd      	mov	sp, r7
2400fe2c:	f85d 7b04 	ldr.w	r7, [sp], #4
2400fe30:	4770      	bx	lr

2400fe32 <HAL_PWREx_WKUP4_Callback>:
/**
  * @brief PWR WKUP4 interrupt callback.
  * @retval None.
  */
__weak void HAL_PWREx_WKUP4_Callback (void)
{
2400fe32:	b480      	push	{r7}
2400fe34:	af00      	add	r7, sp, #0
  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_PWREx_WKUP4Callback can be implemented in the user file
  */
}
2400fe36:	bf00      	nop
2400fe38:	46bd      	mov	sp, r7
2400fe3a:	f85d 7b04 	ldr.w	r7, [sp], #4
2400fe3e:	4770      	bx	lr

2400fe40 <HAL_PWREx_WKUP5_Callback>:
/**
  * @brief PWR WKUP5 interrupt callback.
  * @retval None.
  */
__weak void HAL_PWREx_WKUP5_Callback (void)
{
2400fe40:	b480      	push	{r7}
2400fe42:	af00      	add	r7, sp, #0
  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_PWREx_WKUP5Callback can be implemented in the user file
  */
}
2400fe44:	bf00      	nop
2400fe46:	46bd      	mov	sp, r7
2400fe48:	f85d 7b04 	ldr.w	r7, [sp], #4
2400fe4c:	4770      	bx	lr

2400fe4e <HAL_PWREx_WKUP6_Callback>:
/**
  * @brief PWR WKUP6 interrupt callback.
  * @retval None.
  */
__weak void HAL_PWREx_WKUP6_Callback (void)
{
2400fe4e:	b480      	push	{r7}
2400fe50:	af00      	add	r7, sp, #0
  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_PWREx_WKUP6Callback can be implemented in the user file
  */
}
2400fe52:	bf00      	nop
2400fe54:	46bd      	mov	sp, r7
2400fe56:	f85d 7b04 	ldr.w	r7, [sp], #4
2400fe5a:	4770      	bx	lr

2400fe5c <HAL_PWREx_EnableBkUpReg>:
/**
  * @brief Enable the Backup Regulator.
  * @retval HAL status.
  */
HAL_StatusTypeDef HAL_PWREx_EnableBkUpReg (void)
{
2400fe5c:	b580      	push	{r7, lr}
2400fe5e:	b082      	sub	sp, #8
2400fe60:	af00      	add	r7, sp, #0
  uint32_t tickstart;

  /* Enable the Backup regulator */
  SET_BIT (PWR->CR2, PWR_CR2_BREN);
2400fe62:	4b10      	ldr	r3, [pc, #64]	; (2400fea4 <HAL_PWREx_EnableBkUpReg+0x48>)
2400fe64:	689b      	ldr	r3, [r3, #8]
2400fe66:	4a0f      	ldr	r2, [pc, #60]	; (2400fea4 <HAL_PWREx_EnableBkUpReg+0x48>)
2400fe68:	f043 0301 	orr.w	r3, r3, #1
2400fe6c:	6093      	str	r3, [r2, #8]

  /* Get tick */
  tickstart = HAL_GetTick ();
2400fe6e:	f7f0 fcf1 	bl	24000854 <HAL_GetTick>
2400fe72:	6078      	str	r0, [r7, #4]

  /* Wait till Backup regulator ready flag is set */
  while (__HAL_PWR_GET_FLAG (PWR_FLAG_BRR) == 0U)
2400fe74:	e009      	b.n	2400fe8a <HAL_PWREx_EnableBkUpReg+0x2e>
  {
    if ((HAL_GetTick() - tickstart ) > PWR_FLAG_SETTING_DELAY)
2400fe76:	f7f0 fced 	bl	24000854 <HAL_GetTick>
2400fe7a:	4602      	mov	r2, r0
2400fe7c:	687b      	ldr	r3, [r7, #4]
2400fe7e:	1ad3      	subs	r3, r2, r3
2400fe80:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
2400fe84:	d901      	bls.n	2400fe8a <HAL_PWREx_EnableBkUpReg+0x2e>
    {
      return HAL_ERROR;
2400fe86:	2301      	movs	r3, #1
2400fe88:	e007      	b.n	2400fe9a <HAL_PWREx_EnableBkUpReg+0x3e>
  while (__HAL_PWR_GET_FLAG (PWR_FLAG_BRR) == 0U)
2400fe8a:	4b06      	ldr	r3, [pc, #24]	; (2400fea4 <HAL_PWREx_EnableBkUpReg+0x48>)
2400fe8c:	689b      	ldr	r3, [r3, #8]
2400fe8e:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
2400fe92:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
2400fe96:	d1ee      	bne.n	2400fe76 <HAL_PWREx_EnableBkUpReg+0x1a>
    }
  }

  return HAL_OK;
2400fe98:	2300      	movs	r3, #0
}
2400fe9a:	4618      	mov	r0, r3
2400fe9c:	3708      	adds	r7, #8
2400fe9e:	46bd      	mov	sp, r7
2400fea0:	bd80      	pop	{r7, pc}
2400fea2:	bf00      	nop
2400fea4:	58024800 	.word	0x58024800

2400fea8 <HAL_PWREx_DisableBkUpReg>:
/**
  * @brief Disable the Backup Regulator.
  * @retval HAL status.
  */
HAL_StatusTypeDef HAL_PWREx_DisableBkUpReg (void)
{
2400fea8:	b580      	push	{r7, lr}
2400feaa:	b082      	sub	sp, #8
2400feac:	af00      	add	r7, sp, #0
  uint32_t tickstart;

  /* Disable the Backup regulator */
  CLEAR_BIT (PWR->CR2, PWR_CR2_BREN);
2400feae:	4b10      	ldr	r3, [pc, #64]	; (2400fef0 <HAL_PWREx_DisableBkUpReg+0x48>)
2400feb0:	689b      	ldr	r3, [r3, #8]
2400feb2:	4a0f      	ldr	r2, [pc, #60]	; (2400fef0 <HAL_PWREx_DisableBkUpReg+0x48>)
2400feb4:	f023 0301 	bic.w	r3, r3, #1
2400feb8:	6093      	str	r3, [r2, #8]

  /* Get tick */
  tickstart = HAL_GetTick ();
2400feba:	f7f0 fccb 	bl	24000854 <HAL_GetTick>
2400febe:	6078      	str	r0, [r7, #4]

  /* Wait till Backup regulator ready flag is reset */
  while (__HAL_PWR_GET_FLAG (PWR_FLAG_BRR) != 0U)
2400fec0:	e009      	b.n	2400fed6 <HAL_PWREx_DisableBkUpReg+0x2e>
  {
    if ((HAL_GetTick() - tickstart ) > PWR_FLAG_SETTING_DELAY)
2400fec2:	f7f0 fcc7 	bl	24000854 <HAL_GetTick>
2400fec6:	4602      	mov	r2, r0
2400fec8:	687b      	ldr	r3, [r7, #4]
2400feca:	1ad3      	subs	r3, r2, r3
2400fecc:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
2400fed0:	d901      	bls.n	2400fed6 <HAL_PWREx_DisableBkUpReg+0x2e>
    {
      return HAL_ERROR;
2400fed2:	2301      	movs	r3, #1
2400fed4:	e007      	b.n	2400fee6 <HAL_PWREx_DisableBkUpReg+0x3e>
  while (__HAL_PWR_GET_FLAG (PWR_FLAG_BRR) != 0U)
2400fed6:	4b06      	ldr	r3, [pc, #24]	; (2400fef0 <HAL_PWREx_DisableBkUpReg+0x48>)
2400fed8:	689b      	ldr	r3, [r3, #8]
2400feda:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
2400fede:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
2400fee2:	d0ee      	beq.n	2400fec2 <HAL_PWREx_DisableBkUpReg+0x1a>
    }
  }

  return HAL_OK;
2400fee4:	2300      	movs	r3, #0
}
2400fee6:	4618      	mov	r0, r3
2400fee8:	3708      	adds	r7, #8
2400feea:	46bd      	mov	sp, r7
2400feec:	bd80      	pop	{r7, pc}
2400feee:	bf00      	nop
2400fef0:	58024800 	.word	0x58024800

2400fef4 <HAL_PWREx_EnableUSBReg>:
/**
  * @brief Enable the USB Regulator.
  * @retval HAL status.
  */
HAL_StatusTypeDef HAL_PWREx_EnableUSBReg (void)
{
2400fef4:	b580      	push	{r7, lr}
2400fef6:	b082      	sub	sp, #8
2400fef8:	af00      	add	r7, sp, #0
  uint32_t tickstart;

  /* Enable the USB regulator */
  SET_BIT (PWR->CR3, PWR_CR3_USBREGEN);
2400fefa:	4b10      	ldr	r3, [pc, #64]	; (2400ff3c <HAL_PWREx_EnableUSBReg+0x48>)
2400fefc:	68db      	ldr	r3, [r3, #12]
2400fefe:	4a0f      	ldr	r2, [pc, #60]	; (2400ff3c <HAL_PWREx_EnableUSBReg+0x48>)
2400ff00:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
2400ff04:	60d3      	str	r3, [r2, #12]

  /* Get tick */
  tickstart = HAL_GetTick ();
2400ff06:	f7f0 fca5 	bl	24000854 <HAL_GetTick>
2400ff0a:	6078      	str	r0, [r7, #4]

  /* Wait till the USB regulator ready flag is set */
  while (__HAL_PWR_GET_FLAG (PWR_FLAG_USB33RDY) == 0U)
2400ff0c:	e009      	b.n	2400ff22 <HAL_PWREx_EnableUSBReg+0x2e>
  {
    if ((HAL_GetTick() - tickstart ) > PWR_FLAG_SETTING_DELAY)
2400ff0e:	f7f0 fca1 	bl	24000854 <HAL_GetTick>
2400ff12:	4602      	mov	r2, r0
2400ff14:	687b      	ldr	r3, [r7, #4]
2400ff16:	1ad3      	subs	r3, r2, r3
2400ff18:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
2400ff1c:	d901      	bls.n	2400ff22 <HAL_PWREx_EnableUSBReg+0x2e>
    {
      return HAL_ERROR;
2400ff1e:	2301      	movs	r3, #1
2400ff20:	e007      	b.n	2400ff32 <HAL_PWREx_EnableUSBReg+0x3e>
  while (__HAL_PWR_GET_FLAG (PWR_FLAG_USB33RDY) == 0U)
2400ff22:	4b06      	ldr	r3, [pc, #24]	; (2400ff3c <HAL_PWREx_EnableUSBReg+0x48>)
2400ff24:	68db      	ldr	r3, [r3, #12]
2400ff26:	f003 6380 	and.w	r3, r3, #67108864	; 0x4000000
2400ff2a:	f1b3 6f80 	cmp.w	r3, #67108864	; 0x4000000
2400ff2e:	d1ee      	bne.n	2400ff0e <HAL_PWREx_EnableUSBReg+0x1a>
    }
  }

  return HAL_OK;
2400ff30:	2300      	movs	r3, #0
}
2400ff32:	4618      	mov	r0, r3
2400ff34:	3708      	adds	r7, #8
2400ff36:	46bd      	mov	sp, r7
2400ff38:	bd80      	pop	{r7, pc}
2400ff3a:	bf00      	nop
2400ff3c:	58024800 	.word	0x58024800

2400ff40 <HAL_PWREx_DisableUSBReg>:
/**
  * @brief Disable the USB Regulator.
  * @retval HAL status.
  */
HAL_StatusTypeDef HAL_PWREx_DisableUSBReg (void)
{
2400ff40:	b580      	push	{r7, lr}
2400ff42:	b082      	sub	sp, #8
2400ff44:	af00      	add	r7, sp, #0
  uint32_t tickstart;

  /* Disable the USB regulator */
  CLEAR_BIT (PWR->CR3, PWR_CR3_USBREGEN);
2400ff46:	4b10      	ldr	r3, [pc, #64]	; (2400ff88 <HAL_PWREx_DisableUSBReg+0x48>)
2400ff48:	68db      	ldr	r3, [r3, #12]
2400ff4a:	4a0f      	ldr	r2, [pc, #60]	; (2400ff88 <HAL_PWREx_DisableUSBReg+0x48>)
2400ff4c:	f023 7300 	bic.w	r3, r3, #33554432	; 0x2000000
2400ff50:	60d3      	str	r3, [r2, #12]

  /* Get tick */
  tickstart = HAL_GetTick ();
2400ff52:	f7f0 fc7f 	bl	24000854 <HAL_GetTick>
2400ff56:	6078      	str	r0, [r7, #4]

  /* Wait till the USB regulator ready flag is reset */
  while(__HAL_PWR_GET_FLAG (PWR_FLAG_USB33RDY) != 0U)
2400ff58:	e009      	b.n	2400ff6e <HAL_PWREx_DisableUSBReg+0x2e>
  {
    if ((HAL_GetTick() - tickstart ) > PWR_FLAG_SETTING_DELAY)
2400ff5a:	f7f0 fc7b 	bl	24000854 <HAL_GetTick>
2400ff5e:	4602      	mov	r2, r0
2400ff60:	687b      	ldr	r3, [r7, #4]
2400ff62:	1ad3      	subs	r3, r2, r3
2400ff64:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
2400ff68:	d901      	bls.n	2400ff6e <HAL_PWREx_DisableUSBReg+0x2e>
    {
      return HAL_ERROR;
2400ff6a:	2301      	movs	r3, #1
2400ff6c:	e007      	b.n	2400ff7e <HAL_PWREx_DisableUSBReg+0x3e>
  while(__HAL_PWR_GET_FLAG (PWR_FLAG_USB33RDY) != 0U)
2400ff6e:	4b06      	ldr	r3, [pc, #24]	; (2400ff88 <HAL_PWREx_DisableUSBReg+0x48>)
2400ff70:	68db      	ldr	r3, [r3, #12]
2400ff72:	f003 6380 	and.w	r3, r3, #67108864	; 0x4000000
2400ff76:	f1b3 6f80 	cmp.w	r3, #67108864	; 0x4000000
2400ff7a:	d0ee      	beq.n	2400ff5a <HAL_PWREx_DisableUSBReg+0x1a>
    }
  }

  return HAL_OK;
2400ff7c:	2300      	movs	r3, #0
}
2400ff7e:	4618      	mov	r0, r3
2400ff80:	3708      	adds	r7, #8
2400ff82:	46bd      	mov	sp, r7
2400ff84:	bd80      	pop	{r7, pc}
2400ff86:	bf00      	nop
2400ff88:	58024800 	.word	0x58024800

2400ff8c <HAL_PWREx_EnableUSBVoltageDetector>:
/**
  * @brief Enable the USB voltage level detector.
  * @retval None.
  */
void HAL_PWREx_EnableUSBVoltageDetector (void)
{
2400ff8c:	b480      	push	{r7}
2400ff8e:	af00      	add	r7, sp, #0
  /* Enable the USB voltage detector */
  SET_BIT (PWR->CR3, PWR_CR3_USB33DEN);
2400ff90:	4b05      	ldr	r3, [pc, #20]	; (2400ffa8 <HAL_PWREx_EnableUSBVoltageDetector+0x1c>)
2400ff92:	68db      	ldr	r3, [r3, #12]
2400ff94:	4a04      	ldr	r2, [pc, #16]	; (2400ffa8 <HAL_PWREx_EnableUSBVoltageDetector+0x1c>)
2400ff96:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
2400ff9a:	60d3      	str	r3, [r2, #12]
}
2400ff9c:	bf00      	nop
2400ff9e:	46bd      	mov	sp, r7
2400ffa0:	f85d 7b04 	ldr.w	r7, [sp], #4
2400ffa4:	4770      	bx	lr
2400ffa6:	bf00      	nop
2400ffa8:	58024800 	.word	0x58024800

2400ffac <HAL_PWREx_DisableUSBVoltageDetector>:
/**
  * @brief Disable the USB voltage level detector.
  * @retval None.
  */
void HAL_PWREx_DisableUSBVoltageDetector (void)
{
2400ffac:	b480      	push	{r7}
2400ffae:	af00      	add	r7, sp, #0
  /* Disable the USB voltage detector */
  CLEAR_BIT (PWR->CR3, PWR_CR3_USB33DEN);
2400ffb0:	4b05      	ldr	r3, [pc, #20]	; (2400ffc8 <HAL_PWREx_DisableUSBVoltageDetector+0x1c>)
2400ffb2:	68db      	ldr	r3, [r3, #12]
2400ffb4:	4a04      	ldr	r2, [pc, #16]	; (2400ffc8 <HAL_PWREx_DisableUSBVoltageDetector+0x1c>)
2400ffb6:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
2400ffba:	60d3      	str	r3, [r2, #12]
}
2400ffbc:	bf00      	nop
2400ffbe:	46bd      	mov	sp, r7
2400ffc0:	f85d 7b04 	ldr.w	r7, [sp], #4
2400ffc4:	4770      	bx	lr
2400ffc6:	bf00      	nop
2400ffc8:	58024800 	.word	0x58024800

2400ffcc <HAL_PWREx_EnableBatteryCharging>:
  *            @arg PWR_BATTERY_CHARGING_RESISTOR_5 : 5 KOhm resistor.
  *            @arg PWR_BATTERY_CHARGING_RESISTOR_1_5 : 1.5 KOhm resistor.
  * @retval None.
  */
void HAL_PWREx_EnableBatteryCharging (uint32_t ResistorValue)
{
2400ffcc:	b480      	push	{r7}
2400ffce:	b083      	sub	sp, #12
2400ffd0:	af00      	add	r7, sp, #0
2400ffd2:	6078      	str	r0, [r7, #4]
  /* Check the parameter */
  assert_param (IS_PWR_BATTERY_RESISTOR_SELECT (ResistorValue));

  /* Specify the charging resistor */
  MODIFY_REG (PWR->CR3, PWR_CR3_VBRS, ResistorValue);
2400ffd4:	4b09      	ldr	r3, [pc, #36]	; (2400fffc <HAL_PWREx_EnableBatteryCharging+0x30>)
2400ffd6:	68db      	ldr	r3, [r3, #12]
2400ffd8:	f423 7200 	bic.w	r2, r3, #512	; 0x200
2400ffdc:	4907      	ldr	r1, [pc, #28]	; (2400fffc <HAL_PWREx_EnableBatteryCharging+0x30>)
2400ffde:	687b      	ldr	r3, [r7, #4]
2400ffe0:	4313      	orrs	r3, r2
2400ffe2:	60cb      	str	r3, [r1, #12]

  /* Enable the Battery charging */
  SET_BIT (PWR->CR3, PWR_CR3_VBE);
2400ffe4:	4b05      	ldr	r3, [pc, #20]	; (2400fffc <HAL_PWREx_EnableBatteryCharging+0x30>)
2400ffe6:	68db      	ldr	r3, [r3, #12]
2400ffe8:	4a04      	ldr	r2, [pc, #16]	; (2400fffc <HAL_PWREx_EnableBatteryCharging+0x30>)
2400ffea:	f443 7380 	orr.w	r3, r3, #256	; 0x100
2400ffee:	60d3      	str	r3, [r2, #12]
}
2400fff0:	bf00      	nop
2400fff2:	370c      	adds	r7, #12
2400fff4:	46bd      	mov	sp, r7
2400fff6:	f85d 7b04 	ldr.w	r7, [sp], #4
2400fffa:	4770      	bx	lr
2400fffc:	58024800 	.word	0x58024800

24010000 <HAL_PWREx_DisableBatteryCharging>:
/**
  * @brief Disable the Battery charging.
  * @retval None.
  */
void HAL_PWREx_DisableBatteryCharging (void)
{
24010000:	b480      	push	{r7}
24010002:	af00      	add	r7, sp, #0
  /* Disable the Battery charging */
  CLEAR_BIT (PWR->CR3, PWR_CR3_VBE);
24010004:	4b05      	ldr	r3, [pc, #20]	; (2401001c <HAL_PWREx_DisableBatteryCharging+0x1c>)
24010006:	68db      	ldr	r3, [r3, #12]
24010008:	4a04      	ldr	r2, [pc, #16]	; (2401001c <HAL_PWREx_DisableBatteryCharging+0x1c>)
2401000a:	f423 7380 	bic.w	r3, r3, #256	; 0x100
2401000e:	60d3      	str	r3, [r2, #12]
}
24010010:	bf00      	nop
24010012:	46bd      	mov	sp, r7
24010014:	f85d 7b04 	ldr.w	r7, [sp], #4
24010018:	4770      	bx	lr
2401001a:	bf00      	nop
2401001c:	58024800 	.word	0x58024800

24010020 <HAL_PWREx_EnableMonitoring>:
/**
  * @brief Enable the VBAT and temperature monitoring.
  * @retval HAL status.
  */
void HAL_PWREx_EnableMonitoring (void)
{
24010020:	b480      	push	{r7}
24010022:	af00      	add	r7, sp, #0
  /* Enable the VBAT and Temperature monitoring */
  SET_BIT (PWR->CR2, PWR_CR2_MONEN);
24010024:	4b05      	ldr	r3, [pc, #20]	; (2401003c <HAL_PWREx_EnableMonitoring+0x1c>)
24010026:	689b      	ldr	r3, [r3, #8]
24010028:	4a04      	ldr	r2, [pc, #16]	; (2401003c <HAL_PWREx_EnableMonitoring+0x1c>)
2401002a:	f043 0310 	orr.w	r3, r3, #16
2401002e:	6093      	str	r3, [r2, #8]
}
24010030:	bf00      	nop
24010032:	46bd      	mov	sp, r7
24010034:	f85d 7b04 	ldr.w	r7, [sp], #4
24010038:	4770      	bx	lr
2401003a:	bf00      	nop
2401003c:	58024800 	.word	0x58024800

24010040 <HAL_PWREx_DisableMonitoring>:
/**
  * @brief Disable the VBAT and temperature monitoring.
  * @retval HAL status.
  */
void HAL_PWREx_DisableMonitoring (void)
{
24010040:	b480      	push	{r7}
24010042:	af00      	add	r7, sp, #0
  /* Disable the VBAT and Temperature monitoring */
  CLEAR_BIT (PWR->CR2, PWR_CR2_MONEN);
24010044:	4b05      	ldr	r3, [pc, #20]	; (2401005c <HAL_PWREx_DisableMonitoring+0x1c>)
24010046:	689b      	ldr	r3, [r3, #8]
24010048:	4a04      	ldr	r2, [pc, #16]	; (2401005c <HAL_PWREx_DisableMonitoring+0x1c>)
2401004a:	f023 0310 	bic.w	r3, r3, #16
2401004e:	6093      	str	r3, [r2, #8]
}
24010050:	bf00      	nop
24010052:	46bd      	mov	sp, r7
24010054:	f85d 7b04 	ldr.w	r7, [sp], #4
24010058:	4770      	bx	lr
2401005a:	bf00      	nop
2401005c:	58024800 	.word	0x58024800

24010060 <HAL_PWREx_GetTemperatureLevel>:
  * @brief Indicate whether the junction temperature is between, above or below
  *        the thresholds.
  * @retval Temperature level.
  */
uint32_t HAL_PWREx_GetTemperatureLevel (void)
{
24010060:	b480      	push	{r7}
24010062:	b083      	sub	sp, #12
24010064:	af00      	add	r7, sp, #0
  uint32_t tempLevel, regValue;

  /* Read the temperature flags */
  regValue = READ_BIT (PWR->CR2, (PWR_CR2_TEMPH | PWR_CR2_TEMPL));
24010066:	4b0f      	ldr	r3, [pc, #60]	; (240100a4 <HAL_PWREx_GetTemperatureLevel+0x44>)
24010068:	689b      	ldr	r3, [r3, #8]
2401006a:	f403 0340 	and.w	r3, r3, #12582912	; 0xc00000
2401006e:	603b      	str	r3, [r7, #0]

  /* Check if the temperature is below the threshold */
  if (regValue == PWR_CR2_TEMPL)
24010070:	683b      	ldr	r3, [r7, #0]
24010072:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
24010076:	d103      	bne.n	24010080 <HAL_PWREx_GetTemperatureLevel+0x20>
  {
    tempLevel = PWR_TEMP_BELOW_LOW_THRESHOLD;
24010078:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
2401007c:	607b      	str	r3, [r7, #4]
2401007e:	e009      	b.n	24010094 <HAL_PWREx_GetTemperatureLevel+0x34>
  }
  /* Check if the temperature is above the threshold */
  else if (regValue == PWR_CR2_TEMPH)
24010080:	683b      	ldr	r3, [r7, #0]
24010082:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
24010086:	d103      	bne.n	24010090 <HAL_PWREx_GetTemperatureLevel+0x30>
  {
    tempLevel = PWR_TEMP_ABOVE_HIGH_THRESHOLD;
24010088:	f44f 0300 	mov.w	r3, #8388608	; 0x800000
2401008c:	607b      	str	r3, [r7, #4]
2401008e:	e001      	b.n	24010094 <HAL_PWREx_GetTemperatureLevel+0x34>
  }
  /* The temperature is between the thresholds */
  else
  {
    tempLevel = PWR_TEMP_BETWEEN_HIGH_LOW_THRESHOLD;
24010090:	2300      	movs	r3, #0
24010092:	607b      	str	r3, [r7, #4]
  }

  return tempLevel;
24010094:	687b      	ldr	r3, [r7, #4]
}
24010096:	4618      	mov	r0, r3
24010098:	370c      	adds	r7, #12
2401009a:	46bd      	mov	sp, r7
2401009c:	f85d 7b04 	ldr.w	r7, [sp], #4
240100a0:	4770      	bx	lr
240100a2:	bf00      	nop
240100a4:	58024800 	.word	0x58024800

240100a8 <HAL_PWREx_GetVBATLevel>:
  * @brief Indicate whether the Battery voltage level is between, above or below
  *        the thresholds.
  * @retval VBAT level.
  */
uint32_t HAL_PWREx_GetVBATLevel (void)
{
240100a8:	b480      	push	{r7}
240100aa:	b083      	sub	sp, #12
240100ac:	af00      	add	r7, sp, #0
  uint32_t VBATLevel, regValue;

  /* Read the VBAT flags */
  regValue = READ_BIT (PWR->CR2, (PWR_CR2_VBATH | PWR_CR2_VBATL));
240100ae:	4b0f      	ldr	r3, [pc, #60]	; (240100ec <HAL_PWREx_GetVBATLevel+0x44>)
240100b0:	689b      	ldr	r3, [r3, #8]
240100b2:	f403 1340 	and.w	r3, r3, #3145728	; 0x300000
240100b6:	603b      	str	r3, [r7, #0]

  /* Check if the VBAT is below the threshold */
  if (regValue == PWR_CR2_VBATL)
240100b8:	683b      	ldr	r3, [r7, #0]
240100ba:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
240100be:	d103      	bne.n	240100c8 <HAL_PWREx_GetVBATLevel+0x20>
  {
    VBATLevel = PWR_VBAT_BELOW_LOW_THRESHOLD;
240100c0:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
240100c4:	607b      	str	r3, [r7, #4]
240100c6:	e009      	b.n	240100dc <HAL_PWREx_GetVBATLevel+0x34>
  }
  /* Check if the VBAT is above the threshold */
  else if (regValue == PWR_CR2_VBATH)
240100c8:	683b      	ldr	r3, [r7, #0]
240100ca:	f5b3 1f00 	cmp.w	r3, #2097152	; 0x200000
240100ce:	d103      	bne.n	240100d8 <HAL_PWREx_GetVBATLevel+0x30>
  {
    VBATLevel = PWR_VBAT_ABOVE_HIGH_THRESHOLD;
240100d0:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
240100d4:	607b      	str	r3, [r7, #4]
240100d6:	e001      	b.n	240100dc <HAL_PWREx_GetVBATLevel+0x34>
  }
  /* The VBAT is between the thresholds */
  else
  {
    VBATLevel = PWR_VBAT_BETWEEN_HIGH_LOW_THRESHOLD;
240100d8:	2300      	movs	r3, #0
240100da:	607b      	str	r3, [r7, #4]
  }

  return VBATLevel;
240100dc:	687b      	ldr	r3, [r7, #4]
}
240100de:	4618      	mov	r0, r3
240100e0:	370c      	adds	r7, #12
240100e2:	46bd      	mov	sp, r7
240100e4:	f85d 7b04 	ldr.w	r7, [sp], #4
240100e8:	4770      	bx	lr
240100ea:	bf00      	nop
240100ec:	58024800 	.word	0x58024800

240100f0 <HAL_PWREx_ConfigAVD>:
  *         driver. All combination are allowed: wake up only Cortex-M7, wake up
  *         only Cortex-M4 and wake up Cortex-M7 and Cortex-M4.
  * @retval None.
  */
void HAL_PWREx_ConfigAVD (PWREx_AVDTypeDef *sConfigAVD)
{
240100f0:	b480      	push	{r7}
240100f2:	b083      	sub	sp, #12
240100f4:	af00      	add	r7, sp, #0
240100f6:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param (IS_PWR_AVD_LEVEL (sConfigAVD->AVDLevel));
  assert_param (IS_PWR_AVD_MODE (sConfigAVD->Mode));

  /* Set the ALS[18:17] bits according to AVDLevel value */
  MODIFY_REG (PWR->CR1, PWR_CR1_ALS, sConfigAVD->AVDLevel);
240100f8:	4b37      	ldr	r3, [pc, #220]	; (240101d8 <HAL_PWREx_ConfigAVD+0xe8>)
240100fa:	681b      	ldr	r3, [r3, #0]
240100fc:	f423 22c0 	bic.w	r2, r3, #393216	; 0x60000
24010100:	687b      	ldr	r3, [r7, #4]
24010102:	681b      	ldr	r3, [r3, #0]
24010104:	4934      	ldr	r1, [pc, #208]	; (240101d8 <HAL_PWREx_ConfigAVD+0xe8>)
24010106:	4313      	orrs	r3, r2
24010108:	600b      	str	r3, [r1, #0]

  /* Clear any previous config */
#if !defined (DUAL_CORE)
  __HAL_PWR_AVD_EXTI_DISABLE_EVENT ();
2401010a:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
2401010e:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
24010112:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
24010116:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
2401011a:	f8c2 3084 	str.w	r3, [r2, #132]	; 0x84
  __HAL_PWR_AVD_EXTI_DISABLE_IT ();
2401011e:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
24010122:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
24010126:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
2401012a:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
2401012e:	f8c2 3080 	str.w	r3, [r2, #128]	; 0x80
#endif /* !defined (DUAL_CORE) */

  __HAL_PWR_AVD_EXTI_DISABLE_RISING_EDGE ();
24010132:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
24010136:	681b      	ldr	r3, [r3, #0]
24010138:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
2401013c:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
24010140:	6013      	str	r3, [r2, #0]
  __HAL_PWR_AVD_EXTI_DISABLE_FALLING_EDGE ();
24010142:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
24010146:	685b      	ldr	r3, [r3, #4]
24010148:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
2401014c:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
24010150:	6053      	str	r3, [r2, #4]

#if !defined (DUAL_CORE)
  /* Configure the interrupt mode */
  if ((sConfigAVD->Mode & AVD_MODE_IT) == AVD_MODE_IT)
24010152:	687b      	ldr	r3, [r7, #4]
24010154:	685b      	ldr	r3, [r3, #4]
24010156:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
2401015a:	2b00      	cmp	r3, #0
2401015c:	d009      	beq.n	24010172 <HAL_PWREx_ConfigAVD+0x82>
  {
    __HAL_PWR_AVD_EXTI_ENABLE_IT ();
2401015e:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
24010162:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
24010166:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
2401016a:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
2401016e:	f8c2 3080 	str.w	r3, [r2, #128]	; 0x80
  }

  /* Configure the event mode */
  if ((sConfigAVD->Mode & AVD_MODE_EVT) == AVD_MODE_EVT)
24010172:	687b      	ldr	r3, [r7, #4]
24010174:	685b      	ldr	r3, [r3, #4]
24010176:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
2401017a:	2b00      	cmp	r3, #0
2401017c:	d009      	beq.n	24010192 <HAL_PWREx_ConfigAVD+0xa2>
  {
    __HAL_PWR_AVD_EXTI_ENABLE_EVENT ();
2401017e:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
24010182:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
24010186:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
2401018a:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
2401018e:	f8c2 3084 	str.w	r3, [r2, #132]	; 0x84
  }
#endif /* !defined (DUAL_CORE) */

  /* Rising edge configuration */
  if ((sConfigAVD->Mode & AVD_RISING_EDGE) == AVD_RISING_EDGE)
24010192:	687b      	ldr	r3, [r7, #4]
24010194:	685b      	ldr	r3, [r3, #4]
24010196:	f003 0301 	and.w	r3, r3, #1
2401019a:	2b00      	cmp	r3, #0
2401019c:	d007      	beq.n	240101ae <HAL_PWREx_ConfigAVD+0xbe>
  {
    __HAL_PWR_AVD_EXTI_ENABLE_RISING_EDGE ();
2401019e:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
240101a2:	681b      	ldr	r3, [r3, #0]
240101a4:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
240101a8:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
240101ac:	6013      	str	r3, [r2, #0]
  }

  /* Falling edge configuration */
  if ((sConfigAVD->Mode & AVD_FALLING_EDGE) == AVD_FALLING_EDGE)
240101ae:	687b      	ldr	r3, [r7, #4]
240101b0:	685b      	ldr	r3, [r3, #4]
240101b2:	f003 0302 	and.w	r3, r3, #2
240101b6:	2b00      	cmp	r3, #0
240101b8:	d007      	beq.n	240101ca <HAL_PWREx_ConfigAVD+0xda>
  {
    __HAL_PWR_AVD_EXTI_ENABLE_FALLING_EDGE ();
240101ba:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
240101be:	685b      	ldr	r3, [r3, #4]
240101c0:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
240101c4:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
240101c8:	6053      	str	r3, [r2, #4]
  }
}
240101ca:	bf00      	nop
240101cc:	370c      	adds	r7, #12
240101ce:	46bd      	mov	sp, r7
240101d0:	f85d 7b04 	ldr.w	r7, [sp], #4
240101d4:	4770      	bx	lr
240101d6:	bf00      	nop
240101d8:	58024800 	.word	0x58024800

240101dc <HAL_PWREx_EnableAVD>:
/**
  * @brief Enable the Analog Voltage Detector (AVD).
  * @retval None.
  */
void HAL_PWREx_EnableAVD (void)
{
240101dc:	b480      	push	{r7}
240101de:	af00      	add	r7, sp, #0
  /* Enable the Analog Voltage Detector */
  SET_BIT (PWR->CR1, PWR_CR1_AVDEN);
240101e0:	4b05      	ldr	r3, [pc, #20]	; (240101f8 <HAL_PWREx_EnableAVD+0x1c>)
240101e2:	681b      	ldr	r3, [r3, #0]
240101e4:	4a04      	ldr	r2, [pc, #16]	; (240101f8 <HAL_PWREx_EnableAVD+0x1c>)
240101e6:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
240101ea:	6013      	str	r3, [r2, #0]
}
240101ec:	bf00      	nop
240101ee:	46bd      	mov	sp, r7
240101f0:	f85d 7b04 	ldr.w	r7, [sp], #4
240101f4:	4770      	bx	lr
240101f6:	bf00      	nop
240101f8:	58024800 	.word	0x58024800

240101fc <HAL_PWREx_DisableAVD>:
/**
  * @brief Disable the Analog Voltage Detector(AVD).
  * @retval None.
  */
void HAL_PWREx_DisableAVD (void)
{
240101fc:	b480      	push	{r7}
240101fe:	af00      	add	r7, sp, #0
  /* Disable the Analog Voltage Detector */
  CLEAR_BIT (PWR->CR1, PWR_CR1_AVDEN);
24010200:	4b05      	ldr	r3, [pc, #20]	; (24010218 <HAL_PWREx_DisableAVD+0x1c>)
24010202:	681b      	ldr	r3, [r3, #0]
24010204:	4a04      	ldr	r2, [pc, #16]	; (24010218 <HAL_PWREx_DisableAVD+0x1c>)
24010206:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
2401020a:	6013      	str	r3, [r2, #0]
}
2401020c:	bf00      	nop
2401020e:	46bd      	mov	sp, r7
24010210:	f85d 7b04 	ldr.w	r7, [sp], #4
24010214:	4770      	bx	lr
24010216:	bf00      	nop
24010218:	58024800 	.word	0x58024800

2401021c <HAL_PWREx_PVD_AVD_IRQHandler>:
  * @brief  This function handles the PWR PVD/AVD interrupt request.
  * @note   This API should be called under the PVD_AVD_IRQHandler().
  * @retval None
  */
void HAL_PWREx_PVD_AVD_IRQHandler (void)
{
2401021c:	b580      	push	{r7, lr}
2401021e:	af00      	add	r7, sp, #0
  /* Check if the Programmable Voltage Detector is enabled (PVD) */
  if(READ_BIT (PWR->CR1, PWR_CR1_PVDEN) != 0U)
24010220:	4b1b      	ldr	r3, [pc, #108]	; (24010290 <HAL_PWREx_PVD_AVD_IRQHandler+0x74>)
24010222:	681b      	ldr	r3, [r3, #0]
24010224:	f003 0310 	and.w	r3, r3, #16
24010228:	2b00      	cmp	r3, #0
2401022a:	d014      	beq.n	24010256 <HAL_PWREx_PVD_AVD_IRQHandler+0x3a>
#if defined (DUAL_CORE)
    if (HAL_GetCurrentCPUID () == CM7_CPUID)
#endif /* defined (DUAL_CORE) */
    {
      /* Check PWR D1/CD EXTI flag */
      if(__HAL_PWR_PVD_EXTI_GET_FLAG () != 0U)
2401022c:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
24010230:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
24010234:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
24010238:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
2401023c:	d10b      	bne.n	24010256 <HAL_PWREx_PVD_AVD_IRQHandler+0x3a>
      {
        /* PWR PVD interrupt user callback */
        HAL_PWR_PVDCallback ();
2401023e:	f7ff fb12 	bl	2400f866 <HAL_PWR_PVDCallback>

        /* Clear PWR EXTI D1/CD pending bit */
        __HAL_PWR_PVD_EXTI_CLEAR_FLAG ();
24010242:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
24010246:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
2401024a:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
2401024e:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
24010252:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
    }
#endif /* defined (DUAL_CORE) */
  }

  /* Check if the Analog Voltage Detector is enabled (AVD) */
  if (READ_BIT (PWR->CR1, PWR_CR1_AVDEN) != 0U)
24010256:	4b0e      	ldr	r3, [pc, #56]	; (24010290 <HAL_PWREx_PVD_AVD_IRQHandler+0x74>)
24010258:	681b      	ldr	r3, [r3, #0]
2401025a:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
2401025e:	2b00      	cmp	r3, #0
24010260:	d014      	beq.n	2401028c <HAL_PWREx_PVD_AVD_IRQHandler+0x70>
#if defined (DUAL_CORE)
    if (HAL_GetCurrentCPUID () == CM7_CPUID)
#endif /* defined (DUAL_CORE) */
    {
      /* Check PWR EXTI D1/CD flag */
      if (__HAL_PWR_AVD_EXTI_GET_FLAG () != 0U)
24010262:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
24010266:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
2401026a:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
2401026e:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
24010272:	d10b      	bne.n	2401028c <HAL_PWREx_PVD_AVD_IRQHandler+0x70>
      {
        /* PWR AVD interrupt user callback */
        HAL_PWREx_AVDCallback ();
24010274:	f000 f80e 	bl	24010294 <HAL_PWREx_AVDCallback>

        /* Clear PWR EXTI D1/CD pending bit */
        __HAL_PWR_AVD_EXTI_CLEAR_FLAG ();
24010278:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
2401027c:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
24010280:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
24010284:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
24010288:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
        __HAL_PWR_AVD_EXTID2_CLEAR_FLAG ();
      }
    }
#endif /* defined (DUAL_CORE) */
  }
}
2401028c:	bf00      	nop
2401028e:	bd80      	pop	{r7, pc}
24010290:	58024800 	.word	0x58024800

24010294 <HAL_PWREx_AVDCallback>:
/**
  * @brief PWR AVD interrupt callback.
  * @retval None.
  */
__weak void HAL_PWREx_AVDCallback (void)
{
24010294:	b480      	push	{r7}
24010296:	af00      	add	r7, sp, #0
  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_PWR_AVDCallback can be implemented in the user file
  */
}
24010298:	bf00      	nop
2401029a:	46bd      	mov	sp, r7
2401029c:	f85d 7b04 	ldr.w	r7, [sp], #4
240102a0:	4770      	bx	lr
	...

240102a4 <HAL_QSPI_Init>:
  *        in the QSPI_InitTypeDef and initialize the associated handle.
  * @param hqspi : QSPI handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_QSPI_Init(QSPI_HandleTypeDef *hqspi)
{
240102a4:	b580      	push	{r7, lr}
240102a6:	b086      	sub	sp, #24
240102a8:	af02      	add	r7, sp, #8
240102aa:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef status;
  uint32_t tickstart = HAL_GetTick();
240102ac:	f7f0 fad2 	bl	24000854 <HAL_GetTick>
240102b0:	60f8      	str	r0, [r7, #12]

  /* Check the QSPI handle allocation */
  if(hqspi == NULL)
240102b2:	687b      	ldr	r3, [r7, #4]
240102b4:	2b00      	cmp	r3, #0
240102b6:	d101      	bne.n	240102bc <HAL_QSPI_Init+0x18>
  {
    return HAL_ERROR;
240102b8:	2301      	movs	r3, #1
240102ba:	e05f      	b.n	2401037c <HAL_QSPI_Init+0xd8>
  if (hqspi->Init.DualFlash != QSPI_DUALFLASH_ENABLE )
  {
    assert_param(IS_QSPI_FLASH_ID(hqspi->Init.FlashID));
  }

  if(hqspi->State == HAL_QSPI_STATE_RESET)
240102bc:	687b      	ldr	r3, [r7, #4]
240102be:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
240102c2:	b2db      	uxtb	r3, r3
240102c4:	2b00      	cmp	r3, #0
240102c6:	d107      	bne.n	240102d8 <HAL_QSPI_Init+0x34>

    /* Init the low level hardware */
    hqspi->MspInitCallback(hqspi);
#else
    /* Init the low level hardware : GPIO, CLOCK */
    HAL_QSPI_MspInit(hqspi);
240102c8:	6878      	ldr	r0, [r7, #4]
240102ca:	f005 ff6d 	bl	240161a8 <HAL_QSPI_MspInit>
#endif

    /* Configure the default timeout for the QSPI memory access */
    HAL_QSPI_SetTimeout(hqspi, HAL_QSPI_TIMEOUT_DEFAULT_VALUE);
240102ce:	f241 3188 	movw	r1, #5000	; 0x1388
240102d2:	6878      	ldr	r0, [r7, #4]
240102d4:	f001 f97a 	bl	240115cc <HAL_QSPI_SetTimeout>
  }

  /* Configure QSPI FIFO Threshold */
  MODIFY_REG(hqspi->Instance->CR, QUADSPI_CR_FTHRES,
240102d8:	687b      	ldr	r3, [r7, #4]
240102da:	681b      	ldr	r3, [r3, #0]
240102dc:	681b      	ldr	r3, [r3, #0]
240102de:	f423 6170 	bic.w	r1, r3, #3840	; 0xf00
240102e2:	687b      	ldr	r3, [r7, #4]
240102e4:	689b      	ldr	r3, [r3, #8]
240102e6:	3b01      	subs	r3, #1
240102e8:	021a      	lsls	r2, r3, #8
240102ea:	687b      	ldr	r3, [r7, #4]
240102ec:	681b      	ldr	r3, [r3, #0]
240102ee:	430a      	orrs	r2, r1
240102f0:	601a      	str	r2, [r3, #0]
             ((hqspi->Init.FifoThreshold - 1U) << QUADSPI_CR_FTHRES_Pos));

  /* Wait till BUSY flag reset */
  status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_BUSY, RESET, tickstart, hqspi->Timeout);
240102f2:	687b      	ldr	r3, [r7, #4]
240102f4:	6c9b      	ldr	r3, [r3, #72]	; 0x48
240102f6:	9300      	str	r3, [sp, #0]
240102f8:	68fb      	ldr	r3, [r7, #12]
240102fa:	2200      	movs	r2, #0
240102fc:	2120      	movs	r1, #32
240102fe:	6878      	ldr	r0, [r7, #4]
24010300:	f001 fa73 	bl	240117ea <QSPI_WaitFlagStateUntilTimeout>
24010304:	4603      	mov	r3, r0
24010306:	72fb      	strb	r3, [r7, #11]

  if(status == HAL_OK)
24010308:	7afb      	ldrb	r3, [r7, #11]
2401030a:	2b00      	cmp	r3, #0
2401030c:	d135      	bne.n	2401037a <HAL_QSPI_Init+0xd6>
  {
    /* Configure QSPI Clock Prescaler and Sample Shift */
    MODIFY_REG(hqspi->Instance->CR, (QUADSPI_CR_PRESCALER | QUADSPI_CR_SSHIFT | QUADSPI_CR_FSEL | QUADSPI_CR_DFM),
2401030e:	687b      	ldr	r3, [r7, #4]
24010310:	681b      	ldr	r3, [r3, #0]
24010312:	681a      	ldr	r2, [r3, #0]
24010314:	4b1b      	ldr	r3, [pc, #108]	; (24010384 <HAL_QSPI_Init+0xe0>)
24010316:	4013      	ands	r3, r2
24010318:	687a      	ldr	r2, [r7, #4]
2401031a:	6852      	ldr	r2, [r2, #4]
2401031c:	0611      	lsls	r1, r2, #24
2401031e:	687a      	ldr	r2, [r7, #4]
24010320:	68d2      	ldr	r2, [r2, #12]
24010322:	4311      	orrs	r1, r2
24010324:	687a      	ldr	r2, [r7, #4]
24010326:	69d2      	ldr	r2, [r2, #28]
24010328:	4311      	orrs	r1, r2
2401032a:	687a      	ldr	r2, [r7, #4]
2401032c:	6a12      	ldr	r2, [r2, #32]
2401032e:	4311      	orrs	r1, r2
24010330:	687a      	ldr	r2, [r7, #4]
24010332:	6812      	ldr	r2, [r2, #0]
24010334:	430b      	orrs	r3, r1
24010336:	6013      	str	r3, [r2, #0]
               ((hqspi->Init.ClockPrescaler << QUADSPI_CR_PRESCALER_Pos) |
                hqspi->Init.SampleShifting  | hqspi->Init.FlashID | hqspi->Init.DualFlash));

    /* Configure QSPI Flash Size, CS High Time and Clock Mode */
    MODIFY_REG(hqspi->Instance->DCR, (QUADSPI_DCR_FSIZE | QUADSPI_DCR_CSHT | QUADSPI_DCR_CKMODE),
24010338:	687b      	ldr	r3, [r7, #4]
2401033a:	681b      	ldr	r3, [r3, #0]
2401033c:	685a      	ldr	r2, [r3, #4]
2401033e:	4b12      	ldr	r3, [pc, #72]	; (24010388 <HAL_QSPI_Init+0xe4>)
24010340:	4013      	ands	r3, r2
24010342:	687a      	ldr	r2, [r7, #4]
24010344:	6912      	ldr	r2, [r2, #16]
24010346:	0411      	lsls	r1, r2, #16
24010348:	687a      	ldr	r2, [r7, #4]
2401034a:	6952      	ldr	r2, [r2, #20]
2401034c:	4311      	orrs	r1, r2
2401034e:	687a      	ldr	r2, [r7, #4]
24010350:	6992      	ldr	r2, [r2, #24]
24010352:	4311      	orrs	r1, r2
24010354:	687a      	ldr	r2, [r7, #4]
24010356:	6812      	ldr	r2, [r2, #0]
24010358:	430b      	orrs	r3, r1
2401035a:	6053      	str	r3, [r2, #4]
               ((hqspi->Init.FlashSize << QUADSPI_DCR_FSIZE_Pos) |
                hqspi->Init.ChipSelectHighTime | hqspi->Init.ClockMode));

    /* Enable the QSPI peripheral */
    __HAL_QSPI_ENABLE(hqspi);
2401035c:	687b      	ldr	r3, [r7, #4]
2401035e:	681b      	ldr	r3, [r3, #0]
24010360:	681a      	ldr	r2, [r3, #0]
24010362:	687b      	ldr	r3, [r7, #4]
24010364:	681b      	ldr	r3, [r3, #0]
24010366:	f042 0201 	orr.w	r2, r2, #1
2401036a:	601a      	str	r2, [r3, #0]

    /* Set QSPI error code to none */
    hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
2401036c:	687b      	ldr	r3, [r7, #4]
2401036e:	2200      	movs	r2, #0
24010370:	645a      	str	r2, [r3, #68]	; 0x44

    /* Initialize the QSPI state */
    hqspi->State = HAL_QSPI_STATE_READY;
24010372:	687b      	ldr	r3, [r7, #4]
24010374:	2201      	movs	r2, #1
24010376:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
  }

  /* Return function status */
  return status;
2401037a:	7afb      	ldrb	r3, [r7, #11]
}
2401037c:	4618      	mov	r0, r3
2401037e:	3710      	adds	r7, #16
24010380:	46bd      	mov	sp, r7
24010382:	bd80      	pop	{r7, pc}
24010384:	00ffff2f 	.word	0x00ffff2f
24010388:	ffe0f8fe 	.word	0xffe0f8fe

2401038c <HAL_QSPI_DeInit>:
  * @brief De-Initialize the QSPI peripheral.
  * @param hqspi : QSPI handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_QSPI_DeInit(QSPI_HandleTypeDef *hqspi)
{
2401038c:	b580      	push	{r7, lr}
2401038e:	b082      	sub	sp, #8
24010390:	af00      	add	r7, sp, #0
24010392:	6078      	str	r0, [r7, #4]
  /* Check the QSPI handle allocation */
  if(hqspi == NULL)
24010394:	687b      	ldr	r3, [r7, #4]
24010396:	2b00      	cmp	r3, #0
24010398:	d101      	bne.n	2401039e <HAL_QSPI_DeInit+0x12>
  {
    return HAL_ERROR;
2401039a:	2301      	movs	r3, #1
2401039c:	e012      	b.n	240103c4 <HAL_QSPI_DeInit+0x38>
  }

  /* Disable the QSPI Peripheral Clock */
  __HAL_QSPI_DISABLE(hqspi);
2401039e:	687b      	ldr	r3, [r7, #4]
240103a0:	681b      	ldr	r3, [r3, #0]
240103a2:	681a      	ldr	r2, [r3, #0]
240103a4:	687b      	ldr	r3, [r7, #4]
240103a6:	681b      	ldr	r3, [r3, #0]
240103a8:	f022 0201 	bic.w	r2, r2, #1
240103ac:	601a      	str	r2, [r3, #0]

  /* DeInit the low level hardware */
  hqspi->MspDeInitCallback(hqspi);
#else
  /* DeInit the low level hardware: GPIO, CLOCK, NVIC... */
  HAL_QSPI_MspDeInit(hqspi);
240103ae:	6878      	ldr	r0, [r7, #4]
240103b0:	f005 ff88 	bl	240162c4 <HAL_QSPI_MspDeInit>
#endif

  /* Set QSPI error code to none */
  hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
240103b4:	687b      	ldr	r3, [r7, #4]
240103b6:	2200      	movs	r2, #0
240103b8:	645a      	str	r2, [r3, #68]	; 0x44

  /* Initialize the QSPI state */
  hqspi->State = HAL_QSPI_STATE_RESET;
240103ba:	687b      	ldr	r3, [r7, #4]
240103bc:	2200      	movs	r2, #0
240103be:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

  return HAL_OK;
240103c2:	2300      	movs	r3, #0
}
240103c4:	4618      	mov	r0, r3
240103c6:	3708      	adds	r7, #8
240103c8:	46bd      	mov	sp, r7
240103ca:	bd80      	pop	{r7, pc}
  * @brief Initialize the QSPI MSP.
  * @param hqspi : QSPI handle
  * @retval None
  */
__weak void HAL_QSPI_MspInit(QSPI_HandleTypeDef *hqspi)
{
240103cc:	b480      	push	{r7}
240103ce:	b083      	sub	sp, #12
240103d0:	af00      	add	r7, sp, #0
240103d2:	6078      	str	r0, [r7, #4]
  UNUSED(hqspi);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_QSPI_MspInit can be implemented in the user file
   */
}
240103d4:	bf00      	nop
240103d6:	370c      	adds	r7, #12
240103d8:	46bd      	mov	sp, r7
240103da:	f85d 7b04 	ldr.w	r7, [sp], #4
240103de:	4770      	bx	lr
  * @brief DeInitialize the QSPI MSP.
  * @param hqspi : QSPI handle
  * @retval None
  */
__weak void HAL_QSPI_MspDeInit(QSPI_HandleTypeDef *hqspi)
{
240103e0:	b480      	push	{r7}
240103e2:	b083      	sub	sp, #12
240103e4:	af00      	add	r7, sp, #0
240103e6:	6078      	str	r0, [r7, #4]
  UNUSED(hqspi);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_QSPI_MspDeInit can be implemented in the user file
   */
}
240103e8:	bf00      	nop
240103ea:	370c      	adds	r7, #12
240103ec:	46bd      	mov	sp, r7
240103ee:	f85d 7b04 	ldr.w	r7, [sp], #4
240103f2:	4770      	bx	lr

240103f4 <HAL_QSPI_IRQHandler>:
  * @brief Handle QSPI interrupt request.
  * @param hqspi : QSPI handle
  * @retval None
  */
void HAL_QSPI_IRQHandler(QSPI_HandleTypeDef *hqspi)
{
240103f4:	b580      	push	{r7, lr}
240103f6:	b086      	sub	sp, #24
240103f8:	af00      	add	r7, sp, #0
240103fa:	6078      	str	r0, [r7, #4]
  __IO uint32_t *data_reg;
  uint32_t flag = READ_REG(hqspi->Instance->SR);
240103fc:	687b      	ldr	r3, [r7, #4]
240103fe:	681b      	ldr	r3, [r3, #0]
24010400:	689b      	ldr	r3, [r3, #8]
24010402:	617b      	str	r3, [r7, #20]
  uint32_t itsource = READ_REG(hqspi->Instance->CR);
24010404:	687b      	ldr	r3, [r7, #4]
24010406:	681b      	ldr	r3, [r3, #0]
24010408:	681b      	ldr	r3, [r3, #0]
2401040a:	613b      	str	r3, [r7, #16]

  /* QSPI Fifo Threshold interrupt occurred ----------------------------------*/
  if(((flag & QSPI_FLAG_FT) != 0U) && ((itsource & QSPI_IT_FT) != 0U))
2401040c:	697b      	ldr	r3, [r7, #20]
2401040e:	f003 0304 	and.w	r3, r3, #4
24010412:	2b00      	cmp	r3, #0
24010414:	d064      	beq.n	240104e0 <HAL_QSPI_IRQHandler+0xec>
24010416:	693b      	ldr	r3, [r7, #16]
24010418:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
2401041c:	2b00      	cmp	r3, #0
2401041e:	d05f      	beq.n	240104e0 <HAL_QSPI_IRQHandler+0xec>
  {
    data_reg = &hqspi->Instance->DR;
24010420:	687b      	ldr	r3, [r7, #4]
24010422:	681b      	ldr	r3, [r3, #0]
24010424:	3320      	adds	r3, #32
24010426:	60fb      	str	r3, [r7, #12]

    if(hqspi->State == HAL_QSPI_STATE_BUSY_INDIRECT_TX)
24010428:	687b      	ldr	r3, [r7, #4]
2401042a:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2401042e:	b2db      	uxtb	r3, r3
24010430:	2b12      	cmp	r3, #18
24010432:	d125      	bne.n	24010480 <HAL_QSPI_IRQHandler+0x8c>
    {
      /* Transmission process */
      while(__HAL_QSPI_GET_FLAG(hqspi, QSPI_FLAG_FT) != RESET)
24010434:	e01c      	b.n	24010470 <HAL_QSPI_IRQHandler+0x7c>
      {
        if (hqspi->TxXferCount > 0U)
24010436:	687b      	ldr	r3, [r7, #4]
24010438:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2401043a:	2b00      	cmp	r3, #0
2401043c:	d00f      	beq.n	2401045e <HAL_QSPI_IRQHandler+0x6a>
        {
          /* Fill the FIFO until the threshold is reached */
          *((__IO uint8_t *)data_reg) = *hqspi->pTxBuffPtr;
2401043e:	687b      	ldr	r3, [r7, #4]
24010440:	6a5b      	ldr	r3, [r3, #36]	; 0x24
24010442:	781a      	ldrb	r2, [r3, #0]
24010444:	68fb      	ldr	r3, [r7, #12]
24010446:	701a      	strb	r2, [r3, #0]
          hqspi->pTxBuffPtr++;
24010448:	687b      	ldr	r3, [r7, #4]
2401044a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2401044c:	1c5a      	adds	r2, r3, #1
2401044e:	687b      	ldr	r3, [r7, #4]
24010450:	625a      	str	r2, [r3, #36]	; 0x24
          hqspi->TxXferCount--;
24010452:	687b      	ldr	r3, [r7, #4]
24010454:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24010456:	1e5a      	subs	r2, r3, #1
24010458:	687b      	ldr	r3, [r7, #4]
2401045a:	62da      	str	r2, [r3, #44]	; 0x2c
2401045c:	e008      	b.n	24010470 <HAL_QSPI_IRQHandler+0x7c>
        }
        else
        {
          /* No more data available for the transfer */
          /* Disable the QSPI FIFO Threshold Interrupt */
          __HAL_QSPI_DISABLE_IT(hqspi, QSPI_IT_FT);
2401045e:	687b      	ldr	r3, [r7, #4]
24010460:	681b      	ldr	r3, [r3, #0]
24010462:	681a      	ldr	r2, [r3, #0]
24010464:	687b      	ldr	r3, [r7, #4]
24010466:	681b      	ldr	r3, [r3, #0]
24010468:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
2401046c:	601a      	str	r2, [r3, #0]
          break;
2401046e:	e033      	b.n	240104d8 <HAL_QSPI_IRQHandler+0xe4>
      while(__HAL_QSPI_GET_FLAG(hqspi, QSPI_FLAG_FT) != RESET)
24010470:	687b      	ldr	r3, [r7, #4]
24010472:	681b      	ldr	r3, [r3, #0]
24010474:	689b      	ldr	r3, [r3, #8]
24010476:	f003 0304 	and.w	r3, r3, #4
2401047a:	2b00      	cmp	r3, #0
2401047c:	d1db      	bne.n	24010436 <HAL_QSPI_IRQHandler+0x42>
2401047e:	e02b      	b.n	240104d8 <HAL_QSPI_IRQHandler+0xe4>
        }
      }
    }
    else if(hqspi->State == HAL_QSPI_STATE_BUSY_INDIRECT_RX)
24010480:	687b      	ldr	r3, [r7, #4]
24010482:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
24010486:	b2db      	uxtb	r3, r3
24010488:	2b22      	cmp	r3, #34	; 0x22
2401048a:	d125      	bne.n	240104d8 <HAL_QSPI_IRQHandler+0xe4>
    {
      /* Receiving Process */
      while(__HAL_QSPI_GET_FLAG(hqspi, QSPI_FLAG_FT) != RESET)
2401048c:	e01d      	b.n	240104ca <HAL_QSPI_IRQHandler+0xd6>
      {
        if (hqspi->RxXferCount > 0U)
2401048e:	687b      	ldr	r3, [r7, #4]
24010490:	6b9b      	ldr	r3, [r3, #56]	; 0x38
24010492:	2b00      	cmp	r3, #0
24010494:	d010      	beq.n	240104b8 <HAL_QSPI_IRQHandler+0xc4>
        {
          /* Read the FIFO until the threshold is reached */
          *hqspi->pRxBuffPtr = *((__IO uint8_t *)data_reg);
24010496:	687b      	ldr	r3, [r7, #4]
24010498:	6b1b      	ldr	r3, [r3, #48]	; 0x30
2401049a:	68fa      	ldr	r2, [r7, #12]
2401049c:	7812      	ldrb	r2, [r2, #0]
2401049e:	b2d2      	uxtb	r2, r2
240104a0:	701a      	strb	r2, [r3, #0]
          hqspi->pRxBuffPtr++;
240104a2:	687b      	ldr	r3, [r7, #4]
240104a4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
240104a6:	1c5a      	adds	r2, r3, #1
240104a8:	687b      	ldr	r3, [r7, #4]
240104aa:	631a      	str	r2, [r3, #48]	; 0x30
          hqspi->RxXferCount--;
240104ac:	687b      	ldr	r3, [r7, #4]
240104ae:	6b9b      	ldr	r3, [r3, #56]	; 0x38
240104b0:	1e5a      	subs	r2, r3, #1
240104b2:	687b      	ldr	r3, [r7, #4]
240104b4:	639a      	str	r2, [r3, #56]	; 0x38
240104b6:	e008      	b.n	240104ca <HAL_QSPI_IRQHandler+0xd6>
        }
        else
        {
          /* All data have been received for the transfer */
          /* Disable the QSPI FIFO Threshold Interrupt */
          __HAL_QSPI_DISABLE_IT(hqspi, QSPI_IT_FT);
240104b8:	687b      	ldr	r3, [r7, #4]
240104ba:	681b      	ldr	r3, [r3, #0]
240104bc:	681a      	ldr	r2, [r3, #0]
240104be:	687b      	ldr	r3, [r7, #4]
240104c0:	681b      	ldr	r3, [r3, #0]
240104c2:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
240104c6:	601a      	str	r2, [r3, #0]
          break;
240104c8:	e006      	b.n	240104d8 <HAL_QSPI_IRQHandler+0xe4>
      while(__HAL_QSPI_GET_FLAG(hqspi, QSPI_FLAG_FT) != RESET)
240104ca:	687b      	ldr	r3, [r7, #4]
240104cc:	681b      	ldr	r3, [r3, #0]
240104ce:	689b      	ldr	r3, [r3, #8]
240104d0:	f003 0304 	and.w	r3, r3, #4
240104d4:	2b00      	cmp	r3, #0
240104d6:	d1da      	bne.n	2401048e <HAL_QSPI_IRQHandler+0x9a>

    /* FIFO Threshold callback */
#if (USE_HAL_QSPI_REGISTER_CALLBACKS == 1)
    hqspi->FifoThresholdCallback(hqspi);
#else
    HAL_QSPI_FifoThresholdCallback(hqspi);
240104d8:	6878      	ldr	r0, [r7, #4]
240104da:	f000 ff76 	bl	240113ca <HAL_QSPI_FifoThresholdCallback>
240104de:	e13c      	b.n	2401075a <HAL_QSPI_IRQHandler+0x366>
#endif
  }

  /* QSPI Transfer Complete interrupt occurred -------------------------------*/
  else if(((flag & QSPI_FLAG_TC) != 0U) && ((itsource & QSPI_IT_TC) != 0U))
240104e0:	697b      	ldr	r3, [r7, #20]
240104e2:	f003 0302 	and.w	r3, r3, #2
240104e6:	2b00      	cmp	r3, #0
240104e8:	f000 80b0 	beq.w	2401064c <HAL_QSPI_IRQHandler+0x258>
240104ec:	693b      	ldr	r3, [r7, #16]
240104ee:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
240104f2:	2b00      	cmp	r3, #0
240104f4:	f000 80aa 	beq.w	2401064c <HAL_QSPI_IRQHandler+0x258>
  {
    /* Clear interrupt */
    WRITE_REG(hqspi->Instance->FCR, QSPI_FLAG_TC);
240104f8:	687b      	ldr	r3, [r7, #4]
240104fa:	681b      	ldr	r3, [r3, #0]
240104fc:	2202      	movs	r2, #2
240104fe:	60da      	str	r2, [r3, #12]

    /* Disable the QSPI FIFO Threshold, Transfer Error and Transfer complete Interrupts */
    __HAL_QSPI_DISABLE_IT(hqspi, QSPI_IT_TC | QSPI_IT_TE | QSPI_IT_FT);
24010500:	687b      	ldr	r3, [r7, #4]
24010502:	681b      	ldr	r3, [r3, #0]
24010504:	681a      	ldr	r2, [r3, #0]
24010506:	687b      	ldr	r3, [r7, #4]
24010508:	681b      	ldr	r3, [r3, #0]
2401050a:	f422 22e0 	bic.w	r2, r2, #458752	; 0x70000
2401050e:	601a      	str	r2, [r3, #0]

    /* Transfer complete callback */
    if(hqspi->State == HAL_QSPI_STATE_BUSY_INDIRECT_TX)
24010510:	687b      	ldr	r3, [r7, #4]
24010512:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
24010516:	b2db      	uxtb	r3, r3
24010518:	2b12      	cmp	r3, #18
2401051a:	d120      	bne.n	2401055e <HAL_QSPI_IRQHandler+0x16a>
    {
      if ((hqspi->Instance->CR & QUADSPI_CR_DMAEN) != 0U)
2401051c:	687b      	ldr	r3, [r7, #4]
2401051e:	681b      	ldr	r3, [r3, #0]
24010520:	681b      	ldr	r3, [r3, #0]
24010522:	f003 0304 	and.w	r3, r3, #4
24010526:	2b00      	cmp	r3, #0
24010528:	d011      	beq.n	2401054e <HAL_QSPI_IRQHandler+0x15a>
      {
        /* Disable the DMA transfer by clearing the DMAEN bit in the QSPI CR register */
        CLEAR_BIT(hqspi->Instance->CR, QUADSPI_CR_DMAEN);
2401052a:	687b      	ldr	r3, [r7, #4]
2401052c:	681b      	ldr	r3, [r3, #0]
2401052e:	681a      	ldr	r2, [r3, #0]
24010530:	687b      	ldr	r3, [r7, #4]
24010532:	681b      	ldr	r3, [r3, #0]
24010534:	f022 0204 	bic.w	r2, r2, #4
24010538:	601a      	str	r2, [r3, #0]

        /* Disable the MDMA channel */
        __HAL_MDMA_DISABLE(hqspi->hmdma);
2401053a:	687b      	ldr	r3, [r7, #4]
2401053c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2401053e:	681b      	ldr	r3, [r3, #0]
24010540:	68da      	ldr	r2, [r3, #12]
24010542:	687b      	ldr	r3, [r7, #4]
24010544:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
24010546:	681b      	ldr	r3, [r3, #0]
24010548:	f022 0201 	bic.w	r2, r2, #1
2401054c:	60da      	str	r2, [r3, #12]
      }


      /* Change state of QSPI */
      hqspi->State = HAL_QSPI_STATE_READY;
2401054e:	687b      	ldr	r3, [r7, #4]
24010550:	2201      	movs	r2, #1
24010552:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

      /* TX Complete callback */
#if (USE_HAL_QSPI_REGISTER_CALLBACKS == 1)
      hqspi->TxCpltCallback(hqspi);
#else
      HAL_QSPI_TxCpltCallback(hqspi);
24010556:	6878      	ldr	r0, [r7, #4]
24010558:	f000 ff2d 	bl	240113b6 <HAL_QSPI_TxCpltCallback>
    if(hqspi->State == HAL_QSPI_STATE_BUSY_INDIRECT_TX)
2401055c:	e0fa      	b.n	24010754 <HAL_QSPI_IRQHandler+0x360>
#endif
    }
    else if(hqspi->State == HAL_QSPI_STATE_BUSY_INDIRECT_RX)
2401055e:	687b      	ldr	r3, [r7, #4]
24010560:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
24010564:	b2db      	uxtb	r3, r3
24010566:	2b22      	cmp	r3, #34	; 0x22
24010568:	d143      	bne.n	240105f2 <HAL_QSPI_IRQHandler+0x1fe>
    {
      if ((hqspi->Instance->CR & QUADSPI_CR_DMAEN) != 0U)
2401056a:	687b      	ldr	r3, [r7, #4]
2401056c:	681b      	ldr	r3, [r3, #0]
2401056e:	681b      	ldr	r3, [r3, #0]
24010570:	f003 0304 	and.w	r3, r3, #4
24010574:	2b00      	cmp	r3, #0
24010576:	d012      	beq.n	2401059e <HAL_QSPI_IRQHandler+0x1aa>
      {
        /* Disable the DMA transfer by clearing the DMAEN bit in the QSPI CR register */
        CLEAR_BIT(hqspi->Instance->CR, QUADSPI_CR_DMAEN);
24010578:	687b      	ldr	r3, [r7, #4]
2401057a:	681b      	ldr	r3, [r3, #0]
2401057c:	681a      	ldr	r2, [r3, #0]
2401057e:	687b      	ldr	r3, [r7, #4]
24010580:	681b      	ldr	r3, [r3, #0]
24010582:	f022 0204 	bic.w	r2, r2, #4
24010586:	601a      	str	r2, [r3, #0]

        /* Disable the MDMA channel */
        __HAL_MDMA_DISABLE(hqspi->hmdma);
24010588:	687b      	ldr	r3, [r7, #4]
2401058a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2401058c:	681b      	ldr	r3, [r3, #0]
2401058e:	68da      	ldr	r2, [r3, #12]
24010590:	687b      	ldr	r3, [r7, #4]
24010592:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
24010594:	681b      	ldr	r3, [r3, #0]
24010596:	f022 0201 	bic.w	r2, r2, #1
2401059a:	60da      	str	r2, [r3, #12]
2401059c:	e021      	b.n	240105e2 <HAL_QSPI_IRQHandler+0x1ee>
      }
      else
      {
        data_reg = &hqspi->Instance->DR;
2401059e:	687b      	ldr	r3, [r7, #4]
240105a0:	681b      	ldr	r3, [r3, #0]
240105a2:	3320      	adds	r3, #32
240105a4:	60fb      	str	r3, [r7, #12]
        while(READ_BIT(hqspi->Instance->SR, QUADSPI_SR_FLEVEL) != 0U)
240105a6:	e013      	b.n	240105d0 <HAL_QSPI_IRQHandler+0x1dc>
        {
          if (hqspi->RxXferCount > 0U)
240105a8:	687b      	ldr	r3, [r7, #4]
240105aa:	6b9b      	ldr	r3, [r3, #56]	; 0x38
240105ac:	2b00      	cmp	r3, #0
240105ae:	d017      	beq.n	240105e0 <HAL_QSPI_IRQHandler+0x1ec>
          {
            /* Read the last data received in the FIFO until it is empty */
            *hqspi->pRxBuffPtr = *((__IO uint8_t *)data_reg);
240105b0:	687b      	ldr	r3, [r7, #4]
240105b2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
240105b4:	68fa      	ldr	r2, [r7, #12]
240105b6:	7812      	ldrb	r2, [r2, #0]
240105b8:	b2d2      	uxtb	r2, r2
240105ba:	701a      	strb	r2, [r3, #0]
            hqspi->pRxBuffPtr++;
240105bc:	687b      	ldr	r3, [r7, #4]
240105be:	6b1b      	ldr	r3, [r3, #48]	; 0x30
240105c0:	1c5a      	adds	r2, r3, #1
240105c2:	687b      	ldr	r3, [r7, #4]
240105c4:	631a      	str	r2, [r3, #48]	; 0x30
            hqspi->RxXferCount--;
240105c6:	687b      	ldr	r3, [r7, #4]
240105c8:	6b9b      	ldr	r3, [r3, #56]	; 0x38
240105ca:	1e5a      	subs	r2, r3, #1
240105cc:	687b      	ldr	r3, [r7, #4]
240105ce:	639a      	str	r2, [r3, #56]	; 0x38
        while(READ_BIT(hqspi->Instance->SR, QUADSPI_SR_FLEVEL) != 0U)
240105d0:	687b      	ldr	r3, [r7, #4]
240105d2:	681b      	ldr	r3, [r3, #0]
240105d4:	689b      	ldr	r3, [r3, #8]
240105d6:	f403 537c 	and.w	r3, r3, #16128	; 0x3f00
240105da:	2b00      	cmp	r3, #0
240105dc:	d1e4      	bne.n	240105a8 <HAL_QSPI_IRQHandler+0x1b4>
240105de:	e000      	b.n	240105e2 <HAL_QSPI_IRQHandler+0x1ee>
          }
          else
          {
            /* All data have been received for the transfer */
            break;
240105e0:	bf00      	nop
        }
      }


      /* Change state of QSPI */
      hqspi->State = HAL_QSPI_STATE_READY;
240105e2:	687b      	ldr	r3, [r7, #4]
240105e4:	2201      	movs	r2, #1
240105e6:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

      /* RX Complete callback */
#if (USE_HAL_QSPI_REGISTER_CALLBACKS == 1)
      hqspi->RxCpltCallback(hqspi);
#else
      HAL_QSPI_RxCpltCallback(hqspi);
240105ea:	6878      	ldr	r0, [r7, #4]
240105ec:	f000 fed9 	bl	240113a2 <HAL_QSPI_RxCpltCallback>
    if(hqspi->State == HAL_QSPI_STATE_BUSY_INDIRECT_TX)
240105f0:	e0b0      	b.n	24010754 <HAL_QSPI_IRQHandler+0x360>
#endif
    }
    else if(hqspi->State == HAL_QSPI_STATE_BUSY)
240105f2:	687b      	ldr	r3, [r7, #4]
240105f4:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
240105f8:	b2db      	uxtb	r3, r3
240105fa:	2b02      	cmp	r3, #2
240105fc:	d107      	bne.n	2401060e <HAL_QSPI_IRQHandler+0x21a>
    {
      /* Change state of QSPI */
      hqspi->State = HAL_QSPI_STATE_READY;
240105fe:	687b      	ldr	r3, [r7, #4]
24010600:	2201      	movs	r2, #1
24010602:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

      /* Command Complete callback */
#if (USE_HAL_QSPI_REGISTER_CALLBACKS == 1)
      hqspi->CmdCpltCallback(hqspi);
#else
      HAL_QSPI_CmdCpltCallback(hqspi);
24010606:	6878      	ldr	r0, [r7, #4]
24010608:	f000 fec1 	bl	2401138e <HAL_QSPI_CmdCpltCallback>
    if(hqspi->State == HAL_QSPI_STATE_BUSY_INDIRECT_TX)
2401060c:	e0a2      	b.n	24010754 <HAL_QSPI_IRQHandler+0x360>
#endif
    }
    else if(hqspi->State == HAL_QSPI_STATE_ABORT)
2401060e:	687b      	ldr	r3, [r7, #4]
24010610:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
24010614:	b2db      	uxtb	r3, r3
24010616:	2b08      	cmp	r3, #8
24010618:	f040 809c 	bne.w	24010754 <HAL_QSPI_IRQHandler+0x360>
    {
      /* Reset functional mode configuration to indirect write mode by default */
      CLEAR_BIT(hqspi->Instance->CCR, QUADSPI_CCR_FMODE);
2401061c:	687b      	ldr	r3, [r7, #4]
2401061e:	681b      	ldr	r3, [r3, #0]
24010620:	695a      	ldr	r2, [r3, #20]
24010622:	687b      	ldr	r3, [r7, #4]
24010624:	681b      	ldr	r3, [r3, #0]
24010626:	f022 6240 	bic.w	r2, r2, #201326592	; 0xc000000
2401062a:	615a      	str	r2, [r3, #20]

      /* Change state of QSPI */
      hqspi->State = HAL_QSPI_STATE_READY;
2401062c:	687b      	ldr	r3, [r7, #4]
2401062e:	2201      	movs	r2, #1
24010630:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

      if (hqspi->ErrorCode == HAL_QSPI_ERROR_NONE)
24010634:	687b      	ldr	r3, [r7, #4]
24010636:	6c5b      	ldr	r3, [r3, #68]	; 0x44
24010638:	2b00      	cmp	r3, #0
2401063a:	d103      	bne.n	24010644 <HAL_QSPI_IRQHandler+0x250>

        /* Abort Complete callback */
#if (USE_HAL_QSPI_REGISTER_CALLBACKS == 1)
        hqspi->AbortCpltCallback(hqspi);
#else
        HAL_QSPI_AbortCpltCallback(hqspi);
2401063c:	6878      	ldr	r0, [r7, #4]
2401063e:	f000 fe9c 	bl	2401137a <HAL_QSPI_AbortCpltCallback>
    if(hqspi->State == HAL_QSPI_STATE_BUSY_INDIRECT_TX)
24010642:	e087      	b.n	24010754 <HAL_QSPI_IRQHandler+0x360>

        /* Error callback */
#if (USE_HAL_QSPI_REGISTER_CALLBACKS == 1)
        hqspi->ErrorCallback(hqspi);
#else
        HAL_QSPI_ErrorCallback(hqspi);
24010644:	6878      	ldr	r0, [r7, #4]
24010646:	f000 fe8e 	bl	24011366 <HAL_QSPI_ErrorCallback>
    if(hqspi->State == HAL_QSPI_STATE_BUSY_INDIRECT_TX)
2401064a:	e083      	b.n	24010754 <HAL_QSPI_IRQHandler+0x360>
     /* Nothing to do */
    }
  }

  /* QSPI Status Match interrupt occurred ------------------------------------*/
  else if(((flag & QSPI_FLAG_SM) != 0U) && ((itsource & QSPI_IT_SM) != 0U))
2401064c:	697b      	ldr	r3, [r7, #20]
2401064e:	f003 0308 	and.w	r3, r3, #8
24010652:	2b00      	cmp	r3, #0
24010654:	d01f      	beq.n	24010696 <HAL_QSPI_IRQHandler+0x2a2>
24010656:	693b      	ldr	r3, [r7, #16]
24010658:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
2401065c:	2b00      	cmp	r3, #0
2401065e:	d01a      	beq.n	24010696 <HAL_QSPI_IRQHandler+0x2a2>
  {
    /* Clear interrupt */
    WRITE_REG(hqspi->Instance->FCR, QSPI_FLAG_SM);
24010660:	687b      	ldr	r3, [r7, #4]
24010662:	681b      	ldr	r3, [r3, #0]
24010664:	2208      	movs	r2, #8
24010666:	60da      	str	r2, [r3, #12]

    /* Check if the automatic poll mode stop is activated */
    if(READ_BIT(hqspi->Instance->CR, QUADSPI_CR_APMS) != 0U)
24010668:	687b      	ldr	r3, [r7, #4]
2401066a:	681b      	ldr	r3, [r3, #0]
2401066c:	681b      	ldr	r3, [r3, #0]
2401066e:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
24010672:	2b00      	cmp	r3, #0
24010674:	d00b      	beq.n	2401068e <HAL_QSPI_IRQHandler+0x29a>
    {
      /* Disable the QSPI Transfer Error and Status Match Interrupts */
      __HAL_QSPI_DISABLE_IT(hqspi, (QSPI_IT_SM | QSPI_IT_TE));
24010676:	687b      	ldr	r3, [r7, #4]
24010678:	681b      	ldr	r3, [r3, #0]
2401067a:	681a      	ldr	r2, [r3, #0]
2401067c:	687b      	ldr	r3, [r7, #4]
2401067e:	681b      	ldr	r3, [r3, #0]
24010680:	f422 2210 	bic.w	r2, r2, #589824	; 0x90000
24010684:	601a      	str	r2, [r3, #0]

      /* Change state of QSPI */
      hqspi->State = HAL_QSPI_STATE_READY;
24010686:	687b      	ldr	r3, [r7, #4]
24010688:	2201      	movs	r2, #1
2401068a:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

    /* Status match callback */
#if (USE_HAL_QSPI_REGISTER_CALLBACKS == 1)
    hqspi->StatusMatchCallback(hqspi);
#else
    HAL_QSPI_StatusMatchCallback(hqspi);
2401068e:	6878      	ldr	r0, [r7, #4]
24010690:	f000 fea5 	bl	240113de <HAL_QSPI_StatusMatchCallback>
24010694:	e061      	b.n	2401075a <HAL_QSPI_IRQHandler+0x366>
#endif
  }

  /* QSPI Transfer Error interrupt occurred ----------------------------------*/
  else if(((flag & QSPI_FLAG_TE) != 0U) && ((itsource & QSPI_IT_TE) != 0U))
24010696:	697b      	ldr	r3, [r7, #20]
24010698:	f003 0301 	and.w	r3, r3, #1
2401069c:	2b00      	cmp	r3, #0
2401069e:	d047      	beq.n	24010730 <HAL_QSPI_IRQHandler+0x33c>
240106a0:	693b      	ldr	r3, [r7, #16]
240106a2:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
240106a6:	2b00      	cmp	r3, #0
240106a8:	d042      	beq.n	24010730 <HAL_QSPI_IRQHandler+0x33c>
  {
    /* Clear interrupt */
    WRITE_REG(hqspi->Instance->FCR, QSPI_FLAG_TE);
240106aa:	687b      	ldr	r3, [r7, #4]
240106ac:	681b      	ldr	r3, [r3, #0]
240106ae:	2201      	movs	r2, #1
240106b0:	60da      	str	r2, [r3, #12]

    /* Disable all the QSPI Interrupts */
    __HAL_QSPI_DISABLE_IT(hqspi, QSPI_IT_SM | QSPI_IT_TC | QSPI_IT_TE | QSPI_IT_FT);
240106b2:	687b      	ldr	r3, [r7, #4]
240106b4:	681b      	ldr	r3, [r3, #0]
240106b6:	681a      	ldr	r2, [r3, #0]
240106b8:	687b      	ldr	r3, [r7, #4]
240106ba:	681b      	ldr	r3, [r3, #0]
240106bc:	f422 2270 	bic.w	r2, r2, #983040	; 0xf0000
240106c0:	601a      	str	r2, [r3, #0]

    /* Set error code */
    hqspi->ErrorCode |= HAL_QSPI_ERROR_TRANSFER;
240106c2:	687b      	ldr	r3, [r7, #4]
240106c4:	6c5b      	ldr	r3, [r3, #68]	; 0x44
240106c6:	f043 0202 	orr.w	r2, r3, #2
240106ca:	687b      	ldr	r3, [r7, #4]
240106cc:	645a      	str	r2, [r3, #68]	; 0x44

    if ((hqspi->Instance->CR & QUADSPI_CR_DMAEN) != 0U)
240106ce:	687b      	ldr	r3, [r7, #4]
240106d0:	681b      	ldr	r3, [r3, #0]
240106d2:	681b      	ldr	r3, [r3, #0]
240106d4:	f003 0304 	and.w	r3, r3, #4
240106d8:	2b00      	cmp	r3, #0
240106da:	d021      	beq.n	24010720 <HAL_QSPI_IRQHandler+0x32c>
    {
      /* Disable the DMA transfer by clearing the DMAEN bit in the QSPI CR register */
      CLEAR_BIT(hqspi->Instance->CR, QUADSPI_CR_DMAEN);
240106dc:	687b      	ldr	r3, [r7, #4]
240106de:	681b      	ldr	r3, [r3, #0]
240106e0:	681a      	ldr	r2, [r3, #0]
240106e2:	687b      	ldr	r3, [r7, #4]
240106e4:	681b      	ldr	r3, [r3, #0]
240106e6:	f022 0204 	bic.w	r2, r2, #4
240106ea:	601a      	str	r2, [r3, #0]

      /* Disable the MDMA channel */
      hqspi->hmdma->XferAbortCallback = QSPI_DMAAbortCplt;
240106ec:	687b      	ldr	r3, [r7, #4]
240106ee:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
240106f0:	4a1c      	ldr	r2, [pc, #112]	; (24010764 <HAL_QSPI_IRQHandler+0x370>)
240106f2:	659a      	str	r2, [r3, #88]	; 0x58
      if (HAL_MDMA_Abort_IT(hqspi->hmdma) != HAL_OK)
240106f4:	687b      	ldr	r3, [r7, #4]
240106f6:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
240106f8:	4618      	mov	r0, r3
240106fa:	f7fe fb54 	bl	2400eda6 <HAL_MDMA_Abort_IT>
240106fe:	4603      	mov	r3, r0
24010700:	2b00      	cmp	r3, #0
24010702:	d029      	beq.n	24010758 <HAL_QSPI_IRQHandler+0x364>
      {
        /* Set error code to DMA */
        hqspi->ErrorCode |= HAL_QSPI_ERROR_DMA;
24010704:	687b      	ldr	r3, [r7, #4]
24010706:	6c5b      	ldr	r3, [r3, #68]	; 0x44
24010708:	f043 0204 	orr.w	r2, r3, #4
2401070c:	687b      	ldr	r3, [r7, #4]
2401070e:	645a      	str	r2, [r3, #68]	; 0x44

        /* Change state of QSPI */
        hqspi->State = HAL_QSPI_STATE_READY;
24010710:	687b      	ldr	r3, [r7, #4]
24010712:	2201      	movs	r2, #1
24010714:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

        /* Error callback */
#if (USE_HAL_QSPI_REGISTER_CALLBACKS == 1)
        hqspi->ErrorCallback(hqspi);
#else
        HAL_QSPI_ErrorCallback(hqspi);
24010718:	6878      	ldr	r0, [r7, #4]
2401071a:	f000 fe24 	bl	24011366 <HAL_QSPI_ErrorCallback>
    if ((hqspi->Instance->CR & QUADSPI_CR_DMAEN) != 0U)
2401071e:	e01b      	b.n	24010758 <HAL_QSPI_IRQHandler+0x364>
      }
    }
    else
    {
      /* Change state of QSPI */
      hqspi->State = HAL_QSPI_STATE_READY;
24010720:	687b      	ldr	r3, [r7, #4]
24010722:	2201      	movs	r2, #1
24010724:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

      /* Error callback */
#if (USE_HAL_QSPI_REGISTER_CALLBACKS == 1)
      hqspi->ErrorCallback(hqspi);
#else
      HAL_QSPI_ErrorCallback(hqspi);
24010728:	6878      	ldr	r0, [r7, #4]
2401072a:	f000 fe1c 	bl	24011366 <HAL_QSPI_ErrorCallback>
    if ((hqspi->Instance->CR & QUADSPI_CR_DMAEN) != 0U)
2401072e:	e013      	b.n	24010758 <HAL_QSPI_IRQHandler+0x364>
#endif
    }
  }

  /* QSPI Timeout interrupt occurred -----------------------------------------*/
  else if(((flag & QSPI_FLAG_TO) != 0U) && ((itsource & QSPI_IT_TO) != 0U))
24010730:	697b      	ldr	r3, [r7, #20]
24010732:	f003 0310 	and.w	r3, r3, #16
24010736:	2b00      	cmp	r3, #0
24010738:	d00f      	beq.n	2401075a <HAL_QSPI_IRQHandler+0x366>
2401073a:	693b      	ldr	r3, [r7, #16]
2401073c:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
24010740:	2b00      	cmp	r3, #0
24010742:	d00a      	beq.n	2401075a <HAL_QSPI_IRQHandler+0x366>
  {
    /* Clear interrupt */
    WRITE_REG(hqspi->Instance->FCR, QSPI_FLAG_TO);
24010744:	687b      	ldr	r3, [r7, #4]
24010746:	681b      	ldr	r3, [r3, #0]
24010748:	2210      	movs	r2, #16
2401074a:	60da      	str	r2, [r3, #12]

    /* Timeout callback */
#if (USE_HAL_QSPI_REGISTER_CALLBACKS == 1)
    hqspi->TimeOutCallback(hqspi);
#else
    HAL_QSPI_TimeOutCallback(hqspi);
2401074c:	6878      	ldr	r0, [r7, #4]
2401074e:	f000 fe50 	bl	240113f2 <HAL_QSPI_TimeOutCallback>

   else
  {
   /* Nothing to do */
  }
}
24010752:	e002      	b.n	2401075a <HAL_QSPI_IRQHandler+0x366>
    if(hqspi->State == HAL_QSPI_STATE_BUSY_INDIRECT_TX)
24010754:	bf00      	nop
24010756:	e000      	b.n	2401075a <HAL_QSPI_IRQHandler+0x366>
    if ((hqspi->Instance->CR & QUADSPI_CR_DMAEN) != 0U)
24010758:	bf00      	nop
}
2401075a:	bf00      	nop
2401075c:	3718      	adds	r7, #24
2401075e:	46bd      	mov	sp, r7
24010760:	bd80      	pop	{r7, pc}
24010762:	bf00      	nop
24010764:	24011785 	.word	0x24011785

24010768 <HAL_QSPI_Command>:
  * @param Timeout : Timeout duration
  * @note   This function is used only in Indirect Read or Write Modes
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_QSPI_Command(QSPI_HandleTypeDef *hqspi, QSPI_CommandTypeDef *cmd, uint32_t Timeout)
{
24010768:	b580      	push	{r7, lr}
2401076a:	b088      	sub	sp, #32
2401076c:	af02      	add	r7, sp, #8
2401076e:	60f8      	str	r0, [r7, #12]
24010770:	60b9      	str	r1, [r7, #8]
24010772:	607a      	str	r2, [r7, #4]
  HAL_StatusTypeDef status;
  uint32_t tickstart = HAL_GetTick();
24010774:	f7f0 f86e 	bl	24000854 <HAL_GetTick>
24010778:	6138      	str	r0, [r7, #16]
  assert_param(IS_QSPI_DDR_MODE(cmd->DdrMode));
  assert_param(IS_QSPI_DDR_HHC(cmd->DdrHoldHalfCycle));
  assert_param(IS_QSPI_SIOO_MODE(cmd->SIOOMode));

  /* Process locked */
  __HAL_LOCK(hqspi);
2401077a:	68fb      	ldr	r3, [r7, #12]
2401077c:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
24010780:	b2db      	uxtb	r3, r3
24010782:	2b01      	cmp	r3, #1
24010784:	d101      	bne.n	2401078a <HAL_QSPI_Command+0x22>
24010786:	2302      	movs	r3, #2
24010788:	e048      	b.n	2401081c <HAL_QSPI_Command+0xb4>
2401078a:	68fb      	ldr	r3, [r7, #12]
2401078c:	2201      	movs	r2, #1
2401078e:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  if(hqspi->State == HAL_QSPI_STATE_READY)
24010792:	68fb      	ldr	r3, [r7, #12]
24010794:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
24010798:	b2db      	uxtb	r3, r3
2401079a:	2b01      	cmp	r3, #1
2401079c:	d137      	bne.n	2401080e <HAL_QSPI_Command+0xa6>
  {
    hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
2401079e:	68fb      	ldr	r3, [r7, #12]
240107a0:	2200      	movs	r2, #0
240107a2:	645a      	str	r2, [r3, #68]	; 0x44

    /* Update QSPI state */
    hqspi->State = HAL_QSPI_STATE_BUSY;
240107a4:	68fb      	ldr	r3, [r7, #12]
240107a6:	2202      	movs	r2, #2
240107a8:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

    /* Wait till BUSY flag reset */
    status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_BUSY, RESET, tickstart, Timeout);
240107ac:	687b      	ldr	r3, [r7, #4]
240107ae:	9300      	str	r3, [sp, #0]
240107b0:	693b      	ldr	r3, [r7, #16]
240107b2:	2200      	movs	r2, #0
240107b4:	2120      	movs	r1, #32
240107b6:	68f8      	ldr	r0, [r7, #12]
240107b8:	f001 f817 	bl	240117ea <QSPI_WaitFlagStateUntilTimeout>
240107bc:	4603      	mov	r3, r0
240107be:	75fb      	strb	r3, [r7, #23]

    if (status == HAL_OK)
240107c0:	7dfb      	ldrb	r3, [r7, #23]
240107c2:	2b00      	cmp	r3, #0
240107c4:	d125      	bne.n	24010812 <HAL_QSPI_Command+0xaa>
    {
      /* Call the configuration function */
      QSPI_Config(hqspi, cmd, QSPI_FUNCTIONAL_MODE_INDIRECT_WRITE);
240107c6:	2200      	movs	r2, #0
240107c8:	68b9      	ldr	r1, [r7, #8]
240107ca:	68f8      	ldr	r0, [r7, #12]
240107cc:	f001 f844 	bl	24011858 <QSPI_Config>

      if (cmd->DataMode == QSPI_DATA_NONE)
240107d0:	68bb      	ldr	r3, [r7, #8]
240107d2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
240107d4:	2b00      	cmp	r3, #0
240107d6:	d115      	bne.n	24010804 <HAL_QSPI_Command+0x9c>
      {
        /* When there is no data phase, the transfer start as soon as the configuration is done
        so wait until TC flag is set to go back in idle state */
        status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_TC, SET, tickstart, Timeout);
240107d8:	687b      	ldr	r3, [r7, #4]
240107da:	9300      	str	r3, [sp, #0]
240107dc:	693b      	ldr	r3, [r7, #16]
240107de:	2201      	movs	r2, #1
240107e0:	2102      	movs	r1, #2
240107e2:	68f8      	ldr	r0, [r7, #12]
240107e4:	f001 f801 	bl	240117ea <QSPI_WaitFlagStateUntilTimeout>
240107e8:	4603      	mov	r3, r0
240107ea:	75fb      	strb	r3, [r7, #23]

        if (status == HAL_OK)
240107ec:	7dfb      	ldrb	r3, [r7, #23]
240107ee:	2b00      	cmp	r3, #0
240107f0:	d10f      	bne.n	24010812 <HAL_QSPI_Command+0xaa>
        {
          __HAL_QSPI_CLEAR_FLAG(hqspi, QSPI_FLAG_TC);
240107f2:	68fb      	ldr	r3, [r7, #12]
240107f4:	681b      	ldr	r3, [r3, #0]
240107f6:	2202      	movs	r2, #2
240107f8:	60da      	str	r2, [r3, #12]

          /* Update QSPI state */
          hqspi->State = HAL_QSPI_STATE_READY;
240107fa:	68fb      	ldr	r3, [r7, #12]
240107fc:	2201      	movs	r2, #1
240107fe:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
24010802:	e006      	b.n	24010812 <HAL_QSPI_Command+0xaa>
        }
      }
      else
      {
        /* Update QSPI state */
        hqspi->State = HAL_QSPI_STATE_READY;
24010804:	68fb      	ldr	r3, [r7, #12]
24010806:	2201      	movs	r2, #1
24010808:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
2401080c:	e001      	b.n	24010812 <HAL_QSPI_Command+0xaa>
      }
    }
  }
  else
  {
    status = HAL_BUSY;
2401080e:	2302      	movs	r3, #2
24010810:	75fb      	strb	r3, [r7, #23]
  }

  /* Process unlocked */
  __HAL_UNLOCK(hqspi);
24010812:	68fb      	ldr	r3, [r7, #12]
24010814:	2200      	movs	r2, #0
24010816:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  /* Return function status */
  return status;
2401081a:	7dfb      	ldrb	r3, [r7, #23]
}
2401081c:	4618      	mov	r0, r3
2401081e:	3718      	adds	r7, #24
24010820:	46bd      	mov	sp, r7
24010822:	bd80      	pop	{r7, pc}

24010824 <HAL_QSPI_Command_IT>:
  * @param cmd : structure that contains the command configuration information
  * @note   This function is used only in Indirect Read or Write Modes
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_QSPI_Command_IT(QSPI_HandleTypeDef *hqspi, QSPI_CommandTypeDef *cmd)
{
24010824:	b580      	push	{r7, lr}
24010826:	b086      	sub	sp, #24
24010828:	af02      	add	r7, sp, #8
2401082a:	6078      	str	r0, [r7, #4]
2401082c:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef status;
  uint32_t tickstart = HAL_GetTick();
2401082e:	f7f0 f811 	bl	24000854 <HAL_GetTick>
24010832:	60b8      	str	r0, [r7, #8]
  assert_param(IS_QSPI_DDR_MODE(cmd->DdrMode));
  assert_param(IS_QSPI_DDR_HHC(cmd->DdrHoldHalfCycle));
  assert_param(IS_QSPI_SIOO_MODE(cmd->SIOOMode));

  /* Process locked */
  __HAL_LOCK(hqspi);
24010834:	687b      	ldr	r3, [r7, #4]
24010836:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2401083a:	b2db      	uxtb	r3, r3
2401083c:	2b01      	cmp	r3, #1
2401083e:	d101      	bne.n	24010844 <HAL_QSPI_Command_IT+0x20>
24010840:	2302      	movs	r3, #2
24010842:	e051      	b.n	240108e8 <HAL_QSPI_Command_IT+0xc4>
24010844:	687b      	ldr	r3, [r7, #4]
24010846:	2201      	movs	r2, #1
24010848:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  if(hqspi->State == HAL_QSPI_STATE_READY)
2401084c:	687b      	ldr	r3, [r7, #4]
2401084e:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
24010852:	b2db      	uxtb	r3, r3
24010854:	2b01      	cmp	r3, #1
24010856:	d140      	bne.n	240108da <HAL_QSPI_Command_IT+0xb6>
  {
    hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
24010858:	687b      	ldr	r3, [r7, #4]
2401085a:	2200      	movs	r2, #0
2401085c:	645a      	str	r2, [r3, #68]	; 0x44

    /* Update QSPI state */
    hqspi->State = HAL_QSPI_STATE_BUSY;
2401085e:	687b      	ldr	r3, [r7, #4]
24010860:	2202      	movs	r2, #2
24010862:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

    /* Wait till BUSY flag reset */
    status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_BUSY, RESET, tickstart, hqspi->Timeout);
24010866:	687b      	ldr	r3, [r7, #4]
24010868:	6c9b      	ldr	r3, [r3, #72]	; 0x48
2401086a:	9300      	str	r3, [sp, #0]
2401086c:	68bb      	ldr	r3, [r7, #8]
2401086e:	2200      	movs	r2, #0
24010870:	2120      	movs	r1, #32
24010872:	6878      	ldr	r0, [r7, #4]
24010874:	f000 ffb9 	bl	240117ea <QSPI_WaitFlagStateUntilTimeout>
24010878:	4603      	mov	r3, r0
2401087a:	73fb      	strb	r3, [r7, #15]

    if (status == HAL_OK)
2401087c:	7bfb      	ldrb	r3, [r7, #15]
2401087e:	2b00      	cmp	r3, #0
24010880:	d126      	bne.n	240108d0 <HAL_QSPI_Command_IT+0xac>
    {
      if (cmd->DataMode == QSPI_DATA_NONE)
24010882:	683b      	ldr	r3, [r7, #0]
24010884:	6a5b      	ldr	r3, [r3, #36]	; 0x24
24010886:	2b00      	cmp	r3, #0
24010888:	d103      	bne.n	24010892 <HAL_QSPI_Command_IT+0x6e>
      {
        /* Clear interrupt */
        __HAL_QSPI_CLEAR_FLAG(hqspi, QSPI_FLAG_TE | QSPI_FLAG_TC);
2401088a:	687b      	ldr	r3, [r7, #4]
2401088c:	681b      	ldr	r3, [r3, #0]
2401088e:	2203      	movs	r2, #3
24010890:	60da      	str	r2, [r3, #12]
      }

      /* Call the configuration function */
      QSPI_Config(hqspi, cmd, QSPI_FUNCTIONAL_MODE_INDIRECT_WRITE);
24010892:	2200      	movs	r2, #0
24010894:	6839      	ldr	r1, [r7, #0]
24010896:	6878      	ldr	r0, [r7, #4]
24010898:	f000 ffde 	bl	24011858 <QSPI_Config>

      if (cmd->DataMode == QSPI_DATA_NONE)
2401089c:	683b      	ldr	r3, [r7, #0]
2401089e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
240108a0:	2b00      	cmp	r3, #0
240108a2:	d10c      	bne.n	240108be <HAL_QSPI_Command_IT+0x9a>
      {
        /* When there is no data phase, the transfer start as soon as the configuration is done
        so activate TC and TE interrupts */
        /* Process unlocked */
        __HAL_UNLOCK(hqspi);
240108a4:	687b      	ldr	r3, [r7, #4]
240108a6:	2200      	movs	r2, #0
240108a8:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

        /* Enable the QSPI Transfer Error Interrupt */
        __HAL_QSPI_ENABLE_IT(hqspi, QSPI_IT_TE | QSPI_IT_TC);
240108ac:	687b      	ldr	r3, [r7, #4]
240108ae:	681b      	ldr	r3, [r3, #0]
240108b0:	681a      	ldr	r2, [r3, #0]
240108b2:	687b      	ldr	r3, [r7, #4]
240108b4:	681b      	ldr	r3, [r3, #0]
240108b6:	f442 3240 	orr.w	r2, r2, #196608	; 0x30000
240108ba:	601a      	str	r2, [r3, #0]
240108bc:	e013      	b.n	240108e6 <HAL_QSPI_Command_IT+0xc2>
      }
      else
      {
        /* Update QSPI state */
        hqspi->State = HAL_QSPI_STATE_READY;
240108be:	687b      	ldr	r3, [r7, #4]
240108c0:	2201      	movs	r2, #1
240108c2:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

        /* Process unlocked */
        __HAL_UNLOCK(hqspi);
240108c6:	687b      	ldr	r3, [r7, #4]
240108c8:	2200      	movs	r2, #0
240108ca:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
240108ce:	e00a      	b.n	240108e6 <HAL_QSPI_Command_IT+0xc2>
      }
    }
    else
    {
      /* Process unlocked */
      __HAL_UNLOCK(hqspi);
240108d0:	687b      	ldr	r3, [r7, #4]
240108d2:	2200      	movs	r2, #0
240108d4:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
240108d8:	e005      	b.n	240108e6 <HAL_QSPI_Command_IT+0xc2>
    }
  }
  else
  {
    status = HAL_BUSY;
240108da:	2302      	movs	r3, #2
240108dc:	73fb      	strb	r3, [r7, #15]

    /* Process unlocked */
    __HAL_UNLOCK(hqspi);
240108de:	687b      	ldr	r3, [r7, #4]
240108e0:	2200      	movs	r2, #0
240108e2:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
  }

  /* Return function status */
  return status;
240108e6:	7bfb      	ldrb	r3, [r7, #15]
}
240108e8:	4618      	mov	r0, r3
240108ea:	3710      	adds	r7, #16
240108ec:	46bd      	mov	sp, r7
240108ee:	bd80      	pop	{r7, pc}

240108f0 <HAL_QSPI_Transmit>:
  * @note   This function is used only in Indirect Write Mode
  
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_QSPI_Transmit(QSPI_HandleTypeDef *hqspi, uint8_t *pData, uint32_t Timeout)
{
240108f0:	b580      	push	{r7, lr}
240108f2:	b08a      	sub	sp, #40	; 0x28
240108f4:	af02      	add	r7, sp, #8
240108f6:	60f8      	str	r0, [r7, #12]
240108f8:	60b9      	str	r1, [r7, #8]
240108fa:	607a      	str	r2, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
240108fc:	2300      	movs	r3, #0
240108fe:	77fb      	strb	r3, [r7, #31]
  uint32_t tickstart = HAL_GetTick();
24010900:	f7ef ffa8 	bl	24000854 <HAL_GetTick>
24010904:	61b8      	str	r0, [r7, #24]
  __IO uint32_t *data_reg = &hqspi->Instance->DR;
24010906:	68fb      	ldr	r3, [r7, #12]
24010908:	681b      	ldr	r3, [r3, #0]
2401090a:	3320      	adds	r3, #32
2401090c:	617b      	str	r3, [r7, #20]

  /* Process locked */
  __HAL_LOCK(hqspi);
2401090e:	68fb      	ldr	r3, [r7, #12]
24010910:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
24010914:	b2db      	uxtb	r3, r3
24010916:	2b01      	cmp	r3, #1
24010918:	d101      	bne.n	2401091e <HAL_QSPI_Transmit+0x2e>
2401091a:	2302      	movs	r3, #2
2401091c:	e076      	b.n	24010a0c <HAL_QSPI_Transmit+0x11c>
2401091e:	68fb      	ldr	r3, [r7, #12]
24010920:	2201      	movs	r2, #1
24010922:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  if(hqspi->State == HAL_QSPI_STATE_READY)
24010926:	68fb      	ldr	r3, [r7, #12]
24010928:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2401092c:	b2db      	uxtb	r3, r3
2401092e:	2b01      	cmp	r3, #1
24010930:	d165      	bne.n	240109fe <HAL_QSPI_Transmit+0x10e>
  {
    hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
24010932:	68fb      	ldr	r3, [r7, #12]
24010934:	2200      	movs	r2, #0
24010936:	645a      	str	r2, [r3, #68]	; 0x44

    if(pData != NULL )
24010938:	68bb      	ldr	r3, [r7, #8]
2401093a:	2b00      	cmp	r3, #0
2401093c:	d056      	beq.n	240109ec <HAL_QSPI_Transmit+0xfc>
    {
      /* Update state */
      hqspi->State = HAL_QSPI_STATE_BUSY_INDIRECT_TX;
2401093e:	68fb      	ldr	r3, [r7, #12]
24010940:	2212      	movs	r2, #18
24010942:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

      /* Configure counters and size of the handle */
      hqspi->TxXferCount = READ_REG(hqspi->Instance->DLR) + 1U;
24010946:	68fb      	ldr	r3, [r7, #12]
24010948:	681b      	ldr	r3, [r3, #0]
2401094a:	691b      	ldr	r3, [r3, #16]
2401094c:	1c5a      	adds	r2, r3, #1
2401094e:	68fb      	ldr	r3, [r7, #12]
24010950:	62da      	str	r2, [r3, #44]	; 0x2c
      hqspi->TxXferSize = READ_REG(hqspi->Instance->DLR) + 1U;
24010952:	68fb      	ldr	r3, [r7, #12]
24010954:	681b      	ldr	r3, [r3, #0]
24010956:	691b      	ldr	r3, [r3, #16]
24010958:	1c5a      	adds	r2, r3, #1
2401095a:	68fb      	ldr	r3, [r7, #12]
2401095c:	629a      	str	r2, [r3, #40]	; 0x28
      hqspi->pTxBuffPtr = pData;
2401095e:	68fb      	ldr	r3, [r7, #12]
24010960:	68ba      	ldr	r2, [r7, #8]
24010962:	625a      	str	r2, [r3, #36]	; 0x24

      /* Configure QSPI: CCR register with functional as indirect write */
      MODIFY_REG(hqspi->Instance->CCR, QUADSPI_CCR_FMODE, QSPI_FUNCTIONAL_MODE_INDIRECT_WRITE);
24010964:	68fb      	ldr	r3, [r7, #12]
24010966:	681b      	ldr	r3, [r3, #0]
24010968:	695a      	ldr	r2, [r3, #20]
2401096a:	68fb      	ldr	r3, [r7, #12]
2401096c:	681b      	ldr	r3, [r3, #0]
2401096e:	f022 6240 	bic.w	r2, r2, #201326592	; 0xc000000
24010972:	615a      	str	r2, [r3, #20]

      while(hqspi->TxXferCount > 0U)
24010974:	e01b      	b.n	240109ae <HAL_QSPI_Transmit+0xbe>
      {
        /* Wait until FT flag is set to send data */
        status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_FT, SET, tickstart, Timeout);
24010976:	687b      	ldr	r3, [r7, #4]
24010978:	9300      	str	r3, [sp, #0]
2401097a:	69bb      	ldr	r3, [r7, #24]
2401097c:	2201      	movs	r2, #1
2401097e:	2104      	movs	r1, #4
24010980:	68f8      	ldr	r0, [r7, #12]
24010982:	f000 ff32 	bl	240117ea <QSPI_WaitFlagStateUntilTimeout>
24010986:	4603      	mov	r3, r0
24010988:	77fb      	strb	r3, [r7, #31]

        if (status != HAL_OK)
2401098a:	7ffb      	ldrb	r3, [r7, #31]
2401098c:	2b00      	cmp	r3, #0
2401098e:	d113      	bne.n	240109b8 <HAL_QSPI_Transmit+0xc8>
        {
          break;
        }

        *((__IO uint8_t *)data_reg) = *hqspi->pTxBuffPtr;
24010990:	68fb      	ldr	r3, [r7, #12]
24010992:	6a5b      	ldr	r3, [r3, #36]	; 0x24
24010994:	781a      	ldrb	r2, [r3, #0]
24010996:	697b      	ldr	r3, [r7, #20]
24010998:	701a      	strb	r2, [r3, #0]
        hqspi->pTxBuffPtr++;
2401099a:	68fb      	ldr	r3, [r7, #12]
2401099c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2401099e:	1c5a      	adds	r2, r3, #1
240109a0:	68fb      	ldr	r3, [r7, #12]
240109a2:	625a      	str	r2, [r3, #36]	; 0x24
        hqspi->TxXferCount--;
240109a4:	68fb      	ldr	r3, [r7, #12]
240109a6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
240109a8:	1e5a      	subs	r2, r3, #1
240109aa:	68fb      	ldr	r3, [r7, #12]
240109ac:	62da      	str	r2, [r3, #44]	; 0x2c
      while(hqspi->TxXferCount > 0U)
240109ae:	68fb      	ldr	r3, [r7, #12]
240109b0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
240109b2:	2b00      	cmp	r3, #0
240109b4:	d1df      	bne.n	24010976 <HAL_QSPI_Transmit+0x86>
240109b6:	e000      	b.n	240109ba <HAL_QSPI_Transmit+0xca>
          break;
240109b8:	bf00      	nop
      }

      if (status == HAL_OK)
240109ba:	7ffb      	ldrb	r3, [r7, #31]
240109bc:	2b00      	cmp	r3, #0
240109be:	d110      	bne.n	240109e2 <HAL_QSPI_Transmit+0xf2>
      {
        /* Wait until TC flag is set to go back in idle state */
        status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_TC, SET, tickstart, Timeout);
240109c0:	687b      	ldr	r3, [r7, #4]
240109c2:	9300      	str	r3, [sp, #0]
240109c4:	69bb      	ldr	r3, [r7, #24]
240109c6:	2201      	movs	r2, #1
240109c8:	2102      	movs	r1, #2
240109ca:	68f8      	ldr	r0, [r7, #12]
240109cc:	f000 ff0d 	bl	240117ea <QSPI_WaitFlagStateUntilTimeout>
240109d0:	4603      	mov	r3, r0
240109d2:	77fb      	strb	r3, [r7, #31]

        if (status == HAL_OK)
240109d4:	7ffb      	ldrb	r3, [r7, #31]
240109d6:	2b00      	cmp	r3, #0
240109d8:	d103      	bne.n	240109e2 <HAL_QSPI_Transmit+0xf2>
        {
          /* Clear Transfer Complete bit */
          __HAL_QSPI_CLEAR_FLAG(hqspi, QSPI_FLAG_TC);
240109da:	68fb      	ldr	r3, [r7, #12]
240109dc:	681b      	ldr	r3, [r3, #0]
240109de:	2202      	movs	r2, #2
240109e0:	60da      	str	r2, [r3, #12]

        }
      }

      /* Update QSPI state */
      hqspi->State = HAL_QSPI_STATE_READY;
240109e2:	68fb      	ldr	r3, [r7, #12]
240109e4:	2201      	movs	r2, #1
240109e6:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
240109ea:	e00a      	b.n	24010a02 <HAL_QSPI_Transmit+0x112>
    }
    else
    {
      hqspi->ErrorCode |= HAL_QSPI_ERROR_INVALID_PARAM;
240109ec:	68fb      	ldr	r3, [r7, #12]
240109ee:	6c5b      	ldr	r3, [r3, #68]	; 0x44
240109f0:	f043 0208 	orr.w	r2, r3, #8
240109f4:	68fb      	ldr	r3, [r7, #12]
240109f6:	645a      	str	r2, [r3, #68]	; 0x44
      status = HAL_ERROR;
240109f8:	2301      	movs	r3, #1
240109fa:	77fb      	strb	r3, [r7, #31]
240109fc:	e001      	b.n	24010a02 <HAL_QSPI_Transmit+0x112>
    }
  }
  else
  {
    status = HAL_BUSY;
240109fe:	2302      	movs	r3, #2
24010a00:	77fb      	strb	r3, [r7, #31]
  }

  /* Process unlocked */
  __HAL_UNLOCK(hqspi);
24010a02:	68fb      	ldr	r3, [r7, #12]
24010a04:	2200      	movs	r2, #0
24010a06:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  return status;
24010a0a:	7ffb      	ldrb	r3, [r7, #31]
}
24010a0c:	4618      	mov	r0, r3
24010a0e:	3720      	adds	r7, #32
24010a10:	46bd      	mov	sp, r7
24010a12:	bd80      	pop	{r7, pc}

24010a14 <HAL_QSPI_Receive>:
  * @param Timeout : Timeout duration
  * @note   This function is used only in Indirect Read Mode
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_QSPI_Receive(QSPI_HandleTypeDef *hqspi, uint8_t *pData, uint32_t Timeout)
{
24010a14:	b580      	push	{r7, lr}
24010a16:	b08a      	sub	sp, #40	; 0x28
24010a18:	af02      	add	r7, sp, #8
24010a1a:	60f8      	str	r0, [r7, #12]
24010a1c:	60b9      	str	r1, [r7, #8]
24010a1e:	607a      	str	r2, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
24010a20:	2300      	movs	r3, #0
24010a22:	77fb      	strb	r3, [r7, #31]
  uint32_t tickstart = HAL_GetTick();
24010a24:	f7ef ff16 	bl	24000854 <HAL_GetTick>
24010a28:	61b8      	str	r0, [r7, #24]
  uint32_t addr_reg = READ_REG(hqspi->Instance->AR);
24010a2a:	68fb      	ldr	r3, [r7, #12]
24010a2c:	681b      	ldr	r3, [r3, #0]
24010a2e:	699b      	ldr	r3, [r3, #24]
24010a30:	617b      	str	r3, [r7, #20]
  __IO uint32_t *data_reg = &hqspi->Instance->DR;
24010a32:	68fb      	ldr	r3, [r7, #12]
24010a34:	681b      	ldr	r3, [r3, #0]
24010a36:	3320      	adds	r3, #32
24010a38:	613b      	str	r3, [r7, #16]

  /* Process locked */
  __HAL_LOCK(hqspi);
24010a3a:	68fb      	ldr	r3, [r7, #12]
24010a3c:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
24010a40:	b2db      	uxtb	r3, r3
24010a42:	2b01      	cmp	r3, #1
24010a44:	d101      	bne.n	24010a4a <HAL_QSPI_Receive+0x36>
24010a46:	2302      	movs	r3, #2
24010a48:	e07d      	b.n	24010b46 <HAL_QSPI_Receive+0x132>
24010a4a:	68fb      	ldr	r3, [r7, #12]
24010a4c:	2201      	movs	r2, #1
24010a4e:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  if(hqspi->State == HAL_QSPI_STATE_READY)
24010a52:	68fb      	ldr	r3, [r7, #12]
24010a54:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
24010a58:	b2db      	uxtb	r3, r3
24010a5a:	2b01      	cmp	r3, #1
24010a5c:	d16c      	bne.n	24010b38 <HAL_QSPI_Receive+0x124>
  {
    hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
24010a5e:	68fb      	ldr	r3, [r7, #12]
24010a60:	2200      	movs	r2, #0
24010a62:	645a      	str	r2, [r3, #68]	; 0x44

    if(pData != NULL )
24010a64:	68bb      	ldr	r3, [r7, #8]
24010a66:	2b00      	cmp	r3, #0
24010a68:	d05d      	beq.n	24010b26 <HAL_QSPI_Receive+0x112>
    {
      /* Update state */
      hqspi->State = HAL_QSPI_STATE_BUSY_INDIRECT_RX;
24010a6a:	68fb      	ldr	r3, [r7, #12]
24010a6c:	2222      	movs	r2, #34	; 0x22
24010a6e:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

      /* Configure counters and size of the handle */
      hqspi->RxXferCount = READ_REG(hqspi->Instance->DLR) + 1U;
24010a72:	68fb      	ldr	r3, [r7, #12]
24010a74:	681b      	ldr	r3, [r3, #0]
24010a76:	691b      	ldr	r3, [r3, #16]
24010a78:	1c5a      	adds	r2, r3, #1
24010a7a:	68fb      	ldr	r3, [r7, #12]
24010a7c:	639a      	str	r2, [r3, #56]	; 0x38
      hqspi->RxXferSize = READ_REG(hqspi->Instance->DLR) + 1U;
24010a7e:	68fb      	ldr	r3, [r7, #12]
24010a80:	681b      	ldr	r3, [r3, #0]
24010a82:	691b      	ldr	r3, [r3, #16]
24010a84:	1c5a      	adds	r2, r3, #1
24010a86:	68fb      	ldr	r3, [r7, #12]
24010a88:	635a      	str	r2, [r3, #52]	; 0x34
      hqspi->pRxBuffPtr = pData;
24010a8a:	68fb      	ldr	r3, [r7, #12]
24010a8c:	68ba      	ldr	r2, [r7, #8]
24010a8e:	631a      	str	r2, [r3, #48]	; 0x30

      /* Configure QSPI: CCR register with functional as indirect read */
      MODIFY_REG(hqspi->Instance->CCR, QUADSPI_CCR_FMODE, QSPI_FUNCTIONAL_MODE_INDIRECT_READ);
24010a90:	68fb      	ldr	r3, [r7, #12]
24010a92:	681b      	ldr	r3, [r3, #0]
24010a94:	695b      	ldr	r3, [r3, #20]
24010a96:	f023 6240 	bic.w	r2, r3, #201326592	; 0xc000000
24010a9a:	68fb      	ldr	r3, [r7, #12]
24010a9c:	681b      	ldr	r3, [r3, #0]
24010a9e:	f042 6280 	orr.w	r2, r2, #67108864	; 0x4000000
24010aa2:	615a      	str	r2, [r3, #20]

      /* Start the transfer by re-writing the address in AR register */
      WRITE_REG(hqspi->Instance->AR, addr_reg);
24010aa4:	68fb      	ldr	r3, [r7, #12]
24010aa6:	681b      	ldr	r3, [r3, #0]
24010aa8:	697a      	ldr	r2, [r7, #20]
24010aaa:	619a      	str	r2, [r3, #24]

      while(hqspi->RxXferCount > 0U)
24010aac:	e01c      	b.n	24010ae8 <HAL_QSPI_Receive+0xd4>
      {
        /* Wait until FT or TC flag is set to read received data */
        status = QSPI_WaitFlagStateUntilTimeout(hqspi, (QSPI_FLAG_FT | QSPI_FLAG_TC), SET, tickstart, Timeout);
24010aae:	687b      	ldr	r3, [r7, #4]
24010ab0:	9300      	str	r3, [sp, #0]
24010ab2:	69bb      	ldr	r3, [r7, #24]
24010ab4:	2201      	movs	r2, #1
24010ab6:	2106      	movs	r1, #6
24010ab8:	68f8      	ldr	r0, [r7, #12]
24010aba:	f000 fe96 	bl	240117ea <QSPI_WaitFlagStateUntilTimeout>
24010abe:	4603      	mov	r3, r0
24010ac0:	77fb      	strb	r3, [r7, #31]

        if  (status != HAL_OK)
24010ac2:	7ffb      	ldrb	r3, [r7, #31]
24010ac4:	2b00      	cmp	r3, #0
24010ac6:	d114      	bne.n	24010af2 <HAL_QSPI_Receive+0xde>
        {
          break;
        }

        *hqspi->pRxBuffPtr = *((__IO uint8_t *)data_reg);
24010ac8:	68fb      	ldr	r3, [r7, #12]
24010aca:	6b1b      	ldr	r3, [r3, #48]	; 0x30
24010acc:	693a      	ldr	r2, [r7, #16]
24010ace:	7812      	ldrb	r2, [r2, #0]
24010ad0:	b2d2      	uxtb	r2, r2
24010ad2:	701a      	strb	r2, [r3, #0]
        hqspi->pRxBuffPtr++;
24010ad4:	68fb      	ldr	r3, [r7, #12]
24010ad6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
24010ad8:	1c5a      	adds	r2, r3, #1
24010ada:	68fb      	ldr	r3, [r7, #12]
24010adc:	631a      	str	r2, [r3, #48]	; 0x30
        hqspi->RxXferCount--;
24010ade:	68fb      	ldr	r3, [r7, #12]
24010ae0:	6b9b      	ldr	r3, [r3, #56]	; 0x38
24010ae2:	1e5a      	subs	r2, r3, #1
24010ae4:	68fb      	ldr	r3, [r7, #12]
24010ae6:	639a      	str	r2, [r3, #56]	; 0x38
      while(hqspi->RxXferCount > 0U)
24010ae8:	68fb      	ldr	r3, [r7, #12]
24010aea:	6b9b      	ldr	r3, [r3, #56]	; 0x38
24010aec:	2b00      	cmp	r3, #0
24010aee:	d1de      	bne.n	24010aae <HAL_QSPI_Receive+0x9a>
24010af0:	e000      	b.n	24010af4 <HAL_QSPI_Receive+0xe0>
          break;
24010af2:	bf00      	nop
      }

      if (status == HAL_OK)
24010af4:	7ffb      	ldrb	r3, [r7, #31]
24010af6:	2b00      	cmp	r3, #0
24010af8:	d110      	bne.n	24010b1c <HAL_QSPI_Receive+0x108>
      {
        /* Wait until TC flag is set to go back in idle state */
        status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_TC, SET, tickstart, Timeout);
24010afa:	687b      	ldr	r3, [r7, #4]
24010afc:	9300      	str	r3, [sp, #0]
24010afe:	69bb      	ldr	r3, [r7, #24]
24010b00:	2201      	movs	r2, #1
24010b02:	2102      	movs	r1, #2
24010b04:	68f8      	ldr	r0, [r7, #12]
24010b06:	f000 fe70 	bl	240117ea <QSPI_WaitFlagStateUntilTimeout>
24010b0a:	4603      	mov	r3, r0
24010b0c:	77fb      	strb	r3, [r7, #31]

        if  (status == HAL_OK)
24010b0e:	7ffb      	ldrb	r3, [r7, #31]
24010b10:	2b00      	cmp	r3, #0
24010b12:	d103      	bne.n	24010b1c <HAL_QSPI_Receive+0x108>
        {
          /* Clear Transfer Complete bit */
          __HAL_QSPI_CLEAR_FLAG(hqspi, QSPI_FLAG_TC);
24010b14:	68fb      	ldr	r3, [r7, #12]
24010b16:	681b      	ldr	r3, [r3, #0]
24010b18:	2202      	movs	r2, #2
24010b1a:	60da      	str	r2, [r3, #12]

        }
      }

      /* Update QSPI state */
      hqspi->State = HAL_QSPI_STATE_READY;
24010b1c:	68fb      	ldr	r3, [r7, #12]
24010b1e:	2201      	movs	r2, #1
24010b20:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
24010b24:	e00a      	b.n	24010b3c <HAL_QSPI_Receive+0x128>
    }
    else
    {
      hqspi->ErrorCode |= HAL_QSPI_ERROR_INVALID_PARAM;
24010b26:	68fb      	ldr	r3, [r7, #12]
24010b28:	6c5b      	ldr	r3, [r3, #68]	; 0x44
24010b2a:	f043 0208 	orr.w	r2, r3, #8
24010b2e:	68fb      	ldr	r3, [r7, #12]
24010b30:	645a      	str	r2, [r3, #68]	; 0x44
      status = HAL_ERROR;
24010b32:	2301      	movs	r3, #1
24010b34:	77fb      	strb	r3, [r7, #31]
24010b36:	e001      	b.n	24010b3c <HAL_QSPI_Receive+0x128>
    }
  }
  else
  {
    status = HAL_BUSY;
24010b38:	2302      	movs	r3, #2
24010b3a:	77fb      	strb	r3, [r7, #31]
  }

  /* Process unlocked */
  __HAL_UNLOCK(hqspi);
24010b3c:	68fb      	ldr	r3, [r7, #12]
24010b3e:	2200      	movs	r2, #0
24010b40:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  return status;
24010b44:	7ffb      	ldrb	r3, [r7, #31]
}
24010b46:	4618      	mov	r0, r3
24010b48:	3720      	adds	r7, #32
24010b4a:	46bd      	mov	sp, r7
24010b4c:	bd80      	pop	{r7, pc}

24010b4e <HAL_QSPI_Transmit_IT>:
  * @param  pData : pointer to data buffer
  * @note   This function is used only in Indirect Write Mode
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_QSPI_Transmit_IT(QSPI_HandleTypeDef *hqspi, uint8_t *pData)
{
24010b4e:	b480      	push	{r7}
24010b50:	b085      	sub	sp, #20
24010b52:	af00      	add	r7, sp, #0
24010b54:	6078      	str	r0, [r7, #4]
24010b56:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
24010b58:	2300      	movs	r3, #0
24010b5a:	73fb      	strb	r3, [r7, #15]

  /* Process locked */
  __HAL_LOCK(hqspi);
24010b5c:	687b      	ldr	r3, [r7, #4]
24010b5e:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
24010b62:	b2db      	uxtb	r3, r3
24010b64:	2b01      	cmp	r3, #1
24010b66:	d101      	bne.n	24010b6c <HAL_QSPI_Transmit_IT+0x1e>
24010b68:	2302      	movs	r3, #2
24010b6a:	e04f      	b.n	24010c0c <HAL_QSPI_Transmit_IT+0xbe>
24010b6c:	687b      	ldr	r3, [r7, #4]
24010b6e:	2201      	movs	r2, #1
24010b70:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  if(hqspi->State == HAL_QSPI_STATE_READY)
24010b74:	687b      	ldr	r3, [r7, #4]
24010b76:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
24010b7a:	b2db      	uxtb	r3, r3
24010b7c:	2b01      	cmp	r3, #1
24010b7e:	d13e      	bne.n	24010bfe <HAL_QSPI_Transmit_IT+0xb0>
  {
    hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
24010b80:	687b      	ldr	r3, [r7, #4]
24010b82:	2200      	movs	r2, #0
24010b84:	645a      	str	r2, [r3, #68]	; 0x44

    if(pData != NULL )
24010b86:	683b      	ldr	r3, [r7, #0]
24010b88:	2b00      	cmp	r3, #0
24010b8a:	d02b      	beq.n	24010be4 <HAL_QSPI_Transmit_IT+0x96>
    {
      /* Update state */
      hqspi->State = HAL_QSPI_STATE_BUSY_INDIRECT_TX;
24010b8c:	687b      	ldr	r3, [r7, #4]
24010b8e:	2212      	movs	r2, #18
24010b90:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

      /* Configure counters and size of the handle */
      hqspi->TxXferCount = READ_REG(hqspi->Instance->DLR) + 1U;
24010b94:	687b      	ldr	r3, [r7, #4]
24010b96:	681b      	ldr	r3, [r3, #0]
24010b98:	691b      	ldr	r3, [r3, #16]
24010b9a:	1c5a      	adds	r2, r3, #1
24010b9c:	687b      	ldr	r3, [r7, #4]
24010b9e:	62da      	str	r2, [r3, #44]	; 0x2c
      hqspi->TxXferSize = READ_REG(hqspi->Instance->DLR) + 1U;
24010ba0:	687b      	ldr	r3, [r7, #4]
24010ba2:	681b      	ldr	r3, [r3, #0]
24010ba4:	691b      	ldr	r3, [r3, #16]
24010ba6:	1c5a      	adds	r2, r3, #1
24010ba8:	687b      	ldr	r3, [r7, #4]
24010baa:	629a      	str	r2, [r3, #40]	; 0x28
      hqspi->pTxBuffPtr = pData;
24010bac:	687b      	ldr	r3, [r7, #4]
24010bae:	683a      	ldr	r2, [r7, #0]
24010bb0:	625a      	str	r2, [r3, #36]	; 0x24

      /* Clear interrupt */
      __HAL_QSPI_CLEAR_FLAG(hqspi, QSPI_FLAG_TE | QSPI_FLAG_TC);
24010bb2:	687b      	ldr	r3, [r7, #4]
24010bb4:	681b      	ldr	r3, [r3, #0]
24010bb6:	2203      	movs	r2, #3
24010bb8:	60da      	str	r2, [r3, #12]

      /* Configure QSPI: CCR register with functional as indirect write */
      MODIFY_REG(hqspi->Instance->CCR, QUADSPI_CCR_FMODE, QSPI_FUNCTIONAL_MODE_INDIRECT_WRITE);
24010bba:	687b      	ldr	r3, [r7, #4]
24010bbc:	681b      	ldr	r3, [r3, #0]
24010bbe:	695a      	ldr	r2, [r3, #20]
24010bc0:	687b      	ldr	r3, [r7, #4]
24010bc2:	681b      	ldr	r3, [r3, #0]
24010bc4:	f022 6240 	bic.w	r2, r2, #201326592	; 0xc000000
24010bc8:	615a      	str	r2, [r3, #20]

      /* Process unlocked */
      __HAL_UNLOCK(hqspi);
24010bca:	687b      	ldr	r3, [r7, #4]
24010bcc:	2200      	movs	r2, #0
24010bce:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

      /* Enable the QSPI transfer error, FIFO threshold and transfer complete Interrupts */
      __HAL_QSPI_ENABLE_IT(hqspi, QSPI_IT_TE | QSPI_IT_FT | QSPI_IT_TC);
24010bd2:	687b      	ldr	r3, [r7, #4]
24010bd4:	681b      	ldr	r3, [r3, #0]
24010bd6:	681a      	ldr	r2, [r3, #0]
24010bd8:	687b      	ldr	r3, [r7, #4]
24010bda:	681b      	ldr	r3, [r3, #0]
24010bdc:	f442 22e0 	orr.w	r2, r2, #458752	; 0x70000
24010be0:	601a      	str	r2, [r3, #0]
24010be2:	e012      	b.n	24010c0a <HAL_QSPI_Transmit_IT+0xbc>
    }
    else
    {
      hqspi->ErrorCode |= HAL_QSPI_ERROR_INVALID_PARAM;
24010be4:	687b      	ldr	r3, [r7, #4]
24010be6:	6c5b      	ldr	r3, [r3, #68]	; 0x44
24010be8:	f043 0208 	orr.w	r2, r3, #8
24010bec:	687b      	ldr	r3, [r7, #4]
24010bee:	645a      	str	r2, [r3, #68]	; 0x44
      status = HAL_ERROR;
24010bf0:	2301      	movs	r3, #1
24010bf2:	73fb      	strb	r3, [r7, #15]

      /* Process unlocked */
      __HAL_UNLOCK(hqspi);
24010bf4:	687b      	ldr	r3, [r7, #4]
24010bf6:	2200      	movs	r2, #0
24010bf8:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
24010bfc:	e005      	b.n	24010c0a <HAL_QSPI_Transmit_IT+0xbc>
    }
  }
  else
  {
    status = HAL_BUSY;
24010bfe:	2302      	movs	r3, #2
24010c00:	73fb      	strb	r3, [r7, #15]

    /* Process unlocked */
    __HAL_UNLOCK(hqspi);
24010c02:	687b      	ldr	r3, [r7, #4]
24010c04:	2200      	movs	r2, #0
24010c06:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
  }

  return status;
24010c0a:	7bfb      	ldrb	r3, [r7, #15]
}
24010c0c:	4618      	mov	r0, r3
24010c0e:	3714      	adds	r7, #20
24010c10:	46bd      	mov	sp, r7
24010c12:	f85d 7b04 	ldr.w	r7, [sp], #4
24010c16:	4770      	bx	lr

24010c18 <HAL_QSPI_Receive_IT>:
  * @param  pData : pointer to data buffer
  * @note   This function is used only in Indirect Read Mode
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_QSPI_Receive_IT(QSPI_HandleTypeDef *hqspi, uint8_t *pData)
{
24010c18:	b480      	push	{r7}
24010c1a:	b085      	sub	sp, #20
24010c1c:	af00      	add	r7, sp, #0
24010c1e:	6078      	str	r0, [r7, #4]
24010c20:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
24010c22:	2300      	movs	r3, #0
24010c24:	73fb      	strb	r3, [r7, #15]
  uint32_t addr_reg = READ_REG(hqspi->Instance->AR);
24010c26:	687b      	ldr	r3, [r7, #4]
24010c28:	681b      	ldr	r3, [r3, #0]
24010c2a:	699b      	ldr	r3, [r3, #24]
24010c2c:	60bb      	str	r3, [r7, #8]

  /* Process locked */
  __HAL_LOCK(hqspi);
24010c2e:	687b      	ldr	r3, [r7, #4]
24010c30:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
24010c34:	b2db      	uxtb	r3, r3
24010c36:	2b01      	cmp	r3, #1
24010c38:	d101      	bne.n	24010c3e <HAL_QSPI_Receive_IT+0x26>
24010c3a:	2302      	movs	r3, #2
24010c3c:	e055      	b.n	24010cea <HAL_QSPI_Receive_IT+0xd2>
24010c3e:	687b      	ldr	r3, [r7, #4]
24010c40:	2201      	movs	r2, #1
24010c42:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  if(hqspi->State == HAL_QSPI_STATE_READY)
24010c46:	687b      	ldr	r3, [r7, #4]
24010c48:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
24010c4c:	b2db      	uxtb	r3, r3
24010c4e:	2b01      	cmp	r3, #1
24010c50:	d144      	bne.n	24010cdc <HAL_QSPI_Receive_IT+0xc4>
  {
    hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
24010c52:	687b      	ldr	r3, [r7, #4]
24010c54:	2200      	movs	r2, #0
24010c56:	645a      	str	r2, [r3, #68]	; 0x44

    if(pData != NULL )
24010c58:	683b      	ldr	r3, [r7, #0]
24010c5a:	2b00      	cmp	r3, #0
24010c5c:	d031      	beq.n	24010cc2 <HAL_QSPI_Receive_IT+0xaa>
    {
      /* Update state */
      hqspi->State = HAL_QSPI_STATE_BUSY_INDIRECT_RX;
24010c5e:	687b      	ldr	r3, [r7, #4]
24010c60:	2222      	movs	r2, #34	; 0x22
24010c62:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

      /* Configure counters and size of the handle */
      hqspi->RxXferCount = READ_REG(hqspi->Instance->DLR) + 1U;
24010c66:	687b      	ldr	r3, [r7, #4]
24010c68:	681b      	ldr	r3, [r3, #0]
24010c6a:	691b      	ldr	r3, [r3, #16]
24010c6c:	1c5a      	adds	r2, r3, #1
24010c6e:	687b      	ldr	r3, [r7, #4]
24010c70:	639a      	str	r2, [r3, #56]	; 0x38
      hqspi->RxXferSize = READ_REG(hqspi->Instance->DLR) + 1U;
24010c72:	687b      	ldr	r3, [r7, #4]
24010c74:	681b      	ldr	r3, [r3, #0]
24010c76:	691b      	ldr	r3, [r3, #16]
24010c78:	1c5a      	adds	r2, r3, #1
24010c7a:	687b      	ldr	r3, [r7, #4]
24010c7c:	635a      	str	r2, [r3, #52]	; 0x34
      hqspi->pRxBuffPtr = pData;
24010c7e:	687b      	ldr	r3, [r7, #4]
24010c80:	683a      	ldr	r2, [r7, #0]
24010c82:	631a      	str	r2, [r3, #48]	; 0x30

      /* Clear interrupt */
      __HAL_QSPI_CLEAR_FLAG(hqspi, QSPI_FLAG_TE | QSPI_FLAG_TC);
24010c84:	687b      	ldr	r3, [r7, #4]
24010c86:	681b      	ldr	r3, [r3, #0]
24010c88:	2203      	movs	r2, #3
24010c8a:	60da      	str	r2, [r3, #12]

      /* Configure QSPI: CCR register with functional as indirect read */
      MODIFY_REG(hqspi->Instance->CCR, QUADSPI_CCR_FMODE, QSPI_FUNCTIONAL_MODE_INDIRECT_READ);
24010c8c:	687b      	ldr	r3, [r7, #4]
24010c8e:	681b      	ldr	r3, [r3, #0]
24010c90:	695b      	ldr	r3, [r3, #20]
24010c92:	f023 6240 	bic.w	r2, r3, #201326592	; 0xc000000
24010c96:	687b      	ldr	r3, [r7, #4]
24010c98:	681b      	ldr	r3, [r3, #0]
24010c9a:	f042 6280 	orr.w	r2, r2, #67108864	; 0x4000000
24010c9e:	615a      	str	r2, [r3, #20]

      /* Start the transfer by re-writing the address in AR register */
      WRITE_REG(hqspi->Instance->AR, addr_reg);
24010ca0:	687b      	ldr	r3, [r7, #4]
24010ca2:	681b      	ldr	r3, [r3, #0]
24010ca4:	68ba      	ldr	r2, [r7, #8]
24010ca6:	619a      	str	r2, [r3, #24]

      /* Process unlocked */
      __HAL_UNLOCK(hqspi);
24010ca8:	687b      	ldr	r3, [r7, #4]
24010caa:	2200      	movs	r2, #0
24010cac:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

      /* Enable the QSPI transfer error, FIFO threshold and transfer complete Interrupts */
      __HAL_QSPI_ENABLE_IT(hqspi, QSPI_IT_TE | QSPI_IT_FT | QSPI_IT_TC);
24010cb0:	687b      	ldr	r3, [r7, #4]
24010cb2:	681b      	ldr	r3, [r3, #0]
24010cb4:	681a      	ldr	r2, [r3, #0]
24010cb6:	687b      	ldr	r3, [r7, #4]
24010cb8:	681b      	ldr	r3, [r3, #0]
24010cba:	f442 22e0 	orr.w	r2, r2, #458752	; 0x70000
24010cbe:	601a      	str	r2, [r3, #0]
24010cc0:	e012      	b.n	24010ce8 <HAL_QSPI_Receive_IT+0xd0>
    }
    else
    {
      hqspi->ErrorCode |= HAL_QSPI_ERROR_INVALID_PARAM;
24010cc2:	687b      	ldr	r3, [r7, #4]
24010cc4:	6c5b      	ldr	r3, [r3, #68]	; 0x44
24010cc6:	f043 0208 	orr.w	r2, r3, #8
24010cca:	687b      	ldr	r3, [r7, #4]
24010ccc:	645a      	str	r2, [r3, #68]	; 0x44
      status = HAL_ERROR;
24010cce:	2301      	movs	r3, #1
24010cd0:	73fb      	strb	r3, [r7, #15]

      /* Process unlocked */
      __HAL_UNLOCK(hqspi);
24010cd2:	687b      	ldr	r3, [r7, #4]
24010cd4:	2200      	movs	r2, #0
24010cd6:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
24010cda:	e005      	b.n	24010ce8 <HAL_QSPI_Receive_IT+0xd0>
    }
  }
  else
  {
    status = HAL_BUSY;
24010cdc:	2302      	movs	r3, #2
24010cde:	73fb      	strb	r3, [r7, #15]

    /* Process unlocked */
    __HAL_UNLOCK(hqspi);
24010ce0:	687b      	ldr	r3, [r7, #4]
24010ce2:	2200      	movs	r2, #0
24010ce4:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
  }

  return status;
24010ce8:	7bfb      	ldrb	r3, [r7, #15]
}
24010cea:	4618      	mov	r0, r3
24010cec:	3714      	adds	r7, #20
24010cee:	46bd      	mov	sp, r7
24010cf0:	f85d 7b04 	ldr.w	r7, [sp], #4
24010cf4:	4770      	bx	lr
	...

24010cf8 <HAL_QSPI_Transmit_DMA>:
  * @param  pData : pointer to data buffer
  * @note   This function is used only in Indirect Write Mode
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_QSPI_Transmit_DMA(QSPI_HandleTypeDef *hqspi, uint8_t *pData)
{
24010cf8:	b590      	push	{r4, r7, lr}
24010cfa:	b087      	sub	sp, #28
24010cfc:	af02      	add	r7, sp, #8
24010cfe:	6078      	str	r0, [r7, #4]
24010d00:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
24010d02:	2300      	movs	r3, #0
24010d04:	73fb      	strb	r3, [r7, #15]
  uint32_t data_size = (READ_REG(hqspi->Instance->DLR) + 1U);
24010d06:	687b      	ldr	r3, [r7, #4]
24010d08:	681b      	ldr	r3, [r3, #0]
24010d0a:	691b      	ldr	r3, [r3, #16]
24010d0c:	3301      	adds	r3, #1
24010d0e:	60bb      	str	r3, [r7, #8]

  /* Process locked */
  __HAL_LOCK(hqspi);
24010d10:	687b      	ldr	r3, [r7, #4]
24010d12:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
24010d16:	b2db      	uxtb	r3, r3
24010d18:	2b01      	cmp	r3, #1
24010d1a:	d101      	bne.n	24010d20 <HAL_QSPI_Transmit_DMA+0x28>
24010d1c:	2302      	movs	r3, #2
24010d1e:	e0cc      	b.n	24010eba <HAL_QSPI_Transmit_DMA+0x1c2>
24010d20:	687b      	ldr	r3, [r7, #4]
24010d22:	2201      	movs	r2, #1
24010d24:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  if(hqspi->State == HAL_QSPI_STATE_READY)
24010d28:	687b      	ldr	r3, [r7, #4]
24010d2a:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
24010d2e:	b2db      	uxtb	r3, r3
24010d30:	2b01      	cmp	r3, #1
24010d32:	f040 80bb 	bne.w	24010eac <HAL_QSPI_Transmit_DMA+0x1b4>
  {
    /* Clear the error code */
    hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
24010d36:	687b      	ldr	r3, [r7, #4]
24010d38:	2200      	movs	r2, #0
24010d3a:	645a      	str	r2, [r3, #68]	; 0x44

    if(pData != NULL )
24010d3c:	683b      	ldr	r3, [r7, #0]
24010d3e:	2b00      	cmp	r3, #0
24010d40:	f000 80a7 	beq.w	24010e92 <HAL_QSPI_Transmit_DMA+0x19a>
    {
      /* Configure counters of the handle */
      hqspi->TxXferCount = data_size;
24010d44:	687b      	ldr	r3, [r7, #4]
24010d46:	68ba      	ldr	r2, [r7, #8]
24010d48:	62da      	str	r2, [r3, #44]	; 0x2c

        /* Update state */
        hqspi->State = HAL_QSPI_STATE_BUSY_INDIRECT_TX;
24010d4a:	687b      	ldr	r3, [r7, #4]
24010d4c:	2212      	movs	r2, #18
24010d4e:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

        /* Clear interrupt */
        __HAL_QSPI_CLEAR_FLAG(hqspi, (QSPI_FLAG_TE | QSPI_FLAG_TC));
24010d52:	687b      	ldr	r3, [r7, #4]
24010d54:	681b      	ldr	r3, [r3, #0]
24010d56:	2203      	movs	r2, #3
24010d58:	60da      	str	r2, [r3, #12]

        /* Configure size and pointer of the handle */
        hqspi->TxXferSize = hqspi->TxXferCount;
24010d5a:	687b      	ldr	r3, [r7, #4]
24010d5c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
24010d5e:	687b      	ldr	r3, [r7, #4]
24010d60:	629a      	str	r2, [r3, #40]	; 0x28
        hqspi->pTxBuffPtr = pData;
24010d62:	687b      	ldr	r3, [r7, #4]
24010d64:	683a      	ldr	r2, [r7, #0]
24010d66:	625a      	str	r2, [r3, #36]	; 0x24

        /* Configure QSPI: CCR register with functional mode as indirect write */
        MODIFY_REG(hqspi->Instance->CCR, QUADSPI_CCR_FMODE, QSPI_FUNCTIONAL_MODE_INDIRECT_WRITE);
24010d68:	687b      	ldr	r3, [r7, #4]
24010d6a:	681b      	ldr	r3, [r3, #0]
24010d6c:	695a      	ldr	r2, [r3, #20]
24010d6e:	687b      	ldr	r3, [r7, #4]
24010d70:	681b      	ldr	r3, [r3, #0]
24010d72:	f022 6240 	bic.w	r2, r2, #201326592	; 0xc000000
24010d76:	615a      	str	r2, [r3, #20]

        /* Set the QSPI MDMA transfer complete callback */
        hqspi->hmdma->XferCpltCallback = QSPI_DMATxCplt;
24010d78:	687b      	ldr	r3, [r7, #4]
24010d7a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
24010d7c:	4a51      	ldr	r2, [pc, #324]	; (24010ec4 <HAL_QSPI_Transmit_DMA+0x1cc>)
24010d7e:	645a      	str	r2, [r3, #68]	; 0x44

        /* Set the MDMA error callback */
        hqspi->hmdma->XferErrorCallback = QSPI_DMAError;
24010d80:	687b      	ldr	r3, [r7, #4]
24010d82:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
24010d84:	4a50      	ldr	r2, [pc, #320]	; (24010ec8 <HAL_QSPI_Transmit_DMA+0x1d0>)
24010d86:	655a      	str	r2, [r3, #84]	; 0x54

        /* Clear the MDMA abort callback */
        hqspi->hmdma->XferAbortCallback = NULL;
24010d88:	687b      	ldr	r3, [r7, #4]
24010d8a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
24010d8c:	2200      	movs	r2, #0
24010d8e:	659a      	str	r2, [r3, #88]	; 0x58

        /* In Transmit mode , the MDMA destination is the QSPI DR register : Force the MDMA Destination Increment to disable */
        MODIFY_REG(hqspi->hmdma->Instance->CTCR, (MDMA_CTCR_DINC | MDMA_CTCR_DINCOS) ,MDMA_DEST_INC_DISABLE);
24010d90:	687b      	ldr	r3, [r7, #4]
24010d92:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
24010d94:	681b      	ldr	r3, [r3, #0]
24010d96:	6919      	ldr	r1, [r3, #16]
24010d98:	687b      	ldr	r3, [r7, #4]
24010d9a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
24010d9c:	681a      	ldr	r2, [r3, #0]
24010d9e:	4b4b      	ldr	r3, [pc, #300]	; (24010ecc <HAL_QSPI_Transmit_DMA+0x1d4>)
24010da0:	400b      	ands	r3, r1
24010da2:	6113      	str	r3, [r2, #16]

        /* Update MDMA configuration with the correct SourceInc field for Write operation */
        if (hqspi->hmdma->Init.SourceDataSize == MDMA_SRC_DATASIZE_BYTE)
24010da4:	687b      	ldr	r3, [r7, #4]
24010da6:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
24010da8:	69db      	ldr	r3, [r3, #28]
24010daa:	2b00      	cmp	r3, #0
24010dac:	d10c      	bne.n	24010dc8 <HAL_QSPI_Transmit_DMA+0xd0>
        {
          MODIFY_REG(hqspi->hmdma->Instance->CTCR, (MDMA_CTCR_SINC | MDMA_CTCR_SINCOS) , MDMA_SRC_INC_BYTE);
24010dae:	687b      	ldr	r3, [r7, #4]
24010db0:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
24010db2:	681b      	ldr	r3, [r3, #0]
24010db4:	691a      	ldr	r2, [r3, #16]
24010db6:	4b46      	ldr	r3, [pc, #280]	; (24010ed0 <HAL_QSPI_Transmit_DMA+0x1d8>)
24010db8:	4013      	ands	r3, r2
24010dba:	687a      	ldr	r2, [r7, #4]
24010dbc:	6bd2      	ldr	r2, [r2, #60]	; 0x3c
24010dbe:	6812      	ldr	r2, [r2, #0]
24010dc0:	f043 0302 	orr.w	r3, r3, #2
24010dc4:	6113      	str	r3, [r2, #16]
24010dc6:	e02c      	b.n	24010e22 <HAL_QSPI_Transmit_DMA+0x12a>
        }
        else if (hqspi->hmdma->Init.SourceDataSize == MDMA_SRC_DATASIZE_HALFWORD)
24010dc8:	687b      	ldr	r3, [r7, #4]
24010dca:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
24010dcc:	69db      	ldr	r3, [r3, #28]
24010dce:	2b10      	cmp	r3, #16
24010dd0:	d10c      	bne.n	24010dec <HAL_QSPI_Transmit_DMA+0xf4>
        {
          MODIFY_REG(hqspi->hmdma->Instance->CTCR, (MDMA_CTCR_SINC | MDMA_CTCR_SINCOS) , MDMA_SRC_INC_HALFWORD);
24010dd2:	687b      	ldr	r3, [r7, #4]
24010dd4:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
24010dd6:	681b      	ldr	r3, [r3, #0]
24010dd8:	691a      	ldr	r2, [r3, #16]
24010dda:	4b3d      	ldr	r3, [pc, #244]	; (24010ed0 <HAL_QSPI_Transmit_DMA+0x1d8>)
24010ddc:	4013      	ands	r3, r2
24010dde:	687a      	ldr	r2, [r7, #4]
24010de0:	6bd2      	ldr	r2, [r2, #60]	; 0x3c
24010de2:	6812      	ldr	r2, [r2, #0]
24010de4:	f443 7381 	orr.w	r3, r3, #258	; 0x102
24010de8:	6113      	str	r3, [r2, #16]
24010dea:	e01a      	b.n	24010e22 <HAL_QSPI_Transmit_DMA+0x12a>
        }
        else if (hqspi->hmdma->Init.SourceDataSize == MDMA_SRC_DATASIZE_WORD)
24010dec:	687b      	ldr	r3, [r7, #4]
24010dee:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
24010df0:	69db      	ldr	r3, [r3, #28]
24010df2:	2b20      	cmp	r3, #32
24010df4:	d10d      	bne.n	24010e12 <HAL_QSPI_Transmit_DMA+0x11a>
        {
          MODIFY_REG(hqspi->hmdma->Instance->CTCR, (MDMA_CTCR_SINC | MDMA_CTCR_SINCOS) , MDMA_SRC_INC_WORD);
24010df6:	687b      	ldr	r3, [r7, #4]
24010df8:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
24010dfa:	681b      	ldr	r3, [r3, #0]
24010dfc:	691b      	ldr	r3, [r3, #16]
24010dfe:	4a34      	ldr	r2, [pc, #208]	; (24010ed0 <HAL_QSPI_Transmit_DMA+0x1d8>)
24010e00:	401a      	ands	r2, r3
24010e02:	687b      	ldr	r3, [r7, #4]
24010e04:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
24010e06:	6819      	ldr	r1, [r3, #0]
24010e08:	f240 2302 	movw	r3, #514	; 0x202
24010e0c:	4313      	orrs	r3, r2
24010e0e:	610b      	str	r3, [r1, #16]
24010e10:	e007      	b.n	24010e22 <HAL_QSPI_Transmit_DMA+0x12a>
        }
        else
        {
          /* in case of incorrect source data size */
          hqspi->ErrorCode |= HAL_QSPI_ERROR_DMA;
24010e12:	687b      	ldr	r3, [r7, #4]
24010e14:	6c5b      	ldr	r3, [r3, #68]	; 0x44
24010e16:	f043 0204 	orr.w	r2, r3, #4
24010e1a:	687b      	ldr	r3, [r7, #4]
24010e1c:	645a      	str	r2, [r3, #68]	; 0x44
          status = HAL_ERROR;
24010e1e:	2301      	movs	r3, #1
24010e20:	73fb      	strb	r3, [r7, #15]
        }

        /* Enable the QSPI transmit MDMA */
        if (HAL_MDMA_Start_IT(hqspi->hmdma, (uint32_t)pData, (uint32_t)&hqspi->Instance->DR, hqspi->TxXferSize, 1) == HAL_OK)
24010e22:	687b      	ldr	r3, [r7, #4]
24010e24:	6bd8      	ldr	r0, [r3, #60]	; 0x3c
24010e26:	6839      	ldr	r1, [r7, #0]
24010e28:	687b      	ldr	r3, [r7, #4]
24010e2a:	681b      	ldr	r3, [r3, #0]
24010e2c:	3320      	adds	r3, #32
24010e2e:	461c      	mov	r4, r3
24010e30:	687b      	ldr	r3, [r7, #4]
24010e32:	6a9a      	ldr	r2, [r3, #40]	; 0x28
24010e34:	2301      	movs	r3, #1
24010e36:	9300      	str	r3, [sp, #0]
24010e38:	4613      	mov	r3, r2
24010e3a:	4622      	mov	r2, r4
24010e3c:	f7fd fed7 	bl	2400ebee <HAL_MDMA_Start_IT>
24010e40:	4603      	mov	r3, r0
24010e42:	2b00      	cmp	r3, #0
24010e44:	d114      	bne.n	24010e70 <HAL_QSPI_Transmit_DMA+0x178>
        {
          /* Process unlocked */
          __HAL_UNLOCK(hqspi);
24010e46:	687b      	ldr	r3, [r7, #4]
24010e48:	2200      	movs	r2, #0
24010e4a:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

          /* Enable the QSPI transfer error Interrupt */
          __HAL_QSPI_ENABLE_IT(hqspi, QSPI_IT_TE);
24010e4e:	687b      	ldr	r3, [r7, #4]
24010e50:	681b      	ldr	r3, [r3, #0]
24010e52:	681a      	ldr	r2, [r3, #0]
24010e54:	687b      	ldr	r3, [r7, #4]
24010e56:	681b      	ldr	r3, [r3, #0]
24010e58:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
24010e5c:	601a      	str	r2, [r3, #0]

          /* Enable the MDMA transfer by setting the DMAEN bit in the QSPI CR register */
          SET_BIT(hqspi->Instance->CR, QUADSPI_CR_DMAEN);
24010e5e:	687b      	ldr	r3, [r7, #4]
24010e60:	681b      	ldr	r3, [r3, #0]
24010e62:	681a      	ldr	r2, [r3, #0]
24010e64:	687b      	ldr	r3, [r7, #4]
24010e66:	681b      	ldr	r3, [r3, #0]
24010e68:	f042 0204 	orr.w	r2, r2, #4
24010e6c:	601a      	str	r2, [r3, #0]
24010e6e:	e023      	b.n	24010eb8 <HAL_QSPI_Transmit_DMA+0x1c0>
        }
        else
        {
          status = HAL_ERROR;
24010e70:	2301      	movs	r3, #1
24010e72:	73fb      	strb	r3, [r7, #15]
          hqspi->ErrorCode |= HAL_QSPI_ERROR_DMA;
24010e74:	687b      	ldr	r3, [r7, #4]
24010e76:	6c5b      	ldr	r3, [r3, #68]	; 0x44
24010e78:	f043 0204 	orr.w	r2, r3, #4
24010e7c:	687b      	ldr	r3, [r7, #4]
24010e7e:	645a      	str	r2, [r3, #68]	; 0x44
          hqspi->State = HAL_QSPI_STATE_READY;
24010e80:	687b      	ldr	r3, [r7, #4]
24010e82:	2201      	movs	r2, #1
24010e84:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

          /* Process unlocked */
          __HAL_UNLOCK(hqspi);
24010e88:	687b      	ldr	r3, [r7, #4]
24010e8a:	2200      	movs	r2, #0
24010e8c:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
24010e90:	e012      	b.n	24010eb8 <HAL_QSPI_Transmit_DMA+0x1c0>
        }
    }
    else
    {
      hqspi->ErrorCode |= HAL_QSPI_ERROR_INVALID_PARAM;
24010e92:	687b      	ldr	r3, [r7, #4]
24010e94:	6c5b      	ldr	r3, [r3, #68]	; 0x44
24010e96:	f043 0208 	orr.w	r2, r3, #8
24010e9a:	687b      	ldr	r3, [r7, #4]
24010e9c:	645a      	str	r2, [r3, #68]	; 0x44
      status = HAL_ERROR;
24010e9e:	2301      	movs	r3, #1
24010ea0:	73fb      	strb	r3, [r7, #15]

      /* Process unlocked */
      __HAL_UNLOCK(hqspi);
24010ea2:	687b      	ldr	r3, [r7, #4]
24010ea4:	2200      	movs	r2, #0
24010ea6:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
24010eaa:	e005      	b.n	24010eb8 <HAL_QSPI_Transmit_DMA+0x1c0>
    }
  }
  else
  {
    status = HAL_BUSY;
24010eac:	2302      	movs	r3, #2
24010eae:	73fb      	strb	r3, [r7, #15]

    /* Process unlocked */
    __HAL_UNLOCK(hqspi);
24010eb0:	687b      	ldr	r3, [r7, #4]
24010eb2:	2200      	movs	r2, #0
24010eb4:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
  }

  return status;
24010eb8:	7bfb      	ldrb	r3, [r7, #15]
}
24010eba:	4618      	mov	r0, r3
24010ebc:	3714      	adds	r7, #20
24010ebe:	46bd      	mov	sp, r7
24010ec0:	bd90      	pop	{r4, r7, pc}
24010ec2:	bf00      	nop
24010ec4:	24011711 	.word	0x24011711
24010ec8:	24011741 	.word	0x24011741
24010ecc:	fffff3f3 	.word	0xfffff3f3
24010ed0:	fffffcfc 	.word	0xfffffcfc

24010ed4 <HAL_QSPI_Receive_DMA>:
  * @param  pData : pointer to data buffer.
  * @note   This function is used only in Indirect Read Mode
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_QSPI_Receive_DMA(QSPI_HandleTypeDef *hqspi, uint8_t *pData)
{
24010ed4:	b590      	push	{r4, r7, lr}
24010ed6:	b089      	sub	sp, #36	; 0x24
24010ed8:	af02      	add	r7, sp, #8
24010eda:	6078      	str	r0, [r7, #4]
24010edc:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
24010ede:	2300      	movs	r3, #0
24010ee0:	75fb      	strb	r3, [r7, #23]
  uint32_t addr_reg = READ_REG(hqspi->Instance->AR);
24010ee2:	687b      	ldr	r3, [r7, #4]
24010ee4:	681b      	ldr	r3, [r3, #0]
24010ee6:	699b      	ldr	r3, [r3, #24]
24010ee8:	613b      	str	r3, [r7, #16]
  uint32_t data_size = (READ_REG(hqspi->Instance->DLR) + 1U);
24010eea:	687b      	ldr	r3, [r7, #4]
24010eec:	681b      	ldr	r3, [r3, #0]
24010eee:	691b      	ldr	r3, [r3, #16]
24010ef0:	3301      	adds	r3, #1
24010ef2:	60fb      	str	r3, [r7, #12]

  /* Process locked */
  __HAL_LOCK(hqspi);
24010ef4:	687b      	ldr	r3, [r7, #4]
24010ef6:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
24010efa:	b2db      	uxtb	r3, r3
24010efc:	2b01      	cmp	r3, #1
24010efe:	d101      	bne.n	24010f04 <HAL_QSPI_Receive_DMA+0x30>
24010f00:	2302      	movs	r3, #2
24010f02:	e0d2      	b.n	240110aa <HAL_QSPI_Receive_DMA+0x1d6>
24010f04:	687b      	ldr	r3, [r7, #4]
24010f06:	2201      	movs	r2, #1
24010f08:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  if(hqspi->State == HAL_QSPI_STATE_READY)
24010f0c:	687b      	ldr	r3, [r7, #4]
24010f0e:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
24010f12:	b2db      	uxtb	r3, r3
24010f14:	2b01      	cmp	r3, #1
24010f16:	f040 80c1 	bne.w	2401109c <HAL_QSPI_Receive_DMA+0x1c8>
  {
    /* Clear the error code */
    hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
24010f1a:	687b      	ldr	r3, [r7, #4]
24010f1c:	2200      	movs	r2, #0
24010f1e:	645a      	str	r2, [r3, #68]	; 0x44

    if(pData != NULL )
24010f20:	683b      	ldr	r3, [r7, #0]
24010f22:	2b00      	cmp	r3, #0
24010f24:	f000 80ad 	beq.w	24011082 <HAL_QSPI_Receive_DMA+0x1ae>
    {
      /* Configure counters of the handle */
      hqspi->RxXferCount = data_size;
24010f28:	687b      	ldr	r3, [r7, #4]
24010f2a:	68fa      	ldr	r2, [r7, #12]
24010f2c:	639a      	str	r2, [r3, #56]	; 0x38
        /* Update state */
        hqspi->State = HAL_QSPI_STATE_BUSY_INDIRECT_RX;
24010f2e:	687b      	ldr	r3, [r7, #4]
24010f30:	2222      	movs	r2, #34	; 0x22
24010f32:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

        /* Clear interrupt */
        __HAL_QSPI_CLEAR_FLAG(hqspi, (QSPI_FLAG_TE | QSPI_FLAG_TC));
24010f36:	687b      	ldr	r3, [r7, #4]
24010f38:	681b      	ldr	r3, [r3, #0]
24010f3a:	2203      	movs	r2, #3
24010f3c:	60da      	str	r2, [r3, #12]

        /* Configure size and pointer of the handle */
        hqspi->RxXferSize = hqspi->RxXferCount;
24010f3e:	687b      	ldr	r3, [r7, #4]
24010f40:	6b9a      	ldr	r2, [r3, #56]	; 0x38
24010f42:	687b      	ldr	r3, [r7, #4]
24010f44:	635a      	str	r2, [r3, #52]	; 0x34
        hqspi->pRxBuffPtr = pData;
24010f46:	687b      	ldr	r3, [r7, #4]
24010f48:	683a      	ldr	r2, [r7, #0]
24010f4a:	631a      	str	r2, [r3, #48]	; 0x30

        /* Set the QSPI MDMA transfer complete callback */
        hqspi->hmdma->XferCpltCallback = QSPI_DMARxCplt;
24010f4c:	687b      	ldr	r3, [r7, #4]
24010f4e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
24010f50:	4a58      	ldr	r2, [pc, #352]	; (240110b4 <HAL_QSPI_Receive_DMA+0x1e0>)
24010f52:	645a      	str	r2, [r3, #68]	; 0x44

        /* Set the MDMA error callback */
        hqspi->hmdma->XferErrorCallback = QSPI_DMAError;
24010f54:	687b      	ldr	r3, [r7, #4]
24010f56:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
24010f58:	4a57      	ldr	r2, [pc, #348]	; (240110b8 <HAL_QSPI_Receive_DMA+0x1e4>)
24010f5a:	655a      	str	r2, [r3, #84]	; 0x54

        /* Clear the MDMA abort callback */
        hqspi->hmdma->XferAbortCallback = NULL;
24010f5c:	687b      	ldr	r3, [r7, #4]
24010f5e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
24010f60:	2200      	movs	r2, #0
24010f62:	659a      	str	r2, [r3, #88]	; 0x58

      /* In Receive mode , the MDMA source is the QSPI DR register : Force the MDMA Source Increment to disable */
      MODIFY_REG(hqspi->hmdma->Instance->CTCR, (MDMA_CTCR_SINC | MDMA_CTCR_SINCOS) , MDMA_SRC_INC_DISABLE);
24010f64:	687b      	ldr	r3, [r7, #4]
24010f66:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
24010f68:	681b      	ldr	r3, [r3, #0]
24010f6a:	6919      	ldr	r1, [r3, #16]
24010f6c:	687b      	ldr	r3, [r7, #4]
24010f6e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
24010f70:	681a      	ldr	r2, [r3, #0]
24010f72:	4b52      	ldr	r3, [pc, #328]	; (240110bc <HAL_QSPI_Receive_DMA+0x1e8>)
24010f74:	400b      	ands	r3, r1
24010f76:	6113      	str	r3, [r2, #16]

      /* Update MDMA configuration with the correct DestinationInc field for read operation */
      if (hqspi->hmdma->Init.DestDataSize == MDMA_DEST_DATASIZE_BYTE)
24010f78:	687b      	ldr	r3, [r7, #4]
24010f7a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
24010f7c:	6a1b      	ldr	r3, [r3, #32]
24010f7e:	2b00      	cmp	r3, #0
24010f80:	d10c      	bne.n	24010f9c <HAL_QSPI_Receive_DMA+0xc8>
      {
        MODIFY_REG(hqspi->hmdma->Instance->CTCR, (MDMA_CTCR_DINC | MDMA_CTCR_DINCOS) , MDMA_DEST_INC_BYTE);
24010f82:	687b      	ldr	r3, [r7, #4]
24010f84:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
24010f86:	681b      	ldr	r3, [r3, #0]
24010f88:	691a      	ldr	r2, [r3, #16]
24010f8a:	4b4d      	ldr	r3, [pc, #308]	; (240110c0 <HAL_QSPI_Receive_DMA+0x1ec>)
24010f8c:	4013      	ands	r3, r2
24010f8e:	687a      	ldr	r2, [r7, #4]
24010f90:	6bd2      	ldr	r2, [r2, #60]	; 0x3c
24010f92:	6812      	ldr	r2, [r2, #0]
24010f94:	f043 0308 	orr.w	r3, r3, #8
24010f98:	6113      	str	r3, [r2, #16]
24010f9a:	e02c      	b.n	24010ff6 <HAL_QSPI_Receive_DMA+0x122>
      }
      else if (hqspi->hmdma->Init.DestDataSize == MDMA_DEST_DATASIZE_HALFWORD)
24010f9c:	687b      	ldr	r3, [r7, #4]
24010f9e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
24010fa0:	6a1b      	ldr	r3, [r3, #32]
24010fa2:	2b40      	cmp	r3, #64	; 0x40
24010fa4:	d10c      	bne.n	24010fc0 <HAL_QSPI_Receive_DMA+0xec>
      {
        MODIFY_REG(hqspi->hmdma->Instance->CTCR, (MDMA_CTCR_DINC | MDMA_CTCR_DINCOS) , MDMA_DEST_INC_HALFWORD);
24010fa6:	687b      	ldr	r3, [r7, #4]
24010fa8:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
24010faa:	681b      	ldr	r3, [r3, #0]
24010fac:	691a      	ldr	r2, [r3, #16]
24010fae:	4b44      	ldr	r3, [pc, #272]	; (240110c0 <HAL_QSPI_Receive_DMA+0x1ec>)
24010fb0:	4013      	ands	r3, r2
24010fb2:	687a      	ldr	r2, [r7, #4]
24010fb4:	6bd2      	ldr	r2, [r2, #60]	; 0x3c
24010fb6:	6812      	ldr	r2, [r2, #0]
24010fb8:	f443 6381 	orr.w	r3, r3, #1032	; 0x408
24010fbc:	6113      	str	r3, [r2, #16]
24010fbe:	e01a      	b.n	24010ff6 <HAL_QSPI_Receive_DMA+0x122>
      }
      else if (hqspi->hmdma->Init.DestDataSize == MDMA_DEST_DATASIZE_WORD)
24010fc0:	687b      	ldr	r3, [r7, #4]
24010fc2:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
24010fc4:	6a1b      	ldr	r3, [r3, #32]
24010fc6:	2b80      	cmp	r3, #128	; 0x80
24010fc8:	d10d      	bne.n	24010fe6 <HAL_QSPI_Receive_DMA+0x112>
      {
        MODIFY_REG(hqspi->hmdma->Instance->CTCR, (MDMA_CTCR_DINC | MDMA_CTCR_DINCOS) , MDMA_DEST_INC_WORD);
24010fca:	687b      	ldr	r3, [r7, #4]
24010fcc:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
24010fce:	681b      	ldr	r3, [r3, #0]
24010fd0:	691b      	ldr	r3, [r3, #16]
24010fd2:	4a3b      	ldr	r2, [pc, #236]	; (240110c0 <HAL_QSPI_Receive_DMA+0x1ec>)
24010fd4:	401a      	ands	r2, r3
24010fd6:	687b      	ldr	r3, [r7, #4]
24010fd8:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
24010fda:	6819      	ldr	r1, [r3, #0]
24010fdc:	f640 0308 	movw	r3, #2056	; 0x808
24010fe0:	4313      	orrs	r3, r2
24010fe2:	610b      	str	r3, [r1, #16]
24010fe4:	e007      	b.n	24010ff6 <HAL_QSPI_Receive_DMA+0x122>
      }
      else
      {
       /* in case of incorrect destination data size */
        hqspi->ErrorCode |= HAL_QSPI_ERROR_DMA;
24010fe6:	687b      	ldr	r3, [r7, #4]
24010fe8:	6c5b      	ldr	r3, [r3, #68]	; 0x44
24010fea:	f043 0204 	orr.w	r2, r3, #4
24010fee:	687b      	ldr	r3, [r7, #4]
24010ff0:	645a      	str	r2, [r3, #68]	; 0x44
        status = HAL_ERROR;
24010ff2:	2301      	movs	r3, #1
24010ff4:	75fb      	strb	r3, [r7, #23]
      }
          /* Configure QSPI: CCR register with functional as indirect read */
          MODIFY_REG(hqspi->Instance->CCR, QUADSPI_CCR_FMODE, QSPI_FUNCTIONAL_MODE_INDIRECT_READ);
24010ff6:	687b      	ldr	r3, [r7, #4]
24010ff8:	681b      	ldr	r3, [r3, #0]
24010ffa:	695b      	ldr	r3, [r3, #20]
24010ffc:	f023 6240 	bic.w	r2, r3, #201326592	; 0xc000000
24011000:	687b      	ldr	r3, [r7, #4]
24011002:	681b      	ldr	r3, [r3, #0]
24011004:	f042 6280 	orr.w	r2, r2, #67108864	; 0x4000000
24011008:	615a      	str	r2, [r3, #20]

          /* Start the transfer by re-writing the address in AR register */
          WRITE_REG(hqspi->Instance->AR, addr_reg);
2401100a:	687b      	ldr	r3, [r7, #4]
2401100c:	681b      	ldr	r3, [r3, #0]
2401100e:	693a      	ldr	r2, [r7, #16]
24011010:	619a      	str	r2, [r3, #24]

        /* Enable the MDMA */
        if (HAL_MDMA_Start_IT(hqspi->hmdma, (uint32_t)&hqspi->Instance->DR, (uint32_t)pData, hqspi->RxXferSize, 1) == HAL_OK)
24011012:	687b      	ldr	r3, [r7, #4]
24011014:	6bd8      	ldr	r0, [r3, #60]	; 0x3c
24011016:	687b      	ldr	r3, [r7, #4]
24011018:	681b      	ldr	r3, [r3, #0]
2401101a:	3320      	adds	r3, #32
2401101c:	461c      	mov	r4, r3
2401101e:	683a      	ldr	r2, [r7, #0]
24011020:	687b      	ldr	r3, [r7, #4]
24011022:	6b59      	ldr	r1, [r3, #52]	; 0x34
24011024:	2301      	movs	r3, #1
24011026:	9300      	str	r3, [sp, #0]
24011028:	460b      	mov	r3, r1
2401102a:	4621      	mov	r1, r4
2401102c:	f7fd fddf 	bl	2400ebee <HAL_MDMA_Start_IT>
24011030:	4603      	mov	r3, r0
24011032:	2b00      	cmp	r3, #0
24011034:	d114      	bne.n	24011060 <HAL_QSPI_Receive_DMA+0x18c>
        {
          /* Process unlocked */
          __HAL_UNLOCK(hqspi);
24011036:	687b      	ldr	r3, [r7, #4]
24011038:	2200      	movs	r2, #0
2401103a:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

          /* Enable the QSPI transfer error Interrupt */
          __HAL_QSPI_ENABLE_IT(hqspi, QSPI_IT_TE);
2401103e:	687b      	ldr	r3, [r7, #4]
24011040:	681b      	ldr	r3, [r3, #0]
24011042:	681a      	ldr	r2, [r3, #0]
24011044:	687b      	ldr	r3, [r7, #4]
24011046:	681b      	ldr	r3, [r3, #0]
24011048:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
2401104c:	601a      	str	r2, [r3, #0]

          /* Enable the MDMA transfer by setting the DMAEN bit in the QSPI CR register */
          SET_BIT(hqspi->Instance->CR, QUADSPI_CR_DMAEN);
2401104e:	687b      	ldr	r3, [r7, #4]
24011050:	681b      	ldr	r3, [r3, #0]
24011052:	681a      	ldr	r2, [r3, #0]
24011054:	687b      	ldr	r3, [r7, #4]
24011056:	681b      	ldr	r3, [r3, #0]
24011058:	f042 0204 	orr.w	r2, r2, #4
2401105c:	601a      	str	r2, [r3, #0]
2401105e:	e023      	b.n	240110a8 <HAL_QSPI_Receive_DMA+0x1d4>
        }
        else
        {
          status = HAL_ERROR;
24011060:	2301      	movs	r3, #1
24011062:	75fb      	strb	r3, [r7, #23]
          hqspi->ErrorCode |= HAL_QSPI_ERROR_DMA;
24011064:	687b      	ldr	r3, [r7, #4]
24011066:	6c5b      	ldr	r3, [r3, #68]	; 0x44
24011068:	f043 0204 	orr.w	r2, r3, #4
2401106c:	687b      	ldr	r3, [r7, #4]
2401106e:	645a      	str	r2, [r3, #68]	; 0x44
          hqspi->State = HAL_QSPI_STATE_READY;
24011070:	687b      	ldr	r3, [r7, #4]
24011072:	2201      	movs	r2, #1
24011074:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

          /* Process unlocked */
          __HAL_UNLOCK(hqspi);
24011078:	687b      	ldr	r3, [r7, #4]
2401107a:	2200      	movs	r2, #0
2401107c:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
24011080:	e012      	b.n	240110a8 <HAL_QSPI_Receive_DMA+0x1d4>
        }
    }
    else
    {
      hqspi->ErrorCode |= HAL_QSPI_ERROR_INVALID_PARAM;
24011082:	687b      	ldr	r3, [r7, #4]
24011084:	6c5b      	ldr	r3, [r3, #68]	; 0x44
24011086:	f043 0208 	orr.w	r2, r3, #8
2401108a:	687b      	ldr	r3, [r7, #4]
2401108c:	645a      	str	r2, [r3, #68]	; 0x44
      status = HAL_ERROR;
2401108e:	2301      	movs	r3, #1
24011090:	75fb      	strb	r3, [r7, #23]

      /* Process unlocked */
      __HAL_UNLOCK(hqspi);
24011092:	687b      	ldr	r3, [r7, #4]
24011094:	2200      	movs	r2, #0
24011096:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
2401109a:	e005      	b.n	240110a8 <HAL_QSPI_Receive_DMA+0x1d4>
    }
  }
  else
  {
    status = HAL_BUSY;
2401109c:	2302      	movs	r3, #2
2401109e:	75fb      	strb	r3, [r7, #23]

    /* Process unlocked */
    __HAL_UNLOCK(hqspi);
240110a0:	687b      	ldr	r3, [r7, #4]
240110a2:	2200      	movs	r2, #0
240110a4:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
  }

  return status;
240110a8:	7dfb      	ldrb	r3, [r7, #23]
}
240110aa:	4618      	mov	r0, r3
240110ac:	371c      	adds	r7, #28
240110ae:	46bd      	mov	sp, r7
240110b0:	bd90      	pop	{r4, r7, pc}
240110b2:	bf00      	nop
240110b4:	240116e1 	.word	0x240116e1
240110b8:	24011741 	.word	0x24011741
240110bc:	fffffcfc 	.word	0xfffffcfc
240110c0:	fffff3f3 	.word	0xfffff3f3

240110c4 <HAL_QSPI_AutoPolling>:
  * @param  Timeout : Timeout duration
  * @note   This function is used only in Automatic Polling Mode
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_QSPI_AutoPolling(QSPI_HandleTypeDef *hqspi, QSPI_CommandTypeDef *cmd, QSPI_AutoPollingTypeDef *cfg, uint32_t Timeout)
{
240110c4:	b580      	push	{r7, lr}
240110c6:	b088      	sub	sp, #32
240110c8:	af02      	add	r7, sp, #8
240110ca:	60f8      	str	r0, [r7, #12]
240110cc:	60b9      	str	r1, [r7, #8]
240110ce:	607a      	str	r2, [r7, #4]
240110d0:	603b      	str	r3, [r7, #0]
  HAL_StatusTypeDef status;
  uint32_t tickstart = HAL_GetTick();
240110d2:	f7ef fbbf 	bl	24000854 <HAL_GetTick>
240110d6:	6138      	str	r0, [r7, #16]
  assert_param(IS_QSPI_INTERVAL(cfg->Interval));
  assert_param(IS_QSPI_STATUS_BYTES_SIZE(cfg->StatusBytesSize));
  assert_param(IS_QSPI_MATCH_MODE(cfg->MatchMode));

  /* Process locked */
  __HAL_LOCK(hqspi);
240110d8:	68fb      	ldr	r3, [r7, #12]
240110da:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
240110de:	b2db      	uxtb	r3, r3
240110e0:	2b01      	cmp	r3, #1
240110e2:	d101      	bne.n	240110e8 <HAL_QSPI_AutoPolling+0x24>
240110e4:	2302      	movs	r3, #2
240110e6:	e060      	b.n	240111aa <HAL_QSPI_AutoPolling+0xe6>
240110e8:	68fb      	ldr	r3, [r7, #12]
240110ea:	2201      	movs	r2, #1
240110ec:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  if(hqspi->State == HAL_QSPI_STATE_READY)
240110f0:	68fb      	ldr	r3, [r7, #12]
240110f2:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
240110f6:	b2db      	uxtb	r3, r3
240110f8:	2b01      	cmp	r3, #1
240110fa:	d14f      	bne.n	2401119c <HAL_QSPI_AutoPolling+0xd8>
  {
    hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
240110fc:	68fb      	ldr	r3, [r7, #12]
240110fe:	2200      	movs	r2, #0
24011100:	645a      	str	r2, [r3, #68]	; 0x44

    /* Update state */
    hqspi->State = HAL_QSPI_STATE_BUSY_AUTO_POLLING;
24011102:	68fb      	ldr	r3, [r7, #12]
24011104:	2242      	movs	r2, #66	; 0x42
24011106:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

    /* Wait till BUSY flag reset */
    status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_BUSY, RESET, tickstart, Timeout);
2401110a:	683b      	ldr	r3, [r7, #0]
2401110c:	9300      	str	r3, [sp, #0]
2401110e:	693b      	ldr	r3, [r7, #16]
24011110:	2200      	movs	r2, #0
24011112:	2120      	movs	r1, #32
24011114:	68f8      	ldr	r0, [r7, #12]
24011116:	f000 fb68 	bl	240117ea <QSPI_WaitFlagStateUntilTimeout>
2401111a:	4603      	mov	r3, r0
2401111c:	75fb      	strb	r3, [r7, #23]

    if (status == HAL_OK)
2401111e:	7dfb      	ldrb	r3, [r7, #23]
24011120:	2b00      	cmp	r3, #0
24011122:	d13d      	bne.n	240111a0 <HAL_QSPI_AutoPolling+0xdc>
    {
      /* Configure QSPI: PSMAR register with the status match value */
      WRITE_REG(hqspi->Instance->PSMAR, cfg->Match);
24011124:	68fb      	ldr	r3, [r7, #12]
24011126:	681b      	ldr	r3, [r3, #0]
24011128:	687a      	ldr	r2, [r7, #4]
2401112a:	6812      	ldr	r2, [r2, #0]
2401112c:	629a      	str	r2, [r3, #40]	; 0x28

      /* Configure QSPI: PSMKR register with the status mask value */
      WRITE_REG(hqspi->Instance->PSMKR, cfg->Mask);
2401112e:	68fb      	ldr	r3, [r7, #12]
24011130:	681b      	ldr	r3, [r3, #0]
24011132:	687a      	ldr	r2, [r7, #4]
24011134:	6852      	ldr	r2, [r2, #4]
24011136:	625a      	str	r2, [r3, #36]	; 0x24

      /* Configure QSPI: PIR register with the interval value */
      WRITE_REG(hqspi->Instance->PIR, cfg->Interval);
24011138:	68fb      	ldr	r3, [r7, #12]
2401113a:	681b      	ldr	r3, [r3, #0]
2401113c:	687a      	ldr	r2, [r7, #4]
2401113e:	6892      	ldr	r2, [r2, #8]
24011140:	62da      	str	r2, [r3, #44]	; 0x2c

      /* Configure QSPI: CR register with Match mode and Automatic stop enabled
      (otherwise there will be an infinite loop in blocking mode) */
      MODIFY_REG(hqspi->Instance->CR, (QUADSPI_CR_PMM | QUADSPI_CR_APMS),
24011142:	68fb      	ldr	r3, [r7, #12]
24011144:	681b      	ldr	r3, [r3, #0]
24011146:	681b      	ldr	r3, [r3, #0]
24011148:	f423 0240 	bic.w	r2, r3, #12582912	; 0xc00000
2401114c:	687b      	ldr	r3, [r7, #4]
2401114e:	691b      	ldr	r3, [r3, #16]
24011150:	431a      	orrs	r2, r3
24011152:	68fb      	ldr	r3, [r7, #12]
24011154:	681b      	ldr	r3, [r3, #0]
24011156:	f442 0280 	orr.w	r2, r2, #4194304	; 0x400000
2401115a:	601a      	str	r2, [r3, #0]
               (cfg->MatchMode | QSPI_AUTOMATIC_STOP_ENABLE));

      /* Call the configuration function */
      cmd->NbData = cfg->StatusBytesSize;
2401115c:	687b      	ldr	r3, [r7, #4]
2401115e:	68da      	ldr	r2, [r3, #12]
24011160:	68bb      	ldr	r3, [r7, #8]
24011162:	629a      	str	r2, [r3, #40]	; 0x28
      QSPI_Config(hqspi, cmd, QSPI_FUNCTIONAL_MODE_AUTO_POLLING);
24011164:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
24011168:	68b9      	ldr	r1, [r7, #8]
2401116a:	68f8      	ldr	r0, [r7, #12]
2401116c:	f000 fb74 	bl	24011858 <QSPI_Config>

      /* Wait until SM flag is set to go back in idle state */
      status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_SM, SET, tickstart, Timeout);
24011170:	683b      	ldr	r3, [r7, #0]
24011172:	9300      	str	r3, [sp, #0]
24011174:	693b      	ldr	r3, [r7, #16]
24011176:	2201      	movs	r2, #1
24011178:	2108      	movs	r1, #8
2401117a:	68f8      	ldr	r0, [r7, #12]
2401117c:	f000 fb35 	bl	240117ea <QSPI_WaitFlagStateUntilTimeout>
24011180:	4603      	mov	r3, r0
24011182:	75fb      	strb	r3, [r7, #23]

      if (status == HAL_OK)
24011184:	7dfb      	ldrb	r3, [r7, #23]
24011186:	2b00      	cmp	r3, #0
24011188:	d10a      	bne.n	240111a0 <HAL_QSPI_AutoPolling+0xdc>
      {
        __HAL_QSPI_CLEAR_FLAG(hqspi, QSPI_FLAG_SM);
2401118a:	68fb      	ldr	r3, [r7, #12]
2401118c:	681b      	ldr	r3, [r3, #0]
2401118e:	2208      	movs	r2, #8
24011190:	60da      	str	r2, [r3, #12]

        /* Update state */
        hqspi->State = HAL_QSPI_STATE_READY;
24011192:	68fb      	ldr	r3, [r7, #12]
24011194:	2201      	movs	r2, #1
24011196:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
2401119a:	e001      	b.n	240111a0 <HAL_QSPI_AutoPolling+0xdc>
      }
    }
  }
  else
  {
    status = HAL_BUSY;
2401119c:	2302      	movs	r3, #2
2401119e:	75fb      	strb	r3, [r7, #23]
  }

  /* Process unlocked */
  __HAL_UNLOCK(hqspi);
240111a0:	68fb      	ldr	r3, [r7, #12]
240111a2:	2200      	movs	r2, #0
240111a4:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  /* Return function status */
  return status;
240111a8:	7dfb      	ldrb	r3, [r7, #23]
}
240111aa:	4618      	mov	r0, r3
240111ac:	3718      	adds	r7, #24
240111ae:	46bd      	mov	sp, r7
240111b0:	bd80      	pop	{r7, pc}

240111b2 <HAL_QSPI_AutoPolling_IT>:
  * @param  cfg : structure that contains the polling configuration information.
  * @note   This function is used only in Automatic Polling Mode
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_QSPI_AutoPolling_IT(QSPI_HandleTypeDef *hqspi, QSPI_CommandTypeDef *cmd, QSPI_AutoPollingTypeDef *cfg)
{
240111b2:	b580      	push	{r7, lr}
240111b4:	b088      	sub	sp, #32
240111b6:	af02      	add	r7, sp, #8
240111b8:	60f8      	str	r0, [r7, #12]
240111ba:	60b9      	str	r1, [r7, #8]
240111bc:	607a      	str	r2, [r7, #4]
  HAL_StatusTypeDef status;
  uint32_t tickstart = HAL_GetTick();
240111be:	f7ef fb49 	bl	24000854 <HAL_GetTick>
240111c2:	6138      	str	r0, [r7, #16]
  assert_param(IS_QSPI_STATUS_BYTES_SIZE(cfg->StatusBytesSize));
  assert_param(IS_QSPI_MATCH_MODE(cfg->MatchMode));
  assert_param(IS_QSPI_AUTOMATIC_STOP(cfg->AutomaticStop));

  /* Process locked */
  __HAL_LOCK(hqspi);
240111c4:	68fb      	ldr	r3, [r7, #12]
240111c6:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
240111ca:	b2db      	uxtb	r3, r3
240111cc:	2b01      	cmp	r3, #1
240111ce:	d101      	bne.n	240111d4 <HAL_QSPI_AutoPolling_IT+0x22>
240111d0:	2302      	movs	r3, #2
240111d2:	e062      	b.n	2401129a <HAL_QSPI_AutoPolling_IT+0xe8>
240111d4:	68fb      	ldr	r3, [r7, #12]
240111d6:	2201      	movs	r2, #1
240111d8:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  if(hqspi->State == HAL_QSPI_STATE_READY)
240111dc:	68fb      	ldr	r3, [r7, #12]
240111de:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
240111e2:	b2db      	uxtb	r3, r3
240111e4:	2b01      	cmp	r3, #1
240111e6:	d151      	bne.n	2401128c <HAL_QSPI_AutoPolling_IT+0xda>
  {
    hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
240111e8:	68fb      	ldr	r3, [r7, #12]
240111ea:	2200      	movs	r2, #0
240111ec:	645a      	str	r2, [r3, #68]	; 0x44

    /* Update state */
    hqspi->State = HAL_QSPI_STATE_BUSY_AUTO_POLLING;
240111ee:	68fb      	ldr	r3, [r7, #12]
240111f0:	2242      	movs	r2, #66	; 0x42
240111f2:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

    /* Wait till BUSY flag reset */
    status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_BUSY, RESET, tickstart, hqspi->Timeout);
240111f6:	68fb      	ldr	r3, [r7, #12]
240111f8:	6c9b      	ldr	r3, [r3, #72]	; 0x48
240111fa:	9300      	str	r3, [sp, #0]
240111fc:	693b      	ldr	r3, [r7, #16]
240111fe:	2200      	movs	r2, #0
24011200:	2120      	movs	r1, #32
24011202:	68f8      	ldr	r0, [r7, #12]
24011204:	f000 faf1 	bl	240117ea <QSPI_WaitFlagStateUntilTimeout>
24011208:	4603      	mov	r3, r0
2401120a:	75fb      	strb	r3, [r7, #23]

    if (status == HAL_OK)
2401120c:	7dfb      	ldrb	r3, [r7, #23]
2401120e:	2b00      	cmp	r3, #0
24011210:	d137      	bne.n	24011282 <HAL_QSPI_AutoPolling_IT+0xd0>
    {
      /* Configure QSPI: PSMAR register with the status match value */
      WRITE_REG(hqspi->Instance->PSMAR, cfg->Match);
24011212:	68fb      	ldr	r3, [r7, #12]
24011214:	681b      	ldr	r3, [r3, #0]
24011216:	687a      	ldr	r2, [r7, #4]
24011218:	6812      	ldr	r2, [r2, #0]
2401121a:	629a      	str	r2, [r3, #40]	; 0x28

      /* Configure QSPI: PSMKR register with the status mask value */
      WRITE_REG(hqspi->Instance->PSMKR, cfg->Mask);
2401121c:	68fb      	ldr	r3, [r7, #12]
2401121e:	681b      	ldr	r3, [r3, #0]
24011220:	687a      	ldr	r2, [r7, #4]
24011222:	6852      	ldr	r2, [r2, #4]
24011224:	625a      	str	r2, [r3, #36]	; 0x24

      /* Configure QSPI: PIR register with the interval value */
      WRITE_REG(hqspi->Instance->PIR, cfg->Interval);
24011226:	68fb      	ldr	r3, [r7, #12]
24011228:	681b      	ldr	r3, [r3, #0]
2401122a:	687a      	ldr	r2, [r7, #4]
2401122c:	6892      	ldr	r2, [r2, #8]
2401122e:	62da      	str	r2, [r3, #44]	; 0x2c

      /* Configure QSPI: CR register with Match mode and Automatic stop mode */
      MODIFY_REG(hqspi->Instance->CR, (QUADSPI_CR_PMM | QUADSPI_CR_APMS),
24011230:	68fb      	ldr	r3, [r7, #12]
24011232:	681b      	ldr	r3, [r3, #0]
24011234:	681b      	ldr	r3, [r3, #0]
24011236:	f423 0140 	bic.w	r1, r3, #12582912	; 0xc00000
2401123a:	687b      	ldr	r3, [r7, #4]
2401123c:	691a      	ldr	r2, [r3, #16]
2401123e:	687b      	ldr	r3, [r7, #4]
24011240:	695b      	ldr	r3, [r3, #20]
24011242:	431a      	orrs	r2, r3
24011244:	68fb      	ldr	r3, [r7, #12]
24011246:	681b      	ldr	r3, [r3, #0]
24011248:	430a      	orrs	r2, r1
2401124a:	601a      	str	r2, [r3, #0]
               (cfg->MatchMode | cfg->AutomaticStop));

      /* Clear interrupt */
      __HAL_QSPI_CLEAR_FLAG(hqspi, QSPI_FLAG_TE | QSPI_FLAG_SM);
2401124c:	68fb      	ldr	r3, [r7, #12]
2401124e:	681b      	ldr	r3, [r3, #0]
24011250:	2209      	movs	r2, #9
24011252:	60da      	str	r2, [r3, #12]

      /* Call the configuration function */
      cmd->NbData = cfg->StatusBytesSize;
24011254:	687b      	ldr	r3, [r7, #4]
24011256:	68da      	ldr	r2, [r3, #12]
24011258:	68bb      	ldr	r3, [r7, #8]
2401125a:	629a      	str	r2, [r3, #40]	; 0x28
      QSPI_Config(hqspi, cmd, QSPI_FUNCTIONAL_MODE_AUTO_POLLING);
2401125c:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
24011260:	68b9      	ldr	r1, [r7, #8]
24011262:	68f8      	ldr	r0, [r7, #12]
24011264:	f000 faf8 	bl	24011858 <QSPI_Config>

      /* Process unlocked */
      __HAL_UNLOCK(hqspi);
24011268:	68fb      	ldr	r3, [r7, #12]
2401126a:	2200      	movs	r2, #0
2401126c:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

      /* Enable the QSPI Transfer Error and status match Interrupt */
      __HAL_QSPI_ENABLE_IT(hqspi, (QSPI_IT_SM | QSPI_IT_TE));
24011270:	68fb      	ldr	r3, [r7, #12]
24011272:	681b      	ldr	r3, [r3, #0]
24011274:	681a      	ldr	r2, [r3, #0]
24011276:	68fb      	ldr	r3, [r7, #12]
24011278:	681b      	ldr	r3, [r3, #0]
2401127a:	f442 2210 	orr.w	r2, r2, #589824	; 0x90000
2401127e:	601a      	str	r2, [r3, #0]
24011280:	e00a      	b.n	24011298 <HAL_QSPI_AutoPolling_IT+0xe6>

    }
    else
    {
      /* Process unlocked */
      __HAL_UNLOCK(hqspi);
24011282:	68fb      	ldr	r3, [r7, #12]
24011284:	2200      	movs	r2, #0
24011286:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
2401128a:	e005      	b.n	24011298 <HAL_QSPI_AutoPolling_IT+0xe6>
    }
  }
  else
  {
    status = HAL_BUSY;
2401128c:	2302      	movs	r3, #2
2401128e:	75fb      	strb	r3, [r7, #23]

    /* Process unlocked */
    __HAL_UNLOCK(hqspi);
24011290:	68fb      	ldr	r3, [r7, #12]
24011292:	2200      	movs	r2, #0
24011294:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
  }

  /* Return function status */
  return status;
24011298:	7dfb      	ldrb	r3, [r7, #23]
}
2401129a:	4618      	mov	r0, r3
2401129c:	3718      	adds	r7, #24
2401129e:	46bd      	mov	sp, r7
240112a0:	bd80      	pop	{r7, pc}

240112a2 <HAL_QSPI_MemoryMapped>:
  * @param  cfg : structure that contains the memory mapped configuration information.
  * @note   This function is used only in Memory mapped Mode
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_QSPI_MemoryMapped(QSPI_HandleTypeDef *hqspi, QSPI_CommandTypeDef *cmd, QSPI_MemoryMappedTypeDef *cfg)
{
240112a2:	b580      	push	{r7, lr}
240112a4:	b088      	sub	sp, #32
240112a6:	af02      	add	r7, sp, #8
240112a8:	60f8      	str	r0, [r7, #12]
240112aa:	60b9      	str	r1, [r7, #8]
240112ac:	607a      	str	r2, [r7, #4]
  HAL_StatusTypeDef status;
  uint32_t tickstart = HAL_GetTick();
240112ae:	f7ef fad1 	bl	24000854 <HAL_GetTick>
240112b2:	6138      	str	r0, [r7, #16]
  assert_param(IS_QSPI_SIOO_MODE(cmd->SIOOMode));

  assert_param(IS_QSPI_TIMEOUT_ACTIVATION(cfg->TimeOutActivation));

  /* Process locked */
  __HAL_LOCK(hqspi);
240112b4:	68fb      	ldr	r3, [r7, #12]
240112b6:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
240112ba:	b2db      	uxtb	r3, r3
240112bc:	2b01      	cmp	r3, #1
240112be:	d101      	bne.n	240112c4 <HAL_QSPI_MemoryMapped+0x22>
240112c0:	2302      	movs	r3, #2
240112c2:	e04c      	b.n	2401135e <HAL_QSPI_MemoryMapped+0xbc>
240112c4:	68fb      	ldr	r3, [r7, #12]
240112c6:	2201      	movs	r2, #1
240112c8:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  if(hqspi->State == HAL_QSPI_STATE_READY)
240112cc:	68fb      	ldr	r3, [r7, #12]
240112ce:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
240112d2:	b2db      	uxtb	r3, r3
240112d4:	2b01      	cmp	r3, #1
240112d6:	d13b      	bne.n	24011350 <HAL_QSPI_MemoryMapped+0xae>
  {
    hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
240112d8:	68fb      	ldr	r3, [r7, #12]
240112da:	2200      	movs	r2, #0
240112dc:	645a      	str	r2, [r3, #68]	; 0x44

    /* Update state */
    hqspi->State = HAL_QSPI_STATE_BUSY_MEM_MAPPED;
240112de:	68fb      	ldr	r3, [r7, #12]
240112e0:	2282      	movs	r2, #130	; 0x82
240112e2:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

    /* Wait till BUSY flag reset */
    status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_BUSY, RESET, tickstart, hqspi->Timeout);
240112e6:	68fb      	ldr	r3, [r7, #12]
240112e8:	6c9b      	ldr	r3, [r3, #72]	; 0x48
240112ea:	9300      	str	r3, [sp, #0]
240112ec:	693b      	ldr	r3, [r7, #16]
240112ee:	2200      	movs	r2, #0
240112f0:	2120      	movs	r1, #32
240112f2:	68f8      	ldr	r0, [r7, #12]
240112f4:	f000 fa79 	bl	240117ea <QSPI_WaitFlagStateUntilTimeout>
240112f8:	4603      	mov	r3, r0
240112fa:	75fb      	strb	r3, [r7, #23]

    if (status == HAL_OK)
240112fc:	7dfb      	ldrb	r3, [r7, #23]
240112fe:	2b00      	cmp	r3, #0
24011300:	d128      	bne.n	24011354 <HAL_QSPI_MemoryMapped+0xb2>
    {
      /* Configure QSPI: CR register with timeout counter enable */
    MODIFY_REG(hqspi->Instance->CR, QUADSPI_CR_TCEN, cfg->TimeOutActivation);
24011302:	68fb      	ldr	r3, [r7, #12]
24011304:	681b      	ldr	r3, [r3, #0]
24011306:	681b      	ldr	r3, [r3, #0]
24011308:	f023 0108 	bic.w	r1, r3, #8
2401130c:	687b      	ldr	r3, [r7, #4]
2401130e:	685a      	ldr	r2, [r3, #4]
24011310:	68fb      	ldr	r3, [r7, #12]
24011312:	681b      	ldr	r3, [r3, #0]
24011314:	430a      	orrs	r2, r1
24011316:	601a      	str	r2, [r3, #0]

    if (cfg->TimeOutActivation == QSPI_TIMEOUT_COUNTER_ENABLE)
24011318:	687b      	ldr	r3, [r7, #4]
2401131a:	685b      	ldr	r3, [r3, #4]
2401131c:	2b08      	cmp	r3, #8
2401131e:	d110      	bne.n	24011342 <HAL_QSPI_MemoryMapped+0xa0>
      {
        assert_param(IS_QSPI_TIMEOUT_PERIOD(cfg->TimeOutPeriod));

        /* Configure QSPI: LPTR register with the low-power timeout value */
        WRITE_REG(hqspi->Instance->LPTR, cfg->TimeOutPeriod);
24011320:	68fb      	ldr	r3, [r7, #12]
24011322:	681b      	ldr	r3, [r3, #0]
24011324:	687a      	ldr	r2, [r7, #4]
24011326:	6812      	ldr	r2, [r2, #0]
24011328:	631a      	str	r2, [r3, #48]	; 0x30

        /* Clear interrupt */
        __HAL_QSPI_CLEAR_FLAG(hqspi, QSPI_FLAG_TO);
2401132a:	68fb      	ldr	r3, [r7, #12]
2401132c:	681b      	ldr	r3, [r3, #0]
2401132e:	2210      	movs	r2, #16
24011330:	60da      	str	r2, [r3, #12]

        /* Enable the QSPI TimeOut Interrupt */
        __HAL_QSPI_ENABLE_IT(hqspi, QSPI_IT_TO);
24011332:	68fb      	ldr	r3, [r7, #12]
24011334:	681b      	ldr	r3, [r3, #0]
24011336:	681a      	ldr	r2, [r3, #0]
24011338:	68fb      	ldr	r3, [r7, #12]
2401133a:	681b      	ldr	r3, [r3, #0]
2401133c:	f442 1280 	orr.w	r2, r2, #1048576	; 0x100000
24011340:	601a      	str	r2, [r3, #0]
      }

      /* Call the configuration function */
      QSPI_Config(hqspi, cmd, QSPI_FUNCTIONAL_MODE_MEMORY_MAPPED);
24011342:	f04f 6240 	mov.w	r2, #201326592	; 0xc000000
24011346:	68b9      	ldr	r1, [r7, #8]
24011348:	68f8      	ldr	r0, [r7, #12]
2401134a:	f000 fa85 	bl	24011858 <QSPI_Config>
2401134e:	e001      	b.n	24011354 <HAL_QSPI_MemoryMapped+0xb2>
    }
  }
  else
  {
    status = HAL_BUSY;
24011350:	2302      	movs	r3, #2
24011352:	75fb      	strb	r3, [r7, #23]
  }

  /* Process unlocked */
  __HAL_UNLOCK(hqspi);
24011354:	68fb      	ldr	r3, [r7, #12]
24011356:	2200      	movs	r2, #0
24011358:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  /* Return function status */
  return status;
2401135c:	7dfb      	ldrb	r3, [r7, #23]
}
2401135e:	4618      	mov	r0, r3
24011360:	3718      	adds	r7, #24
24011362:	46bd      	mov	sp, r7
24011364:	bd80      	pop	{r7, pc}

24011366 <HAL_QSPI_ErrorCallback>:
  * @brief  Transfer Error callback.
  * @param  hqspi : QSPI handle
  * @retval None
  */
__weak void HAL_QSPI_ErrorCallback(QSPI_HandleTypeDef *hqspi)
{
24011366:	b480      	push	{r7}
24011368:	b083      	sub	sp, #12
2401136a:	af00      	add	r7, sp, #0
2401136c:	6078      	str	r0, [r7, #4]
  UNUSED(hqspi);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_QSPI_ErrorCallback could be implemented in the user file
   */
}
2401136e:	bf00      	nop
24011370:	370c      	adds	r7, #12
24011372:	46bd      	mov	sp, r7
24011374:	f85d 7b04 	ldr.w	r7, [sp], #4
24011378:	4770      	bx	lr

2401137a <HAL_QSPI_AbortCpltCallback>:
  * @brief  Abort completed callback.
  * @param  hqspi : QSPI handle
  * @retval None
  */
__weak void HAL_QSPI_AbortCpltCallback(QSPI_HandleTypeDef *hqspi)
{
2401137a:	b480      	push	{r7}
2401137c:	b083      	sub	sp, #12
2401137e:	af00      	add	r7, sp, #0
24011380:	6078      	str	r0, [r7, #4]
  UNUSED(hqspi);

  /* NOTE: This function should not be modified, when the callback is needed,
           the HAL_QSPI_AbortCpltCallback could be implemented in the user file
   */
}
24011382:	bf00      	nop
24011384:	370c      	adds	r7, #12
24011386:	46bd      	mov	sp, r7
24011388:	f85d 7b04 	ldr.w	r7, [sp], #4
2401138c:	4770      	bx	lr

2401138e <HAL_QSPI_CmdCpltCallback>:
  * @brief  Command completed callback.
  * @param  hqspi : QSPI handle
  * @retval None
  */
__weak void HAL_QSPI_CmdCpltCallback(QSPI_HandleTypeDef *hqspi)
{
2401138e:	b480      	push	{r7}
24011390:	b083      	sub	sp, #12
24011392:	af00      	add	r7, sp, #0
24011394:	6078      	str	r0, [r7, #4]
  UNUSED(hqspi);

  /* NOTE: This function should not be modified, when the callback is needed,
           the HAL_QSPI_CmdCpltCallback could be implemented in the user file
   */
}
24011396:	bf00      	nop
24011398:	370c      	adds	r7, #12
2401139a:	46bd      	mov	sp, r7
2401139c:	f85d 7b04 	ldr.w	r7, [sp], #4
240113a0:	4770      	bx	lr

240113a2 <HAL_QSPI_RxCpltCallback>:
  * @brief  Rx Transfer completed callback.
  * @param  hqspi : QSPI handle
  * @retval None
  */
__weak void HAL_QSPI_RxCpltCallback(QSPI_HandleTypeDef *hqspi)
{
240113a2:	b480      	push	{r7}
240113a4:	b083      	sub	sp, #12
240113a6:	af00      	add	r7, sp, #0
240113a8:	6078      	str	r0, [r7, #4]
  UNUSED(hqspi);

  /* NOTE: This function should not be modified, when the callback is needed,
           the HAL_QSPI_RxCpltCallback could be implemented in the user file
   */
}
240113aa:	bf00      	nop
240113ac:	370c      	adds	r7, #12
240113ae:	46bd      	mov	sp, r7
240113b0:	f85d 7b04 	ldr.w	r7, [sp], #4
240113b4:	4770      	bx	lr

240113b6 <HAL_QSPI_TxCpltCallback>:
  * @brief  Tx Transfer completed callback.
  * @param  hqspi : QSPI handle
  * @retval None
  */
__weak void HAL_QSPI_TxCpltCallback(QSPI_HandleTypeDef *hqspi)
{
240113b6:	b480      	push	{r7}
240113b8:	b083      	sub	sp, #12
240113ba:	af00      	add	r7, sp, #0
240113bc:	6078      	str	r0, [r7, #4]
  UNUSED(hqspi);

  /* NOTE: This function should not be modified, when the callback is needed,
           the HAL_QSPI_TxCpltCallback could be implemented in the user file
   */
}
240113be:	bf00      	nop
240113c0:	370c      	adds	r7, #12
240113c2:	46bd      	mov	sp, r7
240113c4:	f85d 7b04 	ldr.w	r7, [sp], #4
240113c8:	4770      	bx	lr

240113ca <HAL_QSPI_FifoThresholdCallback>:
  * @brief  FIFO Threshold callback.
  * @param  hqspi : QSPI handle
  * @retval None
  */
__weak void HAL_QSPI_FifoThresholdCallback(QSPI_HandleTypeDef *hqspi)
{
240113ca:	b480      	push	{r7}
240113cc:	b083      	sub	sp, #12
240113ce:	af00      	add	r7, sp, #0
240113d0:	6078      	str	r0, [r7, #4]
  UNUSED(hqspi);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_QSPI_FIFOThresholdCallback could be implemented in the user file
   */
}
240113d2:	bf00      	nop
240113d4:	370c      	adds	r7, #12
240113d6:	46bd      	mov	sp, r7
240113d8:	f85d 7b04 	ldr.w	r7, [sp], #4
240113dc:	4770      	bx	lr

240113de <HAL_QSPI_StatusMatchCallback>:
  * @brief  Status Match callback.
  * @param  hqspi : QSPI handle
  * @retval None
  */
__weak void HAL_QSPI_StatusMatchCallback(QSPI_HandleTypeDef *hqspi)
{
240113de:	b480      	push	{r7}
240113e0:	b083      	sub	sp, #12
240113e2:	af00      	add	r7, sp, #0
240113e4:	6078      	str	r0, [r7, #4]
  UNUSED(hqspi);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_QSPI_StatusMatchCallback could be implemented in the user file
   */
}
240113e6:	bf00      	nop
240113e8:	370c      	adds	r7, #12
240113ea:	46bd      	mov	sp, r7
240113ec:	f85d 7b04 	ldr.w	r7, [sp], #4
240113f0:	4770      	bx	lr

240113f2 <HAL_QSPI_TimeOutCallback>:
  * @brief  Timeout callback.
  * @param  hqspi : QSPI handle
  * @retval None
  */
__weak void HAL_QSPI_TimeOutCallback(QSPI_HandleTypeDef *hqspi)
{
240113f2:	b480      	push	{r7}
240113f4:	b083      	sub	sp, #12
240113f6:	af00      	add	r7, sp, #0
240113f8:	6078      	str	r0, [r7, #4]
  UNUSED(hqspi);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_QSPI_TimeOutCallback could be implemented in the user file
   */
}
240113fa:	bf00      	nop
240113fc:	370c      	adds	r7, #12
240113fe:	46bd      	mov	sp, r7
24011400:	f85d 7b04 	ldr.w	r7, [sp], #4
24011404:	4770      	bx	lr

24011406 <HAL_QSPI_GetState>:
  * @brief  Return the QSPI handle state.
  * @param  hqspi : QSPI handle
  * @retval HAL state
  */
HAL_QSPI_StateTypeDef HAL_QSPI_GetState(QSPI_HandleTypeDef *hqspi)
{
24011406:	b480      	push	{r7}
24011408:	b083      	sub	sp, #12
2401140a:	af00      	add	r7, sp, #0
2401140c:	6078      	str	r0, [r7, #4]
  /* Return QSPI handle state */
  return hqspi->State;
2401140e:	687b      	ldr	r3, [r7, #4]
24011410:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
24011414:	b2db      	uxtb	r3, r3
}
24011416:	4618      	mov	r0, r3
24011418:	370c      	adds	r7, #12
2401141a:	46bd      	mov	sp, r7
2401141c:	f85d 7b04 	ldr.w	r7, [sp], #4
24011420:	4770      	bx	lr

24011422 <HAL_QSPI_GetError>:
* @brief  Return the QSPI error code.
* @param  hqspi : QSPI handle
* @retval QSPI Error Code
*/
uint32_t HAL_QSPI_GetError(QSPI_HandleTypeDef *hqspi)
{
24011422:	b480      	push	{r7}
24011424:	b083      	sub	sp, #12
24011426:	af00      	add	r7, sp, #0
24011428:	6078      	str	r0, [r7, #4]
  return hqspi->ErrorCode;
2401142a:	687b      	ldr	r3, [r7, #4]
2401142c:	6c5b      	ldr	r3, [r3, #68]	; 0x44
}
2401142e:	4618      	mov	r0, r3
24011430:	370c      	adds	r7, #12
24011432:	46bd      	mov	sp, r7
24011434:	f85d 7b04 	ldr.w	r7, [sp], #4
24011438:	4770      	bx	lr

2401143a <HAL_QSPI_Abort>:
* @brief  Abort the current transmission.
* @param  hqspi : QSPI handle
* @retval HAL status
*/
HAL_StatusTypeDef HAL_QSPI_Abort(QSPI_HandleTypeDef *hqspi)
{
2401143a:	b580      	push	{r7, lr}
2401143c:	b086      	sub	sp, #24
2401143e:	af02      	add	r7, sp, #8
24011440:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
24011442:	2300      	movs	r3, #0
24011444:	73fb      	strb	r3, [r7, #15]
  uint32_t tickstart = HAL_GetTick();
24011446:	f7ef fa05 	bl	24000854 <HAL_GetTick>
2401144a:	60b8      	str	r0, [r7, #8]

  /* Check if the state is in one of the busy states */
  if (((uint32_t)hqspi->State & 0x2U) != 0U)
2401144c:	687b      	ldr	r3, [r7, #4]
2401144e:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
24011452:	b2db      	uxtb	r3, r3
24011454:	f003 0302 	and.w	r3, r3, #2
24011458:	2b00      	cmp	r3, #0
2401145a:	d056      	beq.n	2401150a <HAL_QSPI_Abort+0xd0>
  {
    /* Process unlocked */
    __HAL_UNLOCK(hqspi);
2401145c:	687b      	ldr	r3, [r7, #4]
2401145e:	2200      	movs	r2, #0
24011460:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    if ((hqspi->Instance->CR & QUADSPI_CR_DMAEN) != 0U)
24011464:	687b      	ldr	r3, [r7, #4]
24011466:	681b      	ldr	r3, [r3, #0]
24011468:	681b      	ldr	r3, [r3, #0]
2401146a:	f003 0304 	and.w	r3, r3, #4
2401146e:	2b00      	cmp	r3, #0
24011470:	d017      	beq.n	240114a2 <HAL_QSPI_Abort+0x68>
    {
      /* Disable the DMA transfer by clearing the DMAEN bit in the QSPI CR register */
      CLEAR_BIT(hqspi->Instance->CR, QUADSPI_CR_DMAEN);
24011472:	687b      	ldr	r3, [r7, #4]
24011474:	681b      	ldr	r3, [r3, #0]
24011476:	681a      	ldr	r2, [r3, #0]
24011478:	687b      	ldr	r3, [r7, #4]
2401147a:	681b      	ldr	r3, [r3, #0]
2401147c:	f022 0204 	bic.w	r2, r2, #4
24011480:	601a      	str	r2, [r3, #0]

      /* Abort MDMA */
      status = HAL_MDMA_Abort(hqspi->hmdma);
24011482:	687b      	ldr	r3, [r7, #4]
24011484:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
24011486:	4618      	mov	r0, r3
24011488:	f7fd fc32 	bl	2400ecf0 <HAL_MDMA_Abort>
2401148c:	4603      	mov	r3, r0
2401148e:	73fb      	strb	r3, [r7, #15]
      if(status != HAL_OK)
24011490:	7bfb      	ldrb	r3, [r7, #15]
24011492:	2b00      	cmp	r3, #0
24011494:	d005      	beq.n	240114a2 <HAL_QSPI_Abort+0x68>
      {
        hqspi->ErrorCode |= HAL_QSPI_ERROR_DMA;
24011496:	687b      	ldr	r3, [r7, #4]
24011498:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2401149a:	f043 0204 	orr.w	r2, r3, #4
2401149e:	687b      	ldr	r3, [r7, #4]
240114a0:	645a      	str	r2, [r3, #68]	; 0x44
      }
    }

    /* Configure QSPI: CR register with Abort request */
    SET_BIT(hqspi->Instance->CR, QUADSPI_CR_ABORT);
240114a2:	687b      	ldr	r3, [r7, #4]
240114a4:	681b      	ldr	r3, [r3, #0]
240114a6:	681a      	ldr	r2, [r3, #0]
240114a8:	687b      	ldr	r3, [r7, #4]
240114aa:	681b      	ldr	r3, [r3, #0]
240114ac:	f042 0202 	orr.w	r2, r2, #2
240114b0:	601a      	str	r2, [r3, #0]

    /* Wait until TC flag is set to go back in idle state */
    status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_TC, SET, tickstart, hqspi->Timeout);
240114b2:	687b      	ldr	r3, [r7, #4]
240114b4:	6c9b      	ldr	r3, [r3, #72]	; 0x48
240114b6:	9300      	str	r3, [sp, #0]
240114b8:	68bb      	ldr	r3, [r7, #8]
240114ba:	2201      	movs	r2, #1
240114bc:	2102      	movs	r1, #2
240114be:	6878      	ldr	r0, [r7, #4]
240114c0:	f000 f993 	bl	240117ea <QSPI_WaitFlagStateUntilTimeout>
240114c4:	4603      	mov	r3, r0
240114c6:	73fb      	strb	r3, [r7, #15]

    if (status == HAL_OK)
240114c8:	7bfb      	ldrb	r3, [r7, #15]
240114ca:	2b00      	cmp	r3, #0
240114cc:	d10e      	bne.n	240114ec <HAL_QSPI_Abort+0xb2>
    {
      __HAL_QSPI_CLEAR_FLAG(hqspi, QSPI_FLAG_TC);
240114ce:	687b      	ldr	r3, [r7, #4]
240114d0:	681b      	ldr	r3, [r3, #0]
240114d2:	2202      	movs	r2, #2
240114d4:	60da      	str	r2, [r3, #12]

      /* Wait until BUSY flag is reset */
      status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_BUSY, RESET, tickstart, hqspi->Timeout);
240114d6:	687b      	ldr	r3, [r7, #4]
240114d8:	6c9b      	ldr	r3, [r3, #72]	; 0x48
240114da:	9300      	str	r3, [sp, #0]
240114dc:	68bb      	ldr	r3, [r7, #8]
240114de:	2200      	movs	r2, #0
240114e0:	2120      	movs	r1, #32
240114e2:	6878      	ldr	r0, [r7, #4]
240114e4:	f000 f981 	bl	240117ea <QSPI_WaitFlagStateUntilTimeout>
240114e8:	4603      	mov	r3, r0
240114ea:	73fb      	strb	r3, [r7, #15]
    }

    if (status == HAL_OK)
240114ec:	7bfb      	ldrb	r3, [r7, #15]
240114ee:	2b00      	cmp	r3, #0
240114f0:	d10b      	bne.n	2401150a <HAL_QSPI_Abort+0xd0>
    {
      /* Reset functional mode configuration to indirect write mode by default */
      CLEAR_BIT(hqspi->Instance->CCR, QUADSPI_CCR_FMODE);
240114f2:	687b      	ldr	r3, [r7, #4]
240114f4:	681b      	ldr	r3, [r3, #0]
240114f6:	695a      	ldr	r2, [r3, #20]
240114f8:	687b      	ldr	r3, [r7, #4]
240114fa:	681b      	ldr	r3, [r3, #0]
240114fc:	f022 6240 	bic.w	r2, r2, #201326592	; 0xc000000
24011500:	615a      	str	r2, [r3, #20]

      /* Update state */
      hqspi->State = HAL_QSPI_STATE_READY;
24011502:	687b      	ldr	r3, [r7, #4]
24011504:	2201      	movs	r2, #1
24011506:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    }
  }

  return status;
2401150a:	7bfb      	ldrb	r3, [r7, #15]
}
2401150c:	4618      	mov	r0, r3
2401150e:	3710      	adds	r7, #16
24011510:	46bd      	mov	sp, r7
24011512:	bd80      	pop	{r7, pc}

24011514 <HAL_QSPI_Abort_IT>:
* @brief  Abort the current transmission (non-blocking function)
* @param  hqspi : QSPI handle
* @retval HAL status
*/
HAL_StatusTypeDef HAL_QSPI_Abort_IT(QSPI_HandleTypeDef *hqspi)
{
24011514:	b580      	push	{r7, lr}
24011516:	b084      	sub	sp, #16
24011518:	af00      	add	r7, sp, #0
2401151a:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
2401151c:	2300      	movs	r3, #0
2401151e:	73fb      	strb	r3, [r7, #15]

  /* Check if the state is in one of the busy states */
  if (((uint32_t)hqspi->State & 0x2U) != 0U)
24011520:	687b      	ldr	r3, [r7, #4]
24011522:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
24011526:	b2db      	uxtb	r3, r3
24011528:	f003 0302 	and.w	r3, r3, #2
2401152c:	2b00      	cmp	r3, #0
2401152e:	d046      	beq.n	240115be <HAL_QSPI_Abort_IT+0xaa>
  {
    /* Process unlocked */
    __HAL_UNLOCK(hqspi);
24011530:	687b      	ldr	r3, [r7, #4]
24011532:	2200      	movs	r2, #0
24011534:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Update QSPI state */
    hqspi->State = HAL_QSPI_STATE_ABORT;
24011538:	687b      	ldr	r3, [r7, #4]
2401153a:	2208      	movs	r2, #8
2401153c:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

    /* Disable all interrupts */
    __HAL_QSPI_DISABLE_IT(hqspi, (QSPI_IT_TO | QSPI_IT_SM | QSPI_IT_FT | QSPI_IT_TC | QSPI_IT_TE));
24011540:	687b      	ldr	r3, [r7, #4]
24011542:	681b      	ldr	r3, [r3, #0]
24011544:	681a      	ldr	r2, [r3, #0]
24011546:	687b      	ldr	r3, [r7, #4]
24011548:	681b      	ldr	r3, [r3, #0]
2401154a:	f422 12f8 	bic.w	r2, r2, #2031616	; 0x1f0000
2401154e:	601a      	str	r2, [r3, #0]

    if ((hqspi->Instance->CR & QUADSPI_CR_DMAEN) != 0U)
24011550:	687b      	ldr	r3, [r7, #4]
24011552:	681b      	ldr	r3, [r3, #0]
24011554:	681b      	ldr	r3, [r3, #0]
24011556:	f003 0304 	and.w	r3, r3, #4
2401155a:	2b00      	cmp	r3, #0
2401155c:	d01b      	beq.n	24011596 <HAL_QSPI_Abort_IT+0x82>
    {
      /* Disable the DMA transfer by clearing the DMAEN bit in the QSPI CR register */
      CLEAR_BIT(hqspi->Instance->CR, QUADSPI_CR_DMAEN);
2401155e:	687b      	ldr	r3, [r7, #4]
24011560:	681b      	ldr	r3, [r3, #0]
24011562:	681a      	ldr	r2, [r3, #0]
24011564:	687b      	ldr	r3, [r7, #4]
24011566:	681b      	ldr	r3, [r3, #0]
24011568:	f022 0204 	bic.w	r2, r2, #4
2401156c:	601a      	str	r2, [r3, #0]

      /* Abort MDMA channel */
      hqspi->hmdma->XferAbortCallback = QSPI_DMAAbortCplt;
2401156e:	687b      	ldr	r3, [r7, #4]
24011570:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
24011572:	4a15      	ldr	r2, [pc, #84]	; (240115c8 <HAL_QSPI_Abort_IT+0xb4>)
24011574:	659a      	str	r2, [r3, #88]	; 0x58
      if (HAL_MDMA_Abort_IT(hqspi->hmdma) != HAL_OK)
24011576:	687b      	ldr	r3, [r7, #4]
24011578:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2401157a:	4618      	mov	r0, r3
2401157c:	f7fd fc13 	bl	2400eda6 <HAL_MDMA_Abort_IT>
24011580:	4603      	mov	r3, r0
24011582:	2b00      	cmp	r3, #0
24011584:	d01b      	beq.n	240115be <HAL_QSPI_Abort_IT+0xaa>
      {
        /* Change state of QSPI */
        hqspi->State = HAL_QSPI_STATE_READY;
24011586:	687b      	ldr	r3, [r7, #4]
24011588:	2201      	movs	r2, #1
2401158a:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

        /* Abort Complete callback */
#if (USE_HAL_QSPI_REGISTER_CALLBACKS == 1)
        hqspi->AbortCpltCallback(hqspi);
#else
        HAL_QSPI_AbortCpltCallback(hqspi);
2401158e:	6878      	ldr	r0, [r7, #4]
24011590:	f7ff fef3 	bl	2401137a <HAL_QSPI_AbortCpltCallback>
24011594:	e013      	b.n	240115be <HAL_QSPI_Abort_IT+0xaa>
      }
    }
    else
    {
      /* Clear interrupt */
      __HAL_QSPI_CLEAR_FLAG(hqspi, QSPI_FLAG_TC);
24011596:	687b      	ldr	r3, [r7, #4]
24011598:	681b      	ldr	r3, [r3, #0]
2401159a:	2202      	movs	r2, #2
2401159c:	60da      	str	r2, [r3, #12]

      /* Enable the QSPI Transfer Complete Interrupt */
      __HAL_QSPI_ENABLE_IT(hqspi, QSPI_IT_TC);
2401159e:	687b      	ldr	r3, [r7, #4]
240115a0:	681b      	ldr	r3, [r3, #0]
240115a2:	681a      	ldr	r2, [r3, #0]
240115a4:	687b      	ldr	r3, [r7, #4]
240115a6:	681b      	ldr	r3, [r3, #0]
240115a8:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
240115ac:	601a      	str	r2, [r3, #0]

      /* Configure QSPI: CR register with Abort request */
      SET_BIT(hqspi->Instance->CR, QUADSPI_CR_ABORT);
240115ae:	687b      	ldr	r3, [r7, #4]
240115b0:	681b      	ldr	r3, [r3, #0]
240115b2:	681a      	ldr	r2, [r3, #0]
240115b4:	687b      	ldr	r3, [r7, #4]
240115b6:	681b      	ldr	r3, [r3, #0]
240115b8:	f042 0202 	orr.w	r2, r2, #2
240115bc:	601a      	str	r2, [r3, #0]
    }
  }
  return status;
240115be:	7bfb      	ldrb	r3, [r7, #15]
}
240115c0:	4618      	mov	r0, r3
240115c2:	3710      	adds	r7, #16
240115c4:	46bd      	mov	sp, r7
240115c6:	bd80      	pop	{r7, pc}
240115c8:	24011785 	.word	0x24011785

240115cc <HAL_QSPI_SetTimeout>:
  * @param  hqspi : QSPI handle.
  * @param  Timeout : Timeout for the QSPI memory access.
  * @retval None
  */
void HAL_QSPI_SetTimeout(QSPI_HandleTypeDef *hqspi, uint32_t Timeout)
{
240115cc:	b480      	push	{r7}
240115ce:	b083      	sub	sp, #12
240115d0:	af00      	add	r7, sp, #0
240115d2:	6078      	str	r0, [r7, #4]
240115d4:	6039      	str	r1, [r7, #0]
  hqspi->Timeout = Timeout;
240115d6:	687b      	ldr	r3, [r7, #4]
240115d8:	683a      	ldr	r2, [r7, #0]
240115da:	649a      	str	r2, [r3, #72]	; 0x48
}
240115dc:	bf00      	nop
240115de:	370c      	adds	r7, #12
240115e0:	46bd      	mov	sp, r7
240115e2:	f85d 7b04 	ldr.w	r7, [sp], #4
240115e6:	4770      	bx	lr

240115e8 <HAL_QSPI_SetFifoThreshold>:
  * @param  hqspi : QSPI handle.
  * @param  Threshold : Threshold of the Fifo (value between 1 and 16).
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_QSPI_SetFifoThreshold(QSPI_HandleTypeDef *hqspi, uint32_t Threshold)
{
240115e8:	b480      	push	{r7}
240115ea:	b085      	sub	sp, #20
240115ec:	af00      	add	r7, sp, #0
240115ee:	6078      	str	r0, [r7, #4]
240115f0:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
240115f2:	2300      	movs	r3, #0
240115f4:	73fb      	strb	r3, [r7, #15]

  /* Process locked */
  __HAL_LOCK(hqspi);
240115f6:	687b      	ldr	r3, [r7, #4]
240115f8:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
240115fc:	b2db      	uxtb	r3, r3
240115fe:	2b01      	cmp	r3, #1
24011600:	d101      	bne.n	24011606 <HAL_QSPI_SetFifoThreshold+0x1e>
24011602:	2302      	movs	r3, #2
24011604:	e021      	b.n	2401164a <HAL_QSPI_SetFifoThreshold+0x62>
24011606:	687b      	ldr	r3, [r7, #4]
24011608:	2201      	movs	r2, #1
2401160a:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  if(hqspi->State == HAL_QSPI_STATE_READY)
2401160e:	687b      	ldr	r3, [r7, #4]
24011610:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
24011614:	b2db      	uxtb	r3, r3
24011616:	2b01      	cmp	r3, #1
24011618:	d110      	bne.n	2401163c <HAL_QSPI_SetFifoThreshold+0x54>
  {
    /* Synchronize init structure with new FIFO threshold value */
    hqspi->Init.FifoThreshold = Threshold;
2401161a:	687b      	ldr	r3, [r7, #4]
2401161c:	683a      	ldr	r2, [r7, #0]
2401161e:	609a      	str	r2, [r3, #8]

    /* Configure QSPI FIFO Threshold */
    MODIFY_REG(hqspi->Instance->CR, QUADSPI_CR_FTHRES,
24011620:	687b      	ldr	r3, [r7, #4]
24011622:	681b      	ldr	r3, [r3, #0]
24011624:	681b      	ldr	r3, [r3, #0]
24011626:	f423 6170 	bic.w	r1, r3, #3840	; 0xf00
2401162a:	687b      	ldr	r3, [r7, #4]
2401162c:	689b      	ldr	r3, [r3, #8]
2401162e:	3b01      	subs	r3, #1
24011630:	021a      	lsls	r2, r3, #8
24011632:	687b      	ldr	r3, [r7, #4]
24011634:	681b      	ldr	r3, [r3, #0]
24011636:	430a      	orrs	r2, r1
24011638:	601a      	str	r2, [r3, #0]
2401163a:	e001      	b.n	24011640 <HAL_QSPI_SetFifoThreshold+0x58>
               ((hqspi->Init.FifoThreshold - 1U) << QUADSPI_CR_FTHRES_Pos));
  }
  else
  {
    status = HAL_BUSY;
2401163c:	2302      	movs	r3, #2
2401163e:	73fb      	strb	r3, [r7, #15]
  }

  /* Process unlocked */
  __HAL_UNLOCK(hqspi);
24011640:	687b      	ldr	r3, [r7, #4]
24011642:	2200      	movs	r2, #0
24011644:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  /* Return function status */
  return status;
24011648:	7bfb      	ldrb	r3, [r7, #15]
}
2401164a:	4618      	mov	r0, r3
2401164c:	3714      	adds	r7, #20
2401164e:	46bd      	mov	sp, r7
24011650:	f85d 7b04 	ldr.w	r7, [sp], #4
24011654:	4770      	bx	lr

24011656 <HAL_QSPI_GetFifoThreshold>:
/** @brief Get QSPI Fifo threshold.
  * @param  hqspi : QSPI handle.
  * @retval Fifo threshold (value between 1 and 16)
  */
uint32_t HAL_QSPI_GetFifoThreshold(QSPI_HandleTypeDef *hqspi)
{
24011656:	b480      	push	{r7}
24011658:	b083      	sub	sp, #12
2401165a:	af00      	add	r7, sp, #0
2401165c:	6078      	str	r0, [r7, #4]
  return ((READ_BIT(hqspi->Instance->CR, QUADSPI_CR_FTHRES) >> QUADSPI_CR_FTHRES_Pos) + 1U);
2401165e:	687b      	ldr	r3, [r7, #4]
24011660:	681b      	ldr	r3, [r3, #0]
24011662:	681b      	ldr	r3, [r3, #0]
24011664:	0a1b      	lsrs	r3, r3, #8
24011666:	f003 030f 	and.w	r3, r3, #15
2401166a:	3301      	adds	r3, #1
}
2401166c:	4618      	mov	r0, r3
2401166e:	370c      	adds	r7, #12
24011670:	46bd      	mov	sp, r7
24011672:	f85d 7b04 	ldr.w	r7, [sp], #4
24011676:	4770      	bx	lr

24011678 <HAL_QSPI_SetFlashID>:
  *                   This parameter can be a value of @ref QSPI_Flash_Select.
  * @note   The FlashID is ignored when dual flash mode is enabled.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_QSPI_SetFlashID(QSPI_HandleTypeDef *hqspi, uint32_t FlashID)
{
24011678:	b480      	push	{r7}
2401167a:	b085      	sub	sp, #20
2401167c:	af00      	add	r7, sp, #0
2401167e:	6078      	str	r0, [r7, #4]
24011680:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
24011682:	2300      	movs	r3, #0
24011684:	73fb      	strb	r3, [r7, #15]

  /* Check the parameter */
  assert_param(IS_QSPI_FLASH_ID(FlashID));

  /* Process locked */
  __HAL_LOCK(hqspi);
24011686:	687b      	ldr	r3, [r7, #4]
24011688:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2401168c:	b2db      	uxtb	r3, r3
2401168e:	2b01      	cmp	r3, #1
24011690:	d101      	bne.n	24011696 <HAL_QSPI_SetFlashID+0x1e>
24011692:	2302      	movs	r3, #2
24011694:	e01e      	b.n	240116d4 <HAL_QSPI_SetFlashID+0x5c>
24011696:	687b      	ldr	r3, [r7, #4]
24011698:	2201      	movs	r2, #1
2401169a:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  if(hqspi->State == HAL_QSPI_STATE_READY)
2401169e:	687b      	ldr	r3, [r7, #4]
240116a0:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
240116a4:	b2db      	uxtb	r3, r3
240116a6:	2b01      	cmp	r3, #1
240116a8:	d10d      	bne.n	240116c6 <HAL_QSPI_SetFlashID+0x4e>
  {
    /* Synchronize init structure with new FlashID value */
    hqspi->Init.FlashID = FlashID;
240116aa:	687b      	ldr	r3, [r7, #4]
240116ac:	683a      	ldr	r2, [r7, #0]
240116ae:	61da      	str	r2, [r3, #28]

    /* Configure QSPI FlashID */
    MODIFY_REG(hqspi->Instance->CR, QUADSPI_CR_FSEL, FlashID);
240116b0:	687b      	ldr	r3, [r7, #4]
240116b2:	681b      	ldr	r3, [r3, #0]
240116b4:	681b      	ldr	r3, [r3, #0]
240116b6:	f023 0180 	bic.w	r1, r3, #128	; 0x80
240116ba:	687b      	ldr	r3, [r7, #4]
240116bc:	681b      	ldr	r3, [r3, #0]
240116be:	683a      	ldr	r2, [r7, #0]
240116c0:	430a      	orrs	r2, r1
240116c2:	601a      	str	r2, [r3, #0]
240116c4:	e001      	b.n	240116ca <HAL_QSPI_SetFlashID+0x52>
  }
  else
  {
    status = HAL_BUSY;
240116c6:	2302      	movs	r3, #2
240116c8:	73fb      	strb	r3, [r7, #15]
  }

  /* Process unlocked */
  __HAL_UNLOCK(hqspi);
240116ca:	687b      	ldr	r3, [r7, #4]
240116cc:	2200      	movs	r2, #0
240116ce:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  /* Return function status */
  return status;
240116d2:	7bfb      	ldrb	r3, [r7, #15]
}
240116d4:	4618      	mov	r0, r3
240116d6:	3714      	adds	r7, #20
240116d8:	46bd      	mov	sp, r7
240116da:	f85d 7b04 	ldr.w	r7, [sp], #4
240116de:	4770      	bx	lr

240116e0 <QSPI_DMARxCplt>:
  * @brief  DMA QSPI receive process complete callback.
  * @param  hmdma : MDMA handle
  * @retval None
  */
static void QSPI_DMARxCplt(MDMA_HandleTypeDef *hmdma)
{
240116e0:	b480      	push	{r7}
240116e2:	b085      	sub	sp, #20
240116e4:	af00      	add	r7, sp, #0
240116e6:	6078      	str	r0, [r7, #4]
  QSPI_HandleTypeDef* hqspi = (QSPI_HandleTypeDef*)(hmdma->Parent);
240116e8:	687b      	ldr	r3, [r7, #4]
240116ea:	6c1b      	ldr	r3, [r3, #64]	; 0x40
240116ec:	60fb      	str	r3, [r7, #12]
  hqspi->RxXferCount = 0U;
240116ee:	68fb      	ldr	r3, [r7, #12]
240116f0:	2200      	movs	r2, #0
240116f2:	639a      	str	r2, [r3, #56]	; 0x38

  /* Enable the QSPI transfer complete Interrupt */
  __HAL_QSPI_ENABLE_IT(hqspi, QSPI_IT_TC);
240116f4:	68fb      	ldr	r3, [r7, #12]
240116f6:	681b      	ldr	r3, [r3, #0]
240116f8:	681a      	ldr	r2, [r3, #0]
240116fa:	68fb      	ldr	r3, [r7, #12]
240116fc:	681b      	ldr	r3, [r3, #0]
240116fe:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
24011702:	601a      	str	r2, [r3, #0]
}
24011704:	bf00      	nop
24011706:	3714      	adds	r7, #20
24011708:	46bd      	mov	sp, r7
2401170a:	f85d 7b04 	ldr.w	r7, [sp], #4
2401170e:	4770      	bx	lr

24011710 <QSPI_DMATxCplt>:
  * @brief  DMA QSPI transmit process complete callback.
  * @param  hmdma : MDMA handle
  * @retval None
  */
static void QSPI_DMATxCplt(MDMA_HandleTypeDef *hmdma)
{
24011710:	b480      	push	{r7}
24011712:	b085      	sub	sp, #20
24011714:	af00      	add	r7, sp, #0
24011716:	6078      	str	r0, [r7, #4]
  QSPI_HandleTypeDef* hqspi = (QSPI_HandleTypeDef*)(hmdma->Parent);
24011718:	687b      	ldr	r3, [r7, #4]
2401171a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
2401171c:	60fb      	str	r3, [r7, #12]
  hqspi->TxXferCount = 0U;
2401171e:	68fb      	ldr	r3, [r7, #12]
24011720:	2200      	movs	r2, #0
24011722:	62da      	str	r2, [r3, #44]	; 0x2c

  /* Enable the QSPI transfer complete Interrupt */
  __HAL_QSPI_ENABLE_IT(hqspi, QSPI_IT_TC);
24011724:	68fb      	ldr	r3, [r7, #12]
24011726:	681b      	ldr	r3, [r3, #0]
24011728:	681a      	ldr	r2, [r3, #0]
2401172a:	68fb      	ldr	r3, [r7, #12]
2401172c:	681b      	ldr	r3, [r3, #0]
2401172e:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
24011732:	601a      	str	r2, [r3, #0]
}
24011734:	bf00      	nop
24011736:	3714      	adds	r7, #20
24011738:	46bd      	mov	sp, r7
2401173a:	f85d 7b04 	ldr.w	r7, [sp], #4
2401173e:	4770      	bx	lr

24011740 <QSPI_DMAError>:
  * @brief  DMA QSPI communication error callback.
  * @param  hmdma : MDMA handle
  * @retval None
  */
static void QSPI_DMAError(MDMA_HandleTypeDef *hmdma)
{
24011740:	b580      	push	{r7, lr}
24011742:	b084      	sub	sp, #16
24011744:	af00      	add	r7, sp, #0
24011746:	6078      	str	r0, [r7, #4]
  QSPI_HandleTypeDef* hqspi = ( QSPI_HandleTypeDef* )(hmdma->Parent);
24011748:	687b      	ldr	r3, [r7, #4]
2401174a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
2401174c:	60fb      	str	r3, [r7, #12]

  hqspi->RxXferCount = 0U;
2401174e:	68fb      	ldr	r3, [r7, #12]
24011750:	2200      	movs	r2, #0
24011752:	639a      	str	r2, [r3, #56]	; 0x38
  hqspi->TxXferCount = 0U;
24011754:	68fb      	ldr	r3, [r7, #12]
24011756:	2200      	movs	r2, #0
24011758:	62da      	str	r2, [r3, #44]	; 0x2c
  hqspi->ErrorCode   |= HAL_QSPI_ERROR_DMA;
2401175a:	68fb      	ldr	r3, [r7, #12]
2401175c:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2401175e:	f043 0204 	orr.w	r2, r3, #4
24011762:	68fb      	ldr	r3, [r7, #12]
24011764:	645a      	str	r2, [r3, #68]	; 0x44

  /* Disable the MDMA transfer by clearing the DMAEN bit in the QSPI CR register */
  CLEAR_BIT(hqspi->Instance->CR, QUADSPI_CR_DMAEN);
24011766:	68fb      	ldr	r3, [r7, #12]
24011768:	681b      	ldr	r3, [r3, #0]
2401176a:	681a      	ldr	r2, [r3, #0]
2401176c:	68fb      	ldr	r3, [r7, #12]
2401176e:	681b      	ldr	r3, [r3, #0]
24011770:	f022 0204 	bic.w	r2, r2, #4
24011774:	601a      	str	r2, [r3, #0]

  /* Abort the QSPI */
  (void)HAL_QSPI_Abort_IT(hqspi);
24011776:	68f8      	ldr	r0, [r7, #12]
24011778:	f7ff fecc 	bl	24011514 <HAL_QSPI_Abort_IT>

}
2401177c:	bf00      	nop
2401177e:	3710      	adds	r7, #16
24011780:	46bd      	mov	sp, r7
24011782:	bd80      	pop	{r7, pc}

24011784 <QSPI_DMAAbortCplt>:
  * @brief  MDMA QSPI abort complete callback.
  * @param  hmdma : MDMA handle
  * @retval None
  */
static void QSPI_DMAAbortCplt(MDMA_HandleTypeDef *hmdma)
{
24011784:	b580      	push	{r7, lr}
24011786:	b084      	sub	sp, #16
24011788:	af00      	add	r7, sp, #0
2401178a:	6078      	str	r0, [r7, #4]
  QSPI_HandleTypeDef* hqspi = ( QSPI_HandleTypeDef* )(hmdma->Parent);
2401178c:	687b      	ldr	r3, [r7, #4]
2401178e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
24011790:	60fb      	str	r3, [r7, #12]

  hqspi->RxXferCount = 0U;
24011792:	68fb      	ldr	r3, [r7, #12]
24011794:	2200      	movs	r2, #0
24011796:	639a      	str	r2, [r3, #56]	; 0x38
  hqspi->TxXferCount = 0U;
24011798:	68fb      	ldr	r3, [r7, #12]
2401179a:	2200      	movs	r2, #0
2401179c:	62da      	str	r2, [r3, #44]	; 0x2c

  if(hqspi->State == HAL_QSPI_STATE_ABORT)
2401179e:	68fb      	ldr	r3, [r7, #12]
240117a0:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
240117a4:	b2db      	uxtb	r3, r3
240117a6:	2b08      	cmp	r3, #8
240117a8:	d114      	bne.n	240117d4 <QSPI_DMAAbortCplt+0x50>
  {
    /* MDMA Abort called by QSPI abort */
    /* Clear interrupt */
    __HAL_QSPI_CLEAR_FLAG(hqspi, QSPI_FLAG_TC);
240117aa:	68fb      	ldr	r3, [r7, #12]
240117ac:	681b      	ldr	r3, [r3, #0]
240117ae:	2202      	movs	r2, #2
240117b0:	60da      	str	r2, [r3, #12]

    /* Enable the QSPI Transfer Complete Interrupt */
    __HAL_QSPI_ENABLE_IT(hqspi, QSPI_IT_TC);
240117b2:	68fb      	ldr	r3, [r7, #12]
240117b4:	681b      	ldr	r3, [r3, #0]
240117b6:	681a      	ldr	r2, [r3, #0]
240117b8:	68fb      	ldr	r3, [r7, #12]
240117ba:	681b      	ldr	r3, [r3, #0]
240117bc:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
240117c0:	601a      	str	r2, [r3, #0]

    /* Configure QSPI: CR register with Abort request */
    SET_BIT(hqspi->Instance->CR, QUADSPI_CR_ABORT);
240117c2:	68fb      	ldr	r3, [r7, #12]
240117c4:	681b      	ldr	r3, [r3, #0]
240117c6:	681a      	ldr	r2, [r3, #0]
240117c8:	68fb      	ldr	r3, [r7, #12]
240117ca:	681b      	ldr	r3, [r3, #0]
240117cc:	f042 0202 	orr.w	r2, r2, #2
240117d0:	601a      	str	r2, [r3, #0]
    hqspi->ErrorCallback(hqspi);
#else
    HAL_QSPI_ErrorCallback(hqspi);
#endif
  }
}
240117d2:	e006      	b.n	240117e2 <QSPI_DMAAbortCplt+0x5e>
    hqspi->State = HAL_QSPI_STATE_READY;
240117d4:	68fb      	ldr	r3, [r7, #12]
240117d6:	2201      	movs	r2, #1
240117d8:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    HAL_QSPI_ErrorCallback(hqspi);
240117dc:	68f8      	ldr	r0, [r7, #12]
240117de:	f7ff fdc2 	bl	24011366 <HAL_QSPI_ErrorCallback>
}
240117e2:	bf00      	nop
240117e4:	3710      	adds	r7, #16
240117e6:	46bd      	mov	sp, r7
240117e8:	bd80      	pop	{r7, pc}

240117ea <QSPI_WaitFlagStateUntilTimeout>:
  * @param  Timeout : Duration of the timeout
  * @retval HAL status
  */
static HAL_StatusTypeDef QSPI_WaitFlagStateUntilTimeout(QSPI_HandleTypeDef *hqspi, uint32_t Flag,
                                                        FlagStatus State, uint32_t Tickstart, uint32_t Timeout)
{
240117ea:	b580      	push	{r7, lr}
240117ec:	b084      	sub	sp, #16
240117ee:	af00      	add	r7, sp, #0
240117f0:	60f8      	str	r0, [r7, #12]
240117f2:	60b9      	str	r1, [r7, #8]
240117f4:	603b      	str	r3, [r7, #0]
240117f6:	4613      	mov	r3, r2
240117f8:	71fb      	strb	r3, [r7, #7]
  /* Wait until flag is in expected state */
  while((__HAL_QSPI_GET_FLAG(hqspi, Flag)) != State)
240117fa:	e01a      	b.n	24011832 <QSPI_WaitFlagStateUntilTimeout+0x48>
  {
    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
240117fc:	69bb      	ldr	r3, [r7, #24]
240117fe:	f1b3 3fff 	cmp.w	r3, #4294967295
24011802:	d016      	beq.n	24011832 <QSPI_WaitFlagStateUntilTimeout+0x48>
    {
      if(((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
24011804:	f7ef f826 	bl	24000854 <HAL_GetTick>
24011808:	4602      	mov	r2, r0
2401180a:	683b      	ldr	r3, [r7, #0]
2401180c:	1ad3      	subs	r3, r2, r3
2401180e:	69ba      	ldr	r2, [r7, #24]
24011810:	429a      	cmp	r2, r3
24011812:	d302      	bcc.n	2401181a <QSPI_WaitFlagStateUntilTimeout+0x30>
24011814:	69bb      	ldr	r3, [r7, #24]
24011816:	2b00      	cmp	r3, #0
24011818:	d10b      	bne.n	24011832 <QSPI_WaitFlagStateUntilTimeout+0x48>
      {
        hqspi->State     = HAL_QSPI_STATE_ERROR;
2401181a:	68fb      	ldr	r3, [r7, #12]
2401181c:	2204      	movs	r2, #4
2401181e:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
        hqspi->ErrorCode |= HAL_QSPI_ERROR_TIMEOUT;
24011822:	68fb      	ldr	r3, [r7, #12]
24011824:	6c5b      	ldr	r3, [r3, #68]	; 0x44
24011826:	f043 0201 	orr.w	r2, r3, #1
2401182a:	68fb      	ldr	r3, [r7, #12]
2401182c:	645a      	str	r2, [r3, #68]	; 0x44

        return HAL_ERROR;
2401182e:	2301      	movs	r3, #1
24011830:	e00e      	b.n	24011850 <QSPI_WaitFlagStateUntilTimeout+0x66>
  while((__HAL_QSPI_GET_FLAG(hqspi, Flag)) != State)
24011832:	68fb      	ldr	r3, [r7, #12]
24011834:	681b      	ldr	r3, [r3, #0]
24011836:	689a      	ldr	r2, [r3, #8]
24011838:	68bb      	ldr	r3, [r7, #8]
2401183a:	4013      	ands	r3, r2
2401183c:	2b00      	cmp	r3, #0
2401183e:	bf14      	ite	ne
24011840:	2301      	movne	r3, #1
24011842:	2300      	moveq	r3, #0
24011844:	b2db      	uxtb	r3, r3
24011846:	461a      	mov	r2, r3
24011848:	79fb      	ldrb	r3, [r7, #7]
2401184a:	429a      	cmp	r2, r3
2401184c:	d1d6      	bne.n	240117fc <QSPI_WaitFlagStateUntilTimeout+0x12>
      }
    }
  }
  return HAL_OK;
2401184e:	2300      	movs	r3, #0
}
24011850:	4618      	mov	r0, r3
24011852:	3710      	adds	r7, #16
24011854:	46bd      	mov	sp, r7
24011856:	bd80      	pop	{r7, pc}

24011858 <QSPI_Config>:
  *            @arg QSPI_FUNCTIONAL_MODE_AUTO_POLLING: Automatic polling mode
  *            @arg QSPI_FUNCTIONAL_MODE_MEMORY_MAPPED: Memory-mapped mode
  * @retval None
  */
static void QSPI_Config(QSPI_HandleTypeDef *hqspi, QSPI_CommandTypeDef *cmd, uint32_t FunctionalMode)
{
24011858:	b480      	push	{r7}
2401185a:	b085      	sub	sp, #20
2401185c:	af00      	add	r7, sp, #0
2401185e:	60f8      	str	r0, [r7, #12]
24011860:	60b9      	str	r1, [r7, #8]
24011862:	607a      	str	r2, [r7, #4]
  assert_param(IS_QSPI_FUNCTIONAL_MODE(FunctionalMode));

  if ((cmd->DataMode != QSPI_DATA_NONE) && (FunctionalMode != QSPI_FUNCTIONAL_MODE_MEMORY_MAPPED))
24011864:	68bb      	ldr	r3, [r7, #8]
24011866:	6a5b      	ldr	r3, [r3, #36]	; 0x24
24011868:	2b00      	cmp	r3, #0
2401186a:	d009      	beq.n	24011880 <QSPI_Config+0x28>
2401186c:	687b      	ldr	r3, [r7, #4]
2401186e:	f1b3 6f40 	cmp.w	r3, #201326592	; 0xc000000
24011872:	d005      	beq.n	24011880 <QSPI_Config+0x28>
  {
    /* Configure QSPI: DLR register with the number of data to read or write */
    WRITE_REG(hqspi->Instance->DLR, (cmd->NbData - 1U));
24011874:	68bb      	ldr	r3, [r7, #8]
24011876:	6a9a      	ldr	r2, [r3, #40]	; 0x28
24011878:	68fb      	ldr	r3, [r7, #12]
2401187a:	681b      	ldr	r3, [r3, #0]
2401187c:	3a01      	subs	r2, #1
2401187e:	611a      	str	r2, [r3, #16]
  }

  if (cmd->InstructionMode != QSPI_INSTRUCTION_NONE)
24011880:	68bb      	ldr	r3, [r7, #8]
24011882:	699b      	ldr	r3, [r3, #24]
24011884:	2b00      	cmp	r3, #0
24011886:	f000 80b9 	beq.w	240119fc <QSPI_Config+0x1a4>
  {
    if (cmd->AlternateByteMode != QSPI_ALTERNATE_BYTES_NONE)
2401188a:	68bb      	ldr	r3, [r7, #8]
2401188c:	6a1b      	ldr	r3, [r3, #32]
2401188e:	2b00      	cmp	r3, #0
24011890:	d05f      	beq.n	24011952 <QSPI_Config+0xfa>
    {
      /* Configure QSPI: ABR register with alternate bytes value */
      WRITE_REG(hqspi->Instance->ABR, cmd->AlternateBytes);
24011892:	68fb      	ldr	r3, [r7, #12]
24011894:	681b      	ldr	r3, [r3, #0]
24011896:	68ba      	ldr	r2, [r7, #8]
24011898:	6892      	ldr	r2, [r2, #8]
2401189a:	61da      	str	r2, [r3, #28]

      if (cmd->AddressMode != QSPI_ADDRESS_NONE)
2401189c:	68bb      	ldr	r3, [r7, #8]
2401189e:	69db      	ldr	r3, [r3, #28]
240118a0:	2b00      	cmp	r3, #0
240118a2:	d031      	beq.n	24011908 <QSPI_Config+0xb0>
      {
        /*---- Command with instruction, address and alternate bytes ----*/
        /* Configure QSPI: CCR register with all communications parameters */
        WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
240118a4:	68bb      	ldr	r3, [r7, #8]
240118a6:	6ada      	ldr	r2, [r3, #44]	; 0x2c
240118a8:	68bb      	ldr	r3, [r7, #8]
240118aa:	6b1b      	ldr	r3, [r3, #48]	; 0x30
240118ac:	431a      	orrs	r2, r3
240118ae:	68bb      	ldr	r3, [r7, #8]
240118b0:	6b5b      	ldr	r3, [r3, #52]	; 0x34
240118b2:	431a      	orrs	r2, r3
240118b4:	68bb      	ldr	r3, [r7, #8]
240118b6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
240118b8:	431a      	orrs	r2, r3
240118ba:	68bb      	ldr	r3, [r7, #8]
240118bc:	695b      	ldr	r3, [r3, #20]
240118be:	049b      	lsls	r3, r3, #18
240118c0:	431a      	orrs	r2, r3
240118c2:	68bb      	ldr	r3, [r7, #8]
240118c4:	691b      	ldr	r3, [r3, #16]
240118c6:	431a      	orrs	r2, r3
240118c8:	68bb      	ldr	r3, [r7, #8]
240118ca:	6a1b      	ldr	r3, [r3, #32]
240118cc:	431a      	orrs	r2, r3
240118ce:	68bb      	ldr	r3, [r7, #8]
240118d0:	68db      	ldr	r3, [r3, #12]
240118d2:	431a      	orrs	r2, r3
240118d4:	68bb      	ldr	r3, [r7, #8]
240118d6:	69db      	ldr	r3, [r3, #28]
240118d8:	431a      	orrs	r2, r3
240118da:	68bb      	ldr	r3, [r7, #8]
240118dc:	699b      	ldr	r3, [r3, #24]
240118de:	431a      	orrs	r2, r3
240118e0:	68bb      	ldr	r3, [r7, #8]
240118e2:	681b      	ldr	r3, [r3, #0]
240118e4:	ea42 0103 	orr.w	r1, r2, r3
240118e8:	68fb      	ldr	r3, [r7, #12]
240118ea:	681b      	ldr	r3, [r3, #0]
240118ec:	687a      	ldr	r2, [r7, #4]
240118ee:	430a      	orrs	r2, r1
240118f0:	615a      	str	r2, [r3, #20]
                                         cmd->DataMode | (cmd->DummyCycles << QUADSPI_CCR_DCYC_Pos) |
                                         cmd->AlternateBytesSize | cmd->AlternateByteMode |
                                         cmd->AddressSize | cmd->AddressMode | cmd->InstructionMode |
                                         cmd->Instruction | FunctionalMode));

        if (FunctionalMode != QSPI_FUNCTIONAL_MODE_MEMORY_MAPPED)
240118f2:	687b      	ldr	r3, [r7, #4]
240118f4:	f1b3 6f40 	cmp.w	r3, #201326592	; 0xc000000
240118f8:	f000 812e 	beq.w	24011b58 <QSPI_Config+0x300>
        {
          /* Configure QSPI: AR register with address value */
          WRITE_REG(hqspi->Instance->AR, cmd->Address);
240118fc:	68fb      	ldr	r3, [r7, #12]
240118fe:	681b      	ldr	r3, [r3, #0]
24011900:	68ba      	ldr	r2, [r7, #8]
24011902:	6852      	ldr	r2, [r2, #4]
24011904:	619a      	str	r2, [r3, #24]
                                           cmd->InstructionMode | FunctionalMode));
        }
      }
    }
  }
}
24011906:	e127      	b.n	24011b58 <QSPI_Config+0x300>
        WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
24011908:	68bb      	ldr	r3, [r7, #8]
2401190a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
2401190c:	68bb      	ldr	r3, [r7, #8]
2401190e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
24011910:	431a      	orrs	r2, r3
24011912:	68bb      	ldr	r3, [r7, #8]
24011914:	6b5b      	ldr	r3, [r3, #52]	; 0x34
24011916:	431a      	orrs	r2, r3
24011918:	68bb      	ldr	r3, [r7, #8]
2401191a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2401191c:	431a      	orrs	r2, r3
2401191e:	68bb      	ldr	r3, [r7, #8]
24011920:	695b      	ldr	r3, [r3, #20]
24011922:	049b      	lsls	r3, r3, #18
24011924:	431a      	orrs	r2, r3
24011926:	68bb      	ldr	r3, [r7, #8]
24011928:	691b      	ldr	r3, [r3, #16]
2401192a:	431a      	orrs	r2, r3
2401192c:	68bb      	ldr	r3, [r7, #8]
2401192e:	6a1b      	ldr	r3, [r3, #32]
24011930:	431a      	orrs	r2, r3
24011932:	68bb      	ldr	r3, [r7, #8]
24011934:	69db      	ldr	r3, [r3, #28]
24011936:	431a      	orrs	r2, r3
24011938:	68bb      	ldr	r3, [r7, #8]
2401193a:	699b      	ldr	r3, [r3, #24]
2401193c:	431a      	orrs	r2, r3
2401193e:	68bb      	ldr	r3, [r7, #8]
24011940:	681b      	ldr	r3, [r3, #0]
24011942:	ea42 0103 	orr.w	r1, r2, r3
24011946:	68fb      	ldr	r3, [r7, #12]
24011948:	681b      	ldr	r3, [r3, #0]
2401194a:	687a      	ldr	r2, [r7, #4]
2401194c:	430a      	orrs	r2, r1
2401194e:	615a      	str	r2, [r3, #20]
}
24011950:	e102      	b.n	24011b58 <QSPI_Config+0x300>
      if (cmd->AddressMode != QSPI_ADDRESS_NONE)
24011952:	68bb      	ldr	r3, [r7, #8]
24011954:	69db      	ldr	r3, [r3, #28]
24011956:	2b00      	cmp	r3, #0
24011958:	d02e      	beq.n	240119b8 <QSPI_Config+0x160>
        WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
2401195a:	68bb      	ldr	r3, [r7, #8]
2401195c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
2401195e:	68bb      	ldr	r3, [r7, #8]
24011960:	6b1b      	ldr	r3, [r3, #48]	; 0x30
24011962:	431a      	orrs	r2, r3
24011964:	68bb      	ldr	r3, [r7, #8]
24011966:	6b5b      	ldr	r3, [r3, #52]	; 0x34
24011968:	431a      	orrs	r2, r3
2401196a:	68bb      	ldr	r3, [r7, #8]
2401196c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2401196e:	431a      	orrs	r2, r3
24011970:	68bb      	ldr	r3, [r7, #8]
24011972:	695b      	ldr	r3, [r3, #20]
24011974:	049b      	lsls	r3, r3, #18
24011976:	431a      	orrs	r2, r3
24011978:	68bb      	ldr	r3, [r7, #8]
2401197a:	6a1b      	ldr	r3, [r3, #32]
2401197c:	431a      	orrs	r2, r3
2401197e:	68bb      	ldr	r3, [r7, #8]
24011980:	68db      	ldr	r3, [r3, #12]
24011982:	431a      	orrs	r2, r3
24011984:	68bb      	ldr	r3, [r7, #8]
24011986:	69db      	ldr	r3, [r3, #28]
24011988:	431a      	orrs	r2, r3
2401198a:	68bb      	ldr	r3, [r7, #8]
2401198c:	699b      	ldr	r3, [r3, #24]
2401198e:	431a      	orrs	r2, r3
24011990:	68bb      	ldr	r3, [r7, #8]
24011992:	681b      	ldr	r3, [r3, #0]
24011994:	ea42 0103 	orr.w	r1, r2, r3
24011998:	68fb      	ldr	r3, [r7, #12]
2401199a:	681b      	ldr	r3, [r3, #0]
2401199c:	687a      	ldr	r2, [r7, #4]
2401199e:	430a      	orrs	r2, r1
240119a0:	615a      	str	r2, [r3, #20]
        if (FunctionalMode != QSPI_FUNCTIONAL_MODE_MEMORY_MAPPED)
240119a2:	687b      	ldr	r3, [r7, #4]
240119a4:	f1b3 6f40 	cmp.w	r3, #201326592	; 0xc000000
240119a8:	f000 80d6 	beq.w	24011b58 <QSPI_Config+0x300>
          WRITE_REG(hqspi->Instance->AR, cmd->Address);
240119ac:	68fb      	ldr	r3, [r7, #12]
240119ae:	681b      	ldr	r3, [r3, #0]
240119b0:	68ba      	ldr	r2, [r7, #8]
240119b2:	6852      	ldr	r2, [r2, #4]
240119b4:	619a      	str	r2, [r3, #24]
}
240119b6:	e0cf      	b.n	24011b58 <QSPI_Config+0x300>
        WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
240119b8:	68bb      	ldr	r3, [r7, #8]
240119ba:	6ada      	ldr	r2, [r3, #44]	; 0x2c
240119bc:	68bb      	ldr	r3, [r7, #8]
240119be:	6b1b      	ldr	r3, [r3, #48]	; 0x30
240119c0:	431a      	orrs	r2, r3
240119c2:	68bb      	ldr	r3, [r7, #8]
240119c4:	6b5b      	ldr	r3, [r3, #52]	; 0x34
240119c6:	431a      	orrs	r2, r3
240119c8:	68bb      	ldr	r3, [r7, #8]
240119ca:	6a5b      	ldr	r3, [r3, #36]	; 0x24
240119cc:	431a      	orrs	r2, r3
240119ce:	68bb      	ldr	r3, [r7, #8]
240119d0:	695b      	ldr	r3, [r3, #20]
240119d2:	049b      	lsls	r3, r3, #18
240119d4:	431a      	orrs	r2, r3
240119d6:	68bb      	ldr	r3, [r7, #8]
240119d8:	6a1b      	ldr	r3, [r3, #32]
240119da:	431a      	orrs	r2, r3
240119dc:	68bb      	ldr	r3, [r7, #8]
240119de:	69db      	ldr	r3, [r3, #28]
240119e0:	431a      	orrs	r2, r3
240119e2:	68bb      	ldr	r3, [r7, #8]
240119e4:	699b      	ldr	r3, [r3, #24]
240119e6:	431a      	orrs	r2, r3
240119e8:	68bb      	ldr	r3, [r7, #8]
240119ea:	681b      	ldr	r3, [r3, #0]
240119ec:	ea42 0103 	orr.w	r1, r2, r3
240119f0:	68fb      	ldr	r3, [r7, #12]
240119f2:	681b      	ldr	r3, [r3, #0]
240119f4:	687a      	ldr	r2, [r7, #4]
240119f6:	430a      	orrs	r2, r1
240119f8:	615a      	str	r2, [r3, #20]
}
240119fa:	e0ad      	b.n	24011b58 <QSPI_Config+0x300>
    if (cmd->AlternateByteMode != QSPI_ALTERNATE_BYTES_NONE)
240119fc:	68bb      	ldr	r3, [r7, #8]
240119fe:	6a1b      	ldr	r3, [r3, #32]
24011a00:	2b00      	cmp	r3, #0
24011a02:	d058      	beq.n	24011ab6 <QSPI_Config+0x25e>
      WRITE_REG(hqspi->Instance->ABR, cmd->AlternateBytes);
24011a04:	68fb      	ldr	r3, [r7, #12]
24011a06:	681b      	ldr	r3, [r3, #0]
24011a08:	68ba      	ldr	r2, [r7, #8]
24011a0a:	6892      	ldr	r2, [r2, #8]
24011a0c:	61da      	str	r2, [r3, #28]
      if (cmd->AddressMode != QSPI_ADDRESS_NONE)
24011a0e:	68bb      	ldr	r3, [r7, #8]
24011a10:	69db      	ldr	r3, [r3, #28]
24011a12:	2b00      	cmp	r3, #0
24011a14:	d02d      	beq.n	24011a72 <QSPI_Config+0x21a>
        WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
24011a16:	68bb      	ldr	r3, [r7, #8]
24011a18:	6ada      	ldr	r2, [r3, #44]	; 0x2c
24011a1a:	68bb      	ldr	r3, [r7, #8]
24011a1c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
24011a1e:	431a      	orrs	r2, r3
24011a20:	68bb      	ldr	r3, [r7, #8]
24011a22:	6b5b      	ldr	r3, [r3, #52]	; 0x34
24011a24:	431a      	orrs	r2, r3
24011a26:	68bb      	ldr	r3, [r7, #8]
24011a28:	6a5b      	ldr	r3, [r3, #36]	; 0x24
24011a2a:	431a      	orrs	r2, r3
24011a2c:	68bb      	ldr	r3, [r7, #8]
24011a2e:	695b      	ldr	r3, [r3, #20]
24011a30:	049b      	lsls	r3, r3, #18
24011a32:	431a      	orrs	r2, r3
24011a34:	68bb      	ldr	r3, [r7, #8]
24011a36:	691b      	ldr	r3, [r3, #16]
24011a38:	431a      	orrs	r2, r3
24011a3a:	68bb      	ldr	r3, [r7, #8]
24011a3c:	6a1b      	ldr	r3, [r3, #32]
24011a3e:	431a      	orrs	r2, r3
24011a40:	68bb      	ldr	r3, [r7, #8]
24011a42:	68db      	ldr	r3, [r3, #12]
24011a44:	431a      	orrs	r2, r3
24011a46:	68bb      	ldr	r3, [r7, #8]
24011a48:	69db      	ldr	r3, [r3, #28]
24011a4a:	431a      	orrs	r2, r3
24011a4c:	68bb      	ldr	r3, [r7, #8]
24011a4e:	699b      	ldr	r3, [r3, #24]
24011a50:	ea42 0103 	orr.w	r1, r2, r3
24011a54:	68fb      	ldr	r3, [r7, #12]
24011a56:	681b      	ldr	r3, [r3, #0]
24011a58:	687a      	ldr	r2, [r7, #4]
24011a5a:	430a      	orrs	r2, r1
24011a5c:	615a      	str	r2, [r3, #20]
        if (FunctionalMode != QSPI_FUNCTIONAL_MODE_MEMORY_MAPPED)
24011a5e:	687b      	ldr	r3, [r7, #4]
24011a60:	f1b3 6f40 	cmp.w	r3, #201326592	; 0xc000000
24011a64:	d078      	beq.n	24011b58 <QSPI_Config+0x300>
          WRITE_REG(hqspi->Instance->AR, cmd->Address);
24011a66:	68fb      	ldr	r3, [r7, #12]
24011a68:	681b      	ldr	r3, [r3, #0]
24011a6a:	68ba      	ldr	r2, [r7, #8]
24011a6c:	6852      	ldr	r2, [r2, #4]
24011a6e:	619a      	str	r2, [r3, #24]
}
24011a70:	e072      	b.n	24011b58 <QSPI_Config+0x300>
        WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
24011a72:	68bb      	ldr	r3, [r7, #8]
24011a74:	6ada      	ldr	r2, [r3, #44]	; 0x2c
24011a76:	68bb      	ldr	r3, [r7, #8]
24011a78:	6b1b      	ldr	r3, [r3, #48]	; 0x30
24011a7a:	431a      	orrs	r2, r3
24011a7c:	68bb      	ldr	r3, [r7, #8]
24011a7e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
24011a80:	431a      	orrs	r2, r3
24011a82:	68bb      	ldr	r3, [r7, #8]
24011a84:	6a5b      	ldr	r3, [r3, #36]	; 0x24
24011a86:	431a      	orrs	r2, r3
24011a88:	68bb      	ldr	r3, [r7, #8]
24011a8a:	695b      	ldr	r3, [r3, #20]
24011a8c:	049b      	lsls	r3, r3, #18
24011a8e:	431a      	orrs	r2, r3
24011a90:	68bb      	ldr	r3, [r7, #8]
24011a92:	691b      	ldr	r3, [r3, #16]
24011a94:	431a      	orrs	r2, r3
24011a96:	68bb      	ldr	r3, [r7, #8]
24011a98:	6a1b      	ldr	r3, [r3, #32]
24011a9a:	431a      	orrs	r2, r3
24011a9c:	68bb      	ldr	r3, [r7, #8]
24011a9e:	69db      	ldr	r3, [r3, #28]
24011aa0:	431a      	orrs	r2, r3
24011aa2:	68bb      	ldr	r3, [r7, #8]
24011aa4:	699b      	ldr	r3, [r3, #24]
24011aa6:	ea42 0103 	orr.w	r1, r2, r3
24011aaa:	68fb      	ldr	r3, [r7, #12]
24011aac:	681b      	ldr	r3, [r3, #0]
24011aae:	687a      	ldr	r2, [r7, #4]
24011ab0:	430a      	orrs	r2, r1
24011ab2:	615a      	str	r2, [r3, #20]
}
24011ab4:	e050      	b.n	24011b58 <QSPI_Config+0x300>
      if (cmd->AddressMode != QSPI_ADDRESS_NONE)
24011ab6:	68bb      	ldr	r3, [r7, #8]
24011ab8:	69db      	ldr	r3, [r3, #28]
24011aba:	2b00      	cmp	r3, #0
24011abc:	d02a      	beq.n	24011b14 <QSPI_Config+0x2bc>
        WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
24011abe:	68bb      	ldr	r3, [r7, #8]
24011ac0:	6ada      	ldr	r2, [r3, #44]	; 0x2c
24011ac2:	68bb      	ldr	r3, [r7, #8]
24011ac4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
24011ac6:	431a      	orrs	r2, r3
24011ac8:	68bb      	ldr	r3, [r7, #8]
24011aca:	6b5b      	ldr	r3, [r3, #52]	; 0x34
24011acc:	431a      	orrs	r2, r3
24011ace:	68bb      	ldr	r3, [r7, #8]
24011ad0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
24011ad2:	431a      	orrs	r2, r3
24011ad4:	68bb      	ldr	r3, [r7, #8]
24011ad6:	695b      	ldr	r3, [r3, #20]
24011ad8:	049b      	lsls	r3, r3, #18
24011ada:	431a      	orrs	r2, r3
24011adc:	68bb      	ldr	r3, [r7, #8]
24011ade:	6a1b      	ldr	r3, [r3, #32]
24011ae0:	431a      	orrs	r2, r3
24011ae2:	68bb      	ldr	r3, [r7, #8]
24011ae4:	68db      	ldr	r3, [r3, #12]
24011ae6:	431a      	orrs	r2, r3
24011ae8:	68bb      	ldr	r3, [r7, #8]
24011aea:	69db      	ldr	r3, [r3, #28]
24011aec:	431a      	orrs	r2, r3
24011aee:	68bb      	ldr	r3, [r7, #8]
24011af0:	699b      	ldr	r3, [r3, #24]
24011af2:	ea42 0103 	orr.w	r1, r2, r3
24011af6:	68fb      	ldr	r3, [r7, #12]
24011af8:	681b      	ldr	r3, [r3, #0]
24011afa:	687a      	ldr	r2, [r7, #4]
24011afc:	430a      	orrs	r2, r1
24011afe:	615a      	str	r2, [r3, #20]
        if (FunctionalMode != QSPI_FUNCTIONAL_MODE_MEMORY_MAPPED)
24011b00:	687b      	ldr	r3, [r7, #4]
24011b02:	f1b3 6f40 	cmp.w	r3, #201326592	; 0xc000000
24011b06:	d027      	beq.n	24011b58 <QSPI_Config+0x300>
          WRITE_REG(hqspi->Instance->AR, cmd->Address);
24011b08:	68fb      	ldr	r3, [r7, #12]
24011b0a:	681b      	ldr	r3, [r3, #0]
24011b0c:	68ba      	ldr	r2, [r7, #8]
24011b0e:	6852      	ldr	r2, [r2, #4]
24011b10:	619a      	str	r2, [r3, #24]
}
24011b12:	e021      	b.n	24011b58 <QSPI_Config+0x300>
        if (cmd->DataMode != QSPI_DATA_NONE)
24011b14:	68bb      	ldr	r3, [r7, #8]
24011b16:	6a5b      	ldr	r3, [r3, #36]	; 0x24
24011b18:	2b00      	cmp	r3, #0
24011b1a:	d01d      	beq.n	24011b58 <QSPI_Config+0x300>
          WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
24011b1c:	68bb      	ldr	r3, [r7, #8]
24011b1e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
24011b20:	68bb      	ldr	r3, [r7, #8]
24011b22:	6b1b      	ldr	r3, [r3, #48]	; 0x30
24011b24:	431a      	orrs	r2, r3
24011b26:	68bb      	ldr	r3, [r7, #8]
24011b28:	6b5b      	ldr	r3, [r3, #52]	; 0x34
24011b2a:	431a      	orrs	r2, r3
24011b2c:	68bb      	ldr	r3, [r7, #8]
24011b2e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
24011b30:	431a      	orrs	r2, r3
24011b32:	68bb      	ldr	r3, [r7, #8]
24011b34:	695b      	ldr	r3, [r3, #20]
24011b36:	049b      	lsls	r3, r3, #18
24011b38:	431a      	orrs	r2, r3
24011b3a:	68bb      	ldr	r3, [r7, #8]
24011b3c:	6a1b      	ldr	r3, [r3, #32]
24011b3e:	431a      	orrs	r2, r3
24011b40:	68bb      	ldr	r3, [r7, #8]
24011b42:	69db      	ldr	r3, [r3, #28]
24011b44:	431a      	orrs	r2, r3
24011b46:	68bb      	ldr	r3, [r7, #8]
24011b48:	699b      	ldr	r3, [r3, #24]
24011b4a:	ea42 0103 	orr.w	r1, r2, r3
24011b4e:	68fb      	ldr	r3, [r7, #12]
24011b50:	681b      	ldr	r3, [r3, #0]
24011b52:	687a      	ldr	r2, [r7, #4]
24011b54:	430a      	orrs	r2, r1
24011b56:	615a      	str	r2, [r3, #20]
}
24011b58:	bf00      	nop
24011b5a:	3714      	adds	r7, #20
24011b5c:	46bd      	mov	sp, r7
24011b5e:	f85d 7b04 	ldr.w	r7, [sp], #4
24011b62:	4770      	bx	lr

24011b64 <HAL_RCC_DeInit>:
  *            - Peripheral clocks
  *            - LSI, LSE and RTC clocks
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_DeInit(void)
{
24011b64:	b580      	push	{r7, lr}
24011b66:	b082      	sub	sp, #8
24011b68:	af00      	add	r7, sp, #0
  uint32_t tickstart;

        /* Increasing the CPU frequency */
  if(FLASH_LATENCY_DEFAULT  > __HAL_FLASH_GET_LATENCY())
24011b6a:	4b89      	ldr	r3, [pc, #548]	; (24011d90 <HAL_RCC_DeInit+0x22c>)
24011b6c:	681b      	ldr	r3, [r3, #0]
24011b6e:	f003 030f 	and.w	r3, r3, #15
24011b72:	2b06      	cmp	r3, #6
24011b74:	d80f      	bhi.n	24011b96 <HAL_RCC_DeInit+0x32>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLASH_LATENCY_DEFAULT);
24011b76:	4b86      	ldr	r3, [pc, #536]	; (24011d90 <HAL_RCC_DeInit+0x22c>)
24011b78:	681b      	ldr	r3, [r3, #0]
24011b7a:	f023 030f 	bic.w	r3, r3, #15
24011b7e:	4a84      	ldr	r2, [pc, #528]	; (24011d90 <HAL_RCC_DeInit+0x22c>)
24011b80:	f043 0307 	orr.w	r3, r3, #7
24011b84:	6013      	str	r3, [r2, #0]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if(__HAL_FLASH_GET_LATENCY() != FLASH_LATENCY_DEFAULT)
24011b86:	4b82      	ldr	r3, [pc, #520]	; (24011d90 <HAL_RCC_DeInit+0x22c>)
24011b88:	681b      	ldr	r3, [r3, #0]
24011b8a:	f003 030f 	and.w	r3, r3, #15
24011b8e:	2b07      	cmp	r3, #7
24011b90:	d001      	beq.n	24011b96 <HAL_RCC_DeInit+0x32>
    {
      return HAL_ERROR;
24011b92:	2301      	movs	r3, #1
24011b94:	e0f7      	b.n	24011d86 <HAL_RCC_DeInit+0x222>

  }


  /* Get Start Tick */
  tickstart = HAL_GetTick();
24011b96:	f7ee fe5d 	bl	24000854 <HAL_GetTick>
24011b9a:	6078      	str	r0, [r7, #4]

  /* Set HSION bit */
  SET_BIT(RCC->CR, RCC_CR_HSION);
24011b9c:	4b7d      	ldr	r3, [pc, #500]	; (24011d94 <HAL_RCC_DeInit+0x230>)
24011b9e:	681b      	ldr	r3, [r3, #0]
24011ba0:	4a7c      	ldr	r2, [pc, #496]	; (24011d94 <HAL_RCC_DeInit+0x230>)
24011ba2:	f043 0301 	orr.w	r3, r3, #1
24011ba6:	6013      	str	r3, [r2, #0]

  /* Wait till HSI is ready */
  while (READ_BIT(RCC->CR, RCC_CR_HSIRDY) == 0U)
24011ba8:	e008      	b.n	24011bbc <HAL_RCC_DeInit+0x58>
  {
    if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
24011baa:	f7ee fe53 	bl	24000854 <HAL_GetTick>
24011bae:	4602      	mov	r2, r0
24011bb0:	687b      	ldr	r3, [r7, #4]
24011bb2:	1ad3      	subs	r3, r2, r3
24011bb4:	2b02      	cmp	r3, #2
24011bb6:	d901      	bls.n	24011bbc <HAL_RCC_DeInit+0x58>
    {
      return HAL_TIMEOUT;
24011bb8:	2303      	movs	r3, #3
24011bba:	e0e4      	b.n	24011d86 <HAL_RCC_DeInit+0x222>
  while (READ_BIT(RCC->CR, RCC_CR_HSIRDY) == 0U)
24011bbc:	4b75      	ldr	r3, [pc, #468]	; (24011d94 <HAL_RCC_DeInit+0x230>)
24011bbe:	681b      	ldr	r3, [r3, #0]
24011bc0:	f003 0304 	and.w	r3, r3, #4
24011bc4:	2b00      	cmp	r3, #0
24011bc6:	d0f0      	beq.n	24011baa <HAL_RCC_DeInit+0x46>
    }
  }

  /* Set HSITRIM[6:0] bits to the reset value */
  SET_BIT(RCC->HSICFGR, RCC_HSICFGR_HSITRIM_6);
24011bc8:	4b72      	ldr	r3, [pc, #456]	; (24011d94 <HAL_RCC_DeInit+0x230>)
24011bca:	685b      	ldr	r3, [r3, #4]
24011bcc:	4a71      	ldr	r2, [pc, #452]	; (24011d94 <HAL_RCC_DeInit+0x230>)
24011bce:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
24011bd2:	6053      	str	r3, [r2, #4]

  /* Reset CFGR register */
  CLEAR_REG(RCC->CFGR);
24011bd4:	4b6f      	ldr	r3, [pc, #444]	; (24011d94 <HAL_RCC_DeInit+0x230>)
24011bd6:	2200      	movs	r2, #0
24011bd8:	611a      	str	r2, [r3, #16]

  /* Update the SystemCoreClock and SystemD2Clock global variables */
  SystemCoreClock = HSI_VALUE;
24011bda:	4b6f      	ldr	r3, [pc, #444]	; (24011d98 <HAL_RCC_DeInit+0x234>)
24011bdc:	4a6f      	ldr	r2, [pc, #444]	; (24011d9c <HAL_RCC_DeInit+0x238>)
24011bde:	601a      	str	r2, [r3, #0]
  SystemD2Clock = HSI_VALUE;
24011be0:	4b6f      	ldr	r3, [pc, #444]	; (24011da0 <HAL_RCC_DeInit+0x23c>)
24011be2:	4a6e      	ldr	r2, [pc, #440]	; (24011d9c <HAL_RCC_DeInit+0x238>)
24011be4:	601a      	str	r2, [r3, #0]

  /* Adapt Systick interrupt period */
  if(HAL_InitTick(uwTickPrio) != HAL_OK)
24011be6:	4b6f      	ldr	r3, [pc, #444]	; (24011da4 <HAL_RCC_DeInit+0x240>)
24011be8:	681b      	ldr	r3, [r3, #0]
24011bea:	4618      	mov	r0, r3
24011bec:	f7ee fde8 	bl	240007c0 <HAL_InitTick>
24011bf0:	4603      	mov	r3, r0
24011bf2:	2b00      	cmp	r3, #0
24011bf4:	d001      	beq.n	24011bfa <HAL_RCC_DeInit+0x96>
  {
    return HAL_ERROR;
24011bf6:	2301      	movs	r3, #1
24011bf8:	e0c5      	b.n	24011d86 <HAL_RCC_DeInit+0x222>
  }

  /* Get Start Tick */
  tickstart = HAL_GetTick();
24011bfa:	f7ee fe2b 	bl	24000854 <HAL_GetTick>
24011bfe:	6078      	str	r0, [r7, #4]

  /* Wait till clock switch is ready */
  while (READ_BIT(RCC->CFGR, RCC_CFGR_SWS) != 0U)
24011c00:	e00a      	b.n	24011c18 <HAL_RCC_DeInit+0xb4>
  {
    if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
24011c02:	f7ee fe27 	bl	24000854 <HAL_GetTick>
24011c06:	4602      	mov	r2, r0
24011c08:	687b      	ldr	r3, [r7, #4]
24011c0a:	1ad3      	subs	r3, r2, r3
24011c0c:	f241 3288 	movw	r2, #5000	; 0x1388
24011c10:	4293      	cmp	r3, r2
24011c12:	d901      	bls.n	24011c18 <HAL_RCC_DeInit+0xb4>
    {
      return HAL_TIMEOUT;
24011c14:	2303      	movs	r3, #3
24011c16:	e0b6      	b.n	24011d86 <HAL_RCC_DeInit+0x222>
  while (READ_BIT(RCC->CFGR, RCC_CFGR_SWS) != 0U)
24011c18:	4b5e      	ldr	r3, [pc, #376]	; (24011d94 <HAL_RCC_DeInit+0x230>)
24011c1a:	691b      	ldr	r3, [r3, #16]
24011c1c:	f003 0338 	and.w	r3, r3, #56	; 0x38
24011c20:	2b00      	cmp	r3, #0
24011c22:	d1ee      	bne.n	24011c02 <HAL_RCC_DeInit+0x9e>
    }
  }

  /* Get Start Tick */
  tickstart = HAL_GetTick();
24011c24:	f7ee fe16 	bl	24000854 <HAL_GetTick>
24011c28:	6078      	str	r0, [r7, #4]

  /* Reset CSION, CSIKERON, HSEON, HSI48ON, HSECSSON, HSIDIV bits */
  CLEAR_BIT(RCC->CR, RCC_CR_HSEON | RCC_CR_HSIKERON| RCC_CR_HSIDIV| RCC_CR_HSIDIVF| RCC_CR_CSION | RCC_CR_CSIKERON  \
24011c2a:	4b5a      	ldr	r3, [pc, #360]	; (24011d94 <HAL_RCC_DeInit+0x230>)
24011c2c:	681a      	ldr	r2, [r3, #0]
24011c2e:	4959      	ldr	r1, [pc, #356]	; (24011d94 <HAL_RCC_DeInit+0x230>)
24011c30:	4b5d      	ldr	r3, [pc, #372]	; (24011da8 <HAL_RCC_DeInit+0x244>)
24011c32:	4013      	ands	r3, r2
24011c34:	600b      	str	r3, [r1, #0]
  | RCC_CR_HSI48ON | RCC_CR_CSSHSEON);

  /* Wait till HSE is disabled */
  while (READ_BIT(RCC->CR, RCC_CR_HSERDY) != 0U)
24011c36:	e008      	b.n	24011c4a <HAL_RCC_DeInit+0xe6>
  {
    if ((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
24011c38:	f7ee fe0c 	bl	24000854 <HAL_GetTick>
24011c3c:	4602      	mov	r2, r0
24011c3e:	687b      	ldr	r3, [r7, #4]
24011c40:	1ad3      	subs	r3, r2, r3
24011c42:	2b64      	cmp	r3, #100	; 0x64
24011c44:	d901      	bls.n	24011c4a <HAL_RCC_DeInit+0xe6>
    {
      return HAL_TIMEOUT;
24011c46:	2303      	movs	r3, #3
24011c48:	e09d      	b.n	24011d86 <HAL_RCC_DeInit+0x222>
  while (READ_BIT(RCC->CR, RCC_CR_HSERDY) != 0U)
24011c4a:	4b52      	ldr	r3, [pc, #328]	; (24011d94 <HAL_RCC_DeInit+0x230>)
24011c4c:	681b      	ldr	r3, [r3, #0]
24011c4e:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
24011c52:	2b00      	cmp	r3, #0
24011c54:	d1f0      	bne.n	24011c38 <HAL_RCC_DeInit+0xd4>
    }
  }

  /* Get Start Tick */
  tickstart = HAL_GetTick();
24011c56:	f7ee fdfd 	bl	24000854 <HAL_GetTick>
24011c5a:	6078      	str	r0, [r7, #4]

  /* Clear PLLON bit */
  CLEAR_BIT(RCC->CR, RCC_CR_PLL1ON);
24011c5c:	4b4d      	ldr	r3, [pc, #308]	; (24011d94 <HAL_RCC_DeInit+0x230>)
24011c5e:	681b      	ldr	r3, [r3, #0]
24011c60:	4a4c      	ldr	r2, [pc, #304]	; (24011d94 <HAL_RCC_DeInit+0x230>)
24011c62:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
24011c66:	6013      	str	r3, [r2, #0]

  /* Wait till PLL is disabled */
  while (READ_BIT(RCC->CR, RCC_CR_PLL1RDY) != 0U)
24011c68:	e008      	b.n	24011c7c <HAL_RCC_DeInit+0x118>
  {
    if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
24011c6a:	f7ee fdf3 	bl	24000854 <HAL_GetTick>
24011c6e:	4602      	mov	r2, r0
24011c70:	687b      	ldr	r3, [r7, #4]
24011c72:	1ad3      	subs	r3, r2, r3
24011c74:	2b02      	cmp	r3, #2
24011c76:	d901      	bls.n	24011c7c <HAL_RCC_DeInit+0x118>
    {
      return HAL_TIMEOUT;
24011c78:	2303      	movs	r3, #3
24011c7a:	e084      	b.n	24011d86 <HAL_RCC_DeInit+0x222>
  while (READ_BIT(RCC->CR, RCC_CR_PLL1RDY) != 0U)
24011c7c:	4b45      	ldr	r3, [pc, #276]	; (24011d94 <HAL_RCC_DeInit+0x230>)
24011c7e:	681b      	ldr	r3, [r3, #0]
24011c80:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
24011c84:	2b00      	cmp	r3, #0
24011c86:	d1f0      	bne.n	24011c6a <HAL_RCC_DeInit+0x106>
    }
  }

  /* Get Start Tick */
  tickstart = HAL_GetTick();
24011c88:	f7ee fde4 	bl	24000854 <HAL_GetTick>
24011c8c:	6078      	str	r0, [r7, #4]

  /* Reset PLL2ON bit */
  CLEAR_BIT(RCC->CR, RCC_CR_PLL2ON);
24011c8e:	4b41      	ldr	r3, [pc, #260]	; (24011d94 <HAL_RCC_DeInit+0x230>)
24011c90:	681b      	ldr	r3, [r3, #0]
24011c92:	4a40      	ldr	r2, [pc, #256]	; (24011d94 <HAL_RCC_DeInit+0x230>)
24011c94:	f023 6380 	bic.w	r3, r3, #67108864	; 0x4000000
24011c98:	6013      	str	r3, [r2, #0]

  /* Wait till PLL2 is disabled */
  while (READ_BIT(RCC->CR, RCC_CR_PLL2RDY) != 0U)
24011c9a:	e008      	b.n	24011cae <HAL_RCC_DeInit+0x14a>
  {
    if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
24011c9c:	f7ee fdda 	bl	24000854 <HAL_GetTick>
24011ca0:	4602      	mov	r2, r0
24011ca2:	687b      	ldr	r3, [r7, #4]
24011ca4:	1ad3      	subs	r3, r2, r3
24011ca6:	2b02      	cmp	r3, #2
24011ca8:	d901      	bls.n	24011cae <HAL_RCC_DeInit+0x14a>
    {
      return HAL_TIMEOUT;
24011caa:	2303      	movs	r3, #3
24011cac:	e06b      	b.n	24011d86 <HAL_RCC_DeInit+0x222>
  while (READ_BIT(RCC->CR, RCC_CR_PLL2RDY) != 0U)
24011cae:	4b39      	ldr	r3, [pc, #228]	; (24011d94 <HAL_RCC_DeInit+0x230>)
24011cb0:	681b      	ldr	r3, [r3, #0]
24011cb2:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
24011cb6:	2b00      	cmp	r3, #0
24011cb8:	d1f0      	bne.n	24011c9c <HAL_RCC_DeInit+0x138>
    }
  }

  /* Get Start Tick */
  tickstart = HAL_GetTick();
24011cba:	f7ee fdcb 	bl	24000854 <HAL_GetTick>
24011cbe:	6078      	str	r0, [r7, #4]

  /* Reset PLL3 bit */
  CLEAR_BIT(RCC->CR, RCC_CR_PLL3ON);
24011cc0:	4b34      	ldr	r3, [pc, #208]	; (24011d94 <HAL_RCC_DeInit+0x230>)
24011cc2:	681b      	ldr	r3, [r3, #0]
24011cc4:	4a33      	ldr	r2, [pc, #204]	; (24011d94 <HAL_RCC_DeInit+0x230>)
24011cc6:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
24011cca:	6013      	str	r3, [r2, #0]

  /* Wait till PLL3 is disabled */
  while (READ_BIT(RCC->CR, RCC_CR_PLL3RDY) != 0U)
24011ccc:	e008      	b.n	24011ce0 <HAL_RCC_DeInit+0x17c>
  {
    if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
24011cce:	f7ee fdc1 	bl	24000854 <HAL_GetTick>
24011cd2:	4602      	mov	r2, r0
24011cd4:	687b      	ldr	r3, [r7, #4]
24011cd6:	1ad3      	subs	r3, r2, r3
24011cd8:	2b02      	cmp	r3, #2
24011cda:	d901      	bls.n	24011ce0 <HAL_RCC_DeInit+0x17c>
    {
      return HAL_TIMEOUT;
24011cdc:	2303      	movs	r3, #3
24011cde:	e052      	b.n	24011d86 <HAL_RCC_DeInit+0x222>
  while (READ_BIT(RCC->CR, RCC_CR_PLL3RDY) != 0U)
24011ce0:	4b2c      	ldr	r3, [pc, #176]	; (24011d94 <HAL_RCC_DeInit+0x230>)
24011ce2:	681b      	ldr	r3, [r3, #0]
24011ce4:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
24011ce8:	2b00      	cmp	r3, #0
24011cea:	d1f0      	bne.n	24011cce <HAL_RCC_DeInit+0x16a>
    }
  }

#if defined(RCC_D1CFGR_HPRE)
  /* Reset D1CFGR register */
  CLEAR_REG(RCC->D1CFGR);
24011cec:	4b29      	ldr	r3, [pc, #164]	; (24011d94 <HAL_RCC_DeInit+0x230>)
24011cee:	2200      	movs	r2, #0
24011cf0:	619a      	str	r2, [r3, #24]

  /* Reset D2CFGR register */
  CLEAR_REG(RCC->D2CFGR);
24011cf2:	4b28      	ldr	r3, [pc, #160]	; (24011d94 <HAL_RCC_DeInit+0x230>)
24011cf4:	2200      	movs	r2, #0
24011cf6:	61da      	str	r2, [r3, #28]

  /* Reset D3CFGR register */
  CLEAR_REG(RCC->D3CFGR);
24011cf8:	4b26      	ldr	r3, [pc, #152]	; (24011d94 <HAL_RCC_DeInit+0x230>)
24011cfa:	2200      	movs	r2, #0
24011cfc:	621a      	str	r2, [r3, #32]
  /* Reset SRDCFGR register */
  CLEAR_REG(RCC->SRDCFGR);
#endif

  /* Reset PLLCKSELR register to default value */
  RCC->PLLCKSELR= RCC_PLLCKSELR_DIVM1_5|RCC_PLLCKSELR_DIVM2_5|RCC_PLLCKSELR_DIVM3_5;
24011cfe:	4b25      	ldr	r3, [pc, #148]	; (24011d94 <HAL_RCC_DeInit+0x230>)
24011d00:	4a2a      	ldr	r2, [pc, #168]	; (24011dac <HAL_RCC_DeInit+0x248>)
24011d02:	629a      	str	r2, [r3, #40]	; 0x28

  /* Reset PLLCFGR register to default value */
  WRITE_REG(RCC->PLLCFGR, 0x01FF0000U);
24011d04:	4b23      	ldr	r3, [pc, #140]	; (24011d94 <HAL_RCC_DeInit+0x230>)
24011d06:	4a2a      	ldr	r2, [pc, #168]	; (24011db0 <HAL_RCC_DeInit+0x24c>)
24011d08:	62da      	str	r2, [r3, #44]	; 0x2c

  /* Reset PLL1DIVR register to default value */
  WRITE_REG(RCC->PLL1DIVR,0x01010280U);
24011d0a:	4b22      	ldr	r3, [pc, #136]	; (24011d94 <HAL_RCC_DeInit+0x230>)
24011d0c:	4a29      	ldr	r2, [pc, #164]	; (24011db4 <HAL_RCC_DeInit+0x250>)
24011d0e:	631a      	str	r2, [r3, #48]	; 0x30

  /* Reset PLL1FRACR register */
  CLEAR_REG(RCC->PLL1FRACR);
24011d10:	4b20      	ldr	r3, [pc, #128]	; (24011d94 <HAL_RCC_DeInit+0x230>)
24011d12:	2200      	movs	r2, #0
24011d14:	635a      	str	r2, [r3, #52]	; 0x34

  /* Reset PLL2DIVR register to default value */
  WRITE_REG(RCC->PLL2DIVR,0x01010280U);
24011d16:	4b1f      	ldr	r3, [pc, #124]	; (24011d94 <HAL_RCC_DeInit+0x230>)
24011d18:	4a26      	ldr	r2, [pc, #152]	; (24011db4 <HAL_RCC_DeInit+0x250>)
24011d1a:	639a      	str	r2, [r3, #56]	; 0x38

  /* Reset PLL2FRACR register */
  CLEAR_REG(RCC->PLL2FRACR);
24011d1c:	4b1d      	ldr	r3, [pc, #116]	; (24011d94 <HAL_RCC_DeInit+0x230>)
24011d1e:	2200      	movs	r2, #0
24011d20:	63da      	str	r2, [r3, #60]	; 0x3c

  /* Reset PLL3DIVR register to default value */
  WRITE_REG(RCC->PLL3DIVR,0x01010280U);
24011d22:	4b1c      	ldr	r3, [pc, #112]	; (24011d94 <HAL_RCC_DeInit+0x230>)
24011d24:	4a23      	ldr	r2, [pc, #140]	; (24011db4 <HAL_RCC_DeInit+0x250>)
24011d26:	641a      	str	r2, [r3, #64]	; 0x40

  /* Reset PLL3FRACR register */
  CLEAR_REG(RCC->PLL3FRACR);
24011d28:	4b1a      	ldr	r3, [pc, #104]	; (24011d94 <HAL_RCC_DeInit+0x230>)
24011d2a:	2200      	movs	r2, #0
24011d2c:	645a      	str	r2, [r3, #68]	; 0x44

  /* Reset HSEBYP bit */
  CLEAR_BIT(RCC->CR, RCC_CR_HSEBYP);
24011d2e:	4b19      	ldr	r3, [pc, #100]	; (24011d94 <HAL_RCC_DeInit+0x230>)
24011d30:	681b      	ldr	r3, [r3, #0]
24011d32:	4a18      	ldr	r2, [pc, #96]	; (24011d94 <HAL_RCC_DeInit+0x230>)
24011d34:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
24011d38:	6013      	str	r3, [r2, #0]

  /* Disable all interrupts */
  CLEAR_REG(RCC->CIER);
24011d3a:	4b16      	ldr	r3, [pc, #88]	; (24011d94 <HAL_RCC_DeInit+0x230>)
24011d3c:	2200      	movs	r2, #0
24011d3e:	661a      	str	r2, [r3, #96]	; 0x60

  /* Clear all interrupts flags */
  WRITE_REG(RCC->CICR,0xFFFFFFFFU);
24011d40:	4b14      	ldr	r3, [pc, #80]	; (24011d94 <HAL_RCC_DeInit+0x230>)
24011d42:	f04f 32ff 	mov.w	r2, #4294967295
24011d46:	669a      	str	r2, [r3, #104]	; 0x68

  /* Reset all RSR flags */
  SET_BIT(RCC->RSR, RCC_RSR_RMVF);
24011d48:	4b12      	ldr	r3, [pc, #72]	; (24011d94 <HAL_RCC_DeInit+0x230>)
24011d4a:	f8d3 30d0 	ldr.w	r3, [r3, #208]	; 0xd0
24011d4e:	4a11      	ldr	r2, [pc, #68]	; (24011d94 <HAL_RCC_DeInit+0x230>)
24011d50:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
24011d54:	f8c2 30d0 	str.w	r3, [r2, #208]	; 0xd0

      /* Decreasing the number of wait states because of lower CPU frequency */
  if(FLASH_LATENCY_DEFAULT  < __HAL_FLASH_GET_LATENCY())
24011d58:	4b0d      	ldr	r3, [pc, #52]	; (24011d90 <HAL_RCC_DeInit+0x22c>)
24011d5a:	681b      	ldr	r3, [r3, #0]
24011d5c:	f003 030f 	and.w	r3, r3, #15
24011d60:	2b07      	cmp	r3, #7
24011d62:	d90f      	bls.n	24011d84 <HAL_RCC_DeInit+0x220>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLASH_LATENCY_DEFAULT);
24011d64:	4b0a      	ldr	r3, [pc, #40]	; (24011d90 <HAL_RCC_DeInit+0x22c>)
24011d66:	681b      	ldr	r3, [r3, #0]
24011d68:	f023 030f 	bic.w	r3, r3, #15
24011d6c:	4a08      	ldr	r2, [pc, #32]	; (24011d90 <HAL_RCC_DeInit+0x22c>)
24011d6e:	f043 0307 	orr.w	r3, r3, #7
24011d72:	6013      	str	r3, [r2, #0]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if(__HAL_FLASH_GET_LATENCY() != FLASH_LATENCY_DEFAULT)
24011d74:	4b06      	ldr	r3, [pc, #24]	; (24011d90 <HAL_RCC_DeInit+0x22c>)
24011d76:	681b      	ldr	r3, [r3, #0]
24011d78:	f003 030f 	and.w	r3, r3, #15
24011d7c:	2b07      	cmp	r3, #7
24011d7e:	d001      	beq.n	24011d84 <HAL_RCC_DeInit+0x220>
    {
      return HAL_ERROR;
24011d80:	2301      	movs	r3, #1
24011d82:	e000      	b.n	24011d86 <HAL_RCC_DeInit+0x222>
    }

}

  return HAL_OK;
24011d84:	2300      	movs	r3, #0
}
24011d86:	4618      	mov	r0, r3
24011d88:	3708      	adds	r7, #8
24011d8a:	46bd      	mov	sp, r7
24011d8c:	bd80      	pop	{r7, pc}
24011d8e:	bf00      	nop
24011d90:	52002000 	.word	0x52002000
24011d94:	58024400 	.word	0x58024400
24011d98:	240004b8 	.word	0x240004b8
24011d9c:	03d09000 	.word	0x03d09000
24011da0:	240004bc 	.word	0x240004bc
24011da4:	240004ac 	.word	0x240004ac
24011da8:	fff6ed45 	.word	0xfff6ed45
24011dac:	02020200 	.word	0x02020200
24011db0:	01ff0000 	.word	0x01ff0000
24011db4:	01010280 	.word	0x01010280

24011db8 <HAL_RCC_OscConfig>:
  *         supported by this function. User should request a transition to HSE Off
  *         first and then HSE On or HSE Bypass.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
24011db8:	b580      	push	{r7, lr}
24011dba:	b08c      	sub	sp, #48	; 0x30
24011dbc:	af00      	add	r7, sp, #0
24011dbe:	6078      	str	r0, [r7, #4]
  uint32_t tickstart;
  uint32_t temp1_pllckcfg, temp2_pllckcfg;

    /* Check Null pointer */
  if(RCC_OscInitStruct == NULL)
24011dc0:	687b      	ldr	r3, [r7, #4]
24011dc2:	2b00      	cmp	r3, #0
24011dc4:	d101      	bne.n	24011dca <HAL_RCC_OscConfig+0x12>
  {
    return HAL_ERROR;
24011dc6:	2301      	movs	r3, #1
24011dc8:	e3c4      	b.n	24012554 <HAL_RCC_OscConfig+0x79c>
  }

  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
  /*------------------------------- HSE Configuration ------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
24011dca:	687b      	ldr	r3, [r7, #4]
24011dcc:	681b      	ldr	r3, [r3, #0]
24011dce:	f003 0301 	and.w	r3, r3, #1
24011dd2:	2b00      	cmp	r3, #0
24011dd4:	f000 8087 	beq.w	24011ee6 <HAL_RCC_OscConfig+0x12e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));

    const uint32_t temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
24011dd8:	4ba2      	ldr	r3, [pc, #648]	; (24012064 <HAL_RCC_OscConfig+0x2ac>)
24011dda:	691b      	ldr	r3, [r3, #16]
24011ddc:	f003 0338 	and.w	r3, r3, #56	; 0x38
24011de0:	62fb      	str	r3, [r7, #44]	; 0x2c
    const uint32_t temp_pllckselr = RCC->PLLCKSELR;
24011de2:	4ba0      	ldr	r3, [pc, #640]	; (24012064 <HAL_RCC_OscConfig+0x2ac>)
24011de4:	6a9b      	ldr	r3, [r3, #40]	; 0x28
24011de6:	62bb      	str	r3, [r7, #40]	; 0x28
    /* When the HSE is used as system clock or clock source for PLL in these cases HSE will not disabled */
    if((temp_sysclksrc == RCC_CFGR_SWS_HSE) || ((temp_sysclksrc == RCC_CFGR_SWS_PLL1) && ((temp_pllckselr & RCC_PLLCKSELR_PLLSRC) == RCC_PLLCKSELR_PLLSRC_HSE)))
24011de8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
24011dea:	2b10      	cmp	r3, #16
24011dec:	d007      	beq.n	24011dfe <HAL_RCC_OscConfig+0x46>
24011dee:	6afb      	ldr	r3, [r7, #44]	; 0x2c
24011df0:	2b18      	cmp	r3, #24
24011df2:	d110      	bne.n	24011e16 <HAL_RCC_OscConfig+0x5e>
24011df4:	6abb      	ldr	r3, [r7, #40]	; 0x28
24011df6:	f003 0303 	and.w	r3, r3, #3
24011dfa:	2b02      	cmp	r3, #2
24011dfc:	d10b      	bne.n	24011e16 <HAL_RCC_OscConfig+0x5e>
    {
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != 0U) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
24011dfe:	4b99      	ldr	r3, [pc, #612]	; (24012064 <HAL_RCC_OscConfig+0x2ac>)
24011e00:	681b      	ldr	r3, [r3, #0]
24011e02:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
24011e06:	2b00      	cmp	r3, #0
24011e08:	d06c      	beq.n	24011ee4 <HAL_RCC_OscConfig+0x12c>
24011e0a:	687b      	ldr	r3, [r7, #4]
24011e0c:	685b      	ldr	r3, [r3, #4]
24011e0e:	2b00      	cmp	r3, #0
24011e10:	d168      	bne.n	24011ee4 <HAL_RCC_OscConfig+0x12c>
      {
        return HAL_ERROR;
24011e12:	2301      	movs	r3, #1
24011e14:	e39e      	b.n	24012554 <HAL_RCC_OscConfig+0x79c>
      }
    }
    else
    {
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
24011e16:	687b      	ldr	r3, [r7, #4]
24011e18:	685b      	ldr	r3, [r3, #4]
24011e1a:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
24011e1e:	d106      	bne.n	24011e2e <HAL_RCC_OscConfig+0x76>
24011e20:	4b90      	ldr	r3, [pc, #576]	; (24012064 <HAL_RCC_OscConfig+0x2ac>)
24011e22:	681b      	ldr	r3, [r3, #0]
24011e24:	4a8f      	ldr	r2, [pc, #572]	; (24012064 <HAL_RCC_OscConfig+0x2ac>)
24011e26:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
24011e2a:	6013      	str	r3, [r2, #0]
24011e2c:	e02e      	b.n	24011e8c <HAL_RCC_OscConfig+0xd4>
24011e2e:	687b      	ldr	r3, [r7, #4]
24011e30:	685b      	ldr	r3, [r3, #4]
24011e32:	2b00      	cmp	r3, #0
24011e34:	d10c      	bne.n	24011e50 <HAL_RCC_OscConfig+0x98>
24011e36:	4b8b      	ldr	r3, [pc, #556]	; (24012064 <HAL_RCC_OscConfig+0x2ac>)
24011e38:	681b      	ldr	r3, [r3, #0]
24011e3a:	4a8a      	ldr	r2, [pc, #552]	; (24012064 <HAL_RCC_OscConfig+0x2ac>)
24011e3c:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
24011e40:	6013      	str	r3, [r2, #0]
24011e42:	4b88      	ldr	r3, [pc, #544]	; (24012064 <HAL_RCC_OscConfig+0x2ac>)
24011e44:	681b      	ldr	r3, [r3, #0]
24011e46:	4a87      	ldr	r2, [pc, #540]	; (24012064 <HAL_RCC_OscConfig+0x2ac>)
24011e48:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
24011e4c:	6013      	str	r3, [r2, #0]
24011e4e:	e01d      	b.n	24011e8c <HAL_RCC_OscConfig+0xd4>
24011e50:	687b      	ldr	r3, [r7, #4]
24011e52:	685b      	ldr	r3, [r3, #4]
24011e54:	f5b3 2fa0 	cmp.w	r3, #327680	; 0x50000
24011e58:	d10c      	bne.n	24011e74 <HAL_RCC_OscConfig+0xbc>
24011e5a:	4b82      	ldr	r3, [pc, #520]	; (24012064 <HAL_RCC_OscConfig+0x2ac>)
24011e5c:	681b      	ldr	r3, [r3, #0]
24011e5e:	4a81      	ldr	r2, [pc, #516]	; (24012064 <HAL_RCC_OscConfig+0x2ac>)
24011e60:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
24011e64:	6013      	str	r3, [r2, #0]
24011e66:	4b7f      	ldr	r3, [pc, #508]	; (24012064 <HAL_RCC_OscConfig+0x2ac>)
24011e68:	681b      	ldr	r3, [r3, #0]
24011e6a:	4a7e      	ldr	r2, [pc, #504]	; (24012064 <HAL_RCC_OscConfig+0x2ac>)
24011e6c:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
24011e70:	6013      	str	r3, [r2, #0]
24011e72:	e00b      	b.n	24011e8c <HAL_RCC_OscConfig+0xd4>
24011e74:	4b7b      	ldr	r3, [pc, #492]	; (24012064 <HAL_RCC_OscConfig+0x2ac>)
24011e76:	681b      	ldr	r3, [r3, #0]
24011e78:	4a7a      	ldr	r2, [pc, #488]	; (24012064 <HAL_RCC_OscConfig+0x2ac>)
24011e7a:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
24011e7e:	6013      	str	r3, [r2, #0]
24011e80:	4b78      	ldr	r3, [pc, #480]	; (24012064 <HAL_RCC_OscConfig+0x2ac>)
24011e82:	681b      	ldr	r3, [r3, #0]
24011e84:	4a77      	ldr	r2, [pc, #476]	; (24012064 <HAL_RCC_OscConfig+0x2ac>)
24011e86:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
24011e8a:	6013      	str	r3, [r2, #0]

      /* Check the HSE State */
      if(RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
24011e8c:	687b      	ldr	r3, [r7, #4]
24011e8e:	685b      	ldr	r3, [r3, #4]
24011e90:	2b00      	cmp	r3, #0
24011e92:	d013      	beq.n	24011ebc <HAL_RCC_OscConfig+0x104>
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
24011e94:	f7ee fcde 	bl	24000854 <HAL_GetTick>
24011e98:	6278      	str	r0, [r7, #36]	; 0x24

        /* Wait till HSE is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == 0U)
24011e9a:	e008      	b.n	24011eae <HAL_RCC_OscConfig+0xf6>
        {
          if((uint32_t) (HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
24011e9c:	f7ee fcda 	bl	24000854 <HAL_GetTick>
24011ea0:	4602      	mov	r2, r0
24011ea2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
24011ea4:	1ad3      	subs	r3, r2, r3
24011ea6:	2b64      	cmp	r3, #100	; 0x64
24011ea8:	d901      	bls.n	24011eae <HAL_RCC_OscConfig+0xf6>
          {
            return HAL_TIMEOUT;
24011eaa:	2303      	movs	r3, #3
24011eac:	e352      	b.n	24012554 <HAL_RCC_OscConfig+0x79c>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == 0U)
24011eae:	4b6d      	ldr	r3, [pc, #436]	; (24012064 <HAL_RCC_OscConfig+0x2ac>)
24011eb0:	681b      	ldr	r3, [r3, #0]
24011eb2:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
24011eb6:	2b00      	cmp	r3, #0
24011eb8:	d0f0      	beq.n	24011e9c <HAL_RCC_OscConfig+0xe4>
24011eba:	e014      	b.n	24011ee6 <HAL_RCC_OscConfig+0x12e>
        }
      }
      else
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
24011ebc:	f7ee fcca 	bl	24000854 <HAL_GetTick>
24011ec0:	6278      	str	r0, [r7, #36]	; 0x24

        /* Wait till HSE is disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != 0U)
24011ec2:	e008      	b.n	24011ed6 <HAL_RCC_OscConfig+0x11e>
        {
          if((uint32_t) (HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
24011ec4:	f7ee fcc6 	bl	24000854 <HAL_GetTick>
24011ec8:	4602      	mov	r2, r0
24011eca:	6a7b      	ldr	r3, [r7, #36]	; 0x24
24011ecc:	1ad3      	subs	r3, r2, r3
24011ece:	2b64      	cmp	r3, #100	; 0x64
24011ed0:	d901      	bls.n	24011ed6 <HAL_RCC_OscConfig+0x11e>
          {
            return HAL_TIMEOUT;
24011ed2:	2303      	movs	r3, #3
24011ed4:	e33e      	b.n	24012554 <HAL_RCC_OscConfig+0x79c>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != 0U)
24011ed6:	4b63      	ldr	r3, [pc, #396]	; (24012064 <HAL_RCC_OscConfig+0x2ac>)
24011ed8:	681b      	ldr	r3, [r3, #0]
24011eda:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
24011ede:	2b00      	cmp	r3, #0
24011ee0:	d1f0      	bne.n	24011ec4 <HAL_RCC_OscConfig+0x10c>
24011ee2:	e000      	b.n	24011ee6 <HAL_RCC_OscConfig+0x12e>
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != 0U) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
24011ee4:	bf00      	nop
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
24011ee6:	687b      	ldr	r3, [r7, #4]
24011ee8:	681b      	ldr	r3, [r3, #0]
24011eea:	f003 0302 	and.w	r3, r3, #2
24011eee:	2b00      	cmp	r3, #0
24011ef0:	f000 8092 	beq.w	24012018 <HAL_RCC_OscConfig+0x260>
    /* Check the parameters */
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    assert_param(IS_RCC_HSICALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));

    /* When the HSI is used as system clock it will not be disabled */
    const uint32_t temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
24011ef4:	4b5b      	ldr	r3, [pc, #364]	; (24012064 <HAL_RCC_OscConfig+0x2ac>)
24011ef6:	691b      	ldr	r3, [r3, #16]
24011ef8:	f003 0338 	and.w	r3, r3, #56	; 0x38
24011efc:	623b      	str	r3, [r7, #32]
    const uint32_t temp_pllckselr = RCC->PLLCKSELR;
24011efe:	4b59      	ldr	r3, [pc, #356]	; (24012064 <HAL_RCC_OscConfig+0x2ac>)
24011f00:	6a9b      	ldr	r3, [r3, #40]	; 0x28
24011f02:	61fb      	str	r3, [r7, #28]
    if((temp_sysclksrc == RCC_CFGR_SWS_HSI) || ((temp_sysclksrc == RCC_CFGR_SWS_PLL1) && ((temp_pllckselr & RCC_PLLCKSELR_PLLSRC) == RCC_PLLCKSELR_PLLSRC_HSI)))
24011f04:	6a3b      	ldr	r3, [r7, #32]
24011f06:	2b00      	cmp	r3, #0
24011f08:	d007      	beq.n	24011f1a <HAL_RCC_OscConfig+0x162>
24011f0a:	6a3b      	ldr	r3, [r7, #32]
24011f0c:	2b18      	cmp	r3, #24
24011f0e:	d12d      	bne.n	24011f6c <HAL_RCC_OscConfig+0x1b4>
24011f10:	69fb      	ldr	r3, [r7, #28]
24011f12:	f003 0303 	and.w	r3, r3, #3
24011f16:	2b00      	cmp	r3, #0
24011f18:	d128      	bne.n	24011f6c <HAL_RCC_OscConfig+0x1b4>
    {
      /* When HSI is used as system clock it will not be disabled */
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != 0U) && (RCC_OscInitStruct->HSIState == RCC_HSI_OFF))
24011f1a:	4b52      	ldr	r3, [pc, #328]	; (24012064 <HAL_RCC_OscConfig+0x2ac>)
24011f1c:	681b      	ldr	r3, [r3, #0]
24011f1e:	f003 0304 	and.w	r3, r3, #4
24011f22:	2b00      	cmp	r3, #0
24011f24:	d005      	beq.n	24011f32 <HAL_RCC_OscConfig+0x17a>
24011f26:	687b      	ldr	r3, [r7, #4]
24011f28:	68db      	ldr	r3, [r3, #12]
24011f2a:	2b00      	cmp	r3, #0
24011f2c:	d101      	bne.n	24011f32 <HAL_RCC_OscConfig+0x17a>
      {
        return HAL_ERROR;
24011f2e:	2301      	movs	r3, #1
24011f30:	e310      	b.n	24012554 <HAL_RCC_OscConfig+0x79c>
      }
      /* Otherwise, just the calibration is allowed */
      else
      {
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
24011f32:	f7ee fd27 	bl	24000984 <HAL_GetREVID>
24011f36:	4602      	mov	r2, r0
24011f38:	f241 0303 	movw	r3, #4099	; 0x1003
24011f3c:	429a      	cmp	r2, r3
24011f3e:	d80a      	bhi.n	24011f56 <HAL_RCC_OscConfig+0x19e>
24011f40:	4b48      	ldr	r3, [pc, #288]	; (24012064 <HAL_RCC_OscConfig+0x2ac>)
24011f42:	685b      	ldr	r3, [r3, #4]
24011f44:	f423 327c 	bic.w	r2, r3, #258048	; 0x3f000
24011f48:	687b      	ldr	r3, [r7, #4]
24011f4a:	691b      	ldr	r3, [r3, #16]
24011f4c:	031b      	lsls	r3, r3, #12
24011f4e:	4945      	ldr	r1, [pc, #276]	; (24012064 <HAL_RCC_OscConfig+0x2ac>)
24011f50:	4313      	orrs	r3, r2
24011f52:	604b      	str	r3, [r1, #4]
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != 0U) && (RCC_OscInitStruct->HSIState == RCC_HSI_OFF))
24011f54:	e060      	b.n	24012018 <HAL_RCC_OscConfig+0x260>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
24011f56:	4b43      	ldr	r3, [pc, #268]	; (24012064 <HAL_RCC_OscConfig+0x2ac>)
24011f58:	685b      	ldr	r3, [r3, #4]
24011f5a:	f023 42fe 	bic.w	r2, r3, #2130706432	; 0x7f000000
24011f5e:	687b      	ldr	r3, [r7, #4]
24011f60:	691b      	ldr	r3, [r3, #16]
24011f62:	061b      	lsls	r3, r3, #24
24011f64:	493f      	ldr	r1, [pc, #252]	; (24012064 <HAL_RCC_OscConfig+0x2ac>)
24011f66:	4313      	orrs	r3, r2
24011f68:	604b      	str	r3, [r1, #4]
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != 0U) && (RCC_OscInitStruct->HSIState == RCC_HSI_OFF))
24011f6a:	e055      	b.n	24012018 <HAL_RCC_OscConfig+0x260>
    }

    else
    {
      /* Check the HSI State */
      if((RCC_OscInitStruct->HSIState)!= RCC_HSI_OFF)
24011f6c:	687b      	ldr	r3, [r7, #4]
24011f6e:	68db      	ldr	r3, [r3, #12]
24011f70:	2b00      	cmp	r3, #0
24011f72:	d038      	beq.n	24011fe6 <HAL_RCC_OscConfig+0x22e>
      {
     /* Enable the Internal High Speed oscillator (HSI, HSIDIV2,HSIDIV4, or HSIDIV8) */
        __HAL_RCC_HSI_CONFIG(RCC_OscInitStruct->HSIState);
24011f74:	4b3b      	ldr	r3, [pc, #236]	; (24012064 <HAL_RCC_OscConfig+0x2ac>)
24011f76:	681b      	ldr	r3, [r3, #0]
24011f78:	f023 0219 	bic.w	r2, r3, #25
24011f7c:	687b      	ldr	r3, [r7, #4]
24011f7e:	68db      	ldr	r3, [r3, #12]
24011f80:	4938      	ldr	r1, [pc, #224]	; (24012064 <HAL_RCC_OscConfig+0x2ac>)
24011f82:	4313      	orrs	r3, r2
24011f84:	600b      	str	r3, [r1, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
24011f86:	f7ee fc65 	bl	24000854 <HAL_GetTick>
24011f8a:	6278      	str	r0, [r7, #36]	; 0x24

        /* Wait till HSI is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == 0U)
24011f8c:	e008      	b.n	24011fa0 <HAL_RCC_OscConfig+0x1e8>
        {
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
24011f8e:	f7ee fc61 	bl	24000854 <HAL_GetTick>
24011f92:	4602      	mov	r2, r0
24011f94:	6a7b      	ldr	r3, [r7, #36]	; 0x24
24011f96:	1ad3      	subs	r3, r2, r3
24011f98:	2b02      	cmp	r3, #2
24011f9a:	d901      	bls.n	24011fa0 <HAL_RCC_OscConfig+0x1e8>
          {
            return HAL_TIMEOUT;
24011f9c:	2303      	movs	r3, #3
24011f9e:	e2d9      	b.n	24012554 <HAL_RCC_OscConfig+0x79c>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == 0U)
24011fa0:	4b30      	ldr	r3, [pc, #192]	; (24012064 <HAL_RCC_OscConfig+0x2ac>)
24011fa2:	681b      	ldr	r3, [r3, #0]
24011fa4:	f003 0304 	and.w	r3, r3, #4
24011fa8:	2b00      	cmp	r3, #0
24011faa:	d0f0      	beq.n	24011f8e <HAL_RCC_OscConfig+0x1d6>
          }
        }

        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
24011fac:	f7ee fcea 	bl	24000984 <HAL_GetREVID>
24011fb0:	4602      	mov	r2, r0
24011fb2:	f241 0303 	movw	r3, #4099	; 0x1003
24011fb6:	429a      	cmp	r2, r3
24011fb8:	d80a      	bhi.n	24011fd0 <HAL_RCC_OscConfig+0x218>
24011fba:	4b2a      	ldr	r3, [pc, #168]	; (24012064 <HAL_RCC_OscConfig+0x2ac>)
24011fbc:	685b      	ldr	r3, [r3, #4]
24011fbe:	f423 327c 	bic.w	r2, r3, #258048	; 0x3f000
24011fc2:	687b      	ldr	r3, [r7, #4]
24011fc4:	691b      	ldr	r3, [r3, #16]
24011fc6:	031b      	lsls	r3, r3, #12
24011fc8:	4926      	ldr	r1, [pc, #152]	; (24012064 <HAL_RCC_OscConfig+0x2ac>)
24011fca:	4313      	orrs	r3, r2
24011fcc:	604b      	str	r3, [r1, #4]
24011fce:	e023      	b.n	24012018 <HAL_RCC_OscConfig+0x260>
24011fd0:	4b24      	ldr	r3, [pc, #144]	; (24012064 <HAL_RCC_OscConfig+0x2ac>)
24011fd2:	685b      	ldr	r3, [r3, #4]
24011fd4:	f023 42fe 	bic.w	r2, r3, #2130706432	; 0x7f000000
24011fd8:	687b      	ldr	r3, [r7, #4]
24011fda:	691b      	ldr	r3, [r3, #16]
24011fdc:	061b      	lsls	r3, r3, #24
24011fde:	4921      	ldr	r1, [pc, #132]	; (24012064 <HAL_RCC_OscConfig+0x2ac>)
24011fe0:	4313      	orrs	r3, r2
24011fe2:	604b      	str	r3, [r1, #4]
24011fe4:	e018      	b.n	24012018 <HAL_RCC_OscConfig+0x260>
      }
      else
      {
        /* Disable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_DISABLE();
24011fe6:	4b1f      	ldr	r3, [pc, #124]	; (24012064 <HAL_RCC_OscConfig+0x2ac>)
24011fe8:	681b      	ldr	r3, [r3, #0]
24011fea:	4a1e      	ldr	r2, [pc, #120]	; (24012064 <HAL_RCC_OscConfig+0x2ac>)
24011fec:	f023 0301 	bic.w	r3, r3, #1
24011ff0:	6013      	str	r3, [r2, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
24011ff2:	f7ee fc2f 	bl	24000854 <HAL_GetTick>
24011ff6:	6278      	str	r0, [r7, #36]	; 0x24

        /* Wait till HSI is disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != 0U)
24011ff8:	e008      	b.n	2401200c <HAL_RCC_OscConfig+0x254>
        {
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
24011ffa:	f7ee fc2b 	bl	24000854 <HAL_GetTick>
24011ffe:	4602      	mov	r2, r0
24012000:	6a7b      	ldr	r3, [r7, #36]	; 0x24
24012002:	1ad3      	subs	r3, r2, r3
24012004:	2b02      	cmp	r3, #2
24012006:	d901      	bls.n	2401200c <HAL_RCC_OscConfig+0x254>
          {
            return HAL_TIMEOUT;
24012008:	2303      	movs	r3, #3
2401200a:	e2a3      	b.n	24012554 <HAL_RCC_OscConfig+0x79c>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != 0U)
2401200c:	4b15      	ldr	r3, [pc, #84]	; (24012064 <HAL_RCC_OscConfig+0x2ac>)
2401200e:	681b      	ldr	r3, [r3, #0]
24012010:	f003 0304 	and.w	r3, r3, #4
24012014:	2b00      	cmp	r3, #0
24012016:	d1f0      	bne.n	24011ffa <HAL_RCC_OscConfig+0x242>
        }
      }
    }
  }
  /*----------------------------- CSI Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_CSI) == RCC_OSCILLATORTYPE_CSI)
24012018:	687b      	ldr	r3, [r7, #4]
2401201a:	681b      	ldr	r3, [r3, #0]
2401201c:	f003 0310 	and.w	r3, r3, #16
24012020:	2b00      	cmp	r3, #0
24012022:	f000 8091 	beq.w	24012148 <HAL_RCC_OscConfig+0x390>
    /* Check the parameters */
    assert_param(IS_RCC_CSI(RCC_OscInitStruct->CSIState));
    assert_param(IS_RCC_CSICALIBRATION_VALUE(RCC_OscInitStruct->CSICalibrationValue));

    /* When the CSI is used as system clock it will not disabled */
    const uint32_t temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
24012026:	4b0f      	ldr	r3, [pc, #60]	; (24012064 <HAL_RCC_OscConfig+0x2ac>)
24012028:	691b      	ldr	r3, [r3, #16]
2401202a:	f003 0338 	and.w	r3, r3, #56	; 0x38
2401202e:	61bb      	str	r3, [r7, #24]
    const uint32_t temp_pllckselr = RCC->PLLCKSELR;
24012030:	4b0c      	ldr	r3, [pc, #48]	; (24012064 <HAL_RCC_OscConfig+0x2ac>)
24012032:	6a9b      	ldr	r3, [r3, #40]	; 0x28
24012034:	617b      	str	r3, [r7, #20]
    if((temp_sysclksrc == RCC_CFGR_SWS_CSI) || ((temp_sysclksrc == RCC_CFGR_SWS_PLL1) && ((temp_pllckselr & RCC_PLLCKSELR_PLLSRC) == RCC_PLLCKSELR_PLLSRC_CSI)))
24012036:	69bb      	ldr	r3, [r7, #24]
24012038:	2b08      	cmp	r3, #8
2401203a:	d007      	beq.n	2401204c <HAL_RCC_OscConfig+0x294>
2401203c:	69bb      	ldr	r3, [r7, #24]
2401203e:	2b18      	cmp	r3, #24
24012040:	d12f      	bne.n	240120a2 <HAL_RCC_OscConfig+0x2ea>
24012042:	697b      	ldr	r3, [r7, #20]
24012044:	f003 0303 	and.w	r3, r3, #3
24012048:	2b01      	cmp	r3, #1
2401204a:	d12a      	bne.n	240120a2 <HAL_RCC_OscConfig+0x2ea>
    {
      /* When CSI is used as system clock it will not disabled */
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) != 0U) && (RCC_OscInitStruct->CSIState != RCC_CSI_ON))
2401204c:	4b05      	ldr	r3, [pc, #20]	; (24012064 <HAL_RCC_OscConfig+0x2ac>)
2401204e:	681b      	ldr	r3, [r3, #0]
24012050:	f403 7380 	and.w	r3, r3, #256	; 0x100
24012054:	2b00      	cmp	r3, #0
24012056:	d007      	beq.n	24012068 <HAL_RCC_OscConfig+0x2b0>
24012058:	687b      	ldr	r3, [r7, #4]
2401205a:	69db      	ldr	r3, [r3, #28]
2401205c:	2b80      	cmp	r3, #128	; 0x80
2401205e:	d003      	beq.n	24012068 <HAL_RCC_OscConfig+0x2b0>
      {
        return HAL_ERROR;
24012060:	2301      	movs	r3, #1
24012062:	e277      	b.n	24012554 <HAL_RCC_OscConfig+0x79c>
24012064:	58024400 	.word	0x58024400
      }
      /* Otherwise, just the calibration is allowed */
      else
      {
        /* Adjusts the Internal High Speed oscillator (CSI) calibration value.*/
        __HAL_RCC_CSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->CSICalibrationValue);
24012068:	f7ee fc8c 	bl	24000984 <HAL_GetREVID>
2401206c:	4602      	mov	r2, r0
2401206e:	f241 0303 	movw	r3, #4099	; 0x1003
24012072:	429a      	cmp	r2, r3
24012074:	d80a      	bhi.n	2401208c <HAL_RCC_OscConfig+0x2d4>
24012076:	4ba2      	ldr	r3, [pc, #648]	; (24012300 <HAL_RCC_OscConfig+0x548>)
24012078:	685b      	ldr	r3, [r3, #4]
2401207a:	f023 42f8 	bic.w	r2, r3, #2080374784	; 0x7c000000
2401207e:	687b      	ldr	r3, [r7, #4]
24012080:	6a1b      	ldr	r3, [r3, #32]
24012082:	069b      	lsls	r3, r3, #26
24012084:	499e      	ldr	r1, [pc, #632]	; (24012300 <HAL_RCC_OscConfig+0x548>)
24012086:	4313      	orrs	r3, r2
24012088:	604b      	str	r3, [r1, #4]
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) != 0U) && (RCC_OscInitStruct->CSIState != RCC_CSI_ON))
2401208a:	e05d      	b.n	24012148 <HAL_RCC_OscConfig+0x390>
        __HAL_RCC_CSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->CSICalibrationValue);
2401208c:	4b9c      	ldr	r3, [pc, #624]	; (24012300 <HAL_RCC_OscConfig+0x548>)
2401208e:	68db      	ldr	r3, [r3, #12]
24012090:	f023 527c 	bic.w	r2, r3, #1056964608	; 0x3f000000
24012094:	687b      	ldr	r3, [r7, #4]
24012096:	6a1b      	ldr	r3, [r3, #32]
24012098:	061b      	lsls	r3, r3, #24
2401209a:	4999      	ldr	r1, [pc, #612]	; (24012300 <HAL_RCC_OscConfig+0x548>)
2401209c:	4313      	orrs	r3, r2
2401209e:	60cb      	str	r3, [r1, #12]
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) != 0U) && (RCC_OscInitStruct->CSIState != RCC_CSI_ON))
240120a0:	e052      	b.n	24012148 <HAL_RCC_OscConfig+0x390>
      }
    }
    else
    {
      /* Check the CSI State */
      if((RCC_OscInitStruct->CSIState)!= RCC_CSI_OFF)
240120a2:	687b      	ldr	r3, [r7, #4]
240120a4:	69db      	ldr	r3, [r3, #28]
240120a6:	2b00      	cmp	r3, #0
240120a8:	d035      	beq.n	24012116 <HAL_RCC_OscConfig+0x35e>
      {
        /* Enable the Internal High Speed oscillator (CSI). */
        __HAL_RCC_CSI_ENABLE();
240120aa:	4b95      	ldr	r3, [pc, #596]	; (24012300 <HAL_RCC_OscConfig+0x548>)
240120ac:	681b      	ldr	r3, [r3, #0]
240120ae:	4a94      	ldr	r2, [pc, #592]	; (24012300 <HAL_RCC_OscConfig+0x548>)
240120b0:	f043 0380 	orr.w	r3, r3, #128	; 0x80
240120b4:	6013      	str	r3, [r2, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
240120b6:	f7ee fbcd 	bl	24000854 <HAL_GetTick>
240120ba:	6278      	str	r0, [r7, #36]	; 0x24

        /* Wait till CSI is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) == 0U)
240120bc:	e008      	b.n	240120d0 <HAL_RCC_OscConfig+0x318>
        {
          if((HAL_GetTick() - tickstart ) > CSI_TIMEOUT_VALUE)
240120be:	f7ee fbc9 	bl	24000854 <HAL_GetTick>
240120c2:	4602      	mov	r2, r0
240120c4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
240120c6:	1ad3      	subs	r3, r2, r3
240120c8:	2b02      	cmp	r3, #2
240120ca:	d901      	bls.n	240120d0 <HAL_RCC_OscConfig+0x318>
          {
            return HAL_TIMEOUT;
240120cc:	2303      	movs	r3, #3
240120ce:	e241      	b.n	24012554 <HAL_RCC_OscConfig+0x79c>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) == 0U)
240120d0:	4b8b      	ldr	r3, [pc, #556]	; (24012300 <HAL_RCC_OscConfig+0x548>)
240120d2:	681b      	ldr	r3, [r3, #0]
240120d4:	f403 7380 	and.w	r3, r3, #256	; 0x100
240120d8:	2b00      	cmp	r3, #0
240120da:	d0f0      	beq.n	240120be <HAL_RCC_OscConfig+0x306>
          }
        }

        /* Adjusts the Internal High Speed oscillator (CSI) calibration value.*/
        __HAL_RCC_CSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->CSICalibrationValue);
240120dc:	f7ee fc52 	bl	24000984 <HAL_GetREVID>
240120e0:	4602      	mov	r2, r0
240120e2:	f241 0303 	movw	r3, #4099	; 0x1003
240120e6:	429a      	cmp	r2, r3
240120e8:	d80a      	bhi.n	24012100 <HAL_RCC_OscConfig+0x348>
240120ea:	4b85      	ldr	r3, [pc, #532]	; (24012300 <HAL_RCC_OscConfig+0x548>)
240120ec:	685b      	ldr	r3, [r3, #4]
240120ee:	f023 42f8 	bic.w	r2, r3, #2080374784	; 0x7c000000
240120f2:	687b      	ldr	r3, [r7, #4]
240120f4:	6a1b      	ldr	r3, [r3, #32]
240120f6:	069b      	lsls	r3, r3, #26
240120f8:	4981      	ldr	r1, [pc, #516]	; (24012300 <HAL_RCC_OscConfig+0x548>)
240120fa:	4313      	orrs	r3, r2
240120fc:	604b      	str	r3, [r1, #4]
240120fe:	e023      	b.n	24012148 <HAL_RCC_OscConfig+0x390>
24012100:	4b7f      	ldr	r3, [pc, #508]	; (24012300 <HAL_RCC_OscConfig+0x548>)
24012102:	68db      	ldr	r3, [r3, #12]
24012104:	f023 527c 	bic.w	r2, r3, #1056964608	; 0x3f000000
24012108:	687b      	ldr	r3, [r7, #4]
2401210a:	6a1b      	ldr	r3, [r3, #32]
2401210c:	061b      	lsls	r3, r3, #24
2401210e:	497c      	ldr	r1, [pc, #496]	; (24012300 <HAL_RCC_OscConfig+0x548>)
24012110:	4313      	orrs	r3, r2
24012112:	60cb      	str	r3, [r1, #12]
24012114:	e018      	b.n	24012148 <HAL_RCC_OscConfig+0x390>
      }
      else
      {
        /* Disable the Internal High Speed oscillator (CSI). */
        __HAL_RCC_CSI_DISABLE();
24012116:	4b7a      	ldr	r3, [pc, #488]	; (24012300 <HAL_RCC_OscConfig+0x548>)
24012118:	681b      	ldr	r3, [r3, #0]
2401211a:	4a79      	ldr	r2, [pc, #484]	; (24012300 <HAL_RCC_OscConfig+0x548>)
2401211c:	f023 0380 	bic.w	r3, r3, #128	; 0x80
24012120:	6013      	str	r3, [r2, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
24012122:	f7ee fb97 	bl	24000854 <HAL_GetTick>
24012126:	6278      	str	r0, [r7, #36]	; 0x24

        /* Wait till CSI is disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) != 0U)
24012128:	e008      	b.n	2401213c <HAL_RCC_OscConfig+0x384>
        {
          if((HAL_GetTick() - tickstart ) > CSI_TIMEOUT_VALUE)
2401212a:	f7ee fb93 	bl	24000854 <HAL_GetTick>
2401212e:	4602      	mov	r2, r0
24012130:	6a7b      	ldr	r3, [r7, #36]	; 0x24
24012132:	1ad3      	subs	r3, r2, r3
24012134:	2b02      	cmp	r3, #2
24012136:	d901      	bls.n	2401213c <HAL_RCC_OscConfig+0x384>
          {
            return HAL_TIMEOUT;
24012138:	2303      	movs	r3, #3
2401213a:	e20b      	b.n	24012554 <HAL_RCC_OscConfig+0x79c>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) != 0U)
2401213c:	4b70      	ldr	r3, [pc, #448]	; (24012300 <HAL_RCC_OscConfig+0x548>)
2401213e:	681b      	ldr	r3, [r3, #0]
24012140:	f403 7380 	and.w	r3, r3, #256	; 0x100
24012144:	2b00      	cmp	r3, #0
24012146:	d1f0      	bne.n	2401212a <HAL_RCC_OscConfig+0x372>
        }
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
24012148:	687b      	ldr	r3, [r7, #4]
2401214a:	681b      	ldr	r3, [r3, #0]
2401214c:	f003 0308 	and.w	r3, r3, #8
24012150:	2b00      	cmp	r3, #0
24012152:	d036      	beq.n	240121c2 <HAL_RCC_OscConfig+0x40a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));

    /* Check the LSI State */
    if((RCC_OscInitStruct->LSIState)!= RCC_LSI_OFF)
24012154:	687b      	ldr	r3, [r7, #4]
24012156:	695b      	ldr	r3, [r3, #20]
24012158:	2b00      	cmp	r3, #0
2401215a:	d019      	beq.n	24012190 <HAL_RCC_OscConfig+0x3d8>
    {
      /* Enable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_ENABLE();
2401215c:	4b68      	ldr	r3, [pc, #416]	; (24012300 <HAL_RCC_OscConfig+0x548>)
2401215e:	6f5b      	ldr	r3, [r3, #116]	; 0x74
24012160:	4a67      	ldr	r2, [pc, #412]	; (24012300 <HAL_RCC_OscConfig+0x548>)
24012162:	f043 0301 	orr.w	r3, r3, #1
24012166:	6753      	str	r3, [r2, #116]	; 0x74

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
24012168:	f7ee fb74 	bl	24000854 <HAL_GetTick>
2401216c:	6278      	str	r0, [r7, #36]	; 0x24

      /* Wait till LSI is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == 0U)
2401216e:	e008      	b.n	24012182 <HAL_RCC_OscConfig+0x3ca>
      {
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
24012170:	f7ee fb70 	bl	24000854 <HAL_GetTick>
24012174:	4602      	mov	r2, r0
24012176:	6a7b      	ldr	r3, [r7, #36]	; 0x24
24012178:	1ad3      	subs	r3, r2, r3
2401217a:	2b02      	cmp	r3, #2
2401217c:	d901      	bls.n	24012182 <HAL_RCC_OscConfig+0x3ca>
        {
          return HAL_TIMEOUT;
2401217e:	2303      	movs	r3, #3
24012180:	e1e8      	b.n	24012554 <HAL_RCC_OscConfig+0x79c>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == 0U)
24012182:	4b5f      	ldr	r3, [pc, #380]	; (24012300 <HAL_RCC_OscConfig+0x548>)
24012184:	6f5b      	ldr	r3, [r3, #116]	; 0x74
24012186:	f003 0302 	and.w	r3, r3, #2
2401218a:	2b00      	cmp	r3, #0
2401218c:	d0f0      	beq.n	24012170 <HAL_RCC_OscConfig+0x3b8>
2401218e:	e018      	b.n	240121c2 <HAL_RCC_OscConfig+0x40a>
      }
    }
    else
    {
      /* Disable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_DISABLE();
24012190:	4b5b      	ldr	r3, [pc, #364]	; (24012300 <HAL_RCC_OscConfig+0x548>)
24012192:	6f5b      	ldr	r3, [r3, #116]	; 0x74
24012194:	4a5a      	ldr	r2, [pc, #360]	; (24012300 <HAL_RCC_OscConfig+0x548>)
24012196:	f023 0301 	bic.w	r3, r3, #1
2401219a:	6753      	str	r3, [r2, #116]	; 0x74

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
2401219c:	f7ee fb5a 	bl	24000854 <HAL_GetTick>
240121a0:	6278      	str	r0, [r7, #36]	; 0x24

      /* Wait till LSI is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != 0U)
240121a2:	e008      	b.n	240121b6 <HAL_RCC_OscConfig+0x3fe>
      {
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
240121a4:	f7ee fb56 	bl	24000854 <HAL_GetTick>
240121a8:	4602      	mov	r2, r0
240121aa:	6a7b      	ldr	r3, [r7, #36]	; 0x24
240121ac:	1ad3      	subs	r3, r2, r3
240121ae:	2b02      	cmp	r3, #2
240121b0:	d901      	bls.n	240121b6 <HAL_RCC_OscConfig+0x3fe>
        {
          return HAL_TIMEOUT;
240121b2:	2303      	movs	r3, #3
240121b4:	e1ce      	b.n	24012554 <HAL_RCC_OscConfig+0x79c>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != 0U)
240121b6:	4b52      	ldr	r3, [pc, #328]	; (24012300 <HAL_RCC_OscConfig+0x548>)
240121b8:	6f5b      	ldr	r3, [r3, #116]	; 0x74
240121ba:	f003 0302 	and.w	r3, r3, #2
240121be:	2b00      	cmp	r3, #0
240121c0:	d1f0      	bne.n	240121a4 <HAL_RCC_OscConfig+0x3ec>
      }
    }
  }

  /*------------------------------ HSI48 Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI48) == RCC_OSCILLATORTYPE_HSI48)
240121c2:	687b      	ldr	r3, [r7, #4]
240121c4:	681b      	ldr	r3, [r3, #0]
240121c6:	f003 0320 	and.w	r3, r3, #32
240121ca:	2b00      	cmp	r3, #0
240121cc:	d036      	beq.n	2401223c <HAL_RCC_OscConfig+0x484>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSI48(RCC_OscInitStruct->HSI48State));

    /* Check the HSI48 State */
    if((RCC_OscInitStruct->HSI48State)!= RCC_HSI48_OFF)
240121ce:	687b      	ldr	r3, [r7, #4]
240121d0:	699b      	ldr	r3, [r3, #24]
240121d2:	2b00      	cmp	r3, #0
240121d4:	d019      	beq.n	2401220a <HAL_RCC_OscConfig+0x452>
    {
      /* Enable the Internal Low Speed oscillator (HSI48). */
      __HAL_RCC_HSI48_ENABLE();
240121d6:	4b4a      	ldr	r3, [pc, #296]	; (24012300 <HAL_RCC_OscConfig+0x548>)
240121d8:	681b      	ldr	r3, [r3, #0]
240121da:	4a49      	ldr	r2, [pc, #292]	; (24012300 <HAL_RCC_OscConfig+0x548>)
240121dc:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
240121e0:	6013      	str	r3, [r2, #0]

      /* Get time-out */
      tickstart = HAL_GetTick();
240121e2:	f7ee fb37 	bl	24000854 <HAL_GetTick>
240121e6:	6278      	str	r0, [r7, #36]	; 0x24

      /* Wait till HSI48 is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) == 0U)
240121e8:	e008      	b.n	240121fc <HAL_RCC_OscConfig+0x444>
      {
        if((HAL_GetTick() - tickstart ) > HSI48_TIMEOUT_VALUE)
240121ea:	f7ee fb33 	bl	24000854 <HAL_GetTick>
240121ee:	4602      	mov	r2, r0
240121f0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
240121f2:	1ad3      	subs	r3, r2, r3
240121f4:	2b02      	cmp	r3, #2
240121f6:	d901      	bls.n	240121fc <HAL_RCC_OscConfig+0x444>
        {
          return HAL_TIMEOUT;
240121f8:	2303      	movs	r3, #3
240121fa:	e1ab      	b.n	24012554 <HAL_RCC_OscConfig+0x79c>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) == 0U)
240121fc:	4b40      	ldr	r3, [pc, #256]	; (24012300 <HAL_RCC_OscConfig+0x548>)
240121fe:	681b      	ldr	r3, [r3, #0]
24012200:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
24012204:	2b00      	cmp	r3, #0
24012206:	d0f0      	beq.n	240121ea <HAL_RCC_OscConfig+0x432>
24012208:	e018      	b.n	2401223c <HAL_RCC_OscConfig+0x484>
      }
    }
    else
    {
      /* Disable the Internal Low Speed oscillator (HSI48). */
      __HAL_RCC_HSI48_DISABLE();
2401220a:	4b3d      	ldr	r3, [pc, #244]	; (24012300 <HAL_RCC_OscConfig+0x548>)
2401220c:	681b      	ldr	r3, [r3, #0]
2401220e:	4a3c      	ldr	r2, [pc, #240]	; (24012300 <HAL_RCC_OscConfig+0x548>)
24012210:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
24012214:	6013      	str	r3, [r2, #0]

      /* Get time-out */
      tickstart = HAL_GetTick();
24012216:	f7ee fb1d 	bl	24000854 <HAL_GetTick>
2401221a:	6278      	str	r0, [r7, #36]	; 0x24

      /* Wait till HSI48 is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) != 0U)
2401221c:	e008      	b.n	24012230 <HAL_RCC_OscConfig+0x478>
      {
        if((HAL_GetTick() - tickstart ) > HSI48_TIMEOUT_VALUE)
2401221e:	f7ee fb19 	bl	24000854 <HAL_GetTick>
24012222:	4602      	mov	r2, r0
24012224:	6a7b      	ldr	r3, [r7, #36]	; 0x24
24012226:	1ad3      	subs	r3, r2, r3
24012228:	2b02      	cmp	r3, #2
2401222a:	d901      	bls.n	24012230 <HAL_RCC_OscConfig+0x478>
        {
          return HAL_TIMEOUT;
2401222c:	2303      	movs	r3, #3
2401222e:	e191      	b.n	24012554 <HAL_RCC_OscConfig+0x79c>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) != 0U)
24012230:	4b33      	ldr	r3, [pc, #204]	; (24012300 <HAL_RCC_OscConfig+0x548>)
24012232:	681b      	ldr	r3, [r3, #0]
24012234:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
24012238:	2b00      	cmp	r3, #0
2401223a:	d1f0      	bne.n	2401221e <HAL_RCC_OscConfig+0x466>
        }
      }
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
2401223c:	687b      	ldr	r3, [r7, #4]
2401223e:	681b      	ldr	r3, [r3, #0]
24012240:	f003 0304 	and.w	r3, r3, #4
24012244:	2b00      	cmp	r3, #0
24012246:	f000 8086 	beq.w	24012356 <HAL_RCC_OscConfig+0x59e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));

    /* Enable write access to Backup domain */
    PWR->CR1 |= PWR_CR1_DBP;
2401224a:	4b2e      	ldr	r3, [pc, #184]	; (24012304 <HAL_RCC_OscConfig+0x54c>)
2401224c:	681b      	ldr	r3, [r3, #0]
2401224e:	4a2d      	ldr	r2, [pc, #180]	; (24012304 <HAL_RCC_OscConfig+0x54c>)
24012250:	f443 7380 	orr.w	r3, r3, #256	; 0x100
24012254:	6013      	str	r3, [r2, #0]

    /* Wait for Backup domain Write protection disable */
    tickstart = HAL_GetTick();
24012256:	f7ee fafd 	bl	24000854 <HAL_GetTick>
2401225a:	6278      	str	r0, [r7, #36]	; 0x24

    while((PWR->CR1 & PWR_CR1_DBP) == 0U)
2401225c:	e008      	b.n	24012270 <HAL_RCC_OscConfig+0x4b8>
    {
      if((HAL_GetTick() - tickstart ) > RCC_DBP_TIMEOUT_VALUE)
2401225e:	f7ee faf9 	bl	24000854 <HAL_GetTick>
24012262:	4602      	mov	r2, r0
24012264:	6a7b      	ldr	r3, [r7, #36]	; 0x24
24012266:	1ad3      	subs	r3, r2, r3
24012268:	2b64      	cmp	r3, #100	; 0x64
2401226a:	d901      	bls.n	24012270 <HAL_RCC_OscConfig+0x4b8>
      {
        return HAL_TIMEOUT;
2401226c:	2303      	movs	r3, #3
2401226e:	e171      	b.n	24012554 <HAL_RCC_OscConfig+0x79c>
    while((PWR->CR1 & PWR_CR1_DBP) == 0U)
24012270:	4b24      	ldr	r3, [pc, #144]	; (24012304 <HAL_RCC_OscConfig+0x54c>)
24012272:	681b      	ldr	r3, [r3, #0]
24012274:	f403 7380 	and.w	r3, r3, #256	; 0x100
24012278:	2b00      	cmp	r3, #0
2401227a:	d0f0      	beq.n	2401225e <HAL_RCC_OscConfig+0x4a6>
      }
    }

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
2401227c:	687b      	ldr	r3, [r7, #4]
2401227e:	689b      	ldr	r3, [r3, #8]
24012280:	2b01      	cmp	r3, #1
24012282:	d106      	bne.n	24012292 <HAL_RCC_OscConfig+0x4da>
24012284:	4b1e      	ldr	r3, [pc, #120]	; (24012300 <HAL_RCC_OscConfig+0x548>)
24012286:	6f1b      	ldr	r3, [r3, #112]	; 0x70
24012288:	4a1d      	ldr	r2, [pc, #116]	; (24012300 <HAL_RCC_OscConfig+0x548>)
2401228a:	f043 0301 	orr.w	r3, r3, #1
2401228e:	6713      	str	r3, [r2, #112]	; 0x70
24012290:	e02d      	b.n	240122ee <HAL_RCC_OscConfig+0x536>
24012292:	687b      	ldr	r3, [r7, #4]
24012294:	689b      	ldr	r3, [r3, #8]
24012296:	2b00      	cmp	r3, #0
24012298:	d10c      	bne.n	240122b4 <HAL_RCC_OscConfig+0x4fc>
2401229a:	4b19      	ldr	r3, [pc, #100]	; (24012300 <HAL_RCC_OscConfig+0x548>)
2401229c:	6f1b      	ldr	r3, [r3, #112]	; 0x70
2401229e:	4a18      	ldr	r2, [pc, #96]	; (24012300 <HAL_RCC_OscConfig+0x548>)
240122a0:	f023 0301 	bic.w	r3, r3, #1
240122a4:	6713      	str	r3, [r2, #112]	; 0x70
240122a6:	4b16      	ldr	r3, [pc, #88]	; (24012300 <HAL_RCC_OscConfig+0x548>)
240122a8:	6f1b      	ldr	r3, [r3, #112]	; 0x70
240122aa:	4a15      	ldr	r2, [pc, #84]	; (24012300 <HAL_RCC_OscConfig+0x548>)
240122ac:	f023 0304 	bic.w	r3, r3, #4
240122b0:	6713      	str	r3, [r2, #112]	; 0x70
240122b2:	e01c      	b.n	240122ee <HAL_RCC_OscConfig+0x536>
240122b4:	687b      	ldr	r3, [r7, #4]
240122b6:	689b      	ldr	r3, [r3, #8]
240122b8:	2b05      	cmp	r3, #5
240122ba:	d10c      	bne.n	240122d6 <HAL_RCC_OscConfig+0x51e>
240122bc:	4b10      	ldr	r3, [pc, #64]	; (24012300 <HAL_RCC_OscConfig+0x548>)
240122be:	6f1b      	ldr	r3, [r3, #112]	; 0x70
240122c0:	4a0f      	ldr	r2, [pc, #60]	; (24012300 <HAL_RCC_OscConfig+0x548>)
240122c2:	f043 0304 	orr.w	r3, r3, #4
240122c6:	6713      	str	r3, [r2, #112]	; 0x70
240122c8:	4b0d      	ldr	r3, [pc, #52]	; (24012300 <HAL_RCC_OscConfig+0x548>)
240122ca:	6f1b      	ldr	r3, [r3, #112]	; 0x70
240122cc:	4a0c      	ldr	r2, [pc, #48]	; (24012300 <HAL_RCC_OscConfig+0x548>)
240122ce:	f043 0301 	orr.w	r3, r3, #1
240122d2:	6713      	str	r3, [r2, #112]	; 0x70
240122d4:	e00b      	b.n	240122ee <HAL_RCC_OscConfig+0x536>
240122d6:	4b0a      	ldr	r3, [pc, #40]	; (24012300 <HAL_RCC_OscConfig+0x548>)
240122d8:	6f1b      	ldr	r3, [r3, #112]	; 0x70
240122da:	4a09      	ldr	r2, [pc, #36]	; (24012300 <HAL_RCC_OscConfig+0x548>)
240122dc:	f023 0301 	bic.w	r3, r3, #1
240122e0:	6713      	str	r3, [r2, #112]	; 0x70
240122e2:	4b07      	ldr	r3, [pc, #28]	; (24012300 <HAL_RCC_OscConfig+0x548>)
240122e4:	6f1b      	ldr	r3, [r3, #112]	; 0x70
240122e6:	4a06      	ldr	r2, [pc, #24]	; (24012300 <HAL_RCC_OscConfig+0x548>)
240122e8:	f023 0304 	bic.w	r3, r3, #4
240122ec:	6713      	str	r3, [r2, #112]	; 0x70
    /* Check the LSE State */
    if((RCC_OscInitStruct->LSEState) != RCC_LSE_OFF)
240122ee:	687b      	ldr	r3, [r7, #4]
240122f0:	689b      	ldr	r3, [r3, #8]
240122f2:	2b00      	cmp	r3, #0
240122f4:	d01a      	beq.n	2401232c <HAL_RCC_OscConfig+0x574>
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
240122f6:	f7ee faad 	bl	24000854 <HAL_GetTick>
240122fa:	6278      	str	r0, [r7, #36]	; 0x24

      /* Wait till LSE is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == 0U)
240122fc:	e00f      	b.n	2401231e <HAL_RCC_OscConfig+0x566>
240122fe:	bf00      	nop
24012300:	58024400 	.word	0x58024400
24012304:	58024800 	.word	0x58024800
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
24012308:	f7ee faa4 	bl	24000854 <HAL_GetTick>
2401230c:	4602      	mov	r2, r0
2401230e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
24012310:	1ad3      	subs	r3, r2, r3
24012312:	f241 3288 	movw	r2, #5000	; 0x1388
24012316:	4293      	cmp	r3, r2
24012318:	d901      	bls.n	2401231e <HAL_RCC_OscConfig+0x566>
        {
          return HAL_TIMEOUT;
2401231a:	2303      	movs	r3, #3
2401231c:	e11a      	b.n	24012554 <HAL_RCC_OscConfig+0x79c>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == 0U)
2401231e:	4b8f      	ldr	r3, [pc, #572]	; (2401255c <HAL_RCC_OscConfig+0x7a4>)
24012320:	6f1b      	ldr	r3, [r3, #112]	; 0x70
24012322:	f003 0302 	and.w	r3, r3, #2
24012326:	2b00      	cmp	r3, #0
24012328:	d0ee      	beq.n	24012308 <HAL_RCC_OscConfig+0x550>
2401232a:	e014      	b.n	24012356 <HAL_RCC_OscConfig+0x59e>
      }
    }
    else
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
2401232c:	f7ee fa92 	bl	24000854 <HAL_GetTick>
24012330:	6278      	str	r0, [r7, #36]	; 0x24

      /* Wait till LSE is disabled */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != 0U)
24012332:	e00a      	b.n	2401234a <HAL_RCC_OscConfig+0x592>
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
24012334:	f7ee fa8e 	bl	24000854 <HAL_GetTick>
24012338:	4602      	mov	r2, r0
2401233a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
2401233c:	1ad3      	subs	r3, r2, r3
2401233e:	f241 3288 	movw	r2, #5000	; 0x1388
24012342:	4293      	cmp	r3, r2
24012344:	d901      	bls.n	2401234a <HAL_RCC_OscConfig+0x592>
        {
          return HAL_TIMEOUT;
24012346:	2303      	movs	r3, #3
24012348:	e104      	b.n	24012554 <HAL_RCC_OscConfig+0x79c>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != 0U)
2401234a:	4b84      	ldr	r3, [pc, #528]	; (2401255c <HAL_RCC_OscConfig+0x7a4>)
2401234c:	6f1b      	ldr	r3, [r3, #112]	; 0x70
2401234e:	f003 0302 	and.w	r3, r3, #2
24012352:	2b00      	cmp	r3, #0
24012354:	d1ee      	bne.n	24012334 <HAL_RCC_OscConfig+0x57c>
    }
  }
  /*-------------------------------- PLL Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
24012356:	687b      	ldr	r3, [r7, #4]
24012358:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2401235a:	2b00      	cmp	r3, #0
2401235c:	f000 80f9 	beq.w	24012552 <HAL_RCC_OscConfig+0x79a>
  {
    /* Check if the PLL is used as system clock or not */
    if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL1)
24012360:	4b7e      	ldr	r3, [pc, #504]	; (2401255c <HAL_RCC_OscConfig+0x7a4>)
24012362:	691b      	ldr	r3, [r3, #16]
24012364:	f003 0338 	and.w	r3, r3, #56	; 0x38
24012368:	2b18      	cmp	r3, #24
2401236a:	f000 80b4 	beq.w	240124d6 <HAL_RCC_OscConfig+0x71e>
    {
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
2401236e:	687b      	ldr	r3, [r7, #4]
24012370:	6a5b      	ldr	r3, [r3, #36]	; 0x24
24012372:	2b02      	cmp	r3, #2
24012374:	f040 8095 	bne.w	240124a2 <HAL_RCC_OscConfig+0x6ea>
        assert_param(IS_RCC_PLLQ_VALUE(RCC_OscInitStruct->PLL.PLLQ));
        assert_param(IS_RCC_PLLR_VALUE(RCC_OscInitStruct->PLL.PLLR));
        assert_param(IS_RCC_PLLFRACN_VALUE(RCC_OscInitStruct->PLL.PLLFRACN));

        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
24012378:	4b78      	ldr	r3, [pc, #480]	; (2401255c <HAL_RCC_OscConfig+0x7a4>)
2401237a:	681b      	ldr	r3, [r3, #0]
2401237c:	4a77      	ldr	r2, [pc, #476]	; (2401255c <HAL_RCC_OscConfig+0x7a4>)
2401237e:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
24012382:	6013      	str	r3, [r2, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
24012384:	f7ee fa66 	bl	24000854 <HAL_GetTick>
24012388:	6278      	str	r0, [r7, #36]	; 0x24

        /* Wait till PLL is disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != 0U)
2401238a:	e008      	b.n	2401239e <HAL_RCC_OscConfig+0x5e6>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
2401238c:	f7ee fa62 	bl	24000854 <HAL_GetTick>
24012390:	4602      	mov	r2, r0
24012392:	6a7b      	ldr	r3, [r7, #36]	; 0x24
24012394:	1ad3      	subs	r3, r2, r3
24012396:	2b02      	cmp	r3, #2
24012398:	d901      	bls.n	2401239e <HAL_RCC_OscConfig+0x5e6>
          {
            return HAL_TIMEOUT;
2401239a:	2303      	movs	r3, #3
2401239c:	e0da      	b.n	24012554 <HAL_RCC_OscConfig+0x79c>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != 0U)
2401239e:	4b6f      	ldr	r3, [pc, #444]	; (2401255c <HAL_RCC_OscConfig+0x7a4>)
240123a0:	681b      	ldr	r3, [r3, #0]
240123a2:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
240123a6:	2b00      	cmp	r3, #0
240123a8:	d1f0      	bne.n	2401238c <HAL_RCC_OscConfig+0x5d4>
          }
        }

        /* Configure the main PLL clock source, multiplication and division factors. */
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
240123aa:	4b6c      	ldr	r3, [pc, #432]	; (2401255c <HAL_RCC_OscConfig+0x7a4>)
240123ac:	6a9a      	ldr	r2, [r3, #40]	; 0x28
240123ae:	4b6c      	ldr	r3, [pc, #432]	; (24012560 <HAL_RCC_OscConfig+0x7a8>)
240123b0:	4013      	ands	r3, r2
240123b2:	687a      	ldr	r2, [r7, #4]
240123b4:	6a91      	ldr	r1, [r2, #40]	; 0x28
240123b6:	687a      	ldr	r2, [r7, #4]
240123b8:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
240123ba:	0112      	lsls	r2, r2, #4
240123bc:	430a      	orrs	r2, r1
240123be:	4967      	ldr	r1, [pc, #412]	; (2401255c <HAL_RCC_OscConfig+0x7a4>)
240123c0:	4313      	orrs	r3, r2
240123c2:	628b      	str	r3, [r1, #40]	; 0x28
240123c4:	687b      	ldr	r3, [r7, #4]
240123c6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
240123c8:	3b01      	subs	r3, #1
240123ca:	f3c3 0208 	ubfx	r2, r3, #0, #9
240123ce:	687b      	ldr	r3, [r7, #4]
240123d0:	6b5b      	ldr	r3, [r3, #52]	; 0x34
240123d2:	3b01      	subs	r3, #1
240123d4:	025b      	lsls	r3, r3, #9
240123d6:	b29b      	uxth	r3, r3
240123d8:	431a      	orrs	r2, r3
240123da:	687b      	ldr	r3, [r7, #4]
240123dc:	6b9b      	ldr	r3, [r3, #56]	; 0x38
240123de:	3b01      	subs	r3, #1
240123e0:	041b      	lsls	r3, r3, #16
240123e2:	f403 03fe 	and.w	r3, r3, #8323072	; 0x7f0000
240123e6:	431a      	orrs	r2, r3
240123e8:	687b      	ldr	r3, [r7, #4]
240123ea:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
240123ec:	3b01      	subs	r3, #1
240123ee:	061b      	lsls	r3, r3, #24
240123f0:	f003 43fe 	and.w	r3, r3, #2130706432	; 0x7f000000
240123f4:	4959      	ldr	r1, [pc, #356]	; (2401255c <HAL_RCC_OscConfig+0x7a4>)
240123f6:	4313      	orrs	r3, r2
240123f8:	630b      	str	r3, [r1, #48]	; 0x30
                             RCC_OscInitStruct->PLL.PLLP,
                             RCC_OscInitStruct->PLL.PLLQ,
                             RCC_OscInitStruct->PLL.PLLR);

         /* Disable PLLFRACN . */
         __HAL_RCC_PLLFRACN_DISABLE();
240123fa:	4b58      	ldr	r3, [pc, #352]	; (2401255c <HAL_RCC_OscConfig+0x7a4>)
240123fc:	6adb      	ldr	r3, [r3, #44]	; 0x2c
240123fe:	4a57      	ldr	r2, [pc, #348]	; (2401255c <HAL_RCC_OscConfig+0x7a4>)
24012400:	f023 0301 	bic.w	r3, r3, #1
24012404:	62d3      	str	r3, [r2, #44]	; 0x2c

         /* Configure PLL PLL1FRACN */
         __HAL_RCC_PLLFRACN_CONFIG(RCC_OscInitStruct->PLL.PLLFRACN);
24012406:	4b55      	ldr	r3, [pc, #340]	; (2401255c <HAL_RCC_OscConfig+0x7a4>)
24012408:	6b5a      	ldr	r2, [r3, #52]	; 0x34
2401240a:	4b56      	ldr	r3, [pc, #344]	; (24012564 <HAL_RCC_OscConfig+0x7ac>)
2401240c:	4013      	ands	r3, r2
2401240e:	687a      	ldr	r2, [r7, #4]
24012410:	6c92      	ldr	r2, [r2, #72]	; 0x48
24012412:	00d2      	lsls	r2, r2, #3
24012414:	4951      	ldr	r1, [pc, #324]	; (2401255c <HAL_RCC_OscConfig+0x7a4>)
24012416:	4313      	orrs	r3, r2
24012418:	634b      	str	r3, [r1, #52]	; 0x34

        /* Select PLL1 input reference frequency range: VCI */
        __HAL_RCC_PLL_VCIRANGE(RCC_OscInitStruct->PLL.PLLRGE) ;
2401241a:	4b50      	ldr	r3, [pc, #320]	; (2401255c <HAL_RCC_OscConfig+0x7a4>)
2401241c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2401241e:	f023 020c 	bic.w	r2, r3, #12
24012422:	687b      	ldr	r3, [r7, #4]
24012424:	6c1b      	ldr	r3, [r3, #64]	; 0x40
24012426:	494d      	ldr	r1, [pc, #308]	; (2401255c <HAL_RCC_OscConfig+0x7a4>)
24012428:	4313      	orrs	r3, r2
2401242a:	62cb      	str	r3, [r1, #44]	; 0x2c

        /* Select PLL1 output frequency range : VCO */
        __HAL_RCC_PLL_VCORANGE(RCC_OscInitStruct->PLL.PLLVCOSEL) ;
2401242c:	4b4b      	ldr	r3, [pc, #300]	; (2401255c <HAL_RCC_OscConfig+0x7a4>)
2401242e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24012430:	f023 0202 	bic.w	r2, r3, #2
24012434:	687b      	ldr	r3, [r7, #4]
24012436:	6c5b      	ldr	r3, [r3, #68]	; 0x44
24012438:	4948      	ldr	r1, [pc, #288]	; (2401255c <HAL_RCC_OscConfig+0x7a4>)
2401243a:	4313      	orrs	r3, r2
2401243c:	62cb      	str	r3, [r1, #44]	; 0x2c

        /* Enable PLL System Clock output. */
         __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVP);
2401243e:	4b47      	ldr	r3, [pc, #284]	; (2401255c <HAL_RCC_OscConfig+0x7a4>)
24012440:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24012442:	4a46      	ldr	r2, [pc, #280]	; (2401255c <HAL_RCC_OscConfig+0x7a4>)
24012444:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
24012448:	62d3      	str	r3, [r2, #44]	; 0x2c

        /* Enable PLL1Q Clock output. */
         __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
2401244a:	4b44      	ldr	r3, [pc, #272]	; (2401255c <HAL_RCC_OscConfig+0x7a4>)
2401244c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2401244e:	4a43      	ldr	r2, [pc, #268]	; (2401255c <HAL_RCC_OscConfig+0x7a4>)
24012450:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
24012454:	62d3      	str	r3, [r2, #44]	; 0x2c

        /* Enable PLL1R  Clock output. */
         __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVR);
24012456:	4b41      	ldr	r3, [pc, #260]	; (2401255c <HAL_RCC_OscConfig+0x7a4>)
24012458:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2401245a:	4a40      	ldr	r2, [pc, #256]	; (2401255c <HAL_RCC_OscConfig+0x7a4>)
2401245c:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
24012460:	62d3      	str	r3, [r2, #44]	; 0x2c

        /* Enable PLL1FRACN . */
         __HAL_RCC_PLLFRACN_ENABLE();
24012462:	4b3e      	ldr	r3, [pc, #248]	; (2401255c <HAL_RCC_OscConfig+0x7a4>)
24012464:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24012466:	4a3d      	ldr	r2, [pc, #244]	; (2401255c <HAL_RCC_OscConfig+0x7a4>)
24012468:	f043 0301 	orr.w	r3, r3, #1
2401246c:	62d3      	str	r3, [r2, #44]	; 0x2c

        /* Enable the main PLL. */
        __HAL_RCC_PLL_ENABLE();
2401246e:	4b3b      	ldr	r3, [pc, #236]	; (2401255c <HAL_RCC_OscConfig+0x7a4>)
24012470:	681b      	ldr	r3, [r3, #0]
24012472:	4a3a      	ldr	r2, [pc, #232]	; (2401255c <HAL_RCC_OscConfig+0x7a4>)
24012474:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
24012478:	6013      	str	r3, [r2, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
2401247a:	f7ee f9eb 	bl	24000854 <HAL_GetTick>
2401247e:	6278      	str	r0, [r7, #36]	; 0x24

        /* Wait till PLL is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == 0U)
24012480:	e008      	b.n	24012494 <HAL_RCC_OscConfig+0x6dc>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
24012482:	f7ee f9e7 	bl	24000854 <HAL_GetTick>
24012486:	4602      	mov	r2, r0
24012488:	6a7b      	ldr	r3, [r7, #36]	; 0x24
2401248a:	1ad3      	subs	r3, r2, r3
2401248c:	2b02      	cmp	r3, #2
2401248e:	d901      	bls.n	24012494 <HAL_RCC_OscConfig+0x6dc>
          {
            return HAL_TIMEOUT;
24012490:	2303      	movs	r3, #3
24012492:	e05f      	b.n	24012554 <HAL_RCC_OscConfig+0x79c>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == 0U)
24012494:	4b31      	ldr	r3, [pc, #196]	; (2401255c <HAL_RCC_OscConfig+0x7a4>)
24012496:	681b      	ldr	r3, [r3, #0]
24012498:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
2401249c:	2b00      	cmp	r3, #0
2401249e:	d0f0      	beq.n	24012482 <HAL_RCC_OscConfig+0x6ca>
240124a0:	e057      	b.n	24012552 <HAL_RCC_OscConfig+0x79a>
        }
      }
      else
      {
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
240124a2:	4b2e      	ldr	r3, [pc, #184]	; (2401255c <HAL_RCC_OscConfig+0x7a4>)
240124a4:	681b      	ldr	r3, [r3, #0]
240124a6:	4a2d      	ldr	r2, [pc, #180]	; (2401255c <HAL_RCC_OscConfig+0x7a4>)
240124a8:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
240124ac:	6013      	str	r3, [r2, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
240124ae:	f7ee f9d1 	bl	24000854 <HAL_GetTick>
240124b2:	6278      	str	r0, [r7, #36]	; 0x24

        /* Wait till PLL is disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != 0U)
240124b4:	e008      	b.n	240124c8 <HAL_RCC_OscConfig+0x710>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
240124b6:	f7ee f9cd 	bl	24000854 <HAL_GetTick>
240124ba:	4602      	mov	r2, r0
240124bc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
240124be:	1ad3      	subs	r3, r2, r3
240124c0:	2b02      	cmp	r3, #2
240124c2:	d901      	bls.n	240124c8 <HAL_RCC_OscConfig+0x710>
          {
            return HAL_TIMEOUT;
240124c4:	2303      	movs	r3, #3
240124c6:	e045      	b.n	24012554 <HAL_RCC_OscConfig+0x79c>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != 0U)
240124c8:	4b24      	ldr	r3, [pc, #144]	; (2401255c <HAL_RCC_OscConfig+0x7a4>)
240124ca:	681b      	ldr	r3, [r3, #0]
240124cc:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
240124d0:	2b00      	cmp	r3, #0
240124d2:	d1f0      	bne.n	240124b6 <HAL_RCC_OscConfig+0x6fe>
240124d4:	e03d      	b.n	24012552 <HAL_RCC_OscConfig+0x79a>
      }
    }
    else
    {
      /* Do not return HAL_ERROR if request repeats the current configuration */
      temp1_pllckcfg = RCC->PLLCKSELR;
240124d6:	4b21      	ldr	r3, [pc, #132]	; (2401255c <HAL_RCC_OscConfig+0x7a4>)
240124d8:	6a9b      	ldr	r3, [r3, #40]	; 0x28
240124da:	613b      	str	r3, [r7, #16]
      temp2_pllckcfg = RCC->PLL1DIVR;
240124dc:	4b1f      	ldr	r3, [pc, #124]	; (2401255c <HAL_RCC_OscConfig+0x7a4>)
240124de:	6b1b      	ldr	r3, [r3, #48]	; 0x30
240124e0:	60fb      	str	r3, [r7, #12]
      if(((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF) ||
240124e2:	687b      	ldr	r3, [r7, #4]
240124e4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
240124e6:	2b01      	cmp	r3, #1
240124e8:	d031      	beq.n	2401254e <HAL_RCC_OscConfig+0x796>
	 (READ_BIT(temp1_pllckcfg, RCC_PLLCKSELR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
240124ea:	693b      	ldr	r3, [r7, #16]
240124ec:	f003 0203 	and.w	r2, r3, #3
240124f0:	687b      	ldr	r3, [r7, #4]
240124f2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
      if(((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF) ||
240124f4:	429a      	cmp	r2, r3
240124f6:	d12a      	bne.n	2401254e <HAL_RCC_OscConfig+0x796>
         ((READ_BIT(temp1_pllckcfg, RCC_PLLCKSELR_DIVM1) >> RCC_PLLCKSELR_DIVM1_Pos) != RCC_OscInitStruct->PLL.PLLM) ||
240124f8:	693b      	ldr	r3, [r7, #16]
240124fa:	091b      	lsrs	r3, r3, #4
240124fc:	f003 023f 	and.w	r2, r3, #63	; 0x3f
24012500:	687b      	ldr	r3, [r7, #4]
24012502:	6adb      	ldr	r3, [r3, #44]	; 0x2c
	 (READ_BIT(temp1_pllckcfg, RCC_PLLCKSELR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
24012504:	429a      	cmp	r2, r3
24012506:	d122      	bne.n	2401254e <HAL_RCC_OscConfig+0x796>
         (READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_N1) != (RCC_OscInitStruct->PLL.PLLN - 1U)) ||
24012508:	68fb      	ldr	r3, [r7, #12]
2401250a:	f3c3 0208 	ubfx	r2, r3, #0, #9
2401250e:	687b      	ldr	r3, [r7, #4]
24012510:	6b1b      	ldr	r3, [r3, #48]	; 0x30
24012512:	3b01      	subs	r3, #1
         ((READ_BIT(temp1_pllckcfg, RCC_PLLCKSELR_DIVM1) >> RCC_PLLCKSELR_DIVM1_Pos) != RCC_OscInitStruct->PLL.PLLM) ||
24012514:	429a      	cmp	r2, r3
24012516:	d11a      	bne.n	2401254e <HAL_RCC_OscConfig+0x796>
         ((READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_P1) >> RCC_PLL1DIVR_P1_Pos) != (RCC_OscInitStruct->PLL.PLLP - 1U)) ||
24012518:	68fb      	ldr	r3, [r7, #12]
2401251a:	0a5b      	lsrs	r3, r3, #9
2401251c:	f003 027f 	and.w	r2, r3, #127	; 0x7f
24012520:	687b      	ldr	r3, [r7, #4]
24012522:	6b5b      	ldr	r3, [r3, #52]	; 0x34
24012524:	3b01      	subs	r3, #1
         (READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_N1) != (RCC_OscInitStruct->PLL.PLLN - 1U)) ||
24012526:	429a      	cmp	r2, r3
24012528:	d111      	bne.n	2401254e <HAL_RCC_OscConfig+0x796>
         ((READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_Q1) >> RCC_PLL1DIVR_Q1_Pos) != (RCC_OscInitStruct->PLL.PLLQ - 1U)) ||
2401252a:	68fb      	ldr	r3, [r7, #12]
2401252c:	0c1b      	lsrs	r3, r3, #16
2401252e:	f003 027f 	and.w	r2, r3, #127	; 0x7f
24012532:	687b      	ldr	r3, [r7, #4]
24012534:	6b9b      	ldr	r3, [r3, #56]	; 0x38
24012536:	3b01      	subs	r3, #1
         ((READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_P1) >> RCC_PLL1DIVR_P1_Pos) != (RCC_OscInitStruct->PLL.PLLP - 1U)) ||
24012538:	429a      	cmp	r2, r3
2401253a:	d108      	bne.n	2401254e <HAL_RCC_OscConfig+0x796>
         ((READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_R1) >> RCC_PLL1DIVR_R1_Pos) != (RCC_OscInitStruct->PLL.PLLR - 1U)))
2401253c:	68fb      	ldr	r3, [r7, #12]
2401253e:	0e1b      	lsrs	r3, r3, #24
24012540:	f003 027f 	and.w	r2, r3, #127	; 0x7f
24012544:	687b      	ldr	r3, [r7, #4]
24012546:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
24012548:	3b01      	subs	r3, #1
         ((READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_Q1) >> RCC_PLL1DIVR_Q1_Pos) != (RCC_OscInitStruct->PLL.PLLQ - 1U)) ||
2401254a:	429a      	cmp	r2, r3
2401254c:	d001      	beq.n	24012552 <HAL_RCC_OscConfig+0x79a>
      {
        return HAL_ERROR;
2401254e:	2301      	movs	r3, #1
24012550:	e000      	b.n	24012554 <HAL_RCC_OscConfig+0x79c>
      }
    }
  }
  return HAL_OK;
24012552:	2300      	movs	r3, #0
}
24012554:	4618      	mov	r0, r3
24012556:	3730      	adds	r7, #48	; 0x30
24012558:	46bd      	mov	sp, r7
2401255a:	bd80      	pop	{r7, pc}
2401255c:	58024400 	.word	0x58024400
24012560:	fffffc0c 	.word	0xfffffc0c
24012564:	ffff0007 	.word	0xffff0007

24012568 <HAL_RCC_ClockConfig>:
  *         D1CPRE[3:0] bits to ensure that  Domain1 core clock not exceed the maximum allowed frequency
  *         (for more details refer to section above "Initialization/de-initialization functions")
  * @retval None
  */
HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)
{
24012568:	b580      	push	{r7, lr}
2401256a:	b086      	sub	sp, #24
2401256c:	af00      	add	r7, sp, #0
2401256e:	6078      	str	r0, [r7, #4]
24012570:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef halstatus;
  uint32_t tickstart;
  uint32_t common_system_clock;

   /* Check Null pointer */
  if(RCC_ClkInitStruct == NULL)
24012572:	687b      	ldr	r3, [r7, #4]
24012574:	2b00      	cmp	r3, #0
24012576:	d101      	bne.n	2401257c <HAL_RCC_ClockConfig+0x14>
  {
    return HAL_ERROR;
24012578:	2301      	movs	r3, #1
2401257a:	e19c      	b.n	240128b6 <HAL_RCC_ClockConfig+0x34e>
  /* To correctly read data from FLASH memory, the number of wait states (LATENCY)
    must be correctly programmed according to the frequency of the CPU clock
    (HCLK) and the supply voltage of the device. */

  /* Increasing the CPU frequency */
  if(FLatency > __HAL_FLASH_GET_LATENCY())
2401257c:	4b8a      	ldr	r3, [pc, #552]	; (240127a8 <HAL_RCC_ClockConfig+0x240>)
2401257e:	681b      	ldr	r3, [r3, #0]
24012580:	f003 030f 	and.w	r3, r3, #15
24012584:	683a      	ldr	r2, [r7, #0]
24012586:	429a      	cmp	r2, r3
24012588:	d910      	bls.n	240125ac <HAL_RCC_ClockConfig+0x44>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
2401258a:	4b87      	ldr	r3, [pc, #540]	; (240127a8 <HAL_RCC_ClockConfig+0x240>)
2401258c:	681b      	ldr	r3, [r3, #0]
2401258e:	f023 020f 	bic.w	r2, r3, #15
24012592:	4985      	ldr	r1, [pc, #532]	; (240127a8 <HAL_RCC_ClockConfig+0x240>)
24012594:	683b      	ldr	r3, [r7, #0]
24012596:	4313      	orrs	r3, r2
24012598:	600b      	str	r3, [r1, #0]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
2401259a:	4b83      	ldr	r3, [pc, #524]	; (240127a8 <HAL_RCC_ClockConfig+0x240>)
2401259c:	681b      	ldr	r3, [r3, #0]
2401259e:	f003 030f 	and.w	r3, r3, #15
240125a2:	683a      	ldr	r2, [r7, #0]
240125a4:	429a      	cmp	r2, r3
240125a6:	d001      	beq.n	240125ac <HAL_RCC_ClockConfig+0x44>
    {
      return HAL_ERROR;
240125a8:	2301      	movs	r3, #1
240125aa:	e184      	b.n	240128b6 <HAL_RCC_ClockConfig+0x34e>

  }

  /* Increasing the BUS frequency divider */
  /*-------------------------- D1PCLK1/CDPCLK1 Configuration ---------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_D1PCLK1) == RCC_CLOCKTYPE_D1PCLK1)
240125ac:	687b      	ldr	r3, [r7, #4]
240125ae:	681b      	ldr	r3, [r3, #0]
240125b0:	f003 0304 	and.w	r3, r3, #4
240125b4:	2b00      	cmp	r3, #0
240125b6:	d010      	beq.n	240125da <HAL_RCC_ClockConfig+0x72>
  {
#if defined (RCC_D1CFGR_D1PPRE)
    if((RCC_ClkInitStruct->APB3CLKDivider) > (RCC->D1CFGR & RCC_D1CFGR_D1PPRE))
240125b8:	687b      	ldr	r3, [r7, #4]
240125ba:	691a      	ldr	r2, [r3, #16]
240125bc:	4b7b      	ldr	r3, [pc, #492]	; (240127ac <HAL_RCC_ClockConfig+0x244>)
240125be:	699b      	ldr	r3, [r3, #24]
240125c0:	f003 0370 	and.w	r3, r3, #112	; 0x70
240125c4:	429a      	cmp	r2, r3
240125c6:	d908      	bls.n	240125da <HAL_RCC_ClockConfig+0x72>
    {
      assert_param(IS_RCC_D1PCLK1(RCC_ClkInitStruct->APB3CLKDivider));
      MODIFY_REG(RCC->D1CFGR, RCC_D1CFGR_D1PPRE, RCC_ClkInitStruct->APB3CLKDivider);
240125c8:	4b78      	ldr	r3, [pc, #480]	; (240127ac <HAL_RCC_ClockConfig+0x244>)
240125ca:	699b      	ldr	r3, [r3, #24]
240125cc:	f023 0270 	bic.w	r2, r3, #112	; 0x70
240125d0:	687b      	ldr	r3, [r7, #4]
240125d2:	691b      	ldr	r3, [r3, #16]
240125d4:	4975      	ldr	r1, [pc, #468]	; (240127ac <HAL_RCC_ClockConfig+0x244>)
240125d6:	4313      	orrs	r3, r2
240125d8:	618b      	str	r3, [r1, #24]
    }
#endif
  }

  /*-------------------------- PCLK1 Configuration ---------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
240125da:	687b      	ldr	r3, [r7, #4]
240125dc:	681b      	ldr	r3, [r3, #0]
240125de:	f003 0308 	and.w	r3, r3, #8
240125e2:	2b00      	cmp	r3, #0
240125e4:	d010      	beq.n	24012608 <HAL_RCC_ClockConfig+0xa0>
  {
#if defined (RCC_D2CFGR_D2PPRE1)
    if((RCC_ClkInitStruct->APB1CLKDivider) > (RCC->D2CFGR & RCC_D2CFGR_D2PPRE1))
240125e6:	687b      	ldr	r3, [r7, #4]
240125e8:	695a      	ldr	r2, [r3, #20]
240125ea:	4b70      	ldr	r3, [pc, #448]	; (240127ac <HAL_RCC_ClockConfig+0x244>)
240125ec:	69db      	ldr	r3, [r3, #28]
240125ee:	f003 0370 	and.w	r3, r3, #112	; 0x70
240125f2:	429a      	cmp	r2, r3
240125f4:	d908      	bls.n	24012608 <HAL_RCC_ClockConfig+0xa0>
    {
      assert_param(IS_RCC_PCLK1(RCC_ClkInitStruct->APB1CLKDivider));
      MODIFY_REG(RCC->D2CFGR, RCC_D2CFGR_D2PPRE1, (RCC_ClkInitStruct->APB1CLKDivider));
240125f6:	4b6d      	ldr	r3, [pc, #436]	; (240127ac <HAL_RCC_ClockConfig+0x244>)
240125f8:	69db      	ldr	r3, [r3, #28]
240125fa:	f023 0270 	bic.w	r2, r3, #112	; 0x70
240125fe:	687b      	ldr	r3, [r7, #4]
24012600:	695b      	ldr	r3, [r3, #20]
24012602:	496a      	ldr	r1, [pc, #424]	; (240127ac <HAL_RCC_ClockConfig+0x244>)
24012604:	4313      	orrs	r3, r2
24012606:	61cb      	str	r3, [r1, #28]
      MODIFY_REG(RCC->CDCFGR2, RCC_CDCFGR2_CDPPRE1, (RCC_ClkInitStruct->APB1CLKDivider));
  }
#endif
    }
  /*-------------------------- PCLK2 Configuration ---------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
24012608:	687b      	ldr	r3, [r7, #4]
2401260a:	681b      	ldr	r3, [r3, #0]
2401260c:	f003 0310 	and.w	r3, r3, #16
24012610:	2b00      	cmp	r3, #0
24012612:	d010      	beq.n	24012636 <HAL_RCC_ClockConfig+0xce>
  {
#if defined(RCC_D2CFGR_D2PPRE2)
    if((RCC_ClkInitStruct->APB2CLKDivider) > (RCC->D2CFGR & RCC_D2CFGR_D2PPRE2))
24012614:	687b      	ldr	r3, [r7, #4]
24012616:	699a      	ldr	r2, [r3, #24]
24012618:	4b64      	ldr	r3, [pc, #400]	; (240127ac <HAL_RCC_ClockConfig+0x244>)
2401261a:	69db      	ldr	r3, [r3, #28]
2401261c:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
24012620:	429a      	cmp	r2, r3
24012622:	d908      	bls.n	24012636 <HAL_RCC_ClockConfig+0xce>
    {
      assert_param(IS_RCC_PCLK2(RCC_ClkInitStruct->APB2CLKDivider));
      MODIFY_REG(RCC->D2CFGR, RCC_D2CFGR_D2PPRE2, (RCC_ClkInitStruct->APB2CLKDivider));
24012624:	4b61      	ldr	r3, [pc, #388]	; (240127ac <HAL_RCC_ClockConfig+0x244>)
24012626:	69db      	ldr	r3, [r3, #28]
24012628:	f423 62e0 	bic.w	r2, r3, #1792	; 0x700
2401262c:	687b      	ldr	r3, [r7, #4]
2401262e:	699b      	ldr	r3, [r3, #24]
24012630:	495e      	ldr	r1, [pc, #376]	; (240127ac <HAL_RCC_ClockConfig+0x244>)
24012632:	4313      	orrs	r3, r2
24012634:	61cb      	str	r3, [r1, #28]
    }
#endif
  }

  /*-------------------------- D3PCLK1 Configuration ---------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_D3PCLK1) == RCC_CLOCKTYPE_D3PCLK1)
24012636:	687b      	ldr	r3, [r7, #4]
24012638:	681b      	ldr	r3, [r3, #0]
2401263a:	f003 0320 	and.w	r3, r3, #32
2401263e:	2b00      	cmp	r3, #0
24012640:	d010      	beq.n	24012664 <HAL_RCC_ClockConfig+0xfc>
  {
#if defined(RCC_D3CFGR_D3PPRE)
    if((RCC_ClkInitStruct->APB4CLKDivider) > (RCC->D3CFGR & RCC_D3CFGR_D3PPRE))
24012642:	687b      	ldr	r3, [r7, #4]
24012644:	69da      	ldr	r2, [r3, #28]
24012646:	4b59      	ldr	r3, [pc, #356]	; (240127ac <HAL_RCC_ClockConfig+0x244>)
24012648:	6a1b      	ldr	r3, [r3, #32]
2401264a:	f003 0370 	and.w	r3, r3, #112	; 0x70
2401264e:	429a      	cmp	r2, r3
24012650:	d908      	bls.n	24012664 <HAL_RCC_ClockConfig+0xfc>
    {
      assert_param(IS_RCC_D3PCLK1(RCC_ClkInitStruct->APB4CLKDivider));
      MODIFY_REG(RCC->D3CFGR, RCC_D3CFGR_D3PPRE, (RCC_ClkInitStruct->APB4CLKDivider) );
24012652:	4b56      	ldr	r3, [pc, #344]	; (240127ac <HAL_RCC_ClockConfig+0x244>)
24012654:	6a1b      	ldr	r3, [r3, #32]
24012656:	f023 0270 	bic.w	r2, r3, #112	; 0x70
2401265a:	687b      	ldr	r3, [r7, #4]
2401265c:	69db      	ldr	r3, [r3, #28]
2401265e:	4953      	ldr	r1, [pc, #332]	; (240127ac <HAL_RCC_ClockConfig+0x244>)
24012660:	4313      	orrs	r3, r2
24012662:	620b      	str	r3, [r1, #32]
    }
#endif
  }

   /*-------------------------- HCLK Configuration --------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
24012664:	687b      	ldr	r3, [r7, #4]
24012666:	681b      	ldr	r3, [r3, #0]
24012668:	f003 0302 	and.w	r3, r3, #2
2401266c:	2b00      	cmp	r3, #0
2401266e:	d010      	beq.n	24012692 <HAL_RCC_ClockConfig+0x12a>
  {
#if defined (RCC_D1CFGR_HPRE)
    if((RCC_ClkInitStruct->AHBCLKDivider) > (RCC->D1CFGR & RCC_D1CFGR_HPRE))
24012670:	687b      	ldr	r3, [r7, #4]
24012672:	68da      	ldr	r2, [r3, #12]
24012674:	4b4d      	ldr	r3, [pc, #308]	; (240127ac <HAL_RCC_ClockConfig+0x244>)
24012676:	699b      	ldr	r3, [r3, #24]
24012678:	f003 030f 	and.w	r3, r3, #15
2401267c:	429a      	cmp	r2, r3
2401267e:	d908      	bls.n	24012692 <HAL_RCC_ClockConfig+0x12a>
    {
      /* Set the new HCLK clock divider */
      assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
      MODIFY_REG(RCC->D1CFGR, RCC_D1CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
24012680:	4b4a      	ldr	r3, [pc, #296]	; (240127ac <HAL_RCC_ClockConfig+0x244>)
24012682:	699b      	ldr	r3, [r3, #24]
24012684:	f023 020f 	bic.w	r2, r3, #15
24012688:	687b      	ldr	r3, [r7, #4]
2401268a:	68db      	ldr	r3, [r3, #12]
2401268c:	4947      	ldr	r1, [pc, #284]	; (240127ac <HAL_RCC_ClockConfig+0x244>)
2401268e:	4313      	orrs	r3, r2
24012690:	618b      	str	r3, [r1, #24]
    }
#endif
  }

    /*------------------------- SYSCLK Configuration -------------------------*/
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
24012692:	687b      	ldr	r3, [r7, #4]
24012694:	681b      	ldr	r3, [r3, #0]
24012696:	f003 0301 	and.w	r3, r3, #1
2401269a:	2b00      	cmp	r3, #0
2401269c:	d055      	beq.n	2401274a <HAL_RCC_ClockConfig+0x1e2>
    {
      assert_param(IS_RCC_SYSCLK(RCC_ClkInitStruct->SYSCLKDivider));
      assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));
#if defined(RCC_D1CFGR_D1CPRE)
      MODIFY_REG(RCC->D1CFGR, RCC_D1CFGR_D1CPRE, RCC_ClkInitStruct->SYSCLKDivider);
2401269e:	4b43      	ldr	r3, [pc, #268]	; (240127ac <HAL_RCC_ClockConfig+0x244>)
240126a0:	699b      	ldr	r3, [r3, #24]
240126a2:	f423 6270 	bic.w	r2, r3, #3840	; 0xf00
240126a6:	687b      	ldr	r3, [r7, #4]
240126a8:	689b      	ldr	r3, [r3, #8]
240126aa:	4940      	ldr	r1, [pc, #256]	; (240127ac <HAL_RCC_ClockConfig+0x244>)
240126ac:	4313      	orrs	r3, r2
240126ae:	618b      	str	r3, [r1, #24]
#else
      MODIFY_REG(RCC->CDCFGR1, RCC_CDCFGR1_CDCPRE, RCC_ClkInitStruct->SYSCLKDivider);
#endif
      /* HSE is selected as System Clock Source */
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
240126b0:	687b      	ldr	r3, [r7, #4]
240126b2:	685b      	ldr	r3, [r3, #4]
240126b4:	2b02      	cmp	r3, #2
240126b6:	d107      	bne.n	240126c8 <HAL_RCC_ClockConfig+0x160>
      {
        /* Check the HSE ready flag */
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == 0U)
240126b8:	4b3c      	ldr	r3, [pc, #240]	; (240127ac <HAL_RCC_ClockConfig+0x244>)
240126ba:	681b      	ldr	r3, [r3, #0]
240126bc:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
240126c0:	2b00      	cmp	r3, #0
240126c2:	d121      	bne.n	24012708 <HAL_RCC_ClockConfig+0x1a0>
        {
          return HAL_ERROR;
240126c4:	2301      	movs	r3, #1
240126c6:	e0f6      	b.n	240128b6 <HAL_RCC_ClockConfig+0x34e>
        }
      }
      /* PLL is selected as System Clock Source */
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
240126c8:	687b      	ldr	r3, [r7, #4]
240126ca:	685b      	ldr	r3, [r3, #4]
240126cc:	2b03      	cmp	r3, #3
240126ce:	d107      	bne.n	240126e0 <HAL_RCC_ClockConfig+0x178>
      {
        /* Check the PLL ready flag */
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == 0U)
240126d0:	4b36      	ldr	r3, [pc, #216]	; (240127ac <HAL_RCC_ClockConfig+0x244>)
240126d2:	681b      	ldr	r3, [r3, #0]
240126d4:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
240126d8:	2b00      	cmp	r3, #0
240126da:	d115      	bne.n	24012708 <HAL_RCC_ClockConfig+0x1a0>
        {
          return HAL_ERROR;
240126dc:	2301      	movs	r3, #1
240126de:	e0ea      	b.n	240128b6 <HAL_RCC_ClockConfig+0x34e>
        }
      }
      /* CSI is selected as System Clock Source */
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_CSI)
240126e0:	687b      	ldr	r3, [r7, #4]
240126e2:	685b      	ldr	r3, [r3, #4]
240126e4:	2b01      	cmp	r3, #1
240126e6:	d107      	bne.n	240126f8 <HAL_RCC_ClockConfig+0x190>
      {
        /* Check the PLL ready flag */
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) == 0U)
240126e8:	4b30      	ldr	r3, [pc, #192]	; (240127ac <HAL_RCC_ClockConfig+0x244>)
240126ea:	681b      	ldr	r3, [r3, #0]
240126ec:	f403 7380 	and.w	r3, r3, #256	; 0x100
240126f0:	2b00      	cmp	r3, #0
240126f2:	d109      	bne.n	24012708 <HAL_RCC_ClockConfig+0x1a0>
        {
          return HAL_ERROR;
240126f4:	2301      	movs	r3, #1
240126f6:	e0de      	b.n	240128b6 <HAL_RCC_ClockConfig+0x34e>
      }
      /* HSI is selected as System Clock Source */
      else
      {
        /* Check the HSI ready flag */
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == 0U)
240126f8:	4b2c      	ldr	r3, [pc, #176]	; (240127ac <HAL_RCC_ClockConfig+0x244>)
240126fa:	681b      	ldr	r3, [r3, #0]
240126fc:	f003 0304 	and.w	r3, r3, #4
24012700:	2b00      	cmp	r3, #0
24012702:	d101      	bne.n	24012708 <HAL_RCC_ClockConfig+0x1a0>
        {
          return HAL_ERROR;
24012704:	2301      	movs	r3, #1
24012706:	e0d6      	b.n	240128b6 <HAL_RCC_ClockConfig+0x34e>
        }
      }
      MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, RCC_ClkInitStruct->SYSCLKSource);
24012708:	4b28      	ldr	r3, [pc, #160]	; (240127ac <HAL_RCC_ClockConfig+0x244>)
2401270a:	691b      	ldr	r3, [r3, #16]
2401270c:	f023 0207 	bic.w	r2, r3, #7
24012710:	687b      	ldr	r3, [r7, #4]
24012712:	685b      	ldr	r3, [r3, #4]
24012714:	4925      	ldr	r1, [pc, #148]	; (240127ac <HAL_RCC_ClockConfig+0x244>)
24012716:	4313      	orrs	r3, r2
24012718:	610b      	str	r3, [r1, #16]

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
2401271a:	f7ee f89b 	bl	24000854 <HAL_GetTick>
2401271e:	6178      	str	r0, [r7, #20]

        while (__HAL_RCC_GET_SYSCLK_SOURCE() !=  (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
24012720:	e00a      	b.n	24012738 <HAL_RCC_ClockConfig+0x1d0>
        {
          if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
24012722:	f7ee f897 	bl	24000854 <HAL_GetTick>
24012726:	4602      	mov	r2, r0
24012728:	697b      	ldr	r3, [r7, #20]
2401272a:	1ad3      	subs	r3, r2, r3
2401272c:	f241 3288 	movw	r2, #5000	; 0x1388
24012730:	4293      	cmp	r3, r2
24012732:	d901      	bls.n	24012738 <HAL_RCC_ClockConfig+0x1d0>
          {
            return HAL_TIMEOUT;
24012734:	2303      	movs	r3, #3
24012736:	e0be      	b.n	240128b6 <HAL_RCC_ClockConfig+0x34e>
        while (__HAL_RCC_GET_SYSCLK_SOURCE() !=  (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
24012738:	4b1c      	ldr	r3, [pc, #112]	; (240127ac <HAL_RCC_ClockConfig+0x244>)
2401273a:	691b      	ldr	r3, [r3, #16]
2401273c:	f003 0238 	and.w	r2, r3, #56	; 0x38
24012740:	687b      	ldr	r3, [r7, #4]
24012742:	685b      	ldr	r3, [r3, #4]
24012744:	00db      	lsls	r3, r3, #3
24012746:	429a      	cmp	r2, r3
24012748:	d1eb      	bne.n	24012722 <HAL_RCC_ClockConfig+0x1ba>

    }

    /* Decreasing the BUS frequency divider */
   /*-------------------------- HCLK Configuration --------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
2401274a:	687b      	ldr	r3, [r7, #4]
2401274c:	681b      	ldr	r3, [r3, #0]
2401274e:	f003 0302 	and.w	r3, r3, #2
24012752:	2b00      	cmp	r3, #0
24012754:	d010      	beq.n	24012778 <HAL_RCC_ClockConfig+0x210>
  {
#if defined(RCC_D1CFGR_HPRE)
    if((RCC_ClkInitStruct->AHBCLKDivider) < (RCC->D1CFGR & RCC_D1CFGR_HPRE))
24012756:	687b      	ldr	r3, [r7, #4]
24012758:	68da      	ldr	r2, [r3, #12]
2401275a:	4b14      	ldr	r3, [pc, #80]	; (240127ac <HAL_RCC_ClockConfig+0x244>)
2401275c:	699b      	ldr	r3, [r3, #24]
2401275e:	f003 030f 	and.w	r3, r3, #15
24012762:	429a      	cmp	r2, r3
24012764:	d208      	bcs.n	24012778 <HAL_RCC_ClockConfig+0x210>
    {
      /* Set the new HCLK clock divider */
      assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
      MODIFY_REG(RCC->D1CFGR, RCC_D1CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
24012766:	4b11      	ldr	r3, [pc, #68]	; (240127ac <HAL_RCC_ClockConfig+0x244>)
24012768:	699b      	ldr	r3, [r3, #24]
2401276a:	f023 020f 	bic.w	r2, r3, #15
2401276e:	687b      	ldr	r3, [r7, #4]
24012770:	68db      	ldr	r3, [r3, #12]
24012772:	490e      	ldr	r1, [pc, #56]	; (240127ac <HAL_RCC_ClockConfig+0x244>)
24012774:	4313      	orrs	r3, r2
24012776:	618b      	str	r3, [r1, #24]
    }
#endif
  }

  /* Decreasing the number of wait states because of lower CPU frequency */
  if(FLatency < __HAL_FLASH_GET_LATENCY())
24012778:	4b0b      	ldr	r3, [pc, #44]	; (240127a8 <HAL_RCC_ClockConfig+0x240>)
2401277a:	681b      	ldr	r3, [r3, #0]
2401277c:	f003 030f 	and.w	r3, r3, #15
24012780:	683a      	ldr	r2, [r7, #0]
24012782:	429a      	cmp	r2, r3
24012784:	d214      	bcs.n	240127b0 <HAL_RCC_ClockConfig+0x248>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
24012786:	4b08      	ldr	r3, [pc, #32]	; (240127a8 <HAL_RCC_ClockConfig+0x240>)
24012788:	681b      	ldr	r3, [r3, #0]
2401278a:	f023 020f 	bic.w	r2, r3, #15
2401278e:	4906      	ldr	r1, [pc, #24]	; (240127a8 <HAL_RCC_ClockConfig+0x240>)
24012790:	683b      	ldr	r3, [r7, #0]
24012792:	4313      	orrs	r3, r2
24012794:	600b      	str	r3, [r1, #0]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
24012796:	4b04      	ldr	r3, [pc, #16]	; (240127a8 <HAL_RCC_ClockConfig+0x240>)
24012798:	681b      	ldr	r3, [r3, #0]
2401279a:	f003 030f 	and.w	r3, r3, #15
2401279e:	683a      	ldr	r2, [r7, #0]
240127a0:	429a      	cmp	r2, r3
240127a2:	d005      	beq.n	240127b0 <HAL_RCC_ClockConfig+0x248>
    {
      return HAL_ERROR;
240127a4:	2301      	movs	r3, #1
240127a6:	e086      	b.n	240128b6 <HAL_RCC_ClockConfig+0x34e>
240127a8:	52002000 	.word	0x52002000
240127ac:	58024400 	.word	0x58024400
    }
 }

  /*-------------------------- D1PCLK1/CDPCLK Configuration ---------------------------*/
 if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_D1PCLK1) == RCC_CLOCKTYPE_D1PCLK1)
240127b0:	687b      	ldr	r3, [r7, #4]
240127b2:	681b      	ldr	r3, [r3, #0]
240127b4:	f003 0304 	and.w	r3, r3, #4
240127b8:	2b00      	cmp	r3, #0
240127ba:	d010      	beq.n	240127de <HAL_RCC_ClockConfig+0x276>
 {
#if defined(RCC_D1CFGR_D1PPRE)
   if((RCC_ClkInitStruct->APB3CLKDivider) < (RCC->D1CFGR & RCC_D1CFGR_D1PPRE))
240127bc:	687b      	ldr	r3, [r7, #4]
240127be:	691a      	ldr	r2, [r3, #16]
240127c0:	4b3f      	ldr	r3, [pc, #252]	; (240128c0 <HAL_RCC_ClockConfig+0x358>)
240127c2:	699b      	ldr	r3, [r3, #24]
240127c4:	f003 0370 	and.w	r3, r3, #112	; 0x70
240127c8:	429a      	cmp	r2, r3
240127ca:	d208      	bcs.n	240127de <HAL_RCC_ClockConfig+0x276>
   {
     assert_param(IS_RCC_D1PCLK1(RCC_ClkInitStruct->APB3CLKDivider));
     MODIFY_REG(RCC->D1CFGR, RCC_D1CFGR_D1PPRE, RCC_ClkInitStruct->APB3CLKDivider);
240127cc:	4b3c      	ldr	r3, [pc, #240]	; (240128c0 <HAL_RCC_ClockConfig+0x358>)
240127ce:	699b      	ldr	r3, [r3, #24]
240127d0:	f023 0270 	bic.w	r2, r3, #112	; 0x70
240127d4:	687b      	ldr	r3, [r7, #4]
240127d6:	691b      	ldr	r3, [r3, #16]
240127d8:	4939      	ldr	r1, [pc, #228]	; (240128c0 <HAL_RCC_ClockConfig+0x358>)
240127da:	4313      	orrs	r3, r2
240127dc:	618b      	str	r3, [r1, #24]
   }
#endif
 }

  /*-------------------------- PCLK1 Configuration ---------------------------*/
 if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
240127de:	687b      	ldr	r3, [r7, #4]
240127e0:	681b      	ldr	r3, [r3, #0]
240127e2:	f003 0308 	and.w	r3, r3, #8
240127e6:	2b00      	cmp	r3, #0
240127e8:	d010      	beq.n	2401280c <HAL_RCC_ClockConfig+0x2a4>
 {
#if defined(RCC_D2CFGR_D2PPRE1)
   if((RCC_ClkInitStruct->APB1CLKDivider) < (RCC->D2CFGR & RCC_D2CFGR_D2PPRE1))
240127ea:	687b      	ldr	r3, [r7, #4]
240127ec:	695a      	ldr	r2, [r3, #20]
240127ee:	4b34      	ldr	r3, [pc, #208]	; (240128c0 <HAL_RCC_ClockConfig+0x358>)
240127f0:	69db      	ldr	r3, [r3, #28]
240127f2:	f003 0370 	and.w	r3, r3, #112	; 0x70
240127f6:	429a      	cmp	r2, r3
240127f8:	d208      	bcs.n	2401280c <HAL_RCC_ClockConfig+0x2a4>
   {
     assert_param(IS_RCC_PCLK1(RCC_ClkInitStruct->APB1CLKDivider));
     MODIFY_REG(RCC->D2CFGR, RCC_D2CFGR_D2PPRE1, (RCC_ClkInitStruct->APB1CLKDivider));
240127fa:	4b31      	ldr	r3, [pc, #196]	; (240128c0 <HAL_RCC_ClockConfig+0x358>)
240127fc:	69db      	ldr	r3, [r3, #28]
240127fe:	f023 0270 	bic.w	r2, r3, #112	; 0x70
24012802:	687b      	ldr	r3, [r7, #4]
24012804:	695b      	ldr	r3, [r3, #20]
24012806:	492e      	ldr	r1, [pc, #184]	; (240128c0 <HAL_RCC_ClockConfig+0x358>)
24012808:	4313      	orrs	r3, r2
2401280a:	61cb      	str	r3, [r1, #28]
   }
#endif
 }

  /*-------------------------- PCLK2 Configuration ---------------------------*/
 if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
2401280c:	687b      	ldr	r3, [r7, #4]
2401280e:	681b      	ldr	r3, [r3, #0]
24012810:	f003 0310 	and.w	r3, r3, #16
24012814:	2b00      	cmp	r3, #0
24012816:	d010      	beq.n	2401283a <HAL_RCC_ClockConfig+0x2d2>
 {
#if defined (RCC_D2CFGR_D2PPRE2)
   if((RCC_ClkInitStruct->APB2CLKDivider) < (RCC->D2CFGR & RCC_D2CFGR_D2PPRE2))
24012818:	687b      	ldr	r3, [r7, #4]
2401281a:	699a      	ldr	r2, [r3, #24]
2401281c:	4b28      	ldr	r3, [pc, #160]	; (240128c0 <HAL_RCC_ClockConfig+0x358>)
2401281e:	69db      	ldr	r3, [r3, #28]
24012820:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
24012824:	429a      	cmp	r2, r3
24012826:	d208      	bcs.n	2401283a <HAL_RCC_ClockConfig+0x2d2>
   {
     assert_param(IS_RCC_PCLK2(RCC_ClkInitStruct->APB2CLKDivider));
     MODIFY_REG(RCC->D2CFGR, RCC_D2CFGR_D2PPRE2, (RCC_ClkInitStruct->APB2CLKDivider));
24012828:	4b25      	ldr	r3, [pc, #148]	; (240128c0 <HAL_RCC_ClockConfig+0x358>)
2401282a:	69db      	ldr	r3, [r3, #28]
2401282c:	f423 62e0 	bic.w	r2, r3, #1792	; 0x700
24012830:	687b      	ldr	r3, [r7, #4]
24012832:	699b      	ldr	r3, [r3, #24]
24012834:	4922      	ldr	r1, [pc, #136]	; (240128c0 <HAL_RCC_ClockConfig+0x358>)
24012836:	4313      	orrs	r3, r2
24012838:	61cb      	str	r3, [r1, #28]
   }
#endif
 }

  /*-------------------------- D3PCLK1/SRDPCLK1 Configuration ---------------------------*/
 if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_D3PCLK1) == RCC_CLOCKTYPE_D3PCLK1)
2401283a:	687b      	ldr	r3, [r7, #4]
2401283c:	681b      	ldr	r3, [r3, #0]
2401283e:	f003 0320 	and.w	r3, r3, #32
24012842:	2b00      	cmp	r3, #0
24012844:	d010      	beq.n	24012868 <HAL_RCC_ClockConfig+0x300>
 {
#if defined(RCC_D3CFGR_D3PPRE)
   if((RCC_ClkInitStruct->APB4CLKDivider) < (RCC->D3CFGR & RCC_D3CFGR_D3PPRE))
24012846:	687b      	ldr	r3, [r7, #4]
24012848:	69da      	ldr	r2, [r3, #28]
2401284a:	4b1d      	ldr	r3, [pc, #116]	; (240128c0 <HAL_RCC_ClockConfig+0x358>)
2401284c:	6a1b      	ldr	r3, [r3, #32]
2401284e:	f003 0370 	and.w	r3, r3, #112	; 0x70
24012852:	429a      	cmp	r2, r3
24012854:	d208      	bcs.n	24012868 <HAL_RCC_ClockConfig+0x300>
   {
     assert_param(IS_RCC_D3PCLK1(RCC_ClkInitStruct->APB4CLKDivider));
     MODIFY_REG(RCC->D3CFGR, RCC_D3CFGR_D3PPRE, (RCC_ClkInitStruct->APB4CLKDivider) );
24012856:	4b1a      	ldr	r3, [pc, #104]	; (240128c0 <HAL_RCC_ClockConfig+0x358>)
24012858:	6a1b      	ldr	r3, [r3, #32]
2401285a:	f023 0270 	bic.w	r2, r3, #112	; 0x70
2401285e:	687b      	ldr	r3, [r7, #4]
24012860:	69db      	ldr	r3, [r3, #28]
24012862:	4917      	ldr	r1, [pc, #92]	; (240128c0 <HAL_RCC_ClockConfig+0x358>)
24012864:	4313      	orrs	r3, r2
24012866:	620b      	str	r3, [r1, #32]
#endif
 }

  /* Update the SystemCoreClock global variable */
#if defined(RCC_D1CFGR_D1CPRE)
  common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos]) & 0x1FU);
24012868:	f000 f8be 	bl	240129e8 <HAL_RCC_GetSysClockFreq>
2401286c:	4601      	mov	r1, r0
2401286e:	4b14      	ldr	r3, [pc, #80]	; (240128c0 <HAL_RCC_ClockConfig+0x358>)
24012870:	699b      	ldr	r3, [r3, #24]
24012872:	0a1b      	lsrs	r3, r3, #8
24012874:	f003 030f 	and.w	r3, r3, #15
24012878:	4a12      	ldr	r2, [pc, #72]	; (240128c4 <HAL_RCC_ClockConfig+0x35c>)
2401287a:	5cd3      	ldrb	r3, [r2, r3]
2401287c:	f003 031f 	and.w	r3, r3, #31
24012880:	fa21 f303 	lsr.w	r3, r1, r3
24012884:	613b      	str	r3, [r7, #16]
#else
  common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->CDCFGR1 & RCC_CDCFGR1_CDCPRE)>> RCC_CDCFGR1_CDCPRE_Pos]) & 0x1FU);
#endif

#if defined(RCC_D1CFGR_HPRE)
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
24012886:	4b0e      	ldr	r3, [pc, #56]	; (240128c0 <HAL_RCC_ClockConfig+0x358>)
24012888:	699b      	ldr	r3, [r3, #24]
2401288a:	f003 030f 	and.w	r3, r3, #15
2401288e:	4a0d      	ldr	r2, [pc, #52]	; (240128c4 <HAL_RCC_ClockConfig+0x35c>)
24012890:	5cd3      	ldrb	r3, [r2, r3]
24012892:	f003 031f 	and.w	r3, r3, #31
24012896:	693a      	ldr	r2, [r7, #16]
24012898:	fa22 f303 	lsr.w	r3, r2, r3
2401289c:	4a0a      	ldr	r2, [pc, #40]	; (240128c8 <HAL_RCC_ClockConfig+0x360>)
2401289e:	6013      	str	r3, [r2, #0]
#endif

#if defined(DUAL_CORE) && defined(CORE_CM4)
  SystemCoreClock = SystemD2Clock;
#else
  SystemCoreClock = common_system_clock;
240128a0:	4a0a      	ldr	r2, [pc, #40]	; (240128cc <HAL_RCC_ClockConfig+0x364>)
240128a2:	693b      	ldr	r3, [r7, #16]
240128a4:	6013      	str	r3, [r2, #0]
#endif /* DUAL_CORE && CORE_CM4 */

  /* Configure the source of time base considering new system clocks settings*/
  halstatus = HAL_InitTick (uwTickPrio);
240128a6:	4b0a      	ldr	r3, [pc, #40]	; (240128d0 <HAL_RCC_ClockConfig+0x368>)
240128a8:	681b      	ldr	r3, [r3, #0]
240128aa:	4618      	mov	r0, r3
240128ac:	f7ed ff88 	bl	240007c0 <HAL_InitTick>
240128b0:	4603      	mov	r3, r0
240128b2:	73fb      	strb	r3, [r7, #15]

  return halstatus;
240128b4:	7bfb      	ldrb	r3, [r7, #15]
}
240128b6:	4618      	mov	r0, r3
240128b8:	3718      	adds	r7, #24
240128ba:	46bd      	mov	sp, r7
240128bc:	bd80      	pop	{r7, pc}
240128be:	bf00      	nop
240128c0:	58024400 	.word	0x58024400
240128c4:	24016b70 	.word	0x24016b70
240128c8:	240004bc 	.word	0x240004bc
240128cc:	240004b8 	.word	0x240004b8
240128d0:	240004ac 	.word	0x240004ac

240128d4 <HAL_RCC_MCOConfig>:
  *          This parameter can be one of the following values:
  *            @arg RCC_MCODIV_1 up to RCC_MCODIV_15  : divider applied to MCOx clock
  * @retval None
  */
void HAL_RCC_MCOConfig(uint32_t RCC_MCOx, uint32_t RCC_MCOSource, uint32_t RCC_MCODiv)
{
240128d4:	b580      	push	{r7, lr}
240128d6:	b08c      	sub	sp, #48	; 0x30
240128d8:	af00      	add	r7, sp, #0
240128da:	60f8      	str	r0, [r7, #12]
240128dc:	60b9      	str	r1, [r7, #8]
240128de:	607a      	str	r2, [r7, #4]
  GPIO_InitTypeDef GPIO_InitStruct;
  /* Check the parameters */
  assert_param(IS_RCC_MCO(RCC_MCOx));
  assert_param(IS_RCC_MCODIV(RCC_MCODiv));
  /* RCC_MCO1 */
  if(RCC_MCOx == RCC_MCO1)
240128e0:	68fb      	ldr	r3, [r7, #12]
240128e2:	2b00      	cmp	r3, #0
240128e4:	d12a      	bne.n	2401293c <HAL_RCC_MCOConfig+0x68>
  {
    assert_param(IS_RCC_MCO1SOURCE(RCC_MCOSource));

    /* MCO1 Clock Enable */
    MCO1_CLK_ENABLE();
240128e6:	4b2d      	ldr	r3, [pc, #180]	; (2401299c <HAL_RCC_MCOConfig+0xc8>)
240128e8:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
240128ec:	4a2b      	ldr	r2, [pc, #172]	; (2401299c <HAL_RCC_MCOConfig+0xc8>)
240128ee:	f043 0301 	orr.w	r3, r3, #1
240128f2:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
240128f6:	4b29      	ldr	r3, [pc, #164]	; (2401299c <HAL_RCC_MCOConfig+0xc8>)
240128f8:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
240128fc:	f003 0301 	and.w	r3, r3, #1
24012900:	61bb      	str	r3, [r7, #24]
24012902:	69bb      	ldr	r3, [r7, #24]

    /* Configure the MCO1 pin in alternate function mode */
    GPIO_InitStruct.Pin = MCO1_PIN;
24012904:	f44f 7380 	mov.w	r3, #256	; 0x100
24012908:	61fb      	str	r3, [r7, #28]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
2401290a:	2302      	movs	r3, #2
2401290c:	623b      	str	r3, [r7, #32]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
2401290e:	2303      	movs	r3, #3
24012910:	62bb      	str	r3, [r7, #40]	; 0x28
    GPIO_InitStruct.Pull = GPIO_NOPULL;
24012912:	2300      	movs	r3, #0
24012914:	627b      	str	r3, [r7, #36]	; 0x24
    GPIO_InitStruct.Alternate = GPIO_AF0_MCO;
24012916:	2300      	movs	r3, #0
24012918:	62fb      	str	r3, [r7, #44]	; 0x2c
    HAL_GPIO_Init(MCO1_GPIO_PORT, &GPIO_InitStruct);
2401291a:	f107 031c 	add.w	r3, r7, #28
2401291e:	4619      	mov	r1, r3
24012920:	481f      	ldr	r0, [pc, #124]	; (240129a0 <HAL_RCC_MCOConfig+0xcc>)
24012922:	f7f5 fe33 	bl	2400858c <HAL_GPIO_Init>

    /* Mask MCO1 and MCO1PRE[3:0] bits then Select MCO1 clock source and pre-scaler */
    MODIFY_REG(RCC->CFGR, (RCC_CFGR_MCO1 | RCC_CFGR_MCO1PRE), (RCC_MCOSource | RCC_MCODiv));
24012926:	4b1d      	ldr	r3, [pc, #116]	; (2401299c <HAL_RCC_MCOConfig+0xc8>)
24012928:	691b      	ldr	r3, [r3, #16]
2401292a:	f023 72fe 	bic.w	r2, r3, #33292288	; 0x1fc0000
2401292e:	68b9      	ldr	r1, [r7, #8]
24012930:	687b      	ldr	r3, [r7, #4]
24012932:	430b      	orrs	r3, r1
24012934:	4919      	ldr	r1, [pc, #100]	; (2401299c <HAL_RCC_MCOConfig+0xc8>)
24012936:	4313      	orrs	r3, r2
24012938:	610b      	str	r3, [r1, #16]
    HAL_GPIO_Init(MCO2_GPIO_PORT, &GPIO_InitStruct);

    /* Mask MCO2 and MCO2PRE[3:0] bits then Select MCO2 clock source and pre-scaler */
    MODIFY_REG(RCC->CFGR, (RCC_CFGR_MCO2 | RCC_CFGR_MCO2PRE), (RCC_MCOSource | (RCC_MCODiv << 7U)));
  }
}
2401293a:	e02a      	b.n	24012992 <HAL_RCC_MCOConfig+0xbe>
    MCO2_CLK_ENABLE();
2401293c:	4b17      	ldr	r3, [pc, #92]	; (2401299c <HAL_RCC_MCOConfig+0xc8>)
2401293e:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
24012942:	4a16      	ldr	r2, [pc, #88]	; (2401299c <HAL_RCC_MCOConfig+0xc8>)
24012944:	f043 0304 	orr.w	r3, r3, #4
24012948:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
2401294c:	4b13      	ldr	r3, [pc, #76]	; (2401299c <HAL_RCC_MCOConfig+0xc8>)
2401294e:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
24012952:	f003 0304 	and.w	r3, r3, #4
24012956:	617b      	str	r3, [r7, #20]
24012958:	697b      	ldr	r3, [r7, #20]
    GPIO_InitStruct.Pin = MCO2_PIN;
2401295a:	f44f 7300 	mov.w	r3, #512	; 0x200
2401295e:	61fb      	str	r3, [r7, #28]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
24012960:	2302      	movs	r3, #2
24012962:	623b      	str	r3, [r7, #32]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
24012964:	2303      	movs	r3, #3
24012966:	62bb      	str	r3, [r7, #40]	; 0x28
    GPIO_InitStruct.Pull = GPIO_NOPULL;
24012968:	2300      	movs	r3, #0
2401296a:	627b      	str	r3, [r7, #36]	; 0x24
    GPIO_InitStruct.Alternate = GPIO_AF0_MCO;
2401296c:	2300      	movs	r3, #0
2401296e:	62fb      	str	r3, [r7, #44]	; 0x2c
    HAL_GPIO_Init(MCO2_GPIO_PORT, &GPIO_InitStruct);
24012970:	f107 031c 	add.w	r3, r7, #28
24012974:	4619      	mov	r1, r3
24012976:	480b      	ldr	r0, [pc, #44]	; (240129a4 <HAL_RCC_MCOConfig+0xd0>)
24012978:	f7f5 fe08 	bl	2400858c <HAL_GPIO_Init>
    MODIFY_REG(RCC->CFGR, (RCC_CFGR_MCO2 | RCC_CFGR_MCO2PRE), (RCC_MCOSource | (RCC_MCODiv << 7U)));
2401297c:	4b07      	ldr	r3, [pc, #28]	; (2401299c <HAL_RCC_MCOConfig+0xc8>)
2401297e:	691b      	ldr	r3, [r3, #16]
24012980:	f023 427e 	bic.w	r2, r3, #4261412864	; 0xfe000000
24012984:	687b      	ldr	r3, [r7, #4]
24012986:	01d9      	lsls	r1, r3, #7
24012988:	68bb      	ldr	r3, [r7, #8]
2401298a:	430b      	orrs	r3, r1
2401298c:	4903      	ldr	r1, [pc, #12]	; (2401299c <HAL_RCC_MCOConfig+0xc8>)
2401298e:	4313      	orrs	r3, r2
24012990:	610b      	str	r3, [r1, #16]
}
24012992:	bf00      	nop
24012994:	3730      	adds	r7, #48	; 0x30
24012996:	46bd      	mov	sp, r7
24012998:	bd80      	pop	{r7, pc}
2401299a:	bf00      	nop
2401299c:	58024400 	.word	0x58024400
240129a0:	58020000 	.word	0x58020000
240129a4:	58020800 	.word	0x58020800

240129a8 <HAL_RCC_EnableCSS>:
  *         allowing the MCU to perform rescue operations. The CSSI is linked to
  *         the Cortex-M NMI (Non-Mask-able Interrupt) exception vector.
  * @retval None
  */
void HAL_RCC_EnableCSS(void)
{
240129a8:	b480      	push	{r7}
240129aa:	af00      	add	r7, sp, #0
  SET_BIT(RCC->CR, RCC_CR_CSSHSEON) ;
240129ac:	4b05      	ldr	r3, [pc, #20]	; (240129c4 <HAL_RCC_EnableCSS+0x1c>)
240129ae:	681b      	ldr	r3, [r3, #0]
240129b0:	4a04      	ldr	r2, [pc, #16]	; (240129c4 <HAL_RCC_EnableCSS+0x1c>)
240129b2:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
240129b6:	6013      	str	r3, [r2, #0]
}
240129b8:	bf00      	nop
240129ba:	46bd      	mov	sp, r7
240129bc:	f85d 7b04 	ldr.w	r7, [sp], #4
240129c0:	4770      	bx	lr
240129c2:	bf00      	nop
240129c4:	58024400 	.word	0x58024400

240129c8 <HAL_RCC_DisableCSS>:
/**
  * @brief  Disables the Clock Security System.
  * @retval None
  */
void HAL_RCC_DisableCSS(void)
{
240129c8:	b480      	push	{r7}
240129ca:	af00      	add	r7, sp, #0
  CLEAR_BIT(RCC->CR, RCC_CR_CSSHSEON);
240129cc:	4b05      	ldr	r3, [pc, #20]	; (240129e4 <HAL_RCC_DisableCSS+0x1c>)
240129ce:	681b      	ldr	r3, [r3, #0]
240129d0:	4a04      	ldr	r2, [pc, #16]	; (240129e4 <HAL_RCC_DisableCSS+0x1c>)
240129d2:	f423 2300 	bic.w	r3, r3, #524288	; 0x80000
240129d6:	6013      	str	r3, [r2, #0]
}
240129d8:	bf00      	nop
240129da:	46bd      	mov	sp, r7
240129dc:	f85d 7b04 	ldr.w	r7, [sp], #4
240129e0:	4770      	bx	lr
240129e2:	bf00      	nop
240129e4:	58024400 	.word	0x58024400

240129e8 <HAL_RCC_GetSysClockFreq>:
  *
  *
  * @retval SYSCLK frequency
  */
uint32_t HAL_RCC_GetSysClockFreq(void)
{
240129e8:	b480      	push	{r7}
240129ea:	b089      	sub	sp, #36	; 0x24
240129ec:	af00      	add	r7, sp, #0
  float_t fracn1, pllvco;
  uint32_t sysclockfreq;

  /* Get SYSCLK source -------------------------------------------------------*/

  switch (RCC->CFGR & RCC_CFGR_SWS)
240129ee:	4baf      	ldr	r3, [pc, #700]	; (24012cac <HAL_RCC_GetSysClockFreq+0x2c4>)
240129f0:	691b      	ldr	r3, [r3, #16]
240129f2:	f003 0338 	and.w	r3, r3, #56	; 0x38
240129f6:	2b18      	cmp	r3, #24
240129f8:	f200 814e 	bhi.w	24012c98 <HAL_RCC_GetSysClockFreq+0x2b0>
240129fc:	a201      	add	r2, pc, #4	; (adr r2, 24012a04 <HAL_RCC_GetSysClockFreq+0x1c>)
240129fe:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
24012a02:	bf00      	nop
24012a04:	24012a69 	.word	0x24012a69
24012a08:	24012c99 	.word	0x24012c99
24012a0c:	24012c99 	.word	0x24012c99
24012a10:	24012c99 	.word	0x24012c99
24012a14:	24012c99 	.word	0x24012c99
24012a18:	24012c99 	.word	0x24012c99
24012a1c:	24012c99 	.word	0x24012c99
24012a20:	24012c99 	.word	0x24012c99
24012a24:	24012a8f 	.word	0x24012a8f
24012a28:	24012c99 	.word	0x24012c99
24012a2c:	24012c99 	.word	0x24012c99
24012a30:	24012c99 	.word	0x24012c99
24012a34:	24012c99 	.word	0x24012c99
24012a38:	24012c99 	.word	0x24012c99
24012a3c:	24012c99 	.word	0x24012c99
24012a40:	24012c99 	.word	0x24012c99
24012a44:	24012a95 	.word	0x24012a95
24012a48:	24012c99 	.word	0x24012c99
24012a4c:	24012c99 	.word	0x24012c99
24012a50:	24012c99 	.word	0x24012c99
24012a54:	24012c99 	.word	0x24012c99
24012a58:	24012c99 	.word	0x24012c99
24012a5c:	24012c99 	.word	0x24012c99
24012a60:	24012c99 	.word	0x24012c99
24012a64:	24012a9b 	.word	0x24012a9b
  {
  case RCC_CFGR_SWS_HSI:  /* HSI used as system clock source */

   if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
24012a68:	4b90      	ldr	r3, [pc, #576]	; (24012cac <HAL_RCC_GetSysClockFreq+0x2c4>)
24012a6a:	681b      	ldr	r3, [r3, #0]
24012a6c:	f003 0320 	and.w	r3, r3, #32
24012a70:	2b00      	cmp	r3, #0
24012a72:	d009      	beq.n	24012a88 <HAL_RCC_GetSysClockFreq+0xa0>
      {
        sysclockfreq = (uint32_t) (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
24012a74:	4b8d      	ldr	r3, [pc, #564]	; (24012cac <HAL_RCC_GetSysClockFreq+0x2c4>)
24012a76:	681b      	ldr	r3, [r3, #0]
24012a78:	08db      	lsrs	r3, r3, #3
24012a7a:	f003 0303 	and.w	r3, r3, #3
24012a7e:	4a8c      	ldr	r2, [pc, #560]	; (24012cb0 <HAL_RCC_GetSysClockFreq+0x2c8>)
24012a80:	fa22 f303 	lsr.w	r3, r2, r3
24012a84:	61bb      	str	r3, [r7, #24]
      else
      {
        sysclockfreq = (uint32_t) HSI_VALUE;
      }

    break;
24012a86:	e10a      	b.n	24012c9e <HAL_RCC_GetSysClockFreq+0x2b6>
        sysclockfreq = (uint32_t) HSI_VALUE;
24012a88:	4b89      	ldr	r3, [pc, #548]	; (24012cb0 <HAL_RCC_GetSysClockFreq+0x2c8>)
24012a8a:	61bb      	str	r3, [r7, #24]
    break;
24012a8c:	e107      	b.n	24012c9e <HAL_RCC_GetSysClockFreq+0x2b6>

  case RCC_CFGR_SWS_CSI:  /* CSI used as system clock  source */
    sysclockfreq = CSI_VALUE;
24012a8e:	4b89      	ldr	r3, [pc, #548]	; (24012cb4 <HAL_RCC_GetSysClockFreq+0x2cc>)
24012a90:	61bb      	str	r3, [r7, #24]
    break;
24012a92:	e104      	b.n	24012c9e <HAL_RCC_GetSysClockFreq+0x2b6>

  case RCC_CFGR_SWS_HSE:  /* HSE used as system clock  source */
    sysclockfreq = HSE_VALUE;
24012a94:	4b88      	ldr	r3, [pc, #544]	; (24012cb8 <HAL_RCC_GetSysClockFreq+0x2d0>)
24012a96:	61bb      	str	r3, [r7, #24]
    break;
24012a98:	e101      	b.n	24012c9e <HAL_RCC_GetSysClockFreq+0x2b6>
  case RCC_CFGR_SWS_PLL1:  /* PLL1 used as system clock  source */

    /* PLL_VCO = (HSE_VALUE or HSI_VALUE or CSI_VALUE/ PLLM) * PLLN
    SYSCLK = PLL_VCO / PLLR
    */
    pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
24012a9a:	4b84      	ldr	r3, [pc, #528]	; (24012cac <HAL_RCC_GetSysClockFreq+0x2c4>)
24012a9c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
24012a9e:	f003 0303 	and.w	r3, r3, #3
24012aa2:	617b      	str	r3, [r7, #20]
    pllm = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM1)>> 4)  ;
24012aa4:	4b81      	ldr	r3, [pc, #516]	; (24012cac <HAL_RCC_GetSysClockFreq+0x2c4>)
24012aa6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
24012aa8:	091b      	lsrs	r3, r3, #4
24012aaa:	f003 033f 	and.w	r3, r3, #63	; 0x3f
24012aae:	613b      	str	r3, [r7, #16]
    pllfracen = ((RCC-> PLLCFGR & RCC_PLLCFGR_PLL1FRACEN)>>RCC_PLLCFGR_PLL1FRACEN_Pos);
24012ab0:	4b7e      	ldr	r3, [pc, #504]	; (24012cac <HAL_RCC_GetSysClockFreq+0x2c4>)
24012ab2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24012ab4:	f003 0301 	and.w	r3, r3, #1
24012ab8:	60fb      	str	r3, [r7, #12]
    fracn1 = (float_t)(uint32_t)(pllfracen* ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1)>> 3));
24012aba:	4b7c      	ldr	r3, [pc, #496]	; (24012cac <HAL_RCC_GetSysClockFreq+0x2c4>)
24012abc:	6b5b      	ldr	r3, [r3, #52]	; 0x34
24012abe:	08db      	lsrs	r3, r3, #3
24012ac0:	f3c3 030c 	ubfx	r3, r3, #0, #13
24012ac4:	68fa      	ldr	r2, [r7, #12]
24012ac6:	fb02 f303 	mul.w	r3, r2, r3
24012aca:	ee07 3a90 	vmov	s15, r3
24012ace:	eef8 7a67 	vcvt.f32.u32	s15, s15
24012ad2:	edc7 7a02 	vstr	s15, [r7, #8]

    if (pllm != 0U)
24012ad6:	693b      	ldr	r3, [r7, #16]
24012ad8:	2b00      	cmp	r3, #0
24012ada:	f000 80da 	beq.w	24012c92 <HAL_RCC_GetSysClockFreq+0x2aa>
    {
      switch (pllsource)
24012ade:	697b      	ldr	r3, [r7, #20]
24012ae0:	2b01      	cmp	r3, #1
24012ae2:	d05a      	beq.n	24012b9a <HAL_RCC_GetSysClockFreq+0x1b2>
24012ae4:	2b01      	cmp	r3, #1
24012ae6:	d302      	bcc.n	24012aee <HAL_RCC_GetSysClockFreq+0x106>
24012ae8:	2b02      	cmp	r3, #2
24012aea:	d078      	beq.n	24012bde <HAL_RCC_GetSysClockFreq+0x1f6>
24012aec:	e099      	b.n	24012c22 <HAL_RCC_GetSysClockFreq+0x23a>
      {
      case RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */

       if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
24012aee:	4b6f      	ldr	r3, [pc, #444]	; (24012cac <HAL_RCC_GetSysClockFreq+0x2c4>)
24012af0:	681b      	ldr	r3, [r3, #0]
24012af2:	f003 0320 	and.w	r3, r3, #32
24012af6:	2b00      	cmp	r3, #0
24012af8:	d02d      	beq.n	24012b56 <HAL_RCC_GetSysClockFreq+0x16e>
        {
          hsivalue= (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
24012afa:	4b6c      	ldr	r3, [pc, #432]	; (24012cac <HAL_RCC_GetSysClockFreq+0x2c4>)
24012afc:	681b      	ldr	r3, [r3, #0]
24012afe:	08db      	lsrs	r3, r3, #3
24012b00:	f003 0303 	and.w	r3, r3, #3
24012b04:	4a6a      	ldr	r2, [pc, #424]	; (24012cb0 <HAL_RCC_GetSysClockFreq+0x2c8>)
24012b06:	fa22 f303 	lsr.w	r3, r2, r3
24012b0a:	607b      	str	r3, [r7, #4]
          pllvco = ( (float_t)hsivalue / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
24012b0c:	687b      	ldr	r3, [r7, #4]
24012b0e:	ee07 3a90 	vmov	s15, r3
24012b12:	eef8 6a67 	vcvt.f32.u32	s13, s15
24012b16:	693b      	ldr	r3, [r7, #16]
24012b18:	ee07 3a90 	vmov	s15, r3
24012b1c:	eef8 7a67 	vcvt.f32.u32	s15, s15
24012b20:	ee86 7aa7 	vdiv.f32	s14, s13, s15
24012b24:	4b61      	ldr	r3, [pc, #388]	; (24012cac <HAL_RCC_GetSysClockFreq+0x2c4>)
24012b26:	6b1b      	ldr	r3, [r3, #48]	; 0x30
24012b28:	f3c3 0308 	ubfx	r3, r3, #0, #9
24012b2c:	ee07 3a90 	vmov	s15, r3
24012b30:	eef8 6a67 	vcvt.f32.u32	s13, s15
24012b34:	ed97 6a02 	vldr	s12, [r7, #8]
24012b38:	eddf 5a60 	vldr	s11, [pc, #384]	; 24012cbc <HAL_RCC_GetSysClockFreq+0x2d4>
24012b3c:	eec6 7a25 	vdiv.f32	s15, s12, s11
24012b40:	ee76 7aa7 	vadd.f32	s15, s13, s15
24012b44:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
24012b48:	ee77 7aa6 	vadd.f32	s15, s15, s13
24012b4c:	ee67 7a27 	vmul.f32	s15, s14, s15
24012b50:	edc7 7a07 	vstr	s15, [r7, #28]
        }
        else
        {
          pllvco = ((float_t)HSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
        }
        break;
24012b54:	e087      	b.n	24012c66 <HAL_RCC_GetSysClockFreq+0x27e>
          pllvco = ((float_t)HSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
24012b56:	693b      	ldr	r3, [r7, #16]
24012b58:	ee07 3a90 	vmov	s15, r3
24012b5c:	eef8 7a67 	vcvt.f32.u32	s15, s15
24012b60:	eddf 6a57 	vldr	s13, [pc, #348]	; 24012cc0 <HAL_RCC_GetSysClockFreq+0x2d8>
24012b64:	ee86 7aa7 	vdiv.f32	s14, s13, s15
24012b68:	4b50      	ldr	r3, [pc, #320]	; (24012cac <HAL_RCC_GetSysClockFreq+0x2c4>)
24012b6a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
24012b6c:	f3c3 0308 	ubfx	r3, r3, #0, #9
24012b70:	ee07 3a90 	vmov	s15, r3
24012b74:	eef8 6a67 	vcvt.f32.u32	s13, s15
24012b78:	ed97 6a02 	vldr	s12, [r7, #8]
24012b7c:	eddf 5a4f 	vldr	s11, [pc, #316]	; 24012cbc <HAL_RCC_GetSysClockFreq+0x2d4>
24012b80:	eec6 7a25 	vdiv.f32	s15, s12, s11
24012b84:	ee76 7aa7 	vadd.f32	s15, s13, s15
24012b88:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
24012b8c:	ee77 7aa6 	vadd.f32	s15, s15, s13
24012b90:	ee67 7a27 	vmul.f32	s15, s14, s15
24012b94:	edc7 7a07 	vstr	s15, [r7, #28]
        break;
24012b98:	e065      	b.n	24012c66 <HAL_RCC_GetSysClockFreq+0x27e>

      case RCC_PLLSOURCE_CSI:  /* CSI used as PLL clock source */
        pllvco = ((float_t)CSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
24012b9a:	693b      	ldr	r3, [r7, #16]
24012b9c:	ee07 3a90 	vmov	s15, r3
24012ba0:	eef8 7a67 	vcvt.f32.u32	s15, s15
24012ba4:	eddf 6a47 	vldr	s13, [pc, #284]	; 24012cc4 <HAL_RCC_GetSysClockFreq+0x2dc>
24012ba8:	ee86 7aa7 	vdiv.f32	s14, s13, s15
24012bac:	4b3f      	ldr	r3, [pc, #252]	; (24012cac <HAL_RCC_GetSysClockFreq+0x2c4>)
24012bae:	6b1b      	ldr	r3, [r3, #48]	; 0x30
24012bb0:	f3c3 0308 	ubfx	r3, r3, #0, #9
24012bb4:	ee07 3a90 	vmov	s15, r3
24012bb8:	eef8 6a67 	vcvt.f32.u32	s13, s15
24012bbc:	ed97 6a02 	vldr	s12, [r7, #8]
24012bc0:	eddf 5a3e 	vldr	s11, [pc, #248]	; 24012cbc <HAL_RCC_GetSysClockFreq+0x2d4>
24012bc4:	eec6 7a25 	vdiv.f32	s15, s12, s11
24012bc8:	ee76 7aa7 	vadd.f32	s15, s13, s15
24012bcc:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
24012bd0:	ee77 7aa6 	vadd.f32	s15, s15, s13
24012bd4:	ee67 7a27 	vmul.f32	s15, s14, s15
24012bd8:	edc7 7a07 	vstr	s15, [r7, #28]
        break;
24012bdc:	e043      	b.n	24012c66 <HAL_RCC_GetSysClockFreq+0x27e>

      case RCC_PLLSOURCE_HSE:  /* HSE used as PLL clock source */
        pllvco = ((float_t)HSE_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
24012bde:	693b      	ldr	r3, [r7, #16]
24012be0:	ee07 3a90 	vmov	s15, r3
24012be4:	eef8 7a67 	vcvt.f32.u32	s15, s15
24012be8:	eddf 6a37 	vldr	s13, [pc, #220]	; 24012cc8 <HAL_RCC_GetSysClockFreq+0x2e0>
24012bec:	ee86 7aa7 	vdiv.f32	s14, s13, s15
24012bf0:	4b2e      	ldr	r3, [pc, #184]	; (24012cac <HAL_RCC_GetSysClockFreq+0x2c4>)
24012bf2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
24012bf4:	f3c3 0308 	ubfx	r3, r3, #0, #9
24012bf8:	ee07 3a90 	vmov	s15, r3
24012bfc:	eef8 6a67 	vcvt.f32.u32	s13, s15
24012c00:	ed97 6a02 	vldr	s12, [r7, #8]
24012c04:	eddf 5a2d 	vldr	s11, [pc, #180]	; 24012cbc <HAL_RCC_GetSysClockFreq+0x2d4>
24012c08:	eec6 7a25 	vdiv.f32	s15, s12, s11
24012c0c:	ee76 7aa7 	vadd.f32	s15, s13, s15
24012c10:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
24012c14:	ee77 7aa6 	vadd.f32	s15, s15, s13
24012c18:	ee67 7a27 	vmul.f32	s15, s14, s15
24012c1c:	edc7 7a07 	vstr	s15, [r7, #28]
        break;
24012c20:	e021      	b.n	24012c66 <HAL_RCC_GetSysClockFreq+0x27e>

      default:
        pllvco = ((float_t)CSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
24012c22:	693b      	ldr	r3, [r7, #16]
24012c24:	ee07 3a90 	vmov	s15, r3
24012c28:	eef8 7a67 	vcvt.f32.u32	s15, s15
24012c2c:	eddf 6a25 	vldr	s13, [pc, #148]	; 24012cc4 <HAL_RCC_GetSysClockFreq+0x2dc>
24012c30:	ee86 7aa7 	vdiv.f32	s14, s13, s15
24012c34:	4b1d      	ldr	r3, [pc, #116]	; (24012cac <HAL_RCC_GetSysClockFreq+0x2c4>)
24012c36:	6b1b      	ldr	r3, [r3, #48]	; 0x30
24012c38:	f3c3 0308 	ubfx	r3, r3, #0, #9
24012c3c:	ee07 3a90 	vmov	s15, r3
24012c40:	eef8 6a67 	vcvt.f32.u32	s13, s15
24012c44:	ed97 6a02 	vldr	s12, [r7, #8]
24012c48:	eddf 5a1c 	vldr	s11, [pc, #112]	; 24012cbc <HAL_RCC_GetSysClockFreq+0x2d4>
24012c4c:	eec6 7a25 	vdiv.f32	s15, s12, s11
24012c50:	ee76 7aa7 	vadd.f32	s15, s13, s15
24012c54:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
24012c58:	ee77 7aa6 	vadd.f32	s15, s15, s13
24012c5c:	ee67 7a27 	vmul.f32	s15, s14, s15
24012c60:	edc7 7a07 	vstr	s15, [r7, #28]
        break;
24012c64:	bf00      	nop
      }
      pllp = (((RCC->PLL1DIVR & RCC_PLL1DIVR_P1) >>9) + 1U ) ;
24012c66:	4b11      	ldr	r3, [pc, #68]	; (24012cac <HAL_RCC_GetSysClockFreq+0x2c4>)
24012c68:	6b1b      	ldr	r3, [r3, #48]	; 0x30
24012c6a:	0a5b      	lsrs	r3, r3, #9
24012c6c:	f003 037f 	and.w	r3, r3, #127	; 0x7f
24012c70:	3301      	adds	r3, #1
24012c72:	603b      	str	r3, [r7, #0]
      sysclockfreq =  (uint32_t)(float_t)(pllvco/(float_t)pllp);
24012c74:	683b      	ldr	r3, [r7, #0]
24012c76:	ee07 3a90 	vmov	s15, r3
24012c7a:	eeb8 7a67 	vcvt.f32.u32	s14, s15
24012c7e:	edd7 6a07 	vldr	s13, [r7, #28]
24012c82:	eec6 7a87 	vdiv.f32	s15, s13, s14
24012c86:	eefc 7ae7 	vcvt.u32.f32	s15, s15
24012c8a:	ee17 3a90 	vmov	r3, s15
24012c8e:	61bb      	str	r3, [r7, #24]
    }
    else
    {
      sysclockfreq = 0U;
    }
    break;
24012c90:	e005      	b.n	24012c9e <HAL_RCC_GetSysClockFreq+0x2b6>
      sysclockfreq = 0U;
24012c92:	2300      	movs	r3, #0
24012c94:	61bb      	str	r3, [r7, #24]
    break;
24012c96:	e002      	b.n	24012c9e <HAL_RCC_GetSysClockFreq+0x2b6>

  default:
    sysclockfreq = CSI_VALUE;
24012c98:	4b06      	ldr	r3, [pc, #24]	; (24012cb4 <HAL_RCC_GetSysClockFreq+0x2cc>)
24012c9a:	61bb      	str	r3, [r7, #24]
    break;
24012c9c:	bf00      	nop
  }

  return sysclockfreq;
24012c9e:	69bb      	ldr	r3, [r7, #24]
}
24012ca0:	4618      	mov	r0, r3
24012ca2:	3724      	adds	r7, #36	; 0x24
24012ca4:	46bd      	mov	sp, r7
24012ca6:	f85d 7b04 	ldr.w	r7, [sp], #4
24012caa:	4770      	bx	lr
24012cac:	58024400 	.word	0x58024400
24012cb0:	03d09000 	.word	0x03d09000
24012cb4:	003d0900 	.word	0x003d0900
24012cb8:	017d7840 	.word	0x017d7840
24012cbc:	46000000 	.word	0x46000000
24012cc0:	4c742400 	.word	0x4c742400
24012cc4:	4a742400 	.word	0x4a742400
24012cc8:	4bbebc20 	.word	0x4bbebc20

24012ccc <HAL_RCC_GetHCLKFreq>:
  * @note   The SystemD2Clock CMSIS variable is used to store System domain2 Clock Frequency
  *         and updated within this function
  * @retval HCLK frequency
  */
uint32_t HAL_RCC_GetHCLKFreq(void)
{
24012ccc:	b580      	push	{r7, lr}
24012cce:	b082      	sub	sp, #8
24012cd0:	af00      	add	r7, sp, #0
uint32_t common_system_clock;

#if defined(RCC_D1CFGR_D1CPRE)
  common_system_clock = HAL_RCC_GetSysClockFreq() >> (D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos] & 0x1FU);
24012cd2:	f7ff fe89 	bl	240129e8 <HAL_RCC_GetSysClockFreq>
24012cd6:	4601      	mov	r1, r0
24012cd8:	4b10      	ldr	r3, [pc, #64]	; (24012d1c <HAL_RCC_GetHCLKFreq+0x50>)
24012cda:	699b      	ldr	r3, [r3, #24]
24012cdc:	0a1b      	lsrs	r3, r3, #8
24012cde:	f003 030f 	and.w	r3, r3, #15
24012ce2:	4a0f      	ldr	r2, [pc, #60]	; (24012d20 <HAL_RCC_GetHCLKFreq+0x54>)
24012ce4:	5cd3      	ldrb	r3, [r2, r3]
24012ce6:	f003 031f 	and.w	r3, r3, #31
24012cea:	fa21 f303 	lsr.w	r3, r1, r3
24012cee:	607b      	str	r3, [r7, #4]
#else
  common_system_clock = HAL_RCC_GetSysClockFreq() >> (D1CorePrescTable[(RCC->CDCFGR1 & RCC_CDCFGR1_CDCPRE)>> RCC_CDCFGR1_CDCPRE_Pos] & 0x1FU);
#endif

#if defined(RCC_D1CFGR_HPRE)
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
24012cf0:	4b0a      	ldr	r3, [pc, #40]	; (24012d1c <HAL_RCC_GetHCLKFreq+0x50>)
24012cf2:	699b      	ldr	r3, [r3, #24]
24012cf4:	f003 030f 	and.w	r3, r3, #15
24012cf8:	4a09      	ldr	r2, [pc, #36]	; (24012d20 <HAL_RCC_GetHCLKFreq+0x54>)
24012cfa:	5cd3      	ldrb	r3, [r2, r3]
24012cfc:	f003 031f 	and.w	r3, r3, #31
24012d00:	687a      	ldr	r2, [r7, #4]
24012d02:	fa22 f303 	lsr.w	r3, r2, r3
24012d06:	4a07      	ldr	r2, [pc, #28]	; (24012d24 <HAL_RCC_GetHCLKFreq+0x58>)
24012d08:	6013      	str	r3, [r2, #0]
#endif

#if defined(DUAL_CORE) && defined(CORE_CM4)
  SystemCoreClock = SystemD2Clock;
#else
  SystemCoreClock = common_system_clock;
24012d0a:	4a07      	ldr	r2, [pc, #28]	; (24012d28 <HAL_RCC_GetHCLKFreq+0x5c>)
24012d0c:	687b      	ldr	r3, [r7, #4]
24012d0e:	6013      	str	r3, [r2, #0]
#endif /* DUAL_CORE && CORE_CM4 */

  return SystemD2Clock;
24012d10:	4b04      	ldr	r3, [pc, #16]	; (24012d24 <HAL_RCC_GetHCLKFreq+0x58>)
24012d12:	681b      	ldr	r3, [r3, #0]
}
24012d14:	4618      	mov	r0, r3
24012d16:	3708      	adds	r7, #8
24012d18:	46bd      	mov	sp, r7
24012d1a:	bd80      	pop	{r7, pc}
24012d1c:	58024400 	.word	0x58024400
24012d20:	24016b70 	.word	0x24016b70
24012d24:	240004bc 	.word	0x240004bc
24012d28:	240004b8 	.word	0x240004b8

24012d2c <HAL_RCC_GetPCLK1Freq>:
  * @note   Each time PCLK1 changes, this function must be called to update the
  *         right PCLK1 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK1 frequency
  */
uint32_t HAL_RCC_GetPCLK1Freq(void)
{
24012d2c:	b580      	push	{r7, lr}
24012d2e:	af00      	add	r7, sp, #0
#if defined (RCC_D2CFGR_D2PPRE1)
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> ((D1CorePrescTable[(RCC->D2CFGR & RCC_D2CFGR_D2PPRE1)>> RCC_D2CFGR_D2PPRE1_Pos]) & 0x1FU));
24012d30:	f7ff ffcc 	bl	24012ccc <HAL_RCC_GetHCLKFreq>
24012d34:	4601      	mov	r1, r0
24012d36:	4b06      	ldr	r3, [pc, #24]	; (24012d50 <HAL_RCC_GetPCLK1Freq+0x24>)
24012d38:	69db      	ldr	r3, [r3, #28]
24012d3a:	091b      	lsrs	r3, r3, #4
24012d3c:	f003 0307 	and.w	r3, r3, #7
24012d40:	4a04      	ldr	r2, [pc, #16]	; (24012d54 <HAL_RCC_GetPCLK1Freq+0x28>)
24012d42:	5cd3      	ldrb	r3, [r2, r3]
24012d44:	f003 031f 	and.w	r3, r3, #31
24012d48:	fa21 f303 	lsr.w	r3, r1, r3
#else
 /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> ((D1CorePrescTable[(RCC->CDCFGR2 & RCC_CDCFGR2_CDPPRE1)>> RCC_CDCFGR2_CDPPRE1_Pos]) & 0x1FU));
#endif
}
24012d4c:	4618      	mov	r0, r3
24012d4e:	bd80      	pop	{r7, pc}
24012d50:	58024400 	.word	0x58024400
24012d54:	24016b70 	.word	0x24016b70

24012d58 <HAL_RCC_GetPCLK2Freq>:
  * @note   Each time PCLK2 changes, this function must be called to update the
  *         right PCLK2 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK1 frequency
  */
uint32_t HAL_RCC_GetPCLK2Freq(void)
{
24012d58:	b580      	push	{r7, lr}
24012d5a:	af00      	add	r7, sp, #0
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
#if defined(RCC_D2CFGR_D2PPRE2)
  return (HAL_RCC_GetHCLKFreq() >> ((D1CorePrescTable[(RCC->D2CFGR & RCC_D2CFGR_D2PPRE2)>> RCC_D2CFGR_D2PPRE2_Pos]) & 0x1FU));
24012d5c:	f7ff ffb6 	bl	24012ccc <HAL_RCC_GetHCLKFreq>
24012d60:	4601      	mov	r1, r0
24012d62:	4b06      	ldr	r3, [pc, #24]	; (24012d7c <HAL_RCC_GetPCLK2Freq+0x24>)
24012d64:	69db      	ldr	r3, [r3, #28]
24012d66:	0a1b      	lsrs	r3, r3, #8
24012d68:	f003 0307 	and.w	r3, r3, #7
24012d6c:	4a04      	ldr	r2, [pc, #16]	; (24012d80 <HAL_RCC_GetPCLK2Freq+0x28>)
24012d6e:	5cd3      	ldrb	r3, [r2, r3]
24012d70:	f003 031f 	and.w	r3, r3, #31
24012d74:	fa21 f303 	lsr.w	r3, r1, r3
#else
  return (HAL_RCC_GetHCLKFreq() >> ((D1CorePrescTable[(RCC->CDCFGR2 & RCC_CDCFGR2_CDPPRE2)>> RCC_CDCFGR2_CDPPRE2_Pos]) & 0x1FU));
#endif
}
24012d78:	4618      	mov	r0, r3
24012d7a:	bd80      	pop	{r7, pc}
24012d7c:	58024400 	.word	0x58024400
24012d80:	24016b70 	.word	0x24016b70

24012d84 <HAL_RCC_GetOscConfig>:
  * @param  RCC_OscInitStruct: pointer to an RCC_OscInitTypeDef structure that
  * will be configured.
  * @retval None
  */
void HAL_RCC_GetOscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
24012d84:	b580      	push	{r7, lr}
24012d86:	b082      	sub	sp, #8
24012d88:	af00      	add	r7, sp, #0
24012d8a:	6078      	str	r0, [r7, #4]
  /* Set all possible values for the Oscillator type parameter ---------------*/
  RCC_OscInitStruct->OscillatorType = RCC_OSCILLATORTYPE_HSE | RCC_OSCILLATORTYPE_HSI | RCC_OSCILLATORTYPE_CSI | \
24012d8c:	687b      	ldr	r3, [r7, #4]
24012d8e:	223f      	movs	r2, #63	; 0x3f
24012d90:	601a      	str	r2, [r3, #0]
  else
  {
    RCC_OscInitStruct->HSEState = RCC_HSE_OFF;
  }
#else
  if((RCC->CR &RCC_CR_HSEBYP) == RCC_CR_HSEBYP)
24012d92:	4b72      	ldr	r3, [pc, #456]	; (24012f5c <HAL_RCC_GetOscConfig+0x1d8>)
24012d94:	681b      	ldr	r3, [r3, #0]
24012d96:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
24012d9a:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
24012d9e:	d104      	bne.n	24012daa <HAL_RCC_GetOscConfig+0x26>
  {
    RCC_OscInitStruct->HSEState = RCC_HSE_BYPASS;
24012da0:	687b      	ldr	r3, [r7, #4]
24012da2:	f44f 22a0 	mov.w	r2, #327680	; 0x50000
24012da6:	605a      	str	r2, [r3, #4]
24012da8:	e00e      	b.n	24012dc8 <HAL_RCC_GetOscConfig+0x44>
  }
  else if((RCC->CR &RCC_CR_HSEON) == RCC_CR_HSEON)
24012daa:	4b6c      	ldr	r3, [pc, #432]	; (24012f5c <HAL_RCC_GetOscConfig+0x1d8>)
24012dac:	681b      	ldr	r3, [r3, #0]
24012dae:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
24012db2:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
24012db6:	d104      	bne.n	24012dc2 <HAL_RCC_GetOscConfig+0x3e>
  {
    RCC_OscInitStruct->HSEState = RCC_HSE_ON;
24012db8:	687b      	ldr	r3, [r7, #4]
24012dba:	f44f 3280 	mov.w	r2, #65536	; 0x10000
24012dbe:	605a      	str	r2, [r3, #4]
24012dc0:	e002      	b.n	24012dc8 <HAL_RCC_GetOscConfig+0x44>
  }
  else
  {
    RCC_OscInitStruct->HSEState = RCC_HSE_OFF;
24012dc2:	687b      	ldr	r3, [r7, #4]
24012dc4:	2200      	movs	r2, #0
24012dc6:	605a      	str	r2, [r3, #4]
  }
#endif /* RCC_CR_HSEEXT */

   /* Get the CSI configuration -----------------------------------------------*/
  if((RCC->CR &RCC_CR_CSION) == RCC_CR_CSION)
24012dc8:	4b64      	ldr	r3, [pc, #400]	; (24012f5c <HAL_RCC_GetOscConfig+0x1d8>)
24012dca:	681b      	ldr	r3, [r3, #0]
24012dcc:	f003 0380 	and.w	r3, r3, #128	; 0x80
24012dd0:	2b80      	cmp	r3, #128	; 0x80
24012dd2:	d103      	bne.n	24012ddc <HAL_RCC_GetOscConfig+0x58>
  {
    RCC_OscInitStruct->CSIState = RCC_CSI_ON;
24012dd4:	687b      	ldr	r3, [r7, #4]
24012dd6:	2280      	movs	r2, #128	; 0x80
24012dd8:	61da      	str	r2, [r3, #28]
24012dda:	e002      	b.n	24012de2 <HAL_RCC_GetOscConfig+0x5e>
  }
  else
  {
    RCC_OscInitStruct->CSIState = RCC_CSI_OFF;
24012ddc:	687b      	ldr	r3, [r7, #4]
24012dde:	2200      	movs	r2, #0
24012de0:	61da      	str	r2, [r3, #28]
  }

#if defined(RCC_VER_X)
  if(HAL_GetREVID() <= REV_ID_Y)
24012de2:	f7ed fdcf 	bl	24000984 <HAL_GetREVID>
24012de6:	4602      	mov	r2, r0
24012de8:	f241 0303 	movw	r3, #4099	; 0x1003
24012dec:	429a      	cmp	r2, r3
24012dee:	d807      	bhi.n	24012e00 <HAL_RCC_GetOscConfig+0x7c>
  {
    RCC_OscInitStruct->CSICalibrationValue = (uint32_t)(READ_BIT(RCC->HSICFGR, HAL_RCC_REV_Y_CSITRIM_Msk) >> HAL_RCC_REV_Y_CSITRIM_Pos);
24012df0:	4b5a      	ldr	r3, [pc, #360]	; (24012f5c <HAL_RCC_GetOscConfig+0x1d8>)
24012df2:	685b      	ldr	r3, [r3, #4]
24012df4:	0e9b      	lsrs	r3, r3, #26
24012df6:	f003 021f 	and.w	r2, r3, #31
24012dfa:	687b      	ldr	r3, [r7, #4]
24012dfc:	621a      	str	r2, [r3, #32]
24012dfe:	e006      	b.n	24012e0e <HAL_RCC_GetOscConfig+0x8a>
  }
  else
  {
    RCC_OscInitStruct->CSICalibrationValue = (uint32_t)(READ_BIT(RCC->CSICFGR, RCC_CSICFGR_CSITRIM) >> RCC_CSICFGR_CSITRIM_Pos);
24012e00:	4b56      	ldr	r3, [pc, #344]	; (24012f5c <HAL_RCC_GetOscConfig+0x1d8>)
24012e02:	68db      	ldr	r3, [r3, #12]
24012e04:	0e1b      	lsrs	r3, r3, #24
24012e06:	f003 023f 	and.w	r2, r3, #63	; 0x3f
24012e0a:	687b      	ldr	r3, [r7, #4]
24012e0c:	621a      	str	r2, [r3, #32]
#else
 RCC_OscInitStruct->CSICalibrationValue = (uint32_t)(READ_BIT(RCC->CSICFGR, RCC_CSICFGR_CSITRIM) >> RCC_CSICFGR_CSITRIM_Pos);
#endif /*RCC_VER_X*/

  /* Get the HSI configuration -----------------------------------------------*/
  if((RCC->CR &RCC_CR_HSION) == RCC_CR_HSION)
24012e0e:	4b53      	ldr	r3, [pc, #332]	; (24012f5c <HAL_RCC_GetOscConfig+0x1d8>)
24012e10:	681b      	ldr	r3, [r3, #0]
24012e12:	f003 0301 	and.w	r3, r3, #1
24012e16:	2b01      	cmp	r3, #1
24012e18:	d103      	bne.n	24012e22 <HAL_RCC_GetOscConfig+0x9e>
  {
    RCC_OscInitStruct->HSIState = RCC_HSI_ON;
24012e1a:	687b      	ldr	r3, [r7, #4]
24012e1c:	2201      	movs	r2, #1
24012e1e:	60da      	str	r2, [r3, #12]
24012e20:	e002      	b.n	24012e28 <HAL_RCC_GetOscConfig+0xa4>
  }
  else
  {
    RCC_OscInitStruct->HSIState = RCC_HSI_OFF;
24012e22:	687b      	ldr	r3, [r7, #4]
24012e24:	2200      	movs	r2, #0
24012e26:	60da      	str	r2, [r3, #12]
  }

#if defined(RCC_VER_X)
  if(HAL_GetREVID() <= REV_ID_Y)
24012e28:	f7ed fdac 	bl	24000984 <HAL_GetREVID>
24012e2c:	4602      	mov	r2, r0
24012e2e:	f241 0303 	movw	r3, #4099	; 0x1003
24012e32:	429a      	cmp	r2, r3
24012e34:	d807      	bhi.n	24012e46 <HAL_RCC_GetOscConfig+0xc2>
  {
    RCC_OscInitStruct->HSICalibrationValue = (uint32_t)(READ_BIT(RCC->HSICFGR, HAL_RCC_REV_Y_HSITRIM_Msk) >> HAL_RCC_REV_Y_HSITRIM_Pos);
24012e36:	4b49      	ldr	r3, [pc, #292]	; (24012f5c <HAL_RCC_GetOscConfig+0x1d8>)
24012e38:	685b      	ldr	r3, [r3, #4]
24012e3a:	0b1b      	lsrs	r3, r3, #12
24012e3c:	f003 023f 	and.w	r2, r3, #63	; 0x3f
24012e40:	687b      	ldr	r3, [r7, #4]
24012e42:	611a      	str	r2, [r3, #16]
24012e44:	e006      	b.n	24012e54 <HAL_RCC_GetOscConfig+0xd0>
  }
  else
  {
    RCC_OscInitStruct->HSICalibrationValue = (uint32_t)(READ_BIT(RCC->HSICFGR, RCC_HSICFGR_HSITRIM) >> RCC_HSICFGR_HSITRIM_Pos);
24012e46:	4b45      	ldr	r3, [pc, #276]	; (24012f5c <HAL_RCC_GetOscConfig+0x1d8>)
24012e48:	685b      	ldr	r3, [r3, #4]
24012e4a:	0e1b      	lsrs	r3, r3, #24
24012e4c:	f003 027f 	and.w	r2, r3, #127	; 0x7f
24012e50:	687b      	ldr	r3, [r7, #4]
24012e52:	611a      	str	r2, [r3, #16]
  else
  {
    RCC_OscInitStruct->LSEState = RCC_LSE_OFF;
  }
#else
  if((RCC->BDCR &RCC_BDCR_LSEBYP) == RCC_BDCR_LSEBYP)
24012e54:	4b41      	ldr	r3, [pc, #260]	; (24012f5c <HAL_RCC_GetOscConfig+0x1d8>)
24012e56:	6f1b      	ldr	r3, [r3, #112]	; 0x70
24012e58:	f003 0304 	and.w	r3, r3, #4
24012e5c:	2b04      	cmp	r3, #4
24012e5e:	d103      	bne.n	24012e68 <HAL_RCC_GetOscConfig+0xe4>
  {
    RCC_OscInitStruct->LSEState = RCC_LSE_BYPASS;
24012e60:	687b      	ldr	r3, [r7, #4]
24012e62:	2205      	movs	r2, #5
24012e64:	609a      	str	r2, [r3, #8]
24012e66:	e00c      	b.n	24012e82 <HAL_RCC_GetOscConfig+0xfe>
  }
  else if((RCC->BDCR &RCC_BDCR_LSEON) == RCC_BDCR_LSEON)
24012e68:	4b3c      	ldr	r3, [pc, #240]	; (24012f5c <HAL_RCC_GetOscConfig+0x1d8>)
24012e6a:	6f1b      	ldr	r3, [r3, #112]	; 0x70
24012e6c:	f003 0301 	and.w	r3, r3, #1
24012e70:	2b01      	cmp	r3, #1
24012e72:	d103      	bne.n	24012e7c <HAL_RCC_GetOscConfig+0xf8>
  {
    RCC_OscInitStruct->LSEState = RCC_LSE_ON;
24012e74:	687b      	ldr	r3, [r7, #4]
24012e76:	2201      	movs	r2, #1
24012e78:	609a      	str	r2, [r3, #8]
24012e7a:	e002      	b.n	24012e82 <HAL_RCC_GetOscConfig+0xfe>
  }
  else
  {
    RCC_OscInitStruct->LSEState = RCC_LSE_OFF;
24012e7c:	687b      	ldr	r3, [r7, #4]
24012e7e:	2200      	movs	r2, #0
24012e80:	609a      	str	r2, [r3, #8]
  }
#endif /* RCC_BDCR_LSEEXT */

  /* Get the LSI configuration -----------------------------------------------*/
  if((RCC->CSR &RCC_CSR_LSION) == RCC_CSR_LSION)
24012e82:	4b36      	ldr	r3, [pc, #216]	; (24012f5c <HAL_RCC_GetOscConfig+0x1d8>)
24012e84:	6f5b      	ldr	r3, [r3, #116]	; 0x74
24012e86:	f003 0301 	and.w	r3, r3, #1
24012e8a:	2b01      	cmp	r3, #1
24012e8c:	d103      	bne.n	24012e96 <HAL_RCC_GetOscConfig+0x112>
  {
    RCC_OscInitStruct->LSIState = RCC_LSI_ON;
24012e8e:	687b      	ldr	r3, [r7, #4]
24012e90:	2201      	movs	r2, #1
24012e92:	615a      	str	r2, [r3, #20]
24012e94:	e002      	b.n	24012e9c <HAL_RCC_GetOscConfig+0x118>
  }
  else
  {
    RCC_OscInitStruct->LSIState = RCC_LSI_OFF;
24012e96:	687b      	ldr	r3, [r7, #4]
24012e98:	2200      	movs	r2, #0
24012e9a:	615a      	str	r2, [r3, #20]
  }

  /* Get the HSI48 configuration ---------------------------------------------*/
  if((RCC->CR & RCC_CR_HSI48ON) == RCC_CR_HSI48ON)
24012e9c:	4b2f      	ldr	r3, [pc, #188]	; (24012f5c <HAL_RCC_GetOscConfig+0x1d8>)
24012e9e:	681b      	ldr	r3, [r3, #0]
24012ea0:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
24012ea4:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
24012ea8:	d103      	bne.n	24012eb2 <HAL_RCC_GetOscConfig+0x12e>
  {
    RCC_OscInitStruct->HSI48State = RCC_HSI48_ON;
24012eaa:	687b      	ldr	r3, [r7, #4]
24012eac:	2201      	movs	r2, #1
24012eae:	619a      	str	r2, [r3, #24]
24012eb0:	e002      	b.n	24012eb8 <HAL_RCC_GetOscConfig+0x134>
  }
  else
  {
    RCC_OscInitStruct->HSI48State = RCC_HSI48_OFF;
24012eb2:	687b      	ldr	r3, [r7, #4]
24012eb4:	2200      	movs	r2, #0
24012eb6:	619a      	str	r2, [r3, #24]
  }

  /* Get the PLL configuration -----------------------------------------------*/
  if((RCC->CR &RCC_CR_PLLON) == RCC_CR_PLLON)
24012eb8:	4b28      	ldr	r3, [pc, #160]	; (24012f5c <HAL_RCC_GetOscConfig+0x1d8>)
24012eba:	681b      	ldr	r3, [r3, #0]
24012ebc:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
24012ec0:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
24012ec4:	d103      	bne.n	24012ece <HAL_RCC_GetOscConfig+0x14a>
  {
    RCC_OscInitStruct->PLL.PLLState = RCC_PLL_ON;
24012ec6:	687b      	ldr	r3, [r7, #4]
24012ec8:	2202      	movs	r2, #2
24012eca:	625a      	str	r2, [r3, #36]	; 0x24
24012ecc:	e002      	b.n	24012ed4 <HAL_RCC_GetOscConfig+0x150>
  }
  else
  {
    RCC_OscInitStruct->PLL.PLLState = RCC_PLL_OFF;
24012ece:	687b      	ldr	r3, [r7, #4]
24012ed0:	2201      	movs	r2, #1
24012ed2:	625a      	str	r2, [r3, #36]	; 0x24
  }
  RCC_OscInitStruct->PLL.PLLSource = (uint32_t)(RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
24012ed4:	4b21      	ldr	r3, [pc, #132]	; (24012f5c <HAL_RCC_GetOscConfig+0x1d8>)
24012ed6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
24012ed8:	f003 0203 	and.w	r2, r3, #3
24012edc:	687b      	ldr	r3, [r7, #4]
24012ede:	629a      	str	r2, [r3, #40]	; 0x28
  RCC_OscInitStruct->PLL.PLLM = (uint32_t)((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM1)>> RCC_PLLCKSELR_DIVM1_Pos);
24012ee0:	4b1e      	ldr	r3, [pc, #120]	; (24012f5c <HAL_RCC_GetOscConfig+0x1d8>)
24012ee2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
24012ee4:	091b      	lsrs	r3, r3, #4
24012ee6:	f003 023f 	and.w	r2, r3, #63	; 0x3f
24012eea:	687b      	ldr	r3, [r7, #4]
24012eec:	62da      	str	r2, [r3, #44]	; 0x2c
  RCC_OscInitStruct->PLL.PLLN = (uint32_t)((RCC->PLL1DIVR & RCC_PLL1DIVR_N1) >> RCC_PLL1DIVR_N1_Pos)+ 1U;
24012eee:	4b1b      	ldr	r3, [pc, #108]	; (24012f5c <HAL_RCC_GetOscConfig+0x1d8>)
24012ef0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
24012ef2:	f3c3 0308 	ubfx	r3, r3, #0, #9
24012ef6:	1c5a      	adds	r2, r3, #1
24012ef8:	687b      	ldr	r3, [r7, #4]
24012efa:	631a      	str	r2, [r3, #48]	; 0x30
  RCC_OscInitStruct->PLL.PLLR = (uint32_t)((RCC->PLL1DIVR & RCC_PLL1DIVR_R1) >> RCC_PLL1DIVR_R1_Pos)+ 1U;
24012efc:	4b17      	ldr	r3, [pc, #92]	; (24012f5c <HAL_RCC_GetOscConfig+0x1d8>)
24012efe:	6b1b      	ldr	r3, [r3, #48]	; 0x30
24012f00:	0e1b      	lsrs	r3, r3, #24
24012f02:	f003 037f 	and.w	r3, r3, #127	; 0x7f
24012f06:	1c5a      	adds	r2, r3, #1
24012f08:	687b      	ldr	r3, [r7, #4]
24012f0a:	63da      	str	r2, [r3, #60]	; 0x3c
  RCC_OscInitStruct->PLL.PLLP = (uint32_t)((RCC->PLL1DIVR & RCC_PLL1DIVR_P1) >> RCC_PLL1DIVR_P1_Pos)+ 1U;
24012f0c:	4b13      	ldr	r3, [pc, #76]	; (24012f5c <HAL_RCC_GetOscConfig+0x1d8>)
24012f0e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
24012f10:	0a5b      	lsrs	r3, r3, #9
24012f12:	f003 037f 	and.w	r3, r3, #127	; 0x7f
24012f16:	1c5a      	adds	r2, r3, #1
24012f18:	687b      	ldr	r3, [r7, #4]
24012f1a:	635a      	str	r2, [r3, #52]	; 0x34
  RCC_OscInitStruct->PLL.PLLQ = (uint32_t)((RCC->PLL1DIVR & RCC_PLL1DIVR_Q1) >> RCC_PLL1DIVR_Q1_Pos)+ 1U;
24012f1c:	4b0f      	ldr	r3, [pc, #60]	; (24012f5c <HAL_RCC_GetOscConfig+0x1d8>)
24012f1e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
24012f20:	0c1b      	lsrs	r3, r3, #16
24012f22:	f003 037f 	and.w	r3, r3, #127	; 0x7f
24012f26:	1c5a      	adds	r2, r3, #1
24012f28:	687b      	ldr	r3, [r7, #4]
24012f2a:	639a      	str	r2, [r3, #56]	; 0x38
  RCC_OscInitStruct->PLL.PLLRGE = (uint32_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLL1RGE));
24012f2c:	4b0b      	ldr	r3, [pc, #44]	; (24012f5c <HAL_RCC_GetOscConfig+0x1d8>)
24012f2e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24012f30:	f003 020c 	and.w	r2, r3, #12
24012f34:	687b      	ldr	r3, [r7, #4]
24012f36:	641a      	str	r2, [r3, #64]	; 0x40
  RCC_OscInitStruct->PLL.PLLVCOSEL = (uint32_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLL1VCOSEL) >> RCC_PLLCFGR_PLL1VCOSEL_Pos);
24012f38:	4b08      	ldr	r3, [pc, #32]	; (24012f5c <HAL_RCC_GetOscConfig+0x1d8>)
24012f3a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24012f3c:	085b      	lsrs	r3, r3, #1
24012f3e:	f003 0201 	and.w	r2, r3, #1
24012f42:	687b      	ldr	r3, [r7, #4]
24012f44:	645a      	str	r2, [r3, #68]	; 0x44
  RCC_OscInitStruct->PLL.PLLFRACN = (uint32_t)(((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1) >> RCC_PLL1FRACR_FRACN1_Pos));
24012f46:	4b05      	ldr	r3, [pc, #20]	; (24012f5c <HAL_RCC_GetOscConfig+0x1d8>)
24012f48:	6b5b      	ldr	r3, [r3, #52]	; 0x34
24012f4a:	08db      	lsrs	r3, r3, #3
24012f4c:	f3c3 020c 	ubfx	r2, r3, #0, #13
24012f50:	687b      	ldr	r3, [r7, #4]
24012f52:	649a      	str	r2, [r3, #72]	; 0x48
}
24012f54:	bf00      	nop
24012f56:	3708      	adds	r7, #8
24012f58:	46bd      	mov	sp, r7
24012f5a:	bd80      	pop	{r7, pc}
24012f5c:	58024400 	.word	0x58024400

24012f60 <HAL_RCC_GetClockConfig>:
  * will be configured.
  * @param  pFLatency: Pointer on the Flash Latency.
  * @retval None
  */
void HAL_RCC_GetClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t *pFLatency)
{
24012f60:	b480      	push	{r7}
24012f62:	b083      	sub	sp, #12
24012f64:	af00      	add	r7, sp, #0
24012f66:	6078      	str	r0, [r7, #4]
24012f68:	6039      	str	r1, [r7, #0]
  /* Set all possible values for the Clock type parameter --------------------*/
  RCC_ClkInitStruct->ClockType = RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_D1PCLK1 | RCC_CLOCKTYPE_PCLK1 |
24012f6a:	687b      	ldr	r3, [r7, #4]
24012f6c:	223f      	movs	r2, #63	; 0x3f
24012f6e:	601a      	str	r2, [r3, #0]
                                 RCC_CLOCKTYPE_PCLK2 |  RCC_CLOCKTYPE_D3PCLK1  ;

  /* Get the SYSCLK configuration --------------------------------------------*/
  RCC_ClkInitStruct->SYSCLKSource = (uint32_t)(RCC->CFGR & RCC_CFGR_SW);
24012f70:	4b1a      	ldr	r3, [pc, #104]	; (24012fdc <HAL_RCC_GetClockConfig+0x7c>)
24012f72:	691b      	ldr	r3, [r3, #16]
24012f74:	f003 0207 	and.w	r2, r3, #7
24012f78:	687b      	ldr	r3, [r7, #4]
24012f7a:	605a      	str	r2, [r3, #4]

#if defined(RCC_D1CFGR_D1CPRE)
  /* Get the SYSCLK configuration ----------------------------------------------*/
  RCC_ClkInitStruct->SYSCLKDivider = (uint32_t)(RCC->D1CFGR & RCC_D1CFGR_D1CPRE);
24012f7c:	4b17      	ldr	r3, [pc, #92]	; (24012fdc <HAL_RCC_GetClockConfig+0x7c>)
24012f7e:	699b      	ldr	r3, [r3, #24]
24012f80:	f403 6270 	and.w	r2, r3, #3840	; 0xf00
24012f84:	687b      	ldr	r3, [r7, #4]
24012f86:	609a      	str	r2, [r3, #8]

  /* Get the D1HCLK configuration ----------------------------------------------*/
  RCC_ClkInitStruct->AHBCLKDivider = (uint32_t)(RCC->D1CFGR & RCC_D1CFGR_HPRE);
24012f88:	4b14      	ldr	r3, [pc, #80]	; (24012fdc <HAL_RCC_GetClockConfig+0x7c>)
24012f8a:	699b      	ldr	r3, [r3, #24]
24012f8c:	f003 020f 	and.w	r2, r3, #15
24012f90:	687b      	ldr	r3, [r7, #4]
24012f92:	60da      	str	r2, [r3, #12]

  /* Get the APB3 configuration ----------------------------------------------*/
  RCC_ClkInitStruct->APB3CLKDivider = (uint32_t)(RCC->D1CFGR & RCC_D1CFGR_D1PPRE);
24012f94:	4b11      	ldr	r3, [pc, #68]	; (24012fdc <HAL_RCC_GetClockConfig+0x7c>)
24012f96:	699b      	ldr	r3, [r3, #24]
24012f98:	f003 0270 	and.w	r2, r3, #112	; 0x70
24012f9c:	687b      	ldr	r3, [r7, #4]
24012f9e:	611a      	str	r2, [r3, #16]

  /* Get the APB1 configuration ----------------------------------------------*/
  RCC_ClkInitStruct->APB1CLKDivider = (uint32_t)(RCC->D2CFGR & RCC_D2CFGR_D2PPRE1);
24012fa0:	4b0e      	ldr	r3, [pc, #56]	; (24012fdc <HAL_RCC_GetClockConfig+0x7c>)
24012fa2:	69db      	ldr	r3, [r3, #28]
24012fa4:	f003 0270 	and.w	r2, r3, #112	; 0x70
24012fa8:	687b      	ldr	r3, [r7, #4]
24012faa:	615a      	str	r2, [r3, #20]

  /* Get the APB2 configuration ----------------------------------------------*/
  RCC_ClkInitStruct->APB2CLKDivider = (uint32_t)(RCC->D2CFGR & RCC_D2CFGR_D2PPRE2);
24012fac:	4b0b      	ldr	r3, [pc, #44]	; (24012fdc <HAL_RCC_GetClockConfig+0x7c>)
24012fae:	69db      	ldr	r3, [r3, #28]
24012fb0:	f403 62e0 	and.w	r2, r3, #1792	; 0x700
24012fb4:	687b      	ldr	r3, [r7, #4]
24012fb6:	619a      	str	r2, [r3, #24]

  /* Get the APB4 configuration ----------------------------------------------*/
  RCC_ClkInitStruct->APB4CLKDivider = (uint32_t)(RCC->D3CFGR & RCC_D3CFGR_D3PPRE);
24012fb8:	4b08      	ldr	r3, [pc, #32]	; (24012fdc <HAL_RCC_GetClockConfig+0x7c>)
24012fba:	6a1b      	ldr	r3, [r3, #32]
24012fbc:	f003 0270 	and.w	r2, r3, #112	; 0x70
24012fc0:	687b      	ldr	r3, [r7, #4]
24012fc2:	61da      	str	r2, [r3, #28]
  /* Get the APB4 configuration ----------------------------------------------*/
  RCC_ClkInitStruct->APB4CLKDivider = (uint32_t)(RCC->SRDCFGR & RCC_SRDCFGR_SRDPPRE);
#endif

  /* Get the Flash Wait State (Latency) configuration ------------------------*/
  *pFLatency = (uint32_t)(FLASH->ACR & FLASH_ACR_LATENCY);
24012fc4:	4b06      	ldr	r3, [pc, #24]	; (24012fe0 <HAL_RCC_GetClockConfig+0x80>)
24012fc6:	681b      	ldr	r3, [r3, #0]
24012fc8:	f003 020f 	and.w	r2, r3, #15
24012fcc:	683b      	ldr	r3, [r7, #0]
24012fce:	601a      	str	r2, [r3, #0]
}
24012fd0:	bf00      	nop
24012fd2:	370c      	adds	r7, #12
24012fd4:	46bd      	mov	sp, r7
24012fd6:	f85d 7b04 	ldr.w	r7, [sp], #4
24012fda:	4770      	bx	lr
24012fdc:	58024400 	.word	0x58024400
24012fe0:	52002000 	.word	0x52002000

24012fe4 <HAL_RCC_NMI_IRQHandler>:
  * @brief This function handles the RCC CSS interrupt request.
  * @note This API should be called under the NMI_Handler().
  * @retval None
  */
void HAL_RCC_NMI_IRQHandler(void)
{
24012fe4:	b580      	push	{r7, lr}
24012fe6:	af00      	add	r7, sp, #0
  /* Check RCC CSSF flag  */
  if(__HAL_RCC_GET_IT(RCC_IT_CSS))
24012fe8:	4b07      	ldr	r3, [pc, #28]	; (24013008 <HAL_RCC_NMI_IRQHandler+0x24>)
24012fea:	6e5b      	ldr	r3, [r3, #100]	; 0x64
24012fec:	f403 6380 	and.w	r3, r3, #1024	; 0x400
24012ff0:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
24012ff4:	d105      	bne.n	24013002 <HAL_RCC_NMI_IRQHandler+0x1e>
  {
    /* RCC Clock Security System interrupt user callback */
    HAL_RCC_CCSCallback();
24012ff6:	f000 f809 	bl	2401300c <HAL_RCC_CSSCallback>

    /* Clear RCC CSS pending bit */
    __HAL_RCC_CLEAR_IT(RCC_IT_CSS);
24012ffa:	4b03      	ldr	r3, [pc, #12]	; (24013008 <HAL_RCC_NMI_IRQHandler+0x24>)
24012ffc:	f44f 6280 	mov.w	r2, #1024	; 0x400
24013000:	669a      	str	r2, [r3, #104]	; 0x68
  }
}
24013002:	bf00      	nop
24013004:	bd80      	pop	{r7, pc}
24013006:	bf00      	nop
24013008:	58024400 	.word	0x58024400

2401300c <HAL_RCC_CSSCallback>:
/**
  * @brief  RCC Clock Security System interrupt callback
  * @retval none
  */
__weak void HAL_RCC_CCSCallback(void)
{
2401300c:	b480      	push	{r7}
2401300e:	af00      	add	r7, sp, #0
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_RCC_CCSCallback could be implemented in the user file
   */
}
24013010:	bf00      	nop
24013012:	46bd      	mov	sp, r7
24013014:	f85d 7b04 	ldr.w	r7, [sp], #4
24013018:	4770      	bx	lr
	...

2401301c <HAL_RCCEx_PeriphCLKConfig>:
  * (*) : Available on some STM32H7 lines only.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
{
2401301c:	b580      	push	{r7, lr}
2401301e:	b086      	sub	sp, #24
24013020:	af00      	add	r7, sp, #0
24013022:	6078      	str	r0, [r7, #4]
  uint32_t tmpreg;
  uint32_t tickstart;
  HAL_StatusTypeDef ret = HAL_OK;      /* Intermediate status */
24013024:	2300      	movs	r3, #0
24013026:	75fb      	strb	r3, [r7, #23]
  HAL_StatusTypeDef status = HAL_OK;   /* Final status */
24013028:	2300      	movs	r3, #0
2401302a:	75bb      	strb	r3, [r7, #22]

  /*---------------------------- SPDIFRX configuration -------------------------------*/

  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPDIFRX) == RCC_PERIPHCLK_SPDIFRX)
2401302c:	687b      	ldr	r3, [r7, #4]
2401302e:	681b      	ldr	r3, [r3, #0]
24013030:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
24013034:	2b00      	cmp	r3, #0
24013036:	d03d      	beq.n	240130b4 <HAL_RCCEx_PeriphCLKConfig+0x98>
  {

    switch(PeriphClkInit->SpdifrxClockSelection)
24013038:	687b      	ldr	r3, [r7, #4]
2401303a:	6e5b      	ldr	r3, [r3, #100]	; 0x64
2401303c:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
24013040:	d013      	beq.n	2401306a <HAL_RCCEx_PeriphCLKConfig+0x4e>
24013042:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
24013046:	d802      	bhi.n	2401304e <HAL_RCCEx_PeriphCLKConfig+0x32>
24013048:	2b00      	cmp	r3, #0
2401304a:	d007      	beq.n	2401305c <HAL_RCCEx_PeriphCLKConfig+0x40>
2401304c:	e01f      	b.n	2401308e <HAL_RCCEx_PeriphCLKConfig+0x72>
2401304e:	f5b3 1f00 	cmp.w	r3, #2097152	; 0x200000
24013052:	d013      	beq.n	2401307c <HAL_RCCEx_PeriphCLKConfig+0x60>
24013054:	f5b3 1f40 	cmp.w	r3, #3145728	; 0x300000
24013058:	d01c      	beq.n	24013094 <HAL_RCCEx_PeriphCLKConfig+0x78>
2401305a:	e018      	b.n	2401308e <HAL_RCCEx_PeriphCLKConfig+0x72>
    {
    case RCC_SPDIFRXCLKSOURCE_PLL:      /* PLL is used as clock source for SPDIFRX*/
      /* Enable PLL1Q Clock output generated form System PLL . */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
2401305c:	4baf      	ldr	r3, [pc, #700]	; (2401331c <HAL_RCCEx_PeriphCLKConfig+0x300>)
2401305e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24013060:	4aae      	ldr	r2, [pc, #696]	; (2401331c <HAL_RCCEx_PeriphCLKConfig+0x300>)
24013062:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
24013066:	62d3      	str	r3, [r2, #44]	; 0x2c

      /* SPDIFRX clock source configuration done later after clock selection check */
      break;
24013068:	e015      	b.n	24013096 <HAL_RCCEx_PeriphCLKConfig+0x7a>

    case RCC_SPDIFRXCLKSOURCE_PLL2: /* PLL2 is used as clock source for SPDIFRX*/

      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_R_UPDATE);
2401306a:	687b      	ldr	r3, [r7, #4]
2401306c:	3304      	adds	r3, #4
2401306e:	2102      	movs	r1, #2
24013070:	4618      	mov	r0, r3
24013072:	f002 f8e1 	bl	24015238 <RCCEx_PLL2_Config>
24013076:	4603      	mov	r3, r0
24013078:	75fb      	strb	r3, [r7, #23]

      /* SPDIFRX clock source configuration done later after clock selection check */
      break;
2401307a:	e00c      	b.n	24013096 <HAL_RCCEx_PeriphCLKConfig+0x7a>

    case RCC_SPDIFRXCLKSOURCE_PLL3:  /* PLL3 is used as clock source for SPDIFRX*/
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_R_UPDATE);
2401307c:	687b      	ldr	r3, [r7, #4]
2401307e:	3324      	adds	r3, #36	; 0x24
24013080:	2102      	movs	r1, #2
24013082:	4618      	mov	r0, r3
24013084:	f002 f98a 	bl	2401539c <RCCEx_PLL3_Config>
24013088:	4603      	mov	r3, r0
2401308a:	75fb      	strb	r3, [r7, #23]

      /* SPDIFRX clock source configuration done later after clock selection check */
      break;
2401308c:	e003      	b.n	24013096 <HAL_RCCEx_PeriphCLKConfig+0x7a>
      /* Internal OSC clock is used as source of SPDIFRX clock*/
      /* SPDIFRX clock source configuration done later after clock selection check */
      break;

    default:
      ret = HAL_ERROR;
2401308e:	2301      	movs	r3, #1
24013090:	75fb      	strb	r3, [r7, #23]
      break;
24013092:	e000      	b.n	24013096 <HAL_RCCEx_PeriphCLKConfig+0x7a>
      break;
24013094:	bf00      	nop
    }

    if(ret == HAL_OK)
24013096:	7dfb      	ldrb	r3, [r7, #23]
24013098:	2b00      	cmp	r3, #0
2401309a:	d109      	bne.n	240130b0 <HAL_RCCEx_PeriphCLKConfig+0x94>
    {
      /* Set the source of SPDIFRX clock*/
      __HAL_RCC_SPDIFRX_CONFIG(PeriphClkInit->SpdifrxClockSelection);
2401309c:	4b9f      	ldr	r3, [pc, #636]	; (2401331c <HAL_RCCEx_PeriphCLKConfig+0x300>)
2401309e:	6d1b      	ldr	r3, [r3, #80]	; 0x50
240130a0:	f423 1240 	bic.w	r2, r3, #3145728	; 0x300000
240130a4:	687b      	ldr	r3, [r7, #4]
240130a6:	6e5b      	ldr	r3, [r3, #100]	; 0x64
240130a8:	499c      	ldr	r1, [pc, #624]	; (2401331c <HAL_RCCEx_PeriphCLKConfig+0x300>)
240130aa:	4313      	orrs	r3, r2
240130ac:	650b      	str	r3, [r1, #80]	; 0x50
240130ae:	e001      	b.n	240130b4 <HAL_RCCEx_PeriphCLKConfig+0x98>
    }
    else
    {
      /* set overall return value */
      status = ret;
240130b0:	7dfb      	ldrb	r3, [r7, #23]
240130b2:	75bb      	strb	r3, [r7, #22]
    }
  }

  /*---------------------------- SAI1 configuration -------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1)
240130b4:	687b      	ldr	r3, [r7, #4]
240130b6:	681b      	ldr	r3, [r3, #0]
240130b8:	f403 7380 	and.w	r3, r3, #256	; 0x100
240130bc:	2b00      	cmp	r3, #0
240130be:	d03d      	beq.n	2401313c <HAL_RCCEx_PeriphCLKConfig+0x120>
  {
    switch(PeriphClkInit->Sai1ClockSelection)
240130c0:	687b      	ldr	r3, [r7, #4]
240130c2:	6d5b      	ldr	r3, [r3, #84]	; 0x54
240130c4:	2b04      	cmp	r3, #4
240130c6:	d826      	bhi.n	24013116 <HAL_RCCEx_PeriphCLKConfig+0xfa>
240130c8:	a201      	add	r2, pc, #4	; (adr r2, 240130d0 <HAL_RCCEx_PeriphCLKConfig+0xb4>)
240130ca:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
240130ce:	bf00      	nop
240130d0:	240130e5 	.word	0x240130e5
240130d4:	240130f3 	.word	0x240130f3
240130d8:	24013105 	.word	0x24013105
240130dc:	2401311d 	.word	0x2401311d
240130e0:	2401311d 	.word	0x2401311d
    {
    case RCC_SAI1CLKSOURCE_PLL:      /* PLL is used as clock source for SAI1*/
      /* Enable SAI Clock output generated form System PLL . */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
240130e4:	4b8d      	ldr	r3, [pc, #564]	; (2401331c <HAL_RCCEx_PeriphCLKConfig+0x300>)
240130e6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
240130e8:	4a8c      	ldr	r2, [pc, #560]	; (2401331c <HAL_RCCEx_PeriphCLKConfig+0x300>)
240130ea:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
240130ee:	62d3      	str	r3, [r2, #44]	; 0x2c

      /* SAI1 clock source configuration done later after clock selection check */
      break;
240130f0:	e015      	b.n	2401311e <HAL_RCCEx_PeriphCLKConfig+0x102>

    case RCC_SAI1CLKSOURCE_PLL2: /* PLL2 is used as clock source for SAI1*/

      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);
240130f2:	687b      	ldr	r3, [r7, #4]
240130f4:	3304      	adds	r3, #4
240130f6:	2100      	movs	r1, #0
240130f8:	4618      	mov	r0, r3
240130fa:	f002 f89d 	bl	24015238 <RCCEx_PLL2_Config>
240130fe:	4603      	mov	r3, r0
24013100:	75fb      	strb	r3, [r7, #23]

      /* SAI1 clock source configuration done later after clock selection check */
      break;
24013102:	e00c      	b.n	2401311e <HAL_RCCEx_PeriphCLKConfig+0x102>

    case RCC_SAI1CLKSOURCE_PLL3:  /* PLL3 is used as clock source for SAI1*/
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_P_UPDATE);
24013104:	687b      	ldr	r3, [r7, #4]
24013106:	3324      	adds	r3, #36	; 0x24
24013108:	2100      	movs	r1, #0
2401310a:	4618      	mov	r0, r3
2401310c:	f002 f946 	bl	2401539c <RCCEx_PLL3_Config>
24013110:	4603      	mov	r3, r0
24013112:	75fb      	strb	r3, [r7, #23]

      /* SAI1 clock source configuration done later after clock selection check */
      break;
24013114:	e003      	b.n	2401311e <HAL_RCCEx_PeriphCLKConfig+0x102>
      /* HSI, HSE, or CSI oscillator is used as source of SAI1 clock */
      /* SAI1 clock source configuration done later after clock selection check */
      break;

    default:
      ret = HAL_ERROR;
24013116:	2301      	movs	r3, #1
24013118:	75fb      	strb	r3, [r7, #23]
      break;
2401311a:	e000      	b.n	2401311e <HAL_RCCEx_PeriphCLKConfig+0x102>
      break;
2401311c:	bf00      	nop
    }

    if(ret == HAL_OK)
2401311e:	7dfb      	ldrb	r3, [r7, #23]
24013120:	2b00      	cmp	r3, #0
24013122:	d109      	bne.n	24013138 <HAL_RCCEx_PeriphCLKConfig+0x11c>
    {
      /* Set the source of SAI1 clock*/
      __HAL_RCC_SAI1_CONFIG(PeriphClkInit->Sai1ClockSelection);
24013124:	4b7d      	ldr	r3, [pc, #500]	; (2401331c <HAL_RCCEx_PeriphCLKConfig+0x300>)
24013126:	6d1b      	ldr	r3, [r3, #80]	; 0x50
24013128:	f023 0207 	bic.w	r2, r3, #7
2401312c:	687b      	ldr	r3, [r7, #4]
2401312e:	6d5b      	ldr	r3, [r3, #84]	; 0x54
24013130:	497a      	ldr	r1, [pc, #488]	; (2401331c <HAL_RCCEx_PeriphCLKConfig+0x300>)
24013132:	4313      	orrs	r3, r2
24013134:	650b      	str	r3, [r1, #80]	; 0x50
24013136:	e001      	b.n	2401313c <HAL_RCCEx_PeriphCLKConfig+0x120>
    }
    else
    {
      /* set overall return value */
      status = ret;
24013138:	7dfb      	ldrb	r3, [r7, #23]
2401313a:	75bb      	strb	r3, [r7, #22]
    }
  }

#if defined(SAI3)
  /*---------------------------- SAI2/3 configuration -------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI23) == RCC_PERIPHCLK_SAI23)
2401313c:	687b      	ldr	r3, [r7, #4]
2401313e:	681b      	ldr	r3, [r3, #0]
24013140:	f403 7300 	and.w	r3, r3, #512	; 0x200
24013144:	2b00      	cmp	r3, #0
24013146:	d03e      	beq.n	240131c6 <HAL_RCCEx_PeriphCLKConfig+0x1aa>
  {
    switch(PeriphClkInit->Sai23ClockSelection)
24013148:	687b      	ldr	r3, [r7, #4]
2401314a:	6d9b      	ldr	r3, [r3, #88]	; 0x58
2401314c:	2b80      	cmp	r3, #128	; 0x80
2401314e:	d01c      	beq.n	2401318a <HAL_RCCEx_PeriphCLKConfig+0x16e>
24013150:	2b80      	cmp	r3, #128	; 0x80
24013152:	d804      	bhi.n	2401315e <HAL_RCCEx_PeriphCLKConfig+0x142>
24013154:	2b00      	cmp	r3, #0
24013156:	d008      	beq.n	2401316a <HAL_RCCEx_PeriphCLKConfig+0x14e>
24013158:	2b40      	cmp	r3, #64	; 0x40
2401315a:	d00d      	beq.n	24013178 <HAL_RCCEx_PeriphCLKConfig+0x15c>
2401315c:	e01e      	b.n	2401319c <HAL_RCCEx_PeriphCLKConfig+0x180>
2401315e:	2bc0      	cmp	r3, #192	; 0xc0
24013160:	d01f      	beq.n	240131a2 <HAL_RCCEx_PeriphCLKConfig+0x186>
24013162:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
24013166:	d01e      	beq.n	240131a6 <HAL_RCCEx_PeriphCLKConfig+0x18a>
24013168:	e018      	b.n	2401319c <HAL_RCCEx_PeriphCLKConfig+0x180>
    {
    case RCC_SAI23CLKSOURCE_PLL:      /* PLL is used as clock source for SAI2/3 */
      /* Enable SAI Clock output generated form System PLL . */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
2401316a:	4b6c      	ldr	r3, [pc, #432]	; (2401331c <HAL_RCCEx_PeriphCLKConfig+0x300>)
2401316c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2401316e:	4a6b      	ldr	r2, [pc, #428]	; (2401331c <HAL_RCCEx_PeriphCLKConfig+0x300>)
24013170:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
24013174:	62d3      	str	r3, [r2, #44]	; 0x2c

      /* SAI2/3 clock source configuration done later after clock selection check */
      break;
24013176:	e017      	b.n	240131a8 <HAL_RCCEx_PeriphCLKConfig+0x18c>

    case RCC_SAI23CLKSOURCE_PLL2: /* PLL2 is used as clock source for SAI2/3 */

      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);
24013178:	687b      	ldr	r3, [r7, #4]
2401317a:	3304      	adds	r3, #4
2401317c:	2100      	movs	r1, #0
2401317e:	4618      	mov	r0, r3
24013180:	f002 f85a 	bl	24015238 <RCCEx_PLL2_Config>
24013184:	4603      	mov	r3, r0
24013186:	75fb      	strb	r3, [r7, #23]

      /* SAI2/3 clock source configuration done later after clock selection check */
      break;
24013188:	e00e      	b.n	240131a8 <HAL_RCCEx_PeriphCLKConfig+0x18c>

    case RCC_SAI23CLKSOURCE_PLL3:  /* PLL3 is used as clock source for SAI2/3 */
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_P_UPDATE);
2401318a:	687b      	ldr	r3, [r7, #4]
2401318c:	3324      	adds	r3, #36	; 0x24
2401318e:	2100      	movs	r1, #0
24013190:	4618      	mov	r0, r3
24013192:	f002 f903 	bl	2401539c <RCCEx_PLL3_Config>
24013196:	4603      	mov	r3, r0
24013198:	75fb      	strb	r3, [r7, #23]

      /* SAI2/3 clock source configuration done later after clock selection check */
      break;
2401319a:	e005      	b.n	240131a8 <HAL_RCCEx_PeriphCLKConfig+0x18c>
      /* HSI, HSE, or CSI oscillator is used as source of SAI2/3 clock */
      /* SAI2/3 clock source configuration done later after clock selection check */
      break;

    default:
      ret = HAL_ERROR;
2401319c:	2301      	movs	r3, #1
2401319e:	75fb      	strb	r3, [r7, #23]
      break;
240131a0:	e002      	b.n	240131a8 <HAL_RCCEx_PeriphCLKConfig+0x18c>
      break;
240131a2:	bf00      	nop
240131a4:	e000      	b.n	240131a8 <HAL_RCCEx_PeriphCLKConfig+0x18c>
      break;
240131a6:	bf00      	nop
    }

    if(ret == HAL_OK)
240131a8:	7dfb      	ldrb	r3, [r7, #23]
240131aa:	2b00      	cmp	r3, #0
240131ac:	d109      	bne.n	240131c2 <HAL_RCCEx_PeriphCLKConfig+0x1a6>
    {
      /* Set the source of SAI2/3 clock*/
      __HAL_RCC_SAI23_CONFIG(PeriphClkInit->Sai23ClockSelection);
240131ae:	4b5b      	ldr	r3, [pc, #364]	; (2401331c <HAL_RCCEx_PeriphCLKConfig+0x300>)
240131b0:	6d1b      	ldr	r3, [r3, #80]	; 0x50
240131b2:	f423 72e0 	bic.w	r2, r3, #448	; 0x1c0
240131b6:	687b      	ldr	r3, [r7, #4]
240131b8:	6d9b      	ldr	r3, [r3, #88]	; 0x58
240131ba:	4958      	ldr	r1, [pc, #352]	; (2401331c <HAL_RCCEx_PeriphCLKConfig+0x300>)
240131bc:	4313      	orrs	r3, r2
240131be:	650b      	str	r3, [r1, #80]	; 0x50
240131c0:	e001      	b.n	240131c6 <HAL_RCCEx_PeriphCLKConfig+0x1aa>
    }
    else
    {
      /* set overall return value */
      status = ret;
240131c2:	7dfb      	ldrb	r3, [r7, #23]
240131c4:	75bb      	strb	r3, [r7, #22]
  }
#endif  /*SAI2B*/

#if defined(SAI4)
  /*---------------------------- SAI4A configuration -------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI4A) == RCC_PERIPHCLK_SAI4A)
240131c6:	687b      	ldr	r3, [r7, #4]
240131c8:	681b      	ldr	r3, [r3, #0]
240131ca:	f403 6380 	and.w	r3, r3, #1024	; 0x400
240131ce:	2b00      	cmp	r3, #0
240131d0:	d044      	beq.n	2401325c <HAL_RCCEx_PeriphCLKConfig+0x240>
  {
    switch(PeriphClkInit->Sai4AClockSelection)
240131d2:	687b      	ldr	r3, [r7, #4]
240131d4:	f8d3 30a4 	ldr.w	r3, [r3, #164]	; 0xa4
240131d8:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
240131dc:	d01f      	beq.n	2401321e <HAL_RCCEx_PeriphCLKConfig+0x202>
240131de:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
240131e2:	d805      	bhi.n	240131f0 <HAL_RCCEx_PeriphCLKConfig+0x1d4>
240131e4:	2b00      	cmp	r3, #0
240131e6:	d00a      	beq.n	240131fe <HAL_RCCEx_PeriphCLKConfig+0x1e2>
240131e8:	f5b3 1f00 	cmp.w	r3, #2097152	; 0x200000
240131ec:	d00e      	beq.n	2401320c <HAL_RCCEx_PeriphCLKConfig+0x1f0>
240131ee:	e01f      	b.n	24013230 <HAL_RCCEx_PeriphCLKConfig+0x214>
240131f0:	f5b3 0fc0 	cmp.w	r3, #6291456	; 0x600000
240131f4:	d01f      	beq.n	24013236 <HAL_RCCEx_PeriphCLKConfig+0x21a>
240131f6:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
240131fa:	d01e      	beq.n	2401323a <HAL_RCCEx_PeriphCLKConfig+0x21e>
240131fc:	e018      	b.n	24013230 <HAL_RCCEx_PeriphCLKConfig+0x214>
    {
    case RCC_SAI4ACLKSOURCE_PLL:      /* PLL is used as clock source for SAI2*/
      /* Enable SAI Clock output generated form System PLL . */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
240131fe:	4b47      	ldr	r3, [pc, #284]	; (2401331c <HAL_RCCEx_PeriphCLKConfig+0x300>)
24013200:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24013202:	4a46      	ldr	r2, [pc, #280]	; (2401331c <HAL_RCCEx_PeriphCLKConfig+0x300>)
24013204:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
24013208:	62d3      	str	r3, [r2, #44]	; 0x2c

      /* SAI1 clock source configuration done later after clock selection check */
      break;
2401320a:	e017      	b.n	2401323c <HAL_RCCEx_PeriphCLKConfig+0x220>

    case RCC_SAI4ACLKSOURCE_PLL2: /* PLL2 is used as clock source for SAI2*/

      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);
2401320c:	687b      	ldr	r3, [r7, #4]
2401320e:	3304      	adds	r3, #4
24013210:	2100      	movs	r1, #0
24013212:	4618      	mov	r0, r3
24013214:	f002 f810 	bl	24015238 <RCCEx_PLL2_Config>
24013218:	4603      	mov	r3, r0
2401321a:	75fb      	strb	r3, [r7, #23]

      /* SAI2 clock source configuration done later after clock selection check */
      break;
2401321c:	e00e      	b.n	2401323c <HAL_RCCEx_PeriphCLKConfig+0x220>

    case RCC_SAI4ACLKSOURCE_PLL3:  /* PLL3 is used as clock source for SAI2*/
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_P_UPDATE);
2401321e:	687b      	ldr	r3, [r7, #4]
24013220:	3324      	adds	r3, #36	; 0x24
24013222:	2100      	movs	r1, #0
24013224:	4618      	mov	r0, r3
24013226:	f002 f8b9 	bl	2401539c <RCCEx_PLL3_Config>
2401322a:	4603      	mov	r3, r0
2401322c:	75fb      	strb	r3, [r7, #23]

      /* SAI1 clock source configuration done later after clock selection check */
      break;
2401322e:	e005      	b.n	2401323c <HAL_RCCEx_PeriphCLKConfig+0x220>
      /* HSI, HSE, or CSI oscillator is used as source of SAI2 clock */
      /* SAI1 clock source configuration done later after clock selection check */
      break;

    default:
      ret = HAL_ERROR;
24013230:	2301      	movs	r3, #1
24013232:	75fb      	strb	r3, [r7, #23]
      break;
24013234:	e002      	b.n	2401323c <HAL_RCCEx_PeriphCLKConfig+0x220>
      break;
24013236:	bf00      	nop
24013238:	e000      	b.n	2401323c <HAL_RCCEx_PeriphCLKConfig+0x220>
      break;
2401323a:	bf00      	nop
    }

    if(ret == HAL_OK)
2401323c:	7dfb      	ldrb	r3, [r7, #23]
2401323e:	2b00      	cmp	r3, #0
24013240:	d10a      	bne.n	24013258 <HAL_RCCEx_PeriphCLKConfig+0x23c>
    {
      /* Set the source of SAI4A clock*/
      __HAL_RCC_SAI4A_CONFIG(PeriphClkInit->Sai4AClockSelection);
24013242:	4b36      	ldr	r3, [pc, #216]	; (2401331c <HAL_RCCEx_PeriphCLKConfig+0x300>)
24013244:	6d9b      	ldr	r3, [r3, #88]	; 0x58
24013246:	f423 0260 	bic.w	r2, r3, #14680064	; 0xe00000
2401324a:	687b      	ldr	r3, [r7, #4]
2401324c:	f8d3 30a4 	ldr.w	r3, [r3, #164]	; 0xa4
24013250:	4932      	ldr	r1, [pc, #200]	; (2401331c <HAL_RCCEx_PeriphCLKConfig+0x300>)
24013252:	4313      	orrs	r3, r2
24013254:	658b      	str	r3, [r1, #88]	; 0x58
24013256:	e001      	b.n	2401325c <HAL_RCCEx_PeriphCLKConfig+0x240>
    }
    else
    {
      /* set overall return value */
      status = ret;
24013258:	7dfb      	ldrb	r3, [r7, #23]
2401325a:	75bb      	strb	r3, [r7, #22]
    }
  }
  /*---------------------------- SAI4B configuration -------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI4B) == RCC_PERIPHCLK_SAI4B)
2401325c:	687b      	ldr	r3, [r7, #4]
2401325e:	681b      	ldr	r3, [r3, #0]
24013260:	f403 6300 	and.w	r3, r3, #2048	; 0x800
24013264:	2b00      	cmp	r3, #0
24013266:	d044      	beq.n	240132f2 <HAL_RCCEx_PeriphCLKConfig+0x2d6>
  {
    switch(PeriphClkInit->Sai4BClockSelection)
24013268:	687b      	ldr	r3, [r7, #4]
2401326a:	f8d3 30a8 	ldr.w	r3, [r3, #168]	; 0xa8
2401326e:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
24013272:	d01f      	beq.n	240132b4 <HAL_RCCEx_PeriphCLKConfig+0x298>
24013274:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
24013278:	d805      	bhi.n	24013286 <HAL_RCCEx_PeriphCLKConfig+0x26a>
2401327a:	2b00      	cmp	r3, #0
2401327c:	d00a      	beq.n	24013294 <HAL_RCCEx_PeriphCLKConfig+0x278>
2401327e:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
24013282:	d00e      	beq.n	240132a2 <HAL_RCCEx_PeriphCLKConfig+0x286>
24013284:	e01f      	b.n	240132c6 <HAL_RCCEx_PeriphCLKConfig+0x2aa>
24013286:	f1b3 7f40 	cmp.w	r3, #50331648	; 0x3000000
2401328a:	d01f      	beq.n	240132cc <HAL_RCCEx_PeriphCLKConfig+0x2b0>
2401328c:	f1b3 6f80 	cmp.w	r3, #67108864	; 0x4000000
24013290:	d01e      	beq.n	240132d0 <HAL_RCCEx_PeriphCLKConfig+0x2b4>
24013292:	e018      	b.n	240132c6 <HAL_RCCEx_PeriphCLKConfig+0x2aa>
    {
    case RCC_SAI4BCLKSOURCE_PLL:      /* PLL is used as clock source for SAI2*/
      /* Enable SAI Clock output generated form System PLL . */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
24013294:	4b21      	ldr	r3, [pc, #132]	; (2401331c <HAL_RCCEx_PeriphCLKConfig+0x300>)
24013296:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24013298:	4a20      	ldr	r2, [pc, #128]	; (2401331c <HAL_RCCEx_PeriphCLKConfig+0x300>)
2401329a:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
2401329e:	62d3      	str	r3, [r2, #44]	; 0x2c

      /* SAI1 clock source configuration done later after clock selection check */
      break;
240132a0:	e017      	b.n	240132d2 <HAL_RCCEx_PeriphCLKConfig+0x2b6>

    case RCC_SAI4BCLKSOURCE_PLL2: /* PLL2 is used as clock source for SAI2*/

      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);
240132a2:	687b      	ldr	r3, [r7, #4]
240132a4:	3304      	adds	r3, #4
240132a6:	2100      	movs	r1, #0
240132a8:	4618      	mov	r0, r3
240132aa:	f001 ffc5 	bl	24015238 <RCCEx_PLL2_Config>
240132ae:	4603      	mov	r3, r0
240132b0:	75fb      	strb	r3, [r7, #23]

      /* SAI2 clock source configuration done later after clock selection check */
      break;
240132b2:	e00e      	b.n	240132d2 <HAL_RCCEx_PeriphCLKConfig+0x2b6>

    case RCC_SAI4BCLKSOURCE_PLL3:  /* PLL3 is used as clock source for SAI2*/
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_P_UPDATE);
240132b4:	687b      	ldr	r3, [r7, #4]
240132b6:	3324      	adds	r3, #36	; 0x24
240132b8:	2100      	movs	r1, #0
240132ba:	4618      	mov	r0, r3
240132bc:	f002 f86e 	bl	2401539c <RCCEx_PLL3_Config>
240132c0:	4603      	mov	r3, r0
240132c2:	75fb      	strb	r3, [r7, #23]

      /* SAI1 clock source configuration done later after clock selection check */
      break;
240132c4:	e005      	b.n	240132d2 <HAL_RCCEx_PeriphCLKConfig+0x2b6>
      /* HSI, HSE, or CSI oscillator is used as source of SAI2 clock */
      /* SAI1 clock source configuration done later after clock selection check */
      break;

    default:
      ret = HAL_ERROR;
240132c6:	2301      	movs	r3, #1
240132c8:	75fb      	strb	r3, [r7, #23]
      break;
240132ca:	e002      	b.n	240132d2 <HAL_RCCEx_PeriphCLKConfig+0x2b6>
      break;
240132cc:	bf00      	nop
240132ce:	e000      	b.n	240132d2 <HAL_RCCEx_PeriphCLKConfig+0x2b6>
      break;
240132d0:	bf00      	nop
    }

    if(ret == HAL_OK)
240132d2:	7dfb      	ldrb	r3, [r7, #23]
240132d4:	2b00      	cmp	r3, #0
240132d6:	d10a      	bne.n	240132ee <HAL_RCCEx_PeriphCLKConfig+0x2d2>
    {
      /* Set the source of SAI4B clock*/
      __HAL_RCC_SAI4B_CONFIG(PeriphClkInit->Sai4BClockSelection);
240132d8:	4b10      	ldr	r3, [pc, #64]	; (2401331c <HAL_RCCEx_PeriphCLKConfig+0x300>)
240132da:	6d9b      	ldr	r3, [r3, #88]	; 0x58
240132dc:	f023 62e0 	bic.w	r2, r3, #117440512	; 0x7000000
240132e0:	687b      	ldr	r3, [r7, #4]
240132e2:	f8d3 30a8 	ldr.w	r3, [r3, #168]	; 0xa8
240132e6:	490d      	ldr	r1, [pc, #52]	; (2401331c <HAL_RCCEx_PeriphCLKConfig+0x300>)
240132e8:	4313      	orrs	r3, r2
240132ea:	658b      	str	r3, [r1, #88]	; 0x58
240132ec:	e001      	b.n	240132f2 <HAL_RCCEx_PeriphCLKConfig+0x2d6>
    }
    else
    {
      /* set overall return value */
      status = ret;
240132ee:	7dfb      	ldrb	r3, [r7, #23]
240132f0:	75bb      	strb	r3, [r7, #22]
  }
#endif  /*SAI4*/

#if defined(QUADSPI)
  /*---------------------------- QSPI configuration -------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_QSPI) == RCC_PERIPHCLK_QSPI)
240132f2:	687b      	ldr	r3, [r7, #4]
240132f4:	681b      	ldr	r3, [r3, #0]
240132f6:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
240132fa:	2b00      	cmp	r3, #0
240132fc:	d035      	beq.n	2401336a <HAL_RCCEx_PeriphCLKConfig+0x34e>
  {
    switch(PeriphClkInit->QspiClockSelection)
240132fe:	687b      	ldr	r3, [r7, #4]
24013300:	6c9b      	ldr	r3, [r3, #72]	; 0x48
24013302:	2b10      	cmp	r3, #16
24013304:	d00c      	beq.n	24013320 <HAL_RCCEx_PeriphCLKConfig+0x304>
24013306:	2b10      	cmp	r3, #16
24013308:	d802      	bhi.n	24013310 <HAL_RCCEx_PeriphCLKConfig+0x2f4>
2401330a:	2b00      	cmp	r3, #0
2401330c:	d01b      	beq.n	24013346 <HAL_RCCEx_PeriphCLKConfig+0x32a>
2401330e:	e017      	b.n	24013340 <HAL_RCCEx_PeriphCLKConfig+0x324>
24013310:	2b20      	cmp	r3, #32
24013312:	d00c      	beq.n	2401332e <HAL_RCCEx_PeriphCLKConfig+0x312>
24013314:	2b30      	cmp	r3, #48	; 0x30
24013316:	d018      	beq.n	2401334a <HAL_RCCEx_PeriphCLKConfig+0x32e>
24013318:	e012      	b.n	24013340 <HAL_RCCEx_PeriphCLKConfig+0x324>
2401331a:	bf00      	nop
2401331c:	58024400 	.word	0x58024400
    {
    case RCC_QSPICLKSOURCE_PLL:      /* PLL is used as clock source for QSPI*/
      /* Enable QSPI Clock output generated form System PLL . */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
24013320:	4baf      	ldr	r3, [pc, #700]	; (240135e0 <HAL_RCCEx_PeriphCLKConfig+0x5c4>)
24013322:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24013324:	4aae      	ldr	r2, [pc, #696]	; (240135e0 <HAL_RCCEx_PeriphCLKConfig+0x5c4>)
24013326:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
2401332a:	62d3      	str	r3, [r2, #44]	; 0x2c

      /* QSPI clock source configuration done later after clock selection check */
      break;
2401332c:	e00e      	b.n	2401334c <HAL_RCCEx_PeriphCLKConfig+0x330>

    case RCC_QSPICLKSOURCE_PLL2: /* PLL2 is used as clock source for QSPI*/

      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_R_UPDATE);
2401332e:	687b      	ldr	r3, [r7, #4]
24013330:	3304      	adds	r3, #4
24013332:	2102      	movs	r1, #2
24013334:	4618      	mov	r0, r3
24013336:	f001 ff7f 	bl	24015238 <RCCEx_PLL2_Config>
2401333a:	4603      	mov	r3, r0
2401333c:	75fb      	strb	r3, [r7, #23]

      /* QSPI clock source configuration done later after clock selection check */
      break;
2401333e:	e005      	b.n	2401334c <HAL_RCCEx_PeriphCLKConfig+0x330>
    case RCC_QSPICLKSOURCE_D1HCLK:
      /* Domain1 HCLK  clock selected as QSPI kernel peripheral clock */
      break;

    default:
      ret = HAL_ERROR;
24013340:	2301      	movs	r3, #1
24013342:	75fb      	strb	r3, [r7, #23]
      break;
24013344:	e002      	b.n	2401334c <HAL_RCCEx_PeriphCLKConfig+0x330>
      break;
24013346:	bf00      	nop
24013348:	e000      	b.n	2401334c <HAL_RCCEx_PeriphCLKConfig+0x330>
      break;
2401334a:	bf00      	nop
    }

    if(ret == HAL_OK)
2401334c:	7dfb      	ldrb	r3, [r7, #23]
2401334e:	2b00      	cmp	r3, #0
24013350:	d109      	bne.n	24013366 <HAL_RCCEx_PeriphCLKConfig+0x34a>
    {
      /* Set the source of QSPI clock*/
      __HAL_RCC_QSPI_CONFIG(PeriphClkInit->QspiClockSelection);
24013352:	4ba3      	ldr	r3, [pc, #652]	; (240135e0 <HAL_RCCEx_PeriphCLKConfig+0x5c4>)
24013354:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
24013356:	f023 0230 	bic.w	r2, r3, #48	; 0x30
2401335a:	687b      	ldr	r3, [r7, #4]
2401335c:	6c9b      	ldr	r3, [r3, #72]	; 0x48
2401335e:	49a0      	ldr	r1, [pc, #640]	; (240135e0 <HAL_RCCEx_PeriphCLKConfig+0x5c4>)
24013360:	4313      	orrs	r3, r2
24013362:	64cb      	str	r3, [r1, #76]	; 0x4c
24013364:	e001      	b.n	2401336a <HAL_RCCEx_PeriphCLKConfig+0x34e>
    }
    else
    {
      /* set overall return value */
      status = ret;
24013366:	7dfb      	ldrb	r3, [r7, #23]
24013368:	75bb      	strb	r3, [r7, #22]
    }
  }
#endif  /*OCTOSPI*/

  /*---------------------------- SPI1/2/3 configuration -------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPI123) == RCC_PERIPHCLK_SPI123)
2401336a:	687b      	ldr	r3, [r7, #4]
2401336c:	681b      	ldr	r3, [r3, #0]
2401336e:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
24013372:	2b00      	cmp	r3, #0
24013374:	d042      	beq.n	240133fc <HAL_RCCEx_PeriphCLKConfig+0x3e0>
  {
    switch(PeriphClkInit->Spi123ClockSelection)
24013376:	687b      	ldr	r3, [r7, #4]
24013378:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
2401337a:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
2401337e:	d01f      	beq.n	240133c0 <HAL_RCCEx_PeriphCLKConfig+0x3a4>
24013380:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
24013384:	d805      	bhi.n	24013392 <HAL_RCCEx_PeriphCLKConfig+0x376>
24013386:	2b00      	cmp	r3, #0
24013388:	d00a      	beq.n	240133a0 <HAL_RCCEx_PeriphCLKConfig+0x384>
2401338a:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
2401338e:	d00e      	beq.n	240133ae <HAL_RCCEx_PeriphCLKConfig+0x392>
24013390:	e01f      	b.n	240133d2 <HAL_RCCEx_PeriphCLKConfig+0x3b6>
24013392:	f5b3 5f40 	cmp.w	r3, #12288	; 0x3000
24013396:	d01f      	beq.n	240133d8 <HAL_RCCEx_PeriphCLKConfig+0x3bc>
24013398:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
2401339c:	d01e      	beq.n	240133dc <HAL_RCCEx_PeriphCLKConfig+0x3c0>
2401339e:	e018      	b.n	240133d2 <HAL_RCCEx_PeriphCLKConfig+0x3b6>
    {
    case RCC_SPI123CLKSOURCE_PLL:      /* PLL is used as clock source for SPI1/2/3 */
      /* Enable SPI Clock output generated form System PLL . */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
240133a0:	4b8f      	ldr	r3, [pc, #572]	; (240135e0 <HAL_RCCEx_PeriphCLKConfig+0x5c4>)
240133a2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
240133a4:	4a8e      	ldr	r2, [pc, #568]	; (240135e0 <HAL_RCCEx_PeriphCLKConfig+0x5c4>)
240133a6:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
240133aa:	62d3      	str	r3, [r2, #44]	; 0x2c

      /* SPI1/2/3 clock source configuration done later after clock selection check */
      break;
240133ac:	e017      	b.n	240133de <HAL_RCCEx_PeriphCLKConfig+0x3c2>

    case RCC_SPI123CLKSOURCE_PLL2: /* PLL2 is used as clock source for SPI1/2/3 */
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);
240133ae:	687b      	ldr	r3, [r7, #4]
240133b0:	3304      	adds	r3, #4
240133b2:	2100      	movs	r1, #0
240133b4:	4618      	mov	r0, r3
240133b6:	f001 ff3f 	bl	24015238 <RCCEx_PLL2_Config>
240133ba:	4603      	mov	r3, r0
240133bc:	75fb      	strb	r3, [r7, #23]

      /* SPI1/2/3 clock source configuration done later after clock selection check */
      break;
240133be:	e00e      	b.n	240133de <HAL_RCCEx_PeriphCLKConfig+0x3c2>

    case RCC_SPI123CLKSOURCE_PLL3:  /* PLL3 is used as clock source for SPI1/2/3 */
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_P_UPDATE);
240133c0:	687b      	ldr	r3, [r7, #4]
240133c2:	3324      	adds	r3, #36	; 0x24
240133c4:	2100      	movs	r1, #0
240133c6:	4618      	mov	r0, r3
240133c8:	f001 ffe8 	bl	2401539c <RCCEx_PLL3_Config>
240133cc:	4603      	mov	r3, r0
240133ce:	75fb      	strb	r3, [r7, #23]

      /* SPI1/2/3 clock source configuration done later after clock selection check */
      break;
240133d0:	e005      	b.n	240133de <HAL_RCCEx_PeriphCLKConfig+0x3c2>
      /* HSI, HSE, or CSI oscillator is used as source of SPI1/2/3 clock */
      /* SPI1/2/3 clock source configuration done later after clock selection check */
      break;

    default:
      ret = HAL_ERROR;
240133d2:	2301      	movs	r3, #1
240133d4:	75fb      	strb	r3, [r7, #23]
      break;
240133d6:	e002      	b.n	240133de <HAL_RCCEx_PeriphCLKConfig+0x3c2>
      break;
240133d8:	bf00      	nop
240133da:	e000      	b.n	240133de <HAL_RCCEx_PeriphCLKConfig+0x3c2>
      break;
240133dc:	bf00      	nop
    }

    if(ret == HAL_OK)
240133de:	7dfb      	ldrb	r3, [r7, #23]
240133e0:	2b00      	cmp	r3, #0
240133e2:	d109      	bne.n	240133f8 <HAL_RCCEx_PeriphCLKConfig+0x3dc>
    {
      /* Set the source of SPI1/2/3 clock*/
      __HAL_RCC_SPI123_CONFIG(PeriphClkInit->Spi123ClockSelection);
240133e4:	4b7e      	ldr	r3, [pc, #504]	; (240135e0 <HAL_RCCEx_PeriphCLKConfig+0x5c4>)
240133e6:	6d1b      	ldr	r3, [r3, #80]	; 0x50
240133e8:	f423 42e0 	bic.w	r2, r3, #28672	; 0x7000
240133ec:	687b      	ldr	r3, [r7, #4]
240133ee:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
240133f0:	497b      	ldr	r1, [pc, #492]	; (240135e0 <HAL_RCCEx_PeriphCLKConfig+0x5c4>)
240133f2:	4313      	orrs	r3, r2
240133f4:	650b      	str	r3, [r1, #80]	; 0x50
240133f6:	e001      	b.n	240133fc <HAL_RCCEx_PeriphCLKConfig+0x3e0>
    }
    else
    {
      /* set overall return value */
      status = ret;
240133f8:	7dfb      	ldrb	r3, [r7, #23]
240133fa:	75bb      	strb	r3, [r7, #22]
    }
  }

  /*---------------------------- SPI4/5 configuration -------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPI45) == RCC_PERIPHCLK_SPI45)
240133fc:	687b      	ldr	r3, [r7, #4]
240133fe:	681b      	ldr	r3, [r3, #0]
24013400:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
24013404:	2b00      	cmp	r3, #0
24013406:	d042      	beq.n	2401348e <HAL_RCCEx_PeriphCLKConfig+0x472>
  {
    switch(PeriphClkInit->Spi45ClockSelection)
24013408:	687b      	ldr	r3, [r7, #4]
2401340a:	6e1b      	ldr	r3, [r3, #96]	; 0x60
2401340c:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
24013410:	d01b      	beq.n	2401344a <HAL_RCCEx_PeriphCLKConfig+0x42e>
24013412:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
24013416:	d805      	bhi.n	24013424 <HAL_RCCEx_PeriphCLKConfig+0x408>
24013418:	2b00      	cmp	r3, #0
2401341a:	d022      	beq.n	24013462 <HAL_RCCEx_PeriphCLKConfig+0x446>
2401341c:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
24013420:	d00a      	beq.n	24013438 <HAL_RCCEx_PeriphCLKConfig+0x41c>
24013422:	e01b      	b.n	2401345c <HAL_RCCEx_PeriphCLKConfig+0x440>
24013424:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
24013428:	d01d      	beq.n	24013466 <HAL_RCCEx_PeriphCLKConfig+0x44a>
2401342a:	f5b3 2fa0 	cmp.w	r3, #327680	; 0x50000
2401342e:	d01c      	beq.n	2401346a <HAL_RCCEx_PeriphCLKConfig+0x44e>
24013430:	f5b3 3f40 	cmp.w	r3, #196608	; 0x30000
24013434:	d01b      	beq.n	2401346e <HAL_RCCEx_PeriphCLKConfig+0x452>
24013436:	e011      	b.n	2401345c <HAL_RCCEx_PeriphCLKConfig+0x440>
      /* SPI4/5 clock source configuration done later after clock selection check */
      break;

    case RCC_SPI45CLKSOURCE_PLL2: /* PLL2 is used as clock source for SPI4/5 */

      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_Q_UPDATE);
24013438:	687b      	ldr	r3, [r7, #4]
2401343a:	3304      	adds	r3, #4
2401343c:	2101      	movs	r1, #1
2401343e:	4618      	mov	r0, r3
24013440:	f001 fefa 	bl	24015238 <RCCEx_PLL2_Config>
24013444:	4603      	mov	r3, r0
24013446:	75fb      	strb	r3, [r7, #23]

      /* SPI4/5 clock source configuration done later after clock selection check */
      break;
24013448:	e012      	b.n	24013470 <HAL_RCCEx_PeriphCLKConfig+0x454>
    case RCC_SPI45CLKSOURCE_PLL3:  /* PLL3 is used as clock source for SPI4/5 */
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_Q_UPDATE);
2401344a:	687b      	ldr	r3, [r7, #4]
2401344c:	3324      	adds	r3, #36	; 0x24
2401344e:	2101      	movs	r1, #1
24013450:	4618      	mov	r0, r3
24013452:	f001 ffa3 	bl	2401539c <RCCEx_PLL3_Config>
24013456:	4603      	mov	r3, r0
24013458:	75fb      	strb	r3, [r7, #23]
      /* SPI4/5 clock source configuration done later after clock selection check */
      break;
2401345a:	e009      	b.n	24013470 <HAL_RCCEx_PeriphCLKConfig+0x454>
      /* HSE,  oscillator is used as source of SPI4/5 clock */
      /* SPI4/5 clock source configuration done later after clock selection check */
      break;

    default:
      ret = HAL_ERROR;
2401345c:	2301      	movs	r3, #1
2401345e:	75fb      	strb	r3, [r7, #23]
      break;
24013460:	e006      	b.n	24013470 <HAL_RCCEx_PeriphCLKConfig+0x454>
      break;
24013462:	bf00      	nop
24013464:	e004      	b.n	24013470 <HAL_RCCEx_PeriphCLKConfig+0x454>
      break;
24013466:	bf00      	nop
24013468:	e002      	b.n	24013470 <HAL_RCCEx_PeriphCLKConfig+0x454>
      break;
2401346a:	bf00      	nop
2401346c:	e000      	b.n	24013470 <HAL_RCCEx_PeriphCLKConfig+0x454>
      break;
2401346e:	bf00      	nop
    }

    if(ret == HAL_OK)
24013470:	7dfb      	ldrb	r3, [r7, #23]
24013472:	2b00      	cmp	r3, #0
24013474:	d109      	bne.n	2401348a <HAL_RCCEx_PeriphCLKConfig+0x46e>
    {
      /* Set the source of SPI4/5 clock*/
      __HAL_RCC_SPI45_CONFIG(PeriphClkInit->Spi45ClockSelection);
24013476:	4b5a      	ldr	r3, [pc, #360]	; (240135e0 <HAL_RCCEx_PeriphCLKConfig+0x5c4>)
24013478:	6d1b      	ldr	r3, [r3, #80]	; 0x50
2401347a:	f423 22e0 	bic.w	r2, r3, #458752	; 0x70000
2401347e:	687b      	ldr	r3, [r7, #4]
24013480:	6e1b      	ldr	r3, [r3, #96]	; 0x60
24013482:	4957      	ldr	r1, [pc, #348]	; (240135e0 <HAL_RCCEx_PeriphCLKConfig+0x5c4>)
24013484:	4313      	orrs	r3, r2
24013486:	650b      	str	r3, [r1, #80]	; 0x50
24013488:	e001      	b.n	2401348e <HAL_RCCEx_PeriphCLKConfig+0x472>
    }
    else
    {
      /* set overall return value */
      status = ret;
2401348a:	7dfb      	ldrb	r3, [r7, #23]
2401348c:	75bb      	strb	r3, [r7, #22]
    }
  }

  /*---------------------------- SPI6 configuration -------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPI6) == RCC_PERIPHCLK_SPI6)
2401348e:	687b      	ldr	r3, [r7, #4]
24013490:	681b      	ldr	r3, [r3, #0]
24013492:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
24013496:	2b00      	cmp	r3, #0
24013498:	d044      	beq.n	24013524 <HAL_RCCEx_PeriphCLKConfig+0x508>
  {
    switch(PeriphClkInit->Spi6ClockSelection)
2401349a:	687b      	ldr	r3, [r7, #4]
2401349c:	f8d3 30ac 	ldr.w	r3, [r3, #172]	; 0xac
240134a0:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
240134a4:	d01b      	beq.n	240134de <HAL_RCCEx_PeriphCLKConfig+0x4c2>
240134a6:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
240134aa:	d805      	bhi.n	240134b8 <HAL_RCCEx_PeriphCLKConfig+0x49c>
240134ac:	2b00      	cmp	r3, #0
240134ae:	d022      	beq.n	240134f6 <HAL_RCCEx_PeriphCLKConfig+0x4da>
240134b0:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
240134b4:	d00a      	beq.n	240134cc <HAL_RCCEx_PeriphCLKConfig+0x4b0>
240134b6:	e01b      	b.n	240134f0 <HAL_RCCEx_PeriphCLKConfig+0x4d4>
240134b8:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
240134bc:	d01d      	beq.n	240134fa <HAL_RCCEx_PeriphCLKConfig+0x4de>
240134be:	f1b3 4fa0 	cmp.w	r3, #1342177280	; 0x50000000
240134c2:	d01c      	beq.n	240134fe <HAL_RCCEx_PeriphCLKConfig+0x4e2>
240134c4:	f1b3 5f40 	cmp.w	r3, #805306368	; 0x30000000
240134c8:	d01b      	beq.n	24013502 <HAL_RCCEx_PeriphCLKConfig+0x4e6>
240134ca:	e011      	b.n	240134f0 <HAL_RCCEx_PeriphCLKConfig+0x4d4>
      /* SPI6 clock source configuration done later after clock selection check */
      break;

    case RCC_SPI6CLKSOURCE_PLL2: /* PLL2 is used as clock source for SPI6*/

      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_Q_UPDATE);
240134cc:	687b      	ldr	r3, [r7, #4]
240134ce:	3304      	adds	r3, #4
240134d0:	2101      	movs	r1, #1
240134d2:	4618      	mov	r0, r3
240134d4:	f001 feb0 	bl	24015238 <RCCEx_PLL2_Config>
240134d8:	4603      	mov	r3, r0
240134da:	75fb      	strb	r3, [r7, #23]

      /* SPI6 clock source configuration done later after clock selection check */
      break;
240134dc:	e012      	b.n	24013504 <HAL_RCCEx_PeriphCLKConfig+0x4e8>
    case RCC_SPI6CLKSOURCE_PLL3:  /* PLL3 is used as clock source for SPI6*/
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_Q_UPDATE);
240134de:	687b      	ldr	r3, [r7, #4]
240134e0:	3324      	adds	r3, #36	; 0x24
240134e2:	2101      	movs	r1, #1
240134e4:	4618      	mov	r0, r3
240134e6:	f001 ff59 	bl	2401539c <RCCEx_PLL3_Config>
240134ea:	4603      	mov	r3, r0
240134ec:	75fb      	strb	r3, [r7, #23]
      /* SPI6 clock source configuration done later after clock selection check */
      break;
240134ee:	e009      	b.n	24013504 <HAL_RCCEx_PeriphCLKConfig+0x4e8>
      /* SPI6 clock source configuration done later after clock selection check */
      break;
#endif

    default:
      ret = HAL_ERROR;
240134f0:	2301      	movs	r3, #1
240134f2:	75fb      	strb	r3, [r7, #23]
      break;
240134f4:	e006      	b.n	24013504 <HAL_RCCEx_PeriphCLKConfig+0x4e8>
      break;
240134f6:	bf00      	nop
240134f8:	e004      	b.n	24013504 <HAL_RCCEx_PeriphCLKConfig+0x4e8>
      break;
240134fa:	bf00      	nop
240134fc:	e002      	b.n	24013504 <HAL_RCCEx_PeriphCLKConfig+0x4e8>
      break;
240134fe:	bf00      	nop
24013500:	e000      	b.n	24013504 <HAL_RCCEx_PeriphCLKConfig+0x4e8>
      break;
24013502:	bf00      	nop
    }

    if(ret == HAL_OK)
24013504:	7dfb      	ldrb	r3, [r7, #23]
24013506:	2b00      	cmp	r3, #0
24013508:	d10a      	bne.n	24013520 <HAL_RCCEx_PeriphCLKConfig+0x504>
    {
      /* Set the source of SPI6 clock*/
      __HAL_RCC_SPI6_CONFIG(PeriphClkInit->Spi6ClockSelection);
2401350a:	4b35      	ldr	r3, [pc, #212]	; (240135e0 <HAL_RCCEx_PeriphCLKConfig+0x5c4>)
2401350c:	6d9b      	ldr	r3, [r3, #88]	; 0x58
2401350e:	f023 42e0 	bic.w	r2, r3, #1879048192	; 0x70000000
24013512:	687b      	ldr	r3, [r7, #4]
24013514:	f8d3 30ac 	ldr.w	r3, [r3, #172]	; 0xac
24013518:	4931      	ldr	r1, [pc, #196]	; (240135e0 <HAL_RCCEx_PeriphCLKConfig+0x5c4>)
2401351a:	4313      	orrs	r3, r2
2401351c:	658b      	str	r3, [r1, #88]	; 0x58
2401351e:	e001      	b.n	24013524 <HAL_RCCEx_PeriphCLKConfig+0x508>
    }
    else
    {
      /* set overall return value */
      status = ret;
24013520:	7dfb      	ldrb	r3, [r7, #23]
24013522:	75bb      	strb	r3, [r7, #22]
  }
#endif /*DSI*/

#if defined(FDCAN1) || defined(FDCAN2)
  /*---------------------------- FDCAN configuration -------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_FDCAN) == RCC_PERIPHCLK_FDCAN)
24013524:	687b      	ldr	r3, [r7, #4]
24013526:	681b      	ldr	r3, [r3, #0]
24013528:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
2401352c:	2b00      	cmp	r3, #0
2401352e:	d02d      	beq.n	2401358c <HAL_RCCEx_PeriphCLKConfig+0x570>
  {
    switch(PeriphClkInit->FdcanClockSelection)
24013530:	687b      	ldr	r3, [r7, #4]
24013532:	6edb      	ldr	r3, [r3, #108]	; 0x6c
24013534:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
24013538:	d005      	beq.n	24013546 <HAL_RCCEx_PeriphCLKConfig+0x52a>
2401353a:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
2401353e:	d009      	beq.n	24013554 <HAL_RCCEx_PeriphCLKConfig+0x538>
24013540:	2b00      	cmp	r3, #0
24013542:	d013      	beq.n	2401356c <HAL_RCCEx_PeriphCLKConfig+0x550>
24013544:	e00f      	b.n	24013566 <HAL_RCCEx_PeriphCLKConfig+0x54a>
    {
    case RCC_FDCANCLKSOURCE_PLL:      /* PLL is used as clock source for FDCAN*/
      /* Enable FDCAN Clock output generated form System PLL . */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
24013546:	4b26      	ldr	r3, [pc, #152]	; (240135e0 <HAL_RCCEx_PeriphCLKConfig+0x5c4>)
24013548:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2401354a:	4a25      	ldr	r2, [pc, #148]	; (240135e0 <HAL_RCCEx_PeriphCLKConfig+0x5c4>)
2401354c:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
24013550:	62d3      	str	r3, [r2, #44]	; 0x2c

      /* FDCAN clock source configuration done later after clock selection check */
      break;
24013552:	e00c      	b.n	2401356e <HAL_RCCEx_PeriphCLKConfig+0x552>

    case RCC_FDCANCLKSOURCE_PLL2: /* PLL2 is used as clock source for FDCAN*/

      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_Q_UPDATE);
24013554:	687b      	ldr	r3, [r7, #4]
24013556:	3304      	adds	r3, #4
24013558:	2101      	movs	r1, #1
2401355a:	4618      	mov	r0, r3
2401355c:	f001 fe6c 	bl	24015238 <RCCEx_PLL2_Config>
24013560:	4603      	mov	r3, r0
24013562:	75fb      	strb	r3, [r7, #23]

      /* FDCAN clock source configuration done later after clock selection check */
      break;
24013564:	e003      	b.n	2401356e <HAL_RCCEx_PeriphCLKConfig+0x552>
      /* HSE is used as clock source for FDCAN*/
      /* FDCAN clock source configuration done later after clock selection check */
      break;

    default:
      ret = HAL_ERROR;
24013566:	2301      	movs	r3, #1
24013568:	75fb      	strb	r3, [r7, #23]
      break;
2401356a:	e000      	b.n	2401356e <HAL_RCCEx_PeriphCLKConfig+0x552>
      break;
2401356c:	bf00      	nop
    }

    if(ret == HAL_OK)
2401356e:	7dfb      	ldrb	r3, [r7, #23]
24013570:	2b00      	cmp	r3, #0
24013572:	d109      	bne.n	24013588 <HAL_RCCEx_PeriphCLKConfig+0x56c>
    {
      /* Set the source of FDCAN clock*/
      __HAL_RCC_FDCAN_CONFIG(PeriphClkInit->FdcanClockSelection);
24013574:	4b1a      	ldr	r3, [pc, #104]	; (240135e0 <HAL_RCCEx_PeriphCLKConfig+0x5c4>)
24013576:	6d1b      	ldr	r3, [r3, #80]	; 0x50
24013578:	f023 5240 	bic.w	r2, r3, #805306368	; 0x30000000
2401357c:	687b      	ldr	r3, [r7, #4]
2401357e:	6edb      	ldr	r3, [r3, #108]	; 0x6c
24013580:	4917      	ldr	r1, [pc, #92]	; (240135e0 <HAL_RCCEx_PeriphCLKConfig+0x5c4>)
24013582:	4313      	orrs	r3, r2
24013584:	650b      	str	r3, [r1, #80]	; 0x50
24013586:	e001      	b.n	2401358c <HAL_RCCEx_PeriphCLKConfig+0x570>
    }
    else
    {
      /* set overall return value */
      status = ret;
24013588:	7dfb      	ldrb	r3, [r7, #23]
2401358a:	75bb      	strb	r3, [r7, #22]
    }
  }
#endif /*FDCAN1 || FDCAN2*/

  /*---------------------------- FMC configuration -------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_FMC) == RCC_PERIPHCLK_FMC)
2401358c:	687b      	ldr	r3, [r7, #4]
2401358e:	681b      	ldr	r3, [r3, #0]
24013590:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
24013594:	2b00      	cmp	r3, #0
24013596:	d035      	beq.n	24013604 <HAL_RCCEx_PeriphCLKConfig+0x5e8>
  {
    switch(PeriphClkInit->FmcClockSelection)
24013598:	687b      	ldr	r3, [r7, #4]
2401359a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2401359c:	2b03      	cmp	r3, #3
2401359e:	d81b      	bhi.n	240135d8 <HAL_RCCEx_PeriphCLKConfig+0x5bc>
240135a0:	a201      	add	r2, pc, #4	; (adr r2, 240135a8 <HAL_RCCEx_PeriphCLKConfig+0x58c>)
240135a2:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
240135a6:	bf00      	nop
240135a8:	240135e5 	.word	0x240135e5
240135ac:	240135b9 	.word	0x240135b9
240135b0:	240135c7 	.word	0x240135c7
240135b4:	240135e5 	.word	0x240135e5
    {
    case RCC_FMCCLKSOURCE_PLL:      /* PLL is used as clock source for FMC*/
      /* Enable FMC Clock output generated form System PLL . */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
240135b8:	4b09      	ldr	r3, [pc, #36]	; (240135e0 <HAL_RCCEx_PeriphCLKConfig+0x5c4>)
240135ba:	6adb      	ldr	r3, [r3, #44]	; 0x2c
240135bc:	4a08      	ldr	r2, [pc, #32]	; (240135e0 <HAL_RCCEx_PeriphCLKConfig+0x5c4>)
240135be:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
240135c2:	62d3      	str	r3, [r2, #44]	; 0x2c

      /* FMC clock source configuration done later after clock selection check */
      break;
240135c4:	e00f      	b.n	240135e6 <HAL_RCCEx_PeriphCLKConfig+0x5ca>

    case RCC_FMCCLKSOURCE_PLL2: /* PLL2 is used as clock source for FMC*/

      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_R_UPDATE);
240135c6:	687b      	ldr	r3, [r7, #4]
240135c8:	3304      	adds	r3, #4
240135ca:	2102      	movs	r1, #2
240135cc:	4618      	mov	r0, r3
240135ce:	f001 fe33 	bl	24015238 <RCCEx_PLL2_Config>
240135d2:	4603      	mov	r3, r0
240135d4:	75fb      	strb	r3, [r7, #23]

      /* FMC clock source configuration done later after clock selection check */
      break;
240135d6:	e006      	b.n	240135e6 <HAL_RCCEx_PeriphCLKConfig+0x5ca>
    case RCC_FMCCLKSOURCE_HCLK:
      /* D1/CD HCLK  clock selected as FMC kernel peripheral clock */
      break;

    default:
      ret = HAL_ERROR;
240135d8:	2301      	movs	r3, #1
240135da:	75fb      	strb	r3, [r7, #23]
      break;
240135dc:	e003      	b.n	240135e6 <HAL_RCCEx_PeriphCLKConfig+0x5ca>
240135de:	bf00      	nop
240135e0:	58024400 	.word	0x58024400
      break;
240135e4:	bf00      	nop
    }

    if(ret == HAL_OK)
240135e6:	7dfb      	ldrb	r3, [r7, #23]
240135e8:	2b00      	cmp	r3, #0
240135ea:	d109      	bne.n	24013600 <HAL_RCCEx_PeriphCLKConfig+0x5e4>
    {
      /* Set the source of FMC clock*/
      __HAL_RCC_FMC_CONFIG(PeriphClkInit->FmcClockSelection);
240135ec:	4bba      	ldr	r3, [pc, #744]	; (240138d8 <HAL_RCCEx_PeriphCLKConfig+0x8bc>)
240135ee:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
240135f0:	f023 0203 	bic.w	r2, r3, #3
240135f4:	687b      	ldr	r3, [r7, #4]
240135f6:	6c5b      	ldr	r3, [r3, #68]	; 0x44
240135f8:	49b7      	ldr	r1, [pc, #732]	; (240138d8 <HAL_RCCEx_PeriphCLKConfig+0x8bc>)
240135fa:	4313      	orrs	r3, r2
240135fc:	64cb      	str	r3, [r1, #76]	; 0x4c
240135fe:	e001      	b.n	24013604 <HAL_RCCEx_PeriphCLKConfig+0x5e8>
    }
    else
    {
      /* set overall return value */
      status = ret;
24013600:	7dfb      	ldrb	r3, [r7, #23]
24013602:	75bb      	strb	r3, [r7, #22]
    }
  }

  /*---------------------------- RTC configuration -------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC)
24013604:	687b      	ldr	r3, [r7, #4]
24013606:	681b      	ldr	r3, [r3, #0]
24013608:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
2401360c:	2b00      	cmp	r3, #0
2401360e:	f000 8086 	beq.w	2401371e <HAL_RCCEx_PeriphCLKConfig+0x702>
  {
    /* check for RTC Parameters used to output RTCCLK */
    assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->RTCClockSelection));

    /* Enable write access to Backup domain */
    SET_BIT(PWR->CR1, PWR_CR1_DBP);
24013612:	4bb2      	ldr	r3, [pc, #712]	; (240138dc <HAL_RCCEx_PeriphCLKConfig+0x8c0>)
24013614:	681b      	ldr	r3, [r3, #0]
24013616:	4ab1      	ldr	r2, [pc, #708]	; (240138dc <HAL_RCCEx_PeriphCLKConfig+0x8c0>)
24013618:	f443 7380 	orr.w	r3, r3, #256	; 0x100
2401361c:	6013      	str	r3, [r2, #0]

    /* Wait for Backup domain Write protection disable */
    tickstart = HAL_GetTick();
2401361e:	f7ed f919 	bl	24000854 <HAL_GetTick>
24013622:	6138      	str	r0, [r7, #16]

    while((PWR->CR1 & PWR_CR1_DBP) == 0U)
24013624:	e009      	b.n	2401363a <HAL_RCCEx_PeriphCLKConfig+0x61e>
    {
      if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
24013626:	f7ed f915 	bl	24000854 <HAL_GetTick>
2401362a:	4602      	mov	r2, r0
2401362c:	693b      	ldr	r3, [r7, #16]
2401362e:	1ad3      	subs	r3, r2, r3
24013630:	2b64      	cmp	r3, #100	; 0x64
24013632:	d902      	bls.n	2401363a <HAL_RCCEx_PeriphCLKConfig+0x61e>
      {
        ret = HAL_TIMEOUT;
24013634:	2303      	movs	r3, #3
24013636:	75fb      	strb	r3, [r7, #23]
        break;
24013638:	e005      	b.n	24013646 <HAL_RCCEx_PeriphCLKConfig+0x62a>
    while((PWR->CR1 & PWR_CR1_DBP) == 0U)
2401363a:	4ba8      	ldr	r3, [pc, #672]	; (240138dc <HAL_RCCEx_PeriphCLKConfig+0x8c0>)
2401363c:	681b      	ldr	r3, [r3, #0]
2401363e:	f403 7380 	and.w	r3, r3, #256	; 0x100
24013642:	2b00      	cmp	r3, #0
24013644:	d0ef      	beq.n	24013626 <HAL_RCCEx_PeriphCLKConfig+0x60a>
      }
    }

    if(ret == HAL_OK)
24013646:	7dfb      	ldrb	r3, [r7, #23]
24013648:	2b00      	cmp	r3, #0
2401364a:	d166      	bne.n	2401371a <HAL_RCCEx_PeriphCLKConfig+0x6fe>
    {
      /* Reset the Backup domain only if the RTC Clock source selection is modified */
      if((RCC->BDCR & RCC_BDCR_RTCSEL) != (PeriphClkInit->RTCClockSelection & RCC_BDCR_RTCSEL))
2401364c:	4ba2      	ldr	r3, [pc, #648]	; (240138d8 <HAL_RCCEx_PeriphCLKConfig+0x8bc>)
2401364e:	6f1a      	ldr	r2, [r3, #112]	; 0x70
24013650:	687b      	ldr	r3, [r7, #4]
24013652:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
24013656:	4053      	eors	r3, r2
24013658:	f403 7340 	and.w	r3, r3, #768	; 0x300
2401365c:	2b00      	cmp	r3, #0
2401365e:	d013      	beq.n	24013688 <HAL_RCCEx_PeriphCLKConfig+0x66c>
      {
        /* Store the content of BDCR register before the reset of Backup Domain */
        tmpreg = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));
24013660:	4b9d      	ldr	r3, [pc, #628]	; (240138d8 <HAL_RCCEx_PeriphCLKConfig+0x8bc>)
24013662:	6f1b      	ldr	r3, [r3, #112]	; 0x70
24013664:	f423 7340 	bic.w	r3, r3, #768	; 0x300
24013668:	60fb      	str	r3, [r7, #12]
        /* RTC Clock selection can be changed only if the Backup Domain is reset */
        __HAL_RCC_BACKUPRESET_FORCE();
2401366a:	4b9b      	ldr	r3, [pc, #620]	; (240138d8 <HAL_RCCEx_PeriphCLKConfig+0x8bc>)
2401366c:	6f1b      	ldr	r3, [r3, #112]	; 0x70
2401366e:	4a9a      	ldr	r2, [pc, #616]	; (240138d8 <HAL_RCCEx_PeriphCLKConfig+0x8bc>)
24013670:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
24013674:	6713      	str	r3, [r2, #112]	; 0x70
        __HAL_RCC_BACKUPRESET_RELEASE();
24013676:	4b98      	ldr	r3, [pc, #608]	; (240138d8 <HAL_RCCEx_PeriphCLKConfig+0x8bc>)
24013678:	6f1b      	ldr	r3, [r3, #112]	; 0x70
2401367a:	4a97      	ldr	r2, [pc, #604]	; (240138d8 <HAL_RCCEx_PeriphCLKConfig+0x8bc>)
2401367c:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
24013680:	6713      	str	r3, [r2, #112]	; 0x70
        /* Restore the Content of BDCR register */
        RCC->BDCR = tmpreg;
24013682:	4a95      	ldr	r2, [pc, #596]	; (240138d8 <HAL_RCCEx_PeriphCLKConfig+0x8bc>)
24013684:	68fb      	ldr	r3, [r7, #12]
24013686:	6713      	str	r3, [r2, #112]	; 0x70
      }

      /* If LSE is selected as RTC clock source (and enabled prior to Backup Domain reset), wait for LSE reactivation */
      if(PeriphClkInit->RTCClockSelection == RCC_RTCCLKSOURCE_LSE)
24013688:	687b      	ldr	r3, [r7, #4]
2401368a:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
2401368e:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
24013692:	d115      	bne.n	240136c0 <HAL_RCCEx_PeriphCLKConfig+0x6a4>
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
24013694:	f7ed f8de 	bl	24000854 <HAL_GetTick>
24013698:	6138      	str	r0, [r7, #16]

        /* Wait till LSE is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == 0U)
2401369a:	e00b      	b.n	240136b4 <HAL_RCCEx_PeriphCLKConfig+0x698>
        {
          if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
2401369c:	f7ed f8da 	bl	24000854 <HAL_GetTick>
240136a0:	4602      	mov	r2, r0
240136a2:	693b      	ldr	r3, [r7, #16]
240136a4:	1ad3      	subs	r3, r2, r3
240136a6:	f241 3288 	movw	r2, #5000	; 0x1388
240136aa:	4293      	cmp	r3, r2
240136ac:	d902      	bls.n	240136b4 <HAL_RCCEx_PeriphCLKConfig+0x698>
          {
            ret = HAL_TIMEOUT;
240136ae:	2303      	movs	r3, #3
240136b0:	75fb      	strb	r3, [r7, #23]
            break;
240136b2:	e005      	b.n	240136c0 <HAL_RCCEx_PeriphCLKConfig+0x6a4>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == 0U)
240136b4:	4b88      	ldr	r3, [pc, #544]	; (240138d8 <HAL_RCCEx_PeriphCLKConfig+0x8bc>)
240136b6:	6f1b      	ldr	r3, [r3, #112]	; 0x70
240136b8:	f003 0302 	and.w	r3, r3, #2
240136bc:	2b00      	cmp	r3, #0
240136be:	d0ed      	beq.n	2401369c <HAL_RCCEx_PeriphCLKConfig+0x680>
          }
        }
      }

      if(ret == HAL_OK)
240136c0:	7dfb      	ldrb	r3, [r7, #23]
240136c2:	2b00      	cmp	r3, #0
240136c4:	d126      	bne.n	24013714 <HAL_RCCEx_PeriphCLKConfig+0x6f8>
      {
        __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
240136c6:	687b      	ldr	r3, [r7, #4]
240136c8:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
240136cc:	f403 7340 	and.w	r3, r3, #768	; 0x300
240136d0:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
240136d4:	d10d      	bne.n	240136f2 <HAL_RCCEx_PeriphCLKConfig+0x6d6>
240136d6:	4b80      	ldr	r3, [pc, #512]	; (240138d8 <HAL_RCCEx_PeriphCLKConfig+0x8bc>)
240136d8:	691b      	ldr	r3, [r3, #16]
240136da:	f423 527c 	bic.w	r2, r3, #16128	; 0x3f00
240136de:	687b      	ldr	r3, [r7, #4]
240136e0:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
240136e4:	0919      	lsrs	r1, r3, #4
240136e6:	4b7e      	ldr	r3, [pc, #504]	; (240138e0 <HAL_RCCEx_PeriphCLKConfig+0x8c4>)
240136e8:	400b      	ands	r3, r1
240136ea:	497b      	ldr	r1, [pc, #492]	; (240138d8 <HAL_RCCEx_PeriphCLKConfig+0x8bc>)
240136ec:	4313      	orrs	r3, r2
240136ee:	610b      	str	r3, [r1, #16]
240136f0:	e005      	b.n	240136fe <HAL_RCCEx_PeriphCLKConfig+0x6e2>
240136f2:	4b79      	ldr	r3, [pc, #484]	; (240138d8 <HAL_RCCEx_PeriphCLKConfig+0x8bc>)
240136f4:	691b      	ldr	r3, [r3, #16]
240136f6:	4a78      	ldr	r2, [pc, #480]	; (240138d8 <HAL_RCCEx_PeriphCLKConfig+0x8bc>)
240136f8:	f423 537c 	bic.w	r3, r3, #16128	; 0x3f00
240136fc:	6113      	str	r3, [r2, #16]
240136fe:	4b76      	ldr	r3, [pc, #472]	; (240138d8 <HAL_RCCEx_PeriphCLKConfig+0x8bc>)
24013700:	6f1a      	ldr	r2, [r3, #112]	; 0x70
24013702:	687b      	ldr	r3, [r7, #4]
24013704:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
24013708:	f3c3 030b 	ubfx	r3, r3, #0, #12
2401370c:	4972      	ldr	r1, [pc, #456]	; (240138d8 <HAL_RCCEx_PeriphCLKConfig+0x8bc>)
2401370e:	4313      	orrs	r3, r2
24013710:	670b      	str	r3, [r1, #112]	; 0x70
24013712:	e004      	b.n	2401371e <HAL_RCCEx_PeriphCLKConfig+0x702>
      }
      else
      {
        /* set overall return value */
        status = ret;
24013714:	7dfb      	ldrb	r3, [r7, #23]
24013716:	75bb      	strb	r3, [r7, #22]
24013718:	e001      	b.n	2401371e <HAL_RCCEx_PeriphCLKConfig+0x702>
      }
    }
    else
    {
      /* set overall return value */
      status = ret;
2401371a:	7dfb      	ldrb	r3, [r7, #23]
2401371c:	75bb      	strb	r3, [r7, #22]
    }
  }


  /*-------------------------- USART1/6 configuration --------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART16) == RCC_PERIPHCLK_USART16)
2401371e:	687b      	ldr	r3, [r7, #4]
24013720:	681b      	ldr	r3, [r3, #0]
24013722:	f003 0301 	and.w	r3, r3, #1
24013726:	2b00      	cmp	r3, #0
24013728:	d07d      	beq.n	24013826 <HAL_RCCEx_PeriphCLKConfig+0x80a>
  {
    switch(PeriphClkInit->Usart16ClockSelection)
2401372a:	687b      	ldr	r3, [r7, #4]
2401372c:	6f9b      	ldr	r3, [r3, #120]	; 0x78
2401372e:	2b28      	cmp	r3, #40	; 0x28
24013730:	d866      	bhi.n	24013800 <HAL_RCCEx_PeriphCLKConfig+0x7e4>
24013732:	a201      	add	r2, pc, #4	; (adr r2, 24013738 <HAL_RCCEx_PeriphCLKConfig+0x71c>)
24013734:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
24013738:	24013807 	.word	0x24013807
2401373c:	24013801 	.word	0x24013801
24013740:	24013801 	.word	0x24013801
24013744:	24013801 	.word	0x24013801
24013748:	24013801 	.word	0x24013801
2401374c:	24013801 	.word	0x24013801
24013750:	24013801 	.word	0x24013801
24013754:	24013801 	.word	0x24013801
24013758:	240137dd 	.word	0x240137dd
2401375c:	24013801 	.word	0x24013801
24013760:	24013801 	.word	0x24013801
24013764:	24013801 	.word	0x24013801
24013768:	24013801 	.word	0x24013801
2401376c:	24013801 	.word	0x24013801
24013770:	24013801 	.word	0x24013801
24013774:	24013801 	.word	0x24013801
24013778:	240137ef 	.word	0x240137ef
2401377c:	24013801 	.word	0x24013801
24013780:	24013801 	.word	0x24013801
24013784:	24013801 	.word	0x24013801
24013788:	24013801 	.word	0x24013801
2401378c:	24013801 	.word	0x24013801
24013790:	24013801 	.word	0x24013801
24013794:	24013801 	.word	0x24013801
24013798:	24013807 	.word	0x24013807
2401379c:	24013801 	.word	0x24013801
240137a0:	24013801 	.word	0x24013801
240137a4:	24013801 	.word	0x24013801
240137a8:	24013801 	.word	0x24013801
240137ac:	24013801 	.word	0x24013801
240137b0:	24013801 	.word	0x24013801
240137b4:	24013801 	.word	0x24013801
240137b8:	24013807 	.word	0x24013807
240137bc:	24013801 	.word	0x24013801
240137c0:	24013801 	.word	0x24013801
240137c4:	24013801 	.word	0x24013801
240137c8:	24013801 	.word	0x24013801
240137cc:	24013801 	.word	0x24013801
240137d0:	24013801 	.word	0x24013801
240137d4:	24013801 	.word	0x24013801
240137d8:	24013807 	.word	0x24013807
    case RCC_USART16CLKSOURCE_PCLK2: /* CD/D2 PCLK2 as clock source for USART1/6 */
      /* USART1/6 clock source configuration done later after clock selection check */
      break;

    case RCC_USART16CLKSOURCE_PLL2: /* PLL2 is used as clock source for USART1/6 */
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_Q_UPDATE);
240137dc:	687b      	ldr	r3, [r7, #4]
240137de:	3304      	adds	r3, #4
240137e0:	2101      	movs	r1, #1
240137e2:	4618      	mov	r0, r3
240137e4:	f001 fd28 	bl	24015238 <RCCEx_PLL2_Config>
240137e8:	4603      	mov	r3, r0
240137ea:	75fb      	strb	r3, [r7, #23]
      /* USART1/6 clock source configuration done later after clock selection check */
      break;
240137ec:	e00c      	b.n	24013808 <HAL_RCCEx_PeriphCLKConfig+0x7ec>

    case RCC_USART16CLKSOURCE_PLL3: /* PLL3 is used as clock source for USART1/6 */
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_Q_UPDATE);
240137ee:	687b      	ldr	r3, [r7, #4]
240137f0:	3324      	adds	r3, #36	; 0x24
240137f2:	2101      	movs	r1, #1
240137f4:	4618      	mov	r0, r3
240137f6:	f001 fdd1 	bl	2401539c <RCCEx_PLL3_Config>
240137fa:	4603      	mov	r3, r0
240137fc:	75fb      	strb	r3, [r7, #23]
      /* USART1/6 clock source configuration done later after clock selection check */
      break;
240137fe:	e003      	b.n	24013808 <HAL_RCCEx_PeriphCLKConfig+0x7ec>
      /* LSE,  oscillator is used as source of USART1/6 clock */
      /* USART1/6 clock source configuration done later after clock selection check */
      break;

    default:
      ret = HAL_ERROR;
24013800:	2301      	movs	r3, #1
24013802:	75fb      	strb	r3, [r7, #23]
      break;
24013804:	e000      	b.n	24013808 <HAL_RCCEx_PeriphCLKConfig+0x7ec>
      break;
24013806:	bf00      	nop
    }

    if(ret == HAL_OK)
24013808:	7dfb      	ldrb	r3, [r7, #23]
2401380a:	2b00      	cmp	r3, #0
2401380c:	d109      	bne.n	24013822 <HAL_RCCEx_PeriphCLKConfig+0x806>
    {
      /* Set the source of USART1/6 clock */
      __HAL_RCC_USART16_CONFIG(PeriphClkInit->Usart16ClockSelection);
2401380e:	4b32      	ldr	r3, [pc, #200]	; (240138d8 <HAL_RCCEx_PeriphCLKConfig+0x8bc>)
24013810:	6d5b      	ldr	r3, [r3, #84]	; 0x54
24013812:	f023 0238 	bic.w	r2, r3, #56	; 0x38
24013816:	687b      	ldr	r3, [r7, #4]
24013818:	6f9b      	ldr	r3, [r3, #120]	; 0x78
2401381a:	492f      	ldr	r1, [pc, #188]	; (240138d8 <HAL_RCCEx_PeriphCLKConfig+0x8bc>)
2401381c:	4313      	orrs	r3, r2
2401381e:	654b      	str	r3, [r1, #84]	; 0x54
24013820:	e001      	b.n	24013826 <HAL_RCCEx_PeriphCLKConfig+0x80a>
    }
    else
    {
      /* set overall return value */
      status = ret;
24013822:	7dfb      	ldrb	r3, [r7, #23]
24013824:	75bb      	strb	r3, [r7, #22]
    }
  }

  /*-------------------------- USART2/3/4/5/7/8 Configuration --------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART234578) == RCC_PERIPHCLK_USART234578)
24013826:	687b      	ldr	r3, [r7, #4]
24013828:	681b      	ldr	r3, [r3, #0]
2401382a:	f003 0302 	and.w	r3, r3, #2
2401382e:	2b00      	cmp	r3, #0
24013830:	d037      	beq.n	240138a2 <HAL_RCCEx_PeriphCLKConfig+0x886>
  {
    switch(PeriphClkInit->Usart234578ClockSelection)
24013832:	687b      	ldr	r3, [r7, #4]
24013834:	6f5b      	ldr	r3, [r3, #116]	; 0x74
24013836:	2b05      	cmp	r3, #5
24013838:	d820      	bhi.n	2401387c <HAL_RCCEx_PeriphCLKConfig+0x860>
2401383a:	a201      	add	r2, pc, #4	; (adr r2, 24013840 <HAL_RCCEx_PeriphCLKConfig+0x824>)
2401383c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
24013840:	24013883 	.word	0x24013883
24013844:	24013859 	.word	0x24013859
24013848:	2401386b 	.word	0x2401386b
2401384c:	24013883 	.word	0x24013883
24013850:	24013883 	.word	0x24013883
24013854:	24013883 	.word	0x24013883
    case RCC_USART234578CLKSOURCE_PCLK1: /* CD/D2 PCLK1 as clock source for USART2/3/4/5/7/8 */
      /* USART2/3/4/5/7/8 clock source configuration done later after clock selection check */
      break;

    case RCC_USART234578CLKSOURCE_PLL2: /* PLL2 is used as clock source for USART2/3/4/5/7/8 */
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_Q_UPDATE);
24013858:	687b      	ldr	r3, [r7, #4]
2401385a:	3304      	adds	r3, #4
2401385c:	2101      	movs	r1, #1
2401385e:	4618      	mov	r0, r3
24013860:	f001 fcea 	bl	24015238 <RCCEx_PLL2_Config>
24013864:	4603      	mov	r3, r0
24013866:	75fb      	strb	r3, [r7, #23]
      /* USART2/3/4/5/7/8 clock source configuration done later after clock selection check */
      break;
24013868:	e00c      	b.n	24013884 <HAL_RCCEx_PeriphCLKConfig+0x868>

    case RCC_USART234578CLKSOURCE_PLL3: /* PLL3 is used as clock source for USART2/3/4/5/7/8 */
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_Q_UPDATE);
2401386a:	687b      	ldr	r3, [r7, #4]
2401386c:	3324      	adds	r3, #36	; 0x24
2401386e:	2101      	movs	r1, #1
24013870:	4618      	mov	r0, r3
24013872:	f001 fd93 	bl	2401539c <RCCEx_PLL3_Config>
24013876:	4603      	mov	r3, r0
24013878:	75fb      	strb	r3, [r7, #23]
      /* USART2/3/4/5/7/8 clock source configuration done later after clock selection check */
      break;
2401387a:	e003      	b.n	24013884 <HAL_RCCEx_PeriphCLKConfig+0x868>
      /* LSE,  oscillator is used as source of USART2/3/4/5/7/8 clock */
      /* USART2/3/4/5/7/8 clock source configuration done later after clock selection check */
      break;

    default:
      ret = HAL_ERROR;
2401387c:	2301      	movs	r3, #1
2401387e:	75fb      	strb	r3, [r7, #23]
      break;
24013880:	e000      	b.n	24013884 <HAL_RCCEx_PeriphCLKConfig+0x868>
      break;
24013882:	bf00      	nop
    }

    if(ret == HAL_OK)
24013884:	7dfb      	ldrb	r3, [r7, #23]
24013886:	2b00      	cmp	r3, #0
24013888:	d109      	bne.n	2401389e <HAL_RCCEx_PeriphCLKConfig+0x882>
    {
      /* Set the source of USART2/3/4/5/7/8 clock */
      __HAL_RCC_USART234578_CONFIG(PeriphClkInit->Usart234578ClockSelection);
2401388a:	4b13      	ldr	r3, [pc, #76]	; (240138d8 <HAL_RCCEx_PeriphCLKConfig+0x8bc>)
2401388c:	6d5b      	ldr	r3, [r3, #84]	; 0x54
2401388e:	f023 0207 	bic.w	r2, r3, #7
24013892:	687b      	ldr	r3, [r7, #4]
24013894:	6f5b      	ldr	r3, [r3, #116]	; 0x74
24013896:	4910      	ldr	r1, [pc, #64]	; (240138d8 <HAL_RCCEx_PeriphCLKConfig+0x8bc>)
24013898:	4313      	orrs	r3, r2
2401389a:	654b      	str	r3, [r1, #84]	; 0x54
2401389c:	e001      	b.n	240138a2 <HAL_RCCEx_PeriphCLKConfig+0x886>
    }
    else
    {
      /* set overall return value */
      status = ret;
2401389e:	7dfb      	ldrb	r3, [r7, #23]
240138a0:	75bb      	strb	r3, [r7, #22]
    }
  }

  /*-------------------------- LPUART1 Configuration -------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPUART1) == RCC_PERIPHCLK_LPUART1)
240138a2:	687b      	ldr	r3, [r7, #4]
240138a4:	681b      	ldr	r3, [r3, #0]
240138a6:	f003 0304 	and.w	r3, r3, #4
240138aa:	2b00      	cmp	r3, #0
240138ac:	d040      	beq.n	24013930 <HAL_RCCEx_PeriphCLKConfig+0x914>
  {
    switch(PeriphClkInit->Lpuart1ClockSelection)
240138ae:	687b      	ldr	r3, [r7, #4]
240138b0:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
240138b4:	2b05      	cmp	r3, #5
240138b6:	d827      	bhi.n	24013908 <HAL_RCCEx_PeriphCLKConfig+0x8ec>
240138b8:	a201      	add	r2, pc, #4	; (adr r2, 240138c0 <HAL_RCCEx_PeriphCLKConfig+0x8a4>)
240138ba:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
240138be:	bf00      	nop
240138c0:	2401390f 	.word	0x2401390f
240138c4:	240138e5 	.word	0x240138e5
240138c8:	240138f7 	.word	0x240138f7
240138cc:	2401390f 	.word	0x2401390f
240138d0:	2401390f 	.word	0x2401390f
240138d4:	2401390f 	.word	0x2401390f
240138d8:	58024400 	.word	0x58024400
240138dc:	58024800 	.word	0x58024800
240138e0:	00ffffcf 	.word	0x00ffffcf
    case RCC_LPUART1CLKSOURCE_PCLK4: /* SRD/D3 PCLK1 (PCLK4) as clock source for LPUART1 */
      /* LPUART1 clock source configuration done later after clock selection check */
      break;

    case RCC_LPUART1CLKSOURCE_PLL2: /* PLL2 is used as clock source for LPUART1 */
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_Q_UPDATE);
240138e4:	687b      	ldr	r3, [r7, #4]
240138e6:	3304      	adds	r3, #4
240138e8:	2101      	movs	r1, #1
240138ea:	4618      	mov	r0, r3
240138ec:	f001 fca4 	bl	24015238 <RCCEx_PLL2_Config>
240138f0:	4603      	mov	r3, r0
240138f2:	75fb      	strb	r3, [r7, #23]
      /* LPUART1 clock source configuration done later after clock selection check */
      break;
240138f4:	e00c      	b.n	24013910 <HAL_RCCEx_PeriphCLKConfig+0x8f4>

    case RCC_LPUART1CLKSOURCE_PLL3: /* PLL3 is used as clock source for LPUART1 */
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_Q_UPDATE);
240138f6:	687b      	ldr	r3, [r7, #4]
240138f8:	3324      	adds	r3, #36	; 0x24
240138fa:	2101      	movs	r1, #1
240138fc:	4618      	mov	r0, r3
240138fe:	f001 fd4d 	bl	2401539c <RCCEx_PLL3_Config>
24013902:	4603      	mov	r3, r0
24013904:	75fb      	strb	r3, [r7, #23]
      /* LPUART1 clock source configuration done later after clock selection check */
      break;
24013906:	e003      	b.n	24013910 <HAL_RCCEx_PeriphCLKConfig+0x8f4>
      /* LSE,  oscillator is used as source of LPUART1 clock */
      /* LPUART1 clock source configuration done later after clock selection check */
      break;

    default:
      ret = HAL_ERROR;
24013908:	2301      	movs	r3, #1
2401390a:	75fb      	strb	r3, [r7, #23]
      break;
2401390c:	e000      	b.n	24013910 <HAL_RCCEx_PeriphCLKConfig+0x8f4>
      break;
2401390e:	bf00      	nop
    }

    if(ret == HAL_OK)
24013910:	7dfb      	ldrb	r3, [r7, #23]
24013912:	2b00      	cmp	r3, #0
24013914:	d10a      	bne.n	2401392c <HAL_RCCEx_PeriphCLKConfig+0x910>
    {
      /* Set the source of LPUART1 clock */
      __HAL_RCC_LPUART1_CONFIG(PeriphClkInit->Lpuart1ClockSelection);
24013916:	4bb2      	ldr	r3, [pc, #712]	; (24013be0 <HAL_RCCEx_PeriphCLKConfig+0xbc4>)
24013918:	6d9b      	ldr	r3, [r3, #88]	; 0x58
2401391a:	f023 0207 	bic.w	r2, r3, #7
2401391e:	687b      	ldr	r3, [r7, #4]
24013920:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
24013924:	49ae      	ldr	r1, [pc, #696]	; (24013be0 <HAL_RCCEx_PeriphCLKConfig+0xbc4>)
24013926:	4313      	orrs	r3, r2
24013928:	658b      	str	r3, [r1, #88]	; 0x58
2401392a:	e001      	b.n	24013930 <HAL_RCCEx_PeriphCLKConfig+0x914>
    }
    else
    {
      /* set overall return value */
      status = ret;
2401392c:	7dfb      	ldrb	r3, [r7, #23]
2401392e:	75bb      	strb	r3, [r7, #22]
    }
  }

  /*---------------------------- LPTIM1 configuration -------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM1) == RCC_PERIPHCLK_LPTIM1)
24013930:	687b      	ldr	r3, [r7, #4]
24013932:	681b      	ldr	r3, [r3, #0]
24013934:	f003 0320 	and.w	r3, r3, #32
24013938:	2b00      	cmp	r3, #0
2401393a:	d044      	beq.n	240139c6 <HAL_RCCEx_PeriphCLKConfig+0x9aa>
  {
    switch(PeriphClkInit->Lptim1ClockSelection)
2401393c:	687b      	ldr	r3, [r7, #4]
2401393e:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
24013942:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
24013946:	d01b      	beq.n	24013980 <HAL_RCCEx_PeriphCLKConfig+0x964>
24013948:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
2401394c:	d805      	bhi.n	2401395a <HAL_RCCEx_PeriphCLKConfig+0x93e>
2401394e:	2b00      	cmp	r3, #0
24013950:	d022      	beq.n	24013998 <HAL_RCCEx_PeriphCLKConfig+0x97c>
24013952:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
24013956:	d00a      	beq.n	2401396e <HAL_RCCEx_PeriphCLKConfig+0x952>
24013958:	e01b      	b.n	24013992 <HAL_RCCEx_PeriphCLKConfig+0x976>
2401395a:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
2401395e:	d01d      	beq.n	2401399c <HAL_RCCEx_PeriphCLKConfig+0x980>
24013960:	f1b3 4fa0 	cmp.w	r3, #1342177280	; 0x50000000
24013964:	d01c      	beq.n	240139a0 <HAL_RCCEx_PeriphCLKConfig+0x984>
24013966:	f1b3 5f40 	cmp.w	r3, #805306368	; 0x30000000
2401396a:	d01b      	beq.n	240139a4 <HAL_RCCEx_PeriphCLKConfig+0x988>
2401396c:	e011      	b.n	24013992 <HAL_RCCEx_PeriphCLKConfig+0x976>
      /* LPTIM1 clock source configuration done later after clock selection check */
      break;

    case RCC_LPTIM1CLKSOURCE_PLL2: /* PLL2 is used as clock source for LPTIM1*/

      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);
2401396e:	687b      	ldr	r3, [r7, #4]
24013970:	3304      	adds	r3, #4
24013972:	2100      	movs	r1, #0
24013974:	4618      	mov	r0, r3
24013976:	f001 fc5f 	bl	24015238 <RCCEx_PLL2_Config>
2401397a:	4603      	mov	r3, r0
2401397c:	75fb      	strb	r3, [r7, #23]

      /* LPTIM1 clock source configuration done later after clock selection check */
      break;
2401397e:	e012      	b.n	240139a6 <HAL_RCCEx_PeriphCLKConfig+0x98a>

    case RCC_LPTIM1CLKSOURCE_PLL3:  /* PLL3 is used as clock source for LPTIM1*/
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_R_UPDATE);
24013980:	687b      	ldr	r3, [r7, #4]
24013982:	3324      	adds	r3, #36	; 0x24
24013984:	2102      	movs	r1, #2
24013986:	4618      	mov	r0, r3
24013988:	f001 fd08 	bl	2401539c <RCCEx_PLL3_Config>
2401398c:	4603      	mov	r3, r0
2401398e:	75fb      	strb	r3, [r7, #23]

      /* LPTIM1 clock source configuration done later after clock selection check */
      break;
24013990:	e009      	b.n	240139a6 <HAL_RCCEx_PeriphCLKConfig+0x98a>
      /* HSI, HSE, or CSI oscillator is used as source of LPTIM1 clock */
      /* LPTIM1 clock source configuration done later after clock selection check */
      break;

    default:
      ret = HAL_ERROR;
24013992:	2301      	movs	r3, #1
24013994:	75fb      	strb	r3, [r7, #23]
      break;
24013996:	e006      	b.n	240139a6 <HAL_RCCEx_PeriphCLKConfig+0x98a>
      break;
24013998:	bf00      	nop
2401399a:	e004      	b.n	240139a6 <HAL_RCCEx_PeriphCLKConfig+0x98a>
      break;
2401399c:	bf00      	nop
2401399e:	e002      	b.n	240139a6 <HAL_RCCEx_PeriphCLKConfig+0x98a>
      break;
240139a0:	bf00      	nop
240139a2:	e000      	b.n	240139a6 <HAL_RCCEx_PeriphCLKConfig+0x98a>
      break;
240139a4:	bf00      	nop
    }

    if(ret == HAL_OK)
240139a6:	7dfb      	ldrb	r3, [r7, #23]
240139a8:	2b00      	cmp	r3, #0
240139aa:	d10a      	bne.n	240139c2 <HAL_RCCEx_PeriphCLKConfig+0x9a6>
    {
      /* Set the source of LPTIM1 clock*/
      __HAL_RCC_LPTIM1_CONFIG(PeriphClkInit->Lptim1ClockSelection);
240139ac:	4b8c      	ldr	r3, [pc, #560]	; (24013be0 <HAL_RCCEx_PeriphCLKConfig+0xbc4>)
240139ae:	6d5b      	ldr	r3, [r3, #84]	; 0x54
240139b0:	f023 42e0 	bic.w	r2, r3, #1879048192	; 0x70000000
240139b4:	687b      	ldr	r3, [r7, #4]
240139b6:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
240139ba:	4989      	ldr	r1, [pc, #548]	; (24013be0 <HAL_RCCEx_PeriphCLKConfig+0xbc4>)
240139bc:	4313      	orrs	r3, r2
240139be:	654b      	str	r3, [r1, #84]	; 0x54
240139c0:	e001      	b.n	240139c6 <HAL_RCCEx_PeriphCLKConfig+0x9aa>
    }
    else
    {
      /* set overall return value */
      status = ret;
240139c2:	7dfb      	ldrb	r3, [r7, #23]
240139c4:	75bb      	strb	r3, [r7, #22]
    }
  }

  /*---------------------------- LPTIM2 configuration -------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM2) == RCC_PERIPHCLK_LPTIM2)
240139c6:	687b      	ldr	r3, [r7, #4]
240139c8:	681b      	ldr	r3, [r3, #0]
240139ca:	f003 0340 	and.w	r3, r3, #64	; 0x40
240139ce:	2b00      	cmp	r3, #0
240139d0:	d044      	beq.n	24013a5c <HAL_RCCEx_PeriphCLKConfig+0xa40>
  {
    switch(PeriphClkInit->Lptim2ClockSelection)
240139d2:	687b      	ldr	r3, [r7, #4]
240139d4:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
240139d8:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
240139dc:	d01b      	beq.n	24013a16 <HAL_RCCEx_PeriphCLKConfig+0x9fa>
240139de:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
240139e2:	d805      	bhi.n	240139f0 <HAL_RCCEx_PeriphCLKConfig+0x9d4>
240139e4:	2b00      	cmp	r3, #0
240139e6:	d022      	beq.n	24013a2e <HAL_RCCEx_PeriphCLKConfig+0xa12>
240139e8:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
240139ec:	d00a      	beq.n	24013a04 <HAL_RCCEx_PeriphCLKConfig+0x9e8>
240139ee:	e01b      	b.n	24013a28 <HAL_RCCEx_PeriphCLKConfig+0xa0c>
240139f0:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
240139f4:	d01d      	beq.n	24013a32 <HAL_RCCEx_PeriphCLKConfig+0xa16>
240139f6:	f5b3 5fa0 	cmp.w	r3, #5120	; 0x1400
240139fa:	d01c      	beq.n	24013a36 <HAL_RCCEx_PeriphCLKConfig+0xa1a>
240139fc:	f5b3 6f40 	cmp.w	r3, #3072	; 0xc00
24013a00:	d01b      	beq.n	24013a3a <HAL_RCCEx_PeriphCLKConfig+0xa1e>
24013a02:	e011      	b.n	24013a28 <HAL_RCCEx_PeriphCLKConfig+0xa0c>
      /* LPTIM2 clock source configuration done later after clock selection check */
      break;

    case RCC_LPTIM2CLKSOURCE_PLL2: /* PLL2 is used as clock source for LPTIM2*/

      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);
24013a04:	687b      	ldr	r3, [r7, #4]
24013a06:	3304      	adds	r3, #4
24013a08:	2100      	movs	r1, #0
24013a0a:	4618      	mov	r0, r3
24013a0c:	f001 fc14 	bl	24015238 <RCCEx_PLL2_Config>
24013a10:	4603      	mov	r3, r0
24013a12:	75fb      	strb	r3, [r7, #23]

      /* LPTIM2 clock source configuration done later after clock selection check */
      break;
24013a14:	e012      	b.n	24013a3c <HAL_RCCEx_PeriphCLKConfig+0xa20>

    case RCC_LPTIM2CLKSOURCE_PLL3:  /* PLL3 is used as clock source for LPTIM2*/
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_R_UPDATE);
24013a16:	687b      	ldr	r3, [r7, #4]
24013a18:	3324      	adds	r3, #36	; 0x24
24013a1a:	2102      	movs	r1, #2
24013a1c:	4618      	mov	r0, r3
24013a1e:	f001 fcbd 	bl	2401539c <RCCEx_PLL3_Config>
24013a22:	4603      	mov	r3, r0
24013a24:	75fb      	strb	r3, [r7, #23]

      /* LPTIM2 clock source configuration done later after clock selection check */
      break;
24013a26:	e009      	b.n	24013a3c <HAL_RCCEx_PeriphCLKConfig+0xa20>
      /* HSI, HSE, or CSI oscillator is used as source of LPTIM2 clock */
      /* LPTIM2 clock source configuration done later after clock selection check */
      break;

    default:
      ret = HAL_ERROR;
24013a28:	2301      	movs	r3, #1
24013a2a:	75fb      	strb	r3, [r7, #23]
      break;
24013a2c:	e006      	b.n	24013a3c <HAL_RCCEx_PeriphCLKConfig+0xa20>
      break;
24013a2e:	bf00      	nop
24013a30:	e004      	b.n	24013a3c <HAL_RCCEx_PeriphCLKConfig+0xa20>
      break;
24013a32:	bf00      	nop
24013a34:	e002      	b.n	24013a3c <HAL_RCCEx_PeriphCLKConfig+0xa20>
      break;
24013a36:	bf00      	nop
24013a38:	e000      	b.n	24013a3c <HAL_RCCEx_PeriphCLKConfig+0xa20>
      break;
24013a3a:	bf00      	nop
    }

    if(ret == HAL_OK)
24013a3c:	7dfb      	ldrb	r3, [r7, #23]
24013a3e:	2b00      	cmp	r3, #0
24013a40:	d10a      	bne.n	24013a58 <HAL_RCCEx_PeriphCLKConfig+0xa3c>
    {
      /* Set the source of LPTIM2 clock*/
      __HAL_RCC_LPTIM2_CONFIG(PeriphClkInit->Lptim2ClockSelection);
24013a42:	4b67      	ldr	r3, [pc, #412]	; (24013be0 <HAL_RCCEx_PeriphCLKConfig+0xbc4>)
24013a44:	6d9b      	ldr	r3, [r3, #88]	; 0x58
24013a46:	f423 52e0 	bic.w	r2, r3, #7168	; 0x1c00
24013a4a:	687b      	ldr	r3, [r7, #4]
24013a4c:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
24013a50:	4963      	ldr	r1, [pc, #396]	; (24013be0 <HAL_RCCEx_PeriphCLKConfig+0xbc4>)
24013a52:	4313      	orrs	r3, r2
24013a54:	658b      	str	r3, [r1, #88]	; 0x58
24013a56:	e001      	b.n	24013a5c <HAL_RCCEx_PeriphCLKConfig+0xa40>
    }
    else
    {
      /* set overall return value */
      status = ret;
24013a58:	7dfb      	ldrb	r3, [r7, #23]
24013a5a:	75bb      	strb	r3, [r7, #22]
    }
  }

  /*---------------------------- LPTIM345 configuration -------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM345) == RCC_PERIPHCLK_LPTIM345)
24013a5c:	687b      	ldr	r3, [r7, #4]
24013a5e:	681b      	ldr	r3, [r3, #0]
24013a60:	f003 0380 	and.w	r3, r3, #128	; 0x80
24013a64:	2b00      	cmp	r3, #0
24013a66:	d044      	beq.n	24013af2 <HAL_RCCEx_PeriphCLKConfig+0xad6>
  {
    switch(PeriphClkInit->Lptim345ClockSelection)
24013a68:	687b      	ldr	r3, [r7, #4]
24013a6a:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
24013a6e:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
24013a72:	d01b      	beq.n	24013aac <HAL_RCCEx_PeriphCLKConfig+0xa90>
24013a74:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
24013a78:	d805      	bhi.n	24013a86 <HAL_RCCEx_PeriphCLKConfig+0xa6a>
24013a7a:	2b00      	cmp	r3, #0
24013a7c:	d022      	beq.n	24013ac4 <HAL_RCCEx_PeriphCLKConfig+0xaa8>
24013a7e:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
24013a82:	d00a      	beq.n	24013a9a <HAL_RCCEx_PeriphCLKConfig+0xa7e>
24013a84:	e01b      	b.n	24013abe <HAL_RCCEx_PeriphCLKConfig+0xaa2>
24013a86:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
24013a8a:	d01d      	beq.n	24013ac8 <HAL_RCCEx_PeriphCLKConfig+0xaac>
24013a8c:	f5b3 4f20 	cmp.w	r3, #40960	; 0xa000
24013a90:	d01c      	beq.n	24013acc <HAL_RCCEx_PeriphCLKConfig+0xab0>
24013a92:	f5b3 4fc0 	cmp.w	r3, #24576	; 0x6000
24013a96:	d01b      	beq.n	24013ad0 <HAL_RCCEx_PeriphCLKConfig+0xab4>
24013a98:	e011      	b.n	24013abe <HAL_RCCEx_PeriphCLKConfig+0xaa2>
    case RCC_LPTIM345CLKSOURCE_PCLK4:      /* SRD/D3 PCLK1 (PCLK4) as clock source for LPTIM3/4/5 */
      /* LPTIM3/4/5 clock source configuration done later after clock selection check */
      break;

    case RCC_LPTIM345CLKSOURCE_PLL2: /* PLL2 is used as clock source for LPTIM3/4/5 */
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);
24013a9a:	687b      	ldr	r3, [r7, #4]
24013a9c:	3304      	adds	r3, #4
24013a9e:	2100      	movs	r1, #0
24013aa0:	4618      	mov	r0, r3
24013aa2:	f001 fbc9 	bl	24015238 <RCCEx_PLL2_Config>
24013aa6:	4603      	mov	r3, r0
24013aa8:	75fb      	strb	r3, [r7, #23]

      /* LPTIM3/4/5 clock source configuration done later after clock selection check */
      break;
24013aaa:	e012      	b.n	24013ad2 <HAL_RCCEx_PeriphCLKConfig+0xab6>

    case RCC_LPTIM345CLKSOURCE_PLL3:  /* PLL3 is used as clock source for LPTIM3/4/5 */
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_R_UPDATE);
24013aac:	687b      	ldr	r3, [r7, #4]
24013aae:	3324      	adds	r3, #36	; 0x24
24013ab0:	2102      	movs	r1, #2
24013ab2:	4618      	mov	r0, r3
24013ab4:	f001 fc72 	bl	2401539c <RCCEx_PLL3_Config>
24013ab8:	4603      	mov	r3, r0
24013aba:	75fb      	strb	r3, [r7, #23]

      /* LPTIM3/4/5 clock source configuration done later after clock selection check */
      break;
24013abc:	e009      	b.n	24013ad2 <HAL_RCCEx_PeriphCLKConfig+0xab6>
      /* HSI, HSE, or CSI oscillator is used as source of LPTIM3/4/5 clock */
      /* LPTIM3/4/5 clock source configuration done later after clock selection check */
      break;

    default:
      ret = HAL_ERROR;
24013abe:	2301      	movs	r3, #1
24013ac0:	75fb      	strb	r3, [r7, #23]
      break;
24013ac2:	e006      	b.n	24013ad2 <HAL_RCCEx_PeriphCLKConfig+0xab6>
      break;
24013ac4:	bf00      	nop
24013ac6:	e004      	b.n	24013ad2 <HAL_RCCEx_PeriphCLKConfig+0xab6>
      break;
24013ac8:	bf00      	nop
24013aca:	e002      	b.n	24013ad2 <HAL_RCCEx_PeriphCLKConfig+0xab6>
      break;
24013acc:	bf00      	nop
24013ace:	e000      	b.n	24013ad2 <HAL_RCCEx_PeriphCLKConfig+0xab6>
      break;
24013ad0:	bf00      	nop
    }

    if(ret == HAL_OK)
24013ad2:	7dfb      	ldrb	r3, [r7, #23]
24013ad4:	2b00      	cmp	r3, #0
24013ad6:	d10a      	bne.n	24013aee <HAL_RCCEx_PeriphCLKConfig+0xad2>
    {
      /* Set the source of LPTIM3/4/5 clock */
      __HAL_RCC_LPTIM345_CONFIG(PeriphClkInit->Lptim345ClockSelection);
24013ad8:	4b41      	ldr	r3, [pc, #260]	; (24013be0 <HAL_RCCEx_PeriphCLKConfig+0xbc4>)
24013ada:	6d9b      	ldr	r3, [r3, #88]	; 0x58
24013adc:	f423 4260 	bic.w	r2, r3, #57344	; 0xe000
24013ae0:	687b      	ldr	r3, [r7, #4]
24013ae2:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
24013ae6:	493e      	ldr	r1, [pc, #248]	; (24013be0 <HAL_RCCEx_PeriphCLKConfig+0xbc4>)
24013ae8:	4313      	orrs	r3, r2
24013aea:	658b      	str	r3, [r1, #88]	; 0x58
24013aec:	e001      	b.n	24013af2 <HAL_RCCEx_PeriphCLKConfig+0xad6>
    }
    else
    {
      /* set overall return value */
      status = ret;
24013aee:	7dfb      	ldrb	r3, [r7, #23]
24013af0:	75bb      	strb	r3, [r7, #22]
    }
  }

  /*------------------------------ I2C1/2/3 Configuration ------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C123) == RCC_PERIPHCLK_I2C123)
24013af2:	687b      	ldr	r3, [r7, #4]
24013af4:	681b      	ldr	r3, [r3, #0]
24013af6:	f003 0308 	and.w	r3, r3, #8
24013afa:	2b00      	cmp	r3, #0
24013afc:	d01a      	beq.n	24013b34 <HAL_RCCEx_PeriphCLKConfig+0xb18>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C123CLKSOURCE(PeriphClkInit->I2c123ClockSelection));

    if ((PeriphClkInit->I2c123ClockSelection )== RCC_I2C123CLKSOURCE_PLL3 )
24013afe:	687b      	ldr	r3, [r7, #4]
24013b00:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
24013b04:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
24013b08:	d10a      	bne.n	24013b20 <HAL_RCCEx_PeriphCLKConfig+0xb04>
    {
        if(RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_R_UPDATE)!= HAL_OK)
24013b0a:	687b      	ldr	r3, [r7, #4]
24013b0c:	3324      	adds	r3, #36	; 0x24
24013b0e:	2102      	movs	r1, #2
24013b10:	4618      	mov	r0, r3
24013b12:	f001 fc43 	bl	2401539c <RCCEx_PLL3_Config>
24013b16:	4603      	mov	r3, r0
24013b18:	2b00      	cmp	r3, #0
24013b1a:	d001      	beq.n	24013b20 <HAL_RCCEx_PeriphCLKConfig+0xb04>
        {
          status = HAL_ERROR;
24013b1c:	2301      	movs	r3, #1
24013b1e:	75bb      	strb	r3, [r7, #22]
        }
    }

      __HAL_RCC_I2C123_CONFIG(PeriphClkInit->I2c123ClockSelection);
24013b20:	4b2f      	ldr	r3, [pc, #188]	; (24013be0 <HAL_RCCEx_PeriphCLKConfig+0xbc4>)
24013b22:	6d5b      	ldr	r3, [r3, #84]	; 0x54
24013b24:	f423 5240 	bic.w	r2, r3, #12288	; 0x3000
24013b28:	687b      	ldr	r3, [r7, #4]
24013b2a:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
24013b2e:	492c      	ldr	r1, [pc, #176]	; (24013be0 <HAL_RCCEx_PeriphCLKConfig+0xbc4>)
24013b30:	4313      	orrs	r3, r2
24013b32:	654b      	str	r3, [r1, #84]	; 0x54

  }

  /*------------------------------ I2C4 Configuration ------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C4) == RCC_PERIPHCLK_I2C4)
24013b34:	687b      	ldr	r3, [r7, #4]
24013b36:	681b      	ldr	r3, [r3, #0]
24013b38:	f003 0310 	and.w	r3, r3, #16
24013b3c:	2b00      	cmp	r3, #0
24013b3e:	d01a      	beq.n	24013b76 <HAL_RCCEx_PeriphCLKConfig+0xb5a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C4CLKSOURCE(PeriphClkInit->I2c4ClockSelection));

    if ((PeriphClkInit->I2c4ClockSelection) == RCC_I2C4CLKSOURCE_PLL3 )
24013b40:	687b      	ldr	r3, [r7, #4]
24013b42:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
24013b46:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
24013b4a:	d10a      	bne.n	24013b62 <HAL_RCCEx_PeriphCLKConfig+0xb46>
    {
      if(RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_R_UPDATE)!= HAL_OK)
24013b4c:	687b      	ldr	r3, [r7, #4]
24013b4e:	3324      	adds	r3, #36	; 0x24
24013b50:	2102      	movs	r1, #2
24013b52:	4618      	mov	r0, r3
24013b54:	f001 fc22 	bl	2401539c <RCCEx_PLL3_Config>
24013b58:	4603      	mov	r3, r0
24013b5a:	2b00      	cmp	r3, #0
24013b5c:	d001      	beq.n	24013b62 <HAL_RCCEx_PeriphCLKConfig+0xb46>
      {
        status = HAL_ERROR;
24013b5e:	2301      	movs	r3, #1
24013b60:	75bb      	strb	r3, [r7, #22]
      }
    }

      __HAL_RCC_I2C4_CONFIG(PeriphClkInit->I2c4ClockSelection);
24013b62:	4b1f      	ldr	r3, [pc, #124]	; (24013be0 <HAL_RCCEx_PeriphCLKConfig+0xbc4>)
24013b64:	6d9b      	ldr	r3, [r3, #88]	; 0x58
24013b66:	f423 7240 	bic.w	r2, r3, #768	; 0x300
24013b6a:	687b      	ldr	r3, [r7, #4]
24013b6c:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
24013b70:	491b      	ldr	r1, [pc, #108]	; (24013be0 <HAL_RCCEx_PeriphCLKConfig+0xbc4>)
24013b72:	4313      	orrs	r3, r2
24013b74:	658b      	str	r3, [r1, #88]	; 0x58

  }

  /*---------------------------- ADC configuration -------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_ADC) == RCC_PERIPHCLK_ADC)
24013b76:	687b      	ldr	r3, [r7, #4]
24013b78:	681b      	ldr	r3, [r3, #0]
24013b7a:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
24013b7e:	2b00      	cmp	r3, #0
24013b80:	d032      	beq.n	24013be8 <HAL_RCCEx_PeriphCLKConfig+0xbcc>
  {
    switch(PeriphClkInit->AdcClockSelection)
24013b82:	687b      	ldr	r3, [r7, #4]
24013b84:	f8d3 30a0 	ldr.w	r3, [r3, #160]	; 0xa0
24013b88:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
24013b8c:	d00d      	beq.n	24013baa <HAL_RCCEx_PeriphCLKConfig+0xb8e>
24013b8e:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
24013b92:	d016      	beq.n	24013bc2 <HAL_RCCEx_PeriphCLKConfig+0xba6>
24013b94:	2b00      	cmp	r3, #0
24013b96:	d111      	bne.n	24013bbc <HAL_RCCEx_PeriphCLKConfig+0xba0>
    {

    case RCC_ADCCLKSOURCE_PLL2: /* PLL2 is used as clock source for ADC*/

      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);
24013b98:	687b      	ldr	r3, [r7, #4]
24013b9a:	3304      	adds	r3, #4
24013b9c:	2100      	movs	r1, #0
24013b9e:	4618      	mov	r0, r3
24013ba0:	f001 fb4a 	bl	24015238 <RCCEx_PLL2_Config>
24013ba4:	4603      	mov	r3, r0
24013ba6:	75fb      	strb	r3, [r7, #23]

      /* ADC clock source configuration done later after clock selection check */
      break;
24013ba8:	e00c      	b.n	24013bc4 <HAL_RCCEx_PeriphCLKConfig+0xba8>

    case RCC_ADCCLKSOURCE_PLL3:  /* PLL3 is used as clock source for ADC*/
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_R_UPDATE);
24013baa:	687b      	ldr	r3, [r7, #4]
24013bac:	3324      	adds	r3, #36	; 0x24
24013bae:	2102      	movs	r1, #2
24013bb0:	4618      	mov	r0, r3
24013bb2:	f001 fbf3 	bl	2401539c <RCCEx_PLL3_Config>
24013bb6:	4603      	mov	r3, r0
24013bb8:	75fb      	strb	r3, [r7, #23]

      /* ADC clock source configuration done later after clock selection check */
      break;
24013bba:	e003      	b.n	24013bc4 <HAL_RCCEx_PeriphCLKConfig+0xba8>
      /* HSI, HSE, or CSI oscillator is used as source of ADC clock */
      /* ADC clock source configuration done later after clock selection check */
      break;

    default:
      ret = HAL_ERROR;
24013bbc:	2301      	movs	r3, #1
24013bbe:	75fb      	strb	r3, [r7, #23]
      break;
24013bc0:	e000      	b.n	24013bc4 <HAL_RCCEx_PeriphCLKConfig+0xba8>
      break;
24013bc2:	bf00      	nop
    }

    if(ret == HAL_OK)
24013bc4:	7dfb      	ldrb	r3, [r7, #23]
24013bc6:	2b00      	cmp	r3, #0
24013bc8:	d10c      	bne.n	24013be4 <HAL_RCCEx_PeriphCLKConfig+0xbc8>
    {
      /* Set the source of ADC clock*/
      __HAL_RCC_ADC_CONFIG(PeriphClkInit->AdcClockSelection);
24013bca:	4b05      	ldr	r3, [pc, #20]	; (24013be0 <HAL_RCCEx_PeriphCLKConfig+0xbc4>)
24013bcc:	6d9b      	ldr	r3, [r3, #88]	; 0x58
24013bce:	f423 3240 	bic.w	r2, r3, #196608	; 0x30000
24013bd2:	687b      	ldr	r3, [r7, #4]
24013bd4:	f8d3 30a0 	ldr.w	r3, [r3, #160]	; 0xa0
24013bd8:	4901      	ldr	r1, [pc, #4]	; (24013be0 <HAL_RCCEx_PeriphCLKConfig+0xbc4>)
24013bda:	4313      	orrs	r3, r2
24013bdc:	658b      	str	r3, [r1, #88]	; 0x58
24013bde:	e003      	b.n	24013be8 <HAL_RCCEx_PeriphCLKConfig+0xbcc>
24013be0:	58024400 	.word	0x58024400
    }
    else
    {
      /* set overall return value */
      status = ret;
24013be4:	7dfb      	ldrb	r3, [r7, #23]
24013be6:	75bb      	strb	r3, [r7, #22]
    }
  }

  /*------------------------------ USB Configuration -------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USB) == RCC_PERIPHCLK_USB)
24013be8:	687b      	ldr	r3, [r7, #4]
24013bea:	681b      	ldr	r3, [r3, #0]
24013bec:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
24013bf0:	2b00      	cmp	r3, #0
24013bf2:	d02f      	beq.n	24013c54 <HAL_RCCEx_PeriphCLKConfig+0xc38>
  {

    switch(PeriphClkInit->UsbClockSelection)
24013bf4:	687b      	ldr	r3, [r7, #4]
24013bf6:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
24013bfa:	f5b3 1f00 	cmp.w	r3, #2097152	; 0x200000
24013bfe:	d00c      	beq.n	24013c1a <HAL_RCCEx_PeriphCLKConfig+0xbfe>
24013c00:	f5b3 1f40 	cmp.w	r3, #3145728	; 0x300000
24013c04:	d015      	beq.n	24013c32 <HAL_RCCEx_PeriphCLKConfig+0xc16>
24013c06:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
24013c0a:	d10f      	bne.n	24013c2c <HAL_RCCEx_PeriphCLKConfig+0xc10>
    {
    case RCC_USBCLKSOURCE_PLL:      /* PLL is used as clock source for USB*/
      /* Enable USB Clock output generated form System USB . */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
24013c0c:	4b71      	ldr	r3, [pc, #452]	; (24013dd4 <HAL_RCCEx_PeriphCLKConfig+0xdb8>)
24013c0e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24013c10:	4a70      	ldr	r2, [pc, #448]	; (24013dd4 <HAL_RCCEx_PeriphCLKConfig+0xdb8>)
24013c12:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
24013c16:	62d3      	str	r3, [r2, #44]	; 0x2c

      /* USB clock source configuration done later after clock selection check */
      break;
24013c18:	e00c      	b.n	24013c34 <HAL_RCCEx_PeriphCLKConfig+0xc18>

    case RCC_USBCLKSOURCE_PLL3: /* PLL3 is used as clock source for USB*/

      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_Q_UPDATE);
24013c1a:	687b      	ldr	r3, [r7, #4]
24013c1c:	3324      	adds	r3, #36	; 0x24
24013c1e:	2101      	movs	r1, #1
24013c20:	4618      	mov	r0, r3
24013c22:	f001 fbbb 	bl	2401539c <RCCEx_PLL3_Config>
24013c26:	4603      	mov	r3, r0
24013c28:	75fb      	strb	r3, [r7, #23]

      /* USB clock source configuration done later after clock selection check */
      break;
24013c2a:	e003      	b.n	24013c34 <HAL_RCCEx_PeriphCLKConfig+0xc18>
      /* HSI48 oscillator is used as source of USB clock */
      /* USB clock source configuration done later after clock selection check */
      break;

    default:
      ret = HAL_ERROR;
24013c2c:	2301      	movs	r3, #1
24013c2e:	75fb      	strb	r3, [r7, #23]
      break;
24013c30:	e000      	b.n	24013c34 <HAL_RCCEx_PeriphCLKConfig+0xc18>
      break;
24013c32:	bf00      	nop
    }

    if(ret == HAL_OK)
24013c34:	7dfb      	ldrb	r3, [r7, #23]
24013c36:	2b00      	cmp	r3, #0
24013c38:	d10a      	bne.n	24013c50 <HAL_RCCEx_PeriphCLKConfig+0xc34>
    {
      /* Set the source of USB clock*/
      __HAL_RCC_USB_CONFIG(PeriphClkInit->UsbClockSelection);
24013c3a:	4b66      	ldr	r3, [pc, #408]	; (24013dd4 <HAL_RCCEx_PeriphCLKConfig+0xdb8>)
24013c3c:	6d5b      	ldr	r3, [r3, #84]	; 0x54
24013c3e:	f423 1240 	bic.w	r2, r3, #3145728	; 0x300000
24013c42:	687b      	ldr	r3, [r7, #4]
24013c44:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
24013c48:	4962      	ldr	r1, [pc, #392]	; (24013dd4 <HAL_RCCEx_PeriphCLKConfig+0xdb8>)
24013c4a:	4313      	orrs	r3, r2
24013c4c:	654b      	str	r3, [r1, #84]	; 0x54
24013c4e:	e001      	b.n	24013c54 <HAL_RCCEx_PeriphCLKConfig+0xc38>
    }
    else
    {
      /* set overall return value */
      status = ret;
24013c50:	7dfb      	ldrb	r3, [r7, #23]
24013c52:	75bb      	strb	r3, [r7, #22]
    }

  }

  /*------------------------------------- SDMMC Configuration ------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SDMMC) == RCC_PERIPHCLK_SDMMC)
24013c54:	687b      	ldr	r3, [r7, #4]
24013c56:	681b      	ldr	r3, [r3, #0]
24013c58:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
24013c5c:	2b00      	cmp	r3, #0
24013c5e:	d029      	beq.n	24013cb4 <HAL_RCCEx_PeriphCLKConfig+0xc98>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SDMMC(PeriphClkInit->SdmmcClockSelection));

    switch(PeriphClkInit->SdmmcClockSelection)
24013c60:	687b      	ldr	r3, [r7, #4]
24013c62:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
24013c64:	2b00      	cmp	r3, #0
24013c66:	d003      	beq.n	24013c70 <HAL_RCCEx_PeriphCLKConfig+0xc54>
24013c68:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
24013c6c:	d007      	beq.n	24013c7e <HAL_RCCEx_PeriphCLKConfig+0xc62>
24013c6e:	e00f      	b.n	24013c90 <HAL_RCCEx_PeriphCLKConfig+0xc74>
    {
    case RCC_SDMMCCLKSOURCE_PLL:      /* PLL is used as clock source for SDMMC*/
      /* Enable SDMMC Clock output generated form System PLL . */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
24013c70:	4b58      	ldr	r3, [pc, #352]	; (24013dd4 <HAL_RCCEx_PeriphCLKConfig+0xdb8>)
24013c72:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24013c74:	4a57      	ldr	r2, [pc, #348]	; (24013dd4 <HAL_RCCEx_PeriphCLKConfig+0xdb8>)
24013c76:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
24013c7a:	62d3      	str	r3, [r2, #44]	; 0x2c

      /* SDMMC clock source configuration done later after clock selection check */
      break;
24013c7c:	e00b      	b.n	24013c96 <HAL_RCCEx_PeriphCLKConfig+0xc7a>

    case RCC_SDMMCCLKSOURCE_PLL2: /* PLL2 is used as clock source for SDMMC*/

      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_R_UPDATE);
24013c7e:	687b      	ldr	r3, [r7, #4]
24013c80:	3304      	adds	r3, #4
24013c82:	2102      	movs	r1, #2
24013c84:	4618      	mov	r0, r3
24013c86:	f001 fad7 	bl	24015238 <RCCEx_PLL2_Config>
24013c8a:	4603      	mov	r3, r0
24013c8c:	75fb      	strb	r3, [r7, #23]

      /* SDMMC clock source configuration done later after clock selection check */
      break;
24013c8e:	e002      	b.n	24013c96 <HAL_RCCEx_PeriphCLKConfig+0xc7a>

    default:
      ret = HAL_ERROR;
24013c90:	2301      	movs	r3, #1
24013c92:	75fb      	strb	r3, [r7, #23]
      break;
24013c94:	bf00      	nop
    }

    if(ret == HAL_OK)
24013c96:	7dfb      	ldrb	r3, [r7, #23]
24013c98:	2b00      	cmp	r3, #0
24013c9a:	d109      	bne.n	24013cb0 <HAL_RCCEx_PeriphCLKConfig+0xc94>
    {
      /* Set the source of SDMMC clock*/
      __HAL_RCC_SDMMC_CONFIG(PeriphClkInit->SdmmcClockSelection);
24013c9c:	4b4d      	ldr	r3, [pc, #308]	; (24013dd4 <HAL_RCCEx_PeriphCLKConfig+0xdb8>)
24013c9e:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
24013ca0:	f423 3280 	bic.w	r2, r3, #65536	; 0x10000
24013ca4:	687b      	ldr	r3, [r7, #4]
24013ca6:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
24013ca8:	494a      	ldr	r1, [pc, #296]	; (24013dd4 <HAL_RCCEx_PeriphCLKConfig+0xdb8>)
24013caa:	4313      	orrs	r3, r2
24013cac:	64cb      	str	r3, [r1, #76]	; 0x4c
24013cae:	e001      	b.n	24013cb4 <HAL_RCCEx_PeriphCLKConfig+0xc98>
    }
    else
    {
      /* set overall return value */
      status = ret;
24013cb0:	7dfb      	ldrb	r3, [r7, #23]
24013cb2:	75bb      	strb	r3, [r7, #22]
    }
  }

#if defined(LTDC)
  /*-------------------------------------- LTDC Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LTDC) == RCC_PERIPHCLK_LTDC)
24013cb4:	687b      	ldr	r3, [r7, #4]
24013cb6:	681b      	ldr	r3, [r3, #0]
24013cb8:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
24013cbc:	2b00      	cmp	r3, #0
24013cbe:	d00a      	beq.n	24013cd6 <HAL_RCCEx_PeriphCLKConfig+0xcba>
  {
    if(RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_R_UPDATE)!=HAL_OK)
24013cc0:	687b      	ldr	r3, [r7, #4]
24013cc2:	3324      	adds	r3, #36	; 0x24
24013cc4:	2102      	movs	r1, #2
24013cc6:	4618      	mov	r0, r3
24013cc8:	f001 fb68 	bl	2401539c <RCCEx_PLL3_Config>
24013ccc:	4603      	mov	r3, r0
24013cce:	2b00      	cmp	r3, #0
24013cd0:	d001      	beq.n	24013cd6 <HAL_RCCEx_PeriphCLKConfig+0xcba>
    {
      status=HAL_ERROR;
24013cd2:	2301      	movs	r3, #1
24013cd4:	75bb      	strb	r3, [r7, #22]
    }
  }
#endif /* LTDC */

  /*------------------------------ RNG Configuration -------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RNG) == RCC_PERIPHCLK_RNG)
24013cd6:	687b      	ldr	r3, [r7, #4]
24013cd8:	681b      	ldr	r3, [r3, #0]
24013cda:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
24013cde:	2b00      	cmp	r3, #0
24013ce0:	d02f      	beq.n	24013d42 <HAL_RCCEx_PeriphCLKConfig+0xd26>
  {

    switch(PeriphClkInit->RngClockSelection)
24013ce2:	687b      	ldr	r3, [r7, #4]
24013ce4:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
24013ce6:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
24013cea:	d00c      	beq.n	24013d06 <HAL_RCCEx_PeriphCLKConfig+0xcea>
24013cec:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
24013cf0:	d802      	bhi.n	24013cf8 <HAL_RCCEx_PeriphCLKConfig+0xcdc>
24013cf2:	2b00      	cmp	r3, #0
24013cf4:	d011      	beq.n	24013d1a <HAL_RCCEx_PeriphCLKConfig+0xcfe>
24013cf6:	e00d      	b.n	24013d14 <HAL_RCCEx_PeriphCLKConfig+0xcf8>
24013cf8:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
24013cfc:	d00f      	beq.n	24013d1e <HAL_RCCEx_PeriphCLKConfig+0xd02>
24013cfe:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
24013d02:	d00e      	beq.n	24013d22 <HAL_RCCEx_PeriphCLKConfig+0xd06>
24013d04:	e006      	b.n	24013d14 <HAL_RCCEx_PeriphCLKConfig+0xcf8>
    {
    case RCC_RNGCLKSOURCE_PLL:     /* PLL is used as clock source for RNG*/
      /* Enable RNG Clock output generated form System RNG . */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
24013d06:	4b33      	ldr	r3, [pc, #204]	; (24013dd4 <HAL_RCCEx_PeriphCLKConfig+0xdb8>)
24013d08:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24013d0a:	4a32      	ldr	r2, [pc, #200]	; (24013dd4 <HAL_RCCEx_PeriphCLKConfig+0xdb8>)
24013d0c:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
24013d10:	62d3      	str	r3, [r2, #44]	; 0x2c

      /* RNG clock source configuration done later after clock selection check */
      break;
24013d12:	e007      	b.n	24013d24 <HAL_RCCEx_PeriphCLKConfig+0xd08>
      /* HSI48 oscillator is used as source of RNG clock */
      /* RNG clock source configuration done later after clock selection check */
      break;

    default:
      ret = HAL_ERROR;
24013d14:	2301      	movs	r3, #1
24013d16:	75fb      	strb	r3, [r7, #23]
      break;
24013d18:	e004      	b.n	24013d24 <HAL_RCCEx_PeriphCLKConfig+0xd08>
      break;
24013d1a:	bf00      	nop
24013d1c:	e002      	b.n	24013d24 <HAL_RCCEx_PeriphCLKConfig+0xd08>
      break;
24013d1e:	bf00      	nop
24013d20:	e000      	b.n	24013d24 <HAL_RCCEx_PeriphCLKConfig+0xd08>
      break;
24013d22:	bf00      	nop
    }

    if(ret == HAL_OK)
24013d24:	7dfb      	ldrb	r3, [r7, #23]
24013d26:	2b00      	cmp	r3, #0
24013d28:	d109      	bne.n	24013d3e <HAL_RCCEx_PeriphCLKConfig+0xd22>
    {
      /* Set the source of RNG clock*/
      __HAL_RCC_RNG_CONFIG(PeriphClkInit->RngClockSelection);
24013d2a:	4b2a      	ldr	r3, [pc, #168]	; (24013dd4 <HAL_RCCEx_PeriphCLKConfig+0xdb8>)
24013d2c:	6d5b      	ldr	r3, [r3, #84]	; 0x54
24013d2e:	f423 7240 	bic.w	r2, r3, #768	; 0x300
24013d32:	687b      	ldr	r3, [r7, #4]
24013d34:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
24013d36:	4927      	ldr	r1, [pc, #156]	; (24013dd4 <HAL_RCCEx_PeriphCLKConfig+0xdb8>)
24013d38:	4313      	orrs	r3, r2
24013d3a:	654b      	str	r3, [r1, #84]	; 0x54
24013d3c:	e001      	b.n	24013d42 <HAL_RCCEx_PeriphCLKConfig+0xd26>
    }
    else
    {
      /* set overall return value */
      status = ret;
24013d3e:	7dfb      	ldrb	r3, [r7, #23]
24013d40:	75bb      	strb	r3, [r7, #22]
    }

  }

  /*------------------------------ SWPMI1 Configuration ------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SWPMI1) == RCC_PERIPHCLK_SWPMI1)
24013d42:	687b      	ldr	r3, [r7, #4]
24013d44:	681b      	ldr	r3, [r3, #0]
24013d46:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
24013d4a:	2b00      	cmp	r3, #0
24013d4c:	d008      	beq.n	24013d60 <HAL_RCCEx_PeriphCLKConfig+0xd44>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SWPMI1CLKSOURCE(PeriphClkInit->Swpmi1ClockSelection));

    /* Configure the SWPMI1 interface clock source */
    __HAL_RCC_SWPMI1_CONFIG(PeriphClkInit->Swpmi1ClockSelection);
24013d4e:	4b21      	ldr	r3, [pc, #132]	; (24013dd4 <HAL_RCCEx_PeriphCLKConfig+0xdb8>)
24013d50:	6d1b      	ldr	r3, [r3, #80]	; 0x50
24013d52:	f023 4200 	bic.w	r2, r3, #2147483648	; 0x80000000
24013d56:	687b      	ldr	r3, [r7, #4]
24013d58:	6f1b      	ldr	r3, [r3, #112]	; 0x70
24013d5a:	491e      	ldr	r1, [pc, #120]	; (24013dd4 <HAL_RCCEx_PeriphCLKConfig+0xdb8>)
24013d5c:	4313      	orrs	r3, r2
24013d5e:	650b      	str	r3, [r1, #80]	; 0x50
    /* Configure the HRTIM1 clock source */
    __HAL_RCC_HRTIM1_CONFIG(PeriphClkInit->Hrtim1ClockSelection);
  }
#endif  /*HRTIM*/
  /*------------------------------ DFSDM1 Configuration ------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_DFSDM1) == RCC_PERIPHCLK_DFSDM1)
24013d60:	687b      	ldr	r3, [r7, #4]
24013d62:	681b      	ldr	r3, [r3, #0]
24013d64:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
24013d68:	2b00      	cmp	r3, #0
24013d6a:	d008      	beq.n	24013d7e <HAL_RCCEx_PeriphCLKConfig+0xd62>
  {
    /* Check the parameters */
    assert_param(IS_RCC_DFSDM1CLKSOURCE(PeriphClkInit->Dfsdm1ClockSelection));

    /* Configure the DFSDM1 interface clock source */
    __HAL_RCC_DFSDM1_CONFIG(PeriphClkInit->Dfsdm1ClockSelection);
24013d6c:	4b19      	ldr	r3, [pc, #100]	; (24013dd4 <HAL_RCCEx_PeriphCLKConfig+0xdb8>)
24013d6e:	6d1b      	ldr	r3, [r3, #80]	; 0x50
24013d70:	f023 7280 	bic.w	r2, r3, #16777216	; 0x1000000
24013d74:	687b      	ldr	r3, [r7, #4]
24013d76:	6e9b      	ldr	r3, [r3, #104]	; 0x68
24013d78:	4916      	ldr	r1, [pc, #88]	; (24013dd4 <HAL_RCCEx_PeriphCLKConfig+0xdb8>)
24013d7a:	4313      	orrs	r3, r2
24013d7c:	650b      	str	r3, [r1, #80]	; 0x50
    __HAL_RCC_DFSDM2_CONFIG(PeriphClkInit->Dfsdm2ClockSelection);
  }
#endif  /* DFSDM2 */

  /*------------------------------------ TIM configuration --------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_TIM) == RCC_PERIPHCLK_TIM)
24013d7e:	687b      	ldr	r3, [r7, #4]
24013d80:	681b      	ldr	r3, [r3, #0]
24013d82:	f003 4380 	and.w	r3, r3, #1073741824	; 0x40000000
24013d86:	2b00      	cmp	r3, #0
24013d88:	d00d      	beq.n	24013da6 <HAL_RCCEx_PeriphCLKConfig+0xd8a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_TIMPRES(PeriphClkInit->TIMPresSelection));

    /* Configure Timer Prescaler */
    __HAL_RCC_TIMCLKPRESCALER(PeriphClkInit->TIMPresSelection);
24013d8a:	4b12      	ldr	r3, [pc, #72]	; (24013dd4 <HAL_RCCEx_PeriphCLKConfig+0xdb8>)
24013d8c:	691b      	ldr	r3, [r3, #16]
24013d8e:	4a11      	ldr	r2, [pc, #68]	; (24013dd4 <HAL_RCCEx_PeriphCLKConfig+0xdb8>)
24013d90:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
24013d94:	6113      	str	r3, [r2, #16]
24013d96:	4b0f      	ldr	r3, [pc, #60]	; (24013dd4 <HAL_RCCEx_PeriphCLKConfig+0xdb8>)
24013d98:	691a      	ldr	r2, [r3, #16]
24013d9a:	687b      	ldr	r3, [r7, #4]
24013d9c:	f8d3 30b8 	ldr.w	r3, [r3, #184]	; 0xb8
24013da0:	490c      	ldr	r1, [pc, #48]	; (24013dd4 <HAL_RCCEx_PeriphCLKConfig+0xdb8>)
24013da2:	4313      	orrs	r3, r2
24013da4:	610b      	str	r3, [r1, #16]
  }

  /*------------------------------------ CKPER configuration --------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_CKPER) == RCC_PERIPHCLK_CKPER)
24013da6:	687b      	ldr	r3, [r7, #4]
24013da8:	681b      	ldr	r3, [r3, #0]
24013daa:	2b00      	cmp	r3, #0
24013dac:	da08      	bge.n	24013dc0 <HAL_RCCEx_PeriphCLKConfig+0xda4>
  {
    /* Check the parameters */
    assert_param(IS_RCC_CLKPSOURCE(PeriphClkInit->CkperClockSelection));

    /* Configure the CKPER clock source */
    __HAL_RCC_CLKP_CONFIG(PeriphClkInit->CkperClockSelection);
24013dae:	4b09      	ldr	r3, [pc, #36]	; (24013dd4 <HAL_RCCEx_PeriphCLKConfig+0xdb8>)
24013db0:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
24013db2:	f023 5240 	bic.w	r2, r3, #805306368	; 0x30000000
24013db6:	687b      	ldr	r3, [r7, #4]
24013db8:	6d1b      	ldr	r3, [r3, #80]	; 0x50
24013dba:	4906      	ldr	r1, [pc, #24]	; (24013dd4 <HAL_RCCEx_PeriphCLKConfig+0xdb8>)
24013dbc:	4313      	orrs	r3, r2
24013dbe:	64cb      	str	r3, [r1, #76]	; 0x4c
  }

  if (status == HAL_OK)
24013dc0:	7dbb      	ldrb	r3, [r7, #22]
24013dc2:	2b00      	cmp	r3, #0
24013dc4:	d101      	bne.n	24013dca <HAL_RCCEx_PeriphCLKConfig+0xdae>
  {
    return HAL_OK;
24013dc6:	2300      	movs	r3, #0
24013dc8:	e000      	b.n	24013dcc <HAL_RCCEx_PeriphCLKConfig+0xdb0>
  }
  return HAL_ERROR;
24013dca:	2301      	movs	r3, #1
}
24013dcc:	4618      	mov	r0, r3
24013dce:	3718      	adds	r7, #24
24013dd0:	46bd      	mov	sp, r7
24013dd2:	bd80      	pop	{r7, pc}
24013dd4:	58024400 	.word	0x58024400

24013dd8 <HAL_RCCEx_GetPeriphCLKConfig>:
  * @retval None
  *
  *   (*) : Available on some STM32H7 lines only.
  */
void HAL_RCCEx_GetPeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
{
24013dd8:	b480      	push	{r7}
24013dda:	b083      	sub	sp, #12
24013ddc:	af00      	add	r7, sp, #0
24013dde:	6078      	str	r0, [r7, #4]
  /* Set all possible values for the extended clock type parameter------------*/
  PeriphClkInit->PeriphClockSelection =
24013de0:	687b      	ldr	r3, [r7, #4]
24013de2:	4aa3      	ldr	r2, [pc, #652]	; (24014070 <HAL_RCCEx_GetPeriphCLKConfig+0x298>)
24013de4:	601a      	str	r2, [r3, #0]
	         RCC_PERIPHCLK_FDCAN   | RCC_PERIPHCLK_SDMMC       | RCC_PERIPHCLK_RNG     | RCC_PERIPHCLK_USB      |
	         RCC_PERIPHCLK_ADC     | RCC_PERIPHCLK_SWPMI1      | RCC_PERIPHCLK_DFSDM1  | RCC_PERIPHCLK_RTC      |
	         RCC_PERIPHCLK_CEC     | RCC_PERIPHCLK_FMC         | RCC_PERIPHCLK_SPDIFRX | RCC_PERIPHCLK_TIM      |
	         RCC_PERIPHCLK_CKPER;

PeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_I2C123;
24013de6:	687b      	ldr	r3, [r7, #4]
24013de8:	681b      	ldr	r3, [r3, #0]
24013dea:	f043 0208 	orr.w	r2, r3, #8
24013dee:	687b      	ldr	r3, [r7, #4]
24013df0:	601a      	str	r2, [r3, #0]
#endif /* RCC_CDCCIP1R_SAI2ASEL */
#if defined(RCC_CDCCIP1R_SAI2BSEL)
  PeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_SAI2B;
#endif /* RCC_CDCCIP1R_SAI2BSEL */
#if defined(SAI3)
  PeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_SAI23;
24013df2:	687b      	ldr	r3, [r7, #4]
24013df4:	681b      	ldr	r3, [r3, #0]
24013df6:	f443 7200 	orr.w	r2, r3, #512	; 0x200
24013dfa:	687b      	ldr	r3, [r7, #4]
24013dfc:	601a      	str	r2, [r3, #0]
#endif /* SAI3 */
#if defined(SAI4)
  PeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_SAI4A;
24013dfe:	687b      	ldr	r3, [r7, #4]
24013e00:	681b      	ldr	r3, [r3, #0]
24013e02:	f443 6280 	orr.w	r2, r3, #1024	; 0x400
24013e06:	687b      	ldr	r3, [r7, #4]
24013e08:	601a      	str	r2, [r3, #0]
  PeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_SAI4B;
24013e0a:	687b      	ldr	r3, [r7, #4]
24013e0c:	681b      	ldr	r3, [r3, #0]
24013e0e:	f443 6200 	orr.w	r2, r3, #2048	; 0x800
24013e12:	687b      	ldr	r3, [r7, #4]
24013e14:	601a      	str	r2, [r3, #0]
#endif /* SAI4 */
#if defined(DFSDM2_BASE)
  PeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_DFSDM2;
#endif /* DFSDM2 */
#if defined(QUADSPI)
  PeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_QSPI;
24013e16:	687b      	ldr	r3, [r7, #4]
24013e18:	681b      	ldr	r3, [r3, #0]
24013e1a:	f043 7200 	orr.w	r2, r3, #33554432	; 0x2000000
24013e1e:	687b      	ldr	r3, [r7, #4]
24013e20:	601a      	str	r2, [r3, #0]
#endif /* OCTOSPI1 || OCTOSPI2 */
#if defined(HRTIM)
  PeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_HRTIM1;
#endif /* HRTIM */
#if defined(LTDC)
  PeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_LTDC;
24013e22:	687b      	ldr	r3, [r7, #4]
24013e24:	681b      	ldr	r3, [r3, #0]
24013e26:	f043 5200 	orr.w	r2, r3, #536870912	; 0x20000000
24013e2a:	687b      	ldr	r3, [r7, #4]
24013e2c:	601a      	str	r2, [r3, #0]
#if defined(DSI)
  PeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_DSI;
#endif /* DSI */

  /* Get the PLL3 Clock configuration -----------------------------------------------*/
  PeriphClkInit->PLL3.PLL3M = (uint32_t)((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM3)>> RCC_PLLCKSELR_DIVM3_Pos);
24013e2e:	4b91      	ldr	r3, [pc, #580]	; (24014074 <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
24013e30:	6a9b      	ldr	r3, [r3, #40]	; 0x28
24013e32:	0d1b      	lsrs	r3, r3, #20
24013e34:	f003 023f 	and.w	r2, r3, #63	; 0x3f
24013e38:	687b      	ldr	r3, [r7, #4]
24013e3a:	625a      	str	r2, [r3, #36]	; 0x24
  PeriphClkInit->PLL3.PLL3N = (uint32_t)((RCC->PLL3DIVR & RCC_PLL3DIVR_N3) >> RCC_PLL3DIVR_N3_Pos)+ 1U;
24013e3c:	4b8d      	ldr	r3, [pc, #564]	; (24014074 <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
24013e3e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
24013e40:	f3c3 0308 	ubfx	r3, r3, #0, #9
24013e44:	1c5a      	adds	r2, r3, #1
24013e46:	687b      	ldr	r3, [r7, #4]
24013e48:	629a      	str	r2, [r3, #40]	; 0x28
  PeriphClkInit->PLL3.PLL3R = (uint32_t)((RCC->PLL3DIVR & RCC_PLL3DIVR_R3) >> RCC_PLL3DIVR_R3_Pos)+ 1U;
24013e4a:	4b8a      	ldr	r3, [pc, #552]	; (24014074 <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
24013e4c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
24013e4e:	0e1b      	lsrs	r3, r3, #24
24013e50:	f003 037f 	and.w	r3, r3, #127	; 0x7f
24013e54:	1c5a      	adds	r2, r3, #1
24013e56:	687b      	ldr	r3, [r7, #4]
24013e58:	635a      	str	r2, [r3, #52]	; 0x34
  PeriphClkInit->PLL3.PLL3P = (uint32_t)((RCC->PLL3DIVR & RCC_PLL3DIVR_P3) >> RCC_PLL3DIVR_P3_Pos)+ 1U;
24013e5a:	4b86      	ldr	r3, [pc, #536]	; (24014074 <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
24013e5c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
24013e5e:	0a5b      	lsrs	r3, r3, #9
24013e60:	f003 037f 	and.w	r3, r3, #127	; 0x7f
24013e64:	1c5a      	adds	r2, r3, #1
24013e66:	687b      	ldr	r3, [r7, #4]
24013e68:	62da      	str	r2, [r3, #44]	; 0x2c
  PeriphClkInit->PLL3.PLL3Q = (uint32_t)((RCC->PLL3DIVR & RCC_PLL3DIVR_Q3) >> RCC_PLL3DIVR_Q3_Pos)+ 1U;
24013e6a:	4b82      	ldr	r3, [pc, #520]	; (24014074 <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
24013e6c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
24013e6e:	0c1b      	lsrs	r3, r3, #16
24013e70:	f003 037f 	and.w	r3, r3, #127	; 0x7f
24013e74:	1c5a      	adds	r2, r3, #1
24013e76:	687b      	ldr	r3, [r7, #4]
24013e78:	631a      	str	r2, [r3, #48]	; 0x30
  PeriphClkInit->PLL3.PLL3RGE = (uint32_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLL3RGE) >> RCC_PLLCFGR_PLL3RGE_Pos);
24013e7a:	4b7e      	ldr	r3, [pc, #504]	; (24014074 <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
24013e7c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24013e7e:	0a9b      	lsrs	r3, r3, #10
24013e80:	f003 0203 	and.w	r2, r3, #3
24013e84:	687b      	ldr	r3, [r7, #4]
24013e86:	639a      	str	r2, [r3, #56]	; 0x38
  PeriphClkInit->PLL3.PLL3VCOSEL = (uint32_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLL3VCOSEL) >> RCC_PLLCFGR_PLL3VCOSEL_Pos);
24013e88:	4b7a      	ldr	r3, [pc, #488]	; (24014074 <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
24013e8a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24013e8c:	0a5b      	lsrs	r3, r3, #9
24013e8e:	f003 0201 	and.w	r2, r3, #1
24013e92:	687b      	ldr	r3, [r7, #4]
24013e94:	63da      	str	r2, [r3, #60]	; 0x3c

  /* Get the PLL2 Clock configuration -----------------------------------------------*/
  PeriphClkInit->PLL2.PLL2M = (uint32_t)((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM2)>> RCC_PLLCKSELR_DIVM2_Pos);
24013e96:	4b77      	ldr	r3, [pc, #476]	; (24014074 <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
24013e98:	6a9b      	ldr	r3, [r3, #40]	; 0x28
24013e9a:	0b1b      	lsrs	r3, r3, #12
24013e9c:	f003 023f 	and.w	r2, r3, #63	; 0x3f
24013ea0:	687b      	ldr	r3, [r7, #4]
24013ea2:	605a      	str	r2, [r3, #4]
  PeriphClkInit->PLL2.PLL2N = (uint32_t)((RCC->PLL2DIVR & RCC_PLL2DIVR_N2) >> RCC_PLL2DIVR_N2_Pos)+ 1U;
24013ea4:	4b73      	ldr	r3, [pc, #460]	; (24014074 <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
24013ea6:	6b9b      	ldr	r3, [r3, #56]	; 0x38
24013ea8:	f3c3 0308 	ubfx	r3, r3, #0, #9
24013eac:	1c5a      	adds	r2, r3, #1
24013eae:	687b      	ldr	r3, [r7, #4]
24013eb0:	609a      	str	r2, [r3, #8]
  PeriphClkInit->PLL2.PLL2R = (uint32_t)((RCC->PLL2DIVR & RCC_PLL2DIVR_R2) >> RCC_PLL2DIVR_R2_Pos)+ 1U;
24013eb2:	4b70      	ldr	r3, [pc, #448]	; (24014074 <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
24013eb4:	6b9b      	ldr	r3, [r3, #56]	; 0x38
24013eb6:	0e1b      	lsrs	r3, r3, #24
24013eb8:	f003 037f 	and.w	r3, r3, #127	; 0x7f
24013ebc:	1c5a      	adds	r2, r3, #1
24013ebe:	687b      	ldr	r3, [r7, #4]
24013ec0:	615a      	str	r2, [r3, #20]
  PeriphClkInit->PLL2.PLL2P = (uint32_t)((RCC->PLL2DIVR & RCC_PLL2DIVR_P2) >> RCC_PLL2DIVR_P2_Pos)+ 1U;
24013ec2:	4b6c      	ldr	r3, [pc, #432]	; (24014074 <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
24013ec4:	6b9b      	ldr	r3, [r3, #56]	; 0x38
24013ec6:	0a5b      	lsrs	r3, r3, #9
24013ec8:	f003 037f 	and.w	r3, r3, #127	; 0x7f
24013ecc:	1c5a      	adds	r2, r3, #1
24013ece:	687b      	ldr	r3, [r7, #4]
24013ed0:	60da      	str	r2, [r3, #12]
  PeriphClkInit->PLL2.PLL2Q = (uint32_t)((RCC->PLL2DIVR & RCC_PLL2DIVR_Q2) >> RCC_PLL2DIVR_Q2_Pos)+ 1U;
24013ed2:	4b68      	ldr	r3, [pc, #416]	; (24014074 <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
24013ed4:	6b9b      	ldr	r3, [r3, #56]	; 0x38
24013ed6:	0c1b      	lsrs	r3, r3, #16
24013ed8:	f003 037f 	and.w	r3, r3, #127	; 0x7f
24013edc:	1c5a      	adds	r2, r3, #1
24013ede:	687b      	ldr	r3, [r7, #4]
24013ee0:	611a      	str	r2, [r3, #16]
  PeriphClkInit->PLL2.PLL2RGE = (uint32_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLL2RGE) >> RCC_PLLCFGR_PLL2RGE_Pos);
24013ee2:	4b64      	ldr	r3, [pc, #400]	; (24014074 <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
24013ee4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24013ee6:	099b      	lsrs	r3, r3, #6
24013ee8:	f003 0203 	and.w	r2, r3, #3
24013eec:	687b      	ldr	r3, [r7, #4]
24013eee:	619a      	str	r2, [r3, #24]
  PeriphClkInit->PLL2.PLL2VCOSEL = (uint32_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLL2VCOSEL) >> RCC_PLLCFGR_PLL2VCOSEL_Pos);
24013ef0:	4b60      	ldr	r3, [pc, #384]	; (24014074 <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
24013ef2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24013ef4:	095b      	lsrs	r3, r3, #5
24013ef6:	f003 0201 	and.w	r2, r3, #1
24013efa:	687b      	ldr	r3, [r7, #4]
24013efc:	61da      	str	r2, [r3, #28]

  /* Get the USART1 configuration --------------------------------------------*/
  PeriphClkInit->Usart16ClockSelection      = __HAL_RCC_GET_USART16_SOURCE();
24013efe:	4b5d      	ldr	r3, [pc, #372]	; (24014074 <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
24013f00:	6d5b      	ldr	r3, [r3, #84]	; 0x54
24013f02:	f003 0238 	and.w	r2, r3, #56	; 0x38
24013f06:	687b      	ldr	r3, [r7, #4]
24013f08:	679a      	str	r2, [r3, #120]	; 0x78
  /* Get the USART2/3/4/5/7/8 clock source -----------------------------------*/
  PeriphClkInit->Usart234578ClockSelection  = __HAL_RCC_GET_USART234578_SOURCE();
24013f0a:	4b5a      	ldr	r3, [pc, #360]	; (24014074 <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
24013f0c:	6d5b      	ldr	r3, [r3, #84]	; 0x54
24013f0e:	f003 0207 	and.w	r2, r3, #7
24013f12:	687b      	ldr	r3, [r7, #4]
24013f14:	675a      	str	r2, [r3, #116]	; 0x74
  /* Get the LPUART1 clock source --------------------------------------------*/
  PeriphClkInit->Lpuart1ClockSelection      = __HAL_RCC_GET_LPUART1_SOURCE();
24013f16:	4b57      	ldr	r3, [pc, #348]	; (24014074 <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
24013f18:	6d9b      	ldr	r3, [r3, #88]	; 0x58
24013f1a:	f003 0207 	and.w	r2, r3, #7
24013f1e:	687b      	ldr	r3, [r7, #4]
24013f20:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
  /* Get the I2C1/2/3 clock source -------------------------------------------*/
  PeriphClkInit->I2c123ClockSelection       = __HAL_RCC_GET_I2C1_SOURCE();
24013f24:	4b53      	ldr	r3, [pc, #332]	; (24014074 <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
24013f26:	6d5b      	ldr	r3, [r3, #84]	; 0x54
24013f28:	f403 5240 	and.w	r2, r3, #12288	; 0x3000
24013f2c:	687b      	ldr	r3, [r7, #4]
24013f2e:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
  /* Get the LPTIM1 clock source ---------------------------------------------*/
  PeriphClkInit->Lptim1ClockSelection       = __HAL_RCC_GET_LPTIM1_SOURCE();
24013f32:	4b50      	ldr	r3, [pc, #320]	; (24014074 <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
24013f34:	6d5b      	ldr	r3, [r3, #84]	; 0x54
24013f36:	f003 42e0 	and.w	r2, r3, #1879048192	; 0x70000000
24013f3a:	687b      	ldr	r3, [r7, #4]
24013f3c:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
  /* Get the LPTIM2 clock source ---------------------------------------------*/
  PeriphClkInit->Lptim2ClockSelection       = __HAL_RCC_GET_LPTIM2_SOURCE();
24013f40:	4b4c      	ldr	r3, [pc, #304]	; (24014074 <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
24013f42:	6d9b      	ldr	r3, [r3, #88]	; 0x58
24013f44:	f403 52e0 	and.w	r2, r3, #7168	; 0x1c00
24013f48:	687b      	ldr	r3, [r7, #4]
24013f4a:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
  /* Get the LPTIM3/4/5 clock source -----------------------------------------*/
  PeriphClkInit->Lptim345ClockSelection     = __HAL_RCC_GET_LPTIM345_SOURCE();
24013f4e:	4b49      	ldr	r3, [pc, #292]	; (24014074 <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
24013f50:	6d9b      	ldr	r3, [r3, #88]	; 0x58
24013f52:	f403 4260 	and.w	r2, r3, #57344	; 0xe000
24013f56:	687b      	ldr	r3, [r7, #4]
24013f58:	f8c3 209c 	str.w	r2, [r3, #156]	; 0x9c
  /* Get the SAI1 clock source -----------------------------------------------*/
  PeriphClkInit->Sai1ClockSelection         = __HAL_RCC_GET_SAI1_SOURCE();
24013f5c:	4b45      	ldr	r3, [pc, #276]	; (24014074 <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
24013f5e:	6d1b      	ldr	r3, [r3, #80]	; 0x50
24013f60:	f003 0207 	and.w	r2, r3, #7
24013f64:	687b      	ldr	r3, [r7, #4]
24013f66:	655a      	str	r2, [r3, #84]	; 0x54
#if defined(SAI3)
  /* Get the SAI2/3 clock source ---------------------------------------------*/
  PeriphClkInit->Sai23ClockSelection        = __HAL_RCC_GET_SAI23_SOURCE();
24013f68:	4b42      	ldr	r3, [pc, #264]	; (24014074 <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
24013f6a:	6d1b      	ldr	r3, [r3, #80]	; 0x50
24013f6c:	f403 72e0 	and.w	r2, r3, #448	; 0x1c0
24013f70:	687b      	ldr	r3, [r7, #4]
24013f72:	659a      	str	r2, [r3, #88]	; 0x58
  /* Get the SAI2B clock source ---------------------------------------------*/
  PeriphClkInit->Sai2BClockSelection        = __HAL_RCC_GET_SAI2B_SOURCE();
#endif  /*SAI2B*/
#if defined(SAI4)
  /* Get the SAI4A clock source ----------------------------------------------*/
  PeriphClkInit->Sai4AClockSelection        = __HAL_RCC_GET_SAI4A_SOURCE();
24013f74:	4b3f      	ldr	r3, [pc, #252]	; (24014074 <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
24013f76:	6d9b      	ldr	r3, [r3, #88]	; 0x58
24013f78:	f403 0260 	and.w	r2, r3, #14680064	; 0xe00000
24013f7c:	687b      	ldr	r3, [r7, #4]
24013f7e:	f8c3 20a4 	str.w	r2, [r3, #164]	; 0xa4
  /* Get the SAI4B clock source ----------------------------------------------*/
  PeriphClkInit->Sai4BClockSelection        = __HAL_RCC_GET_SAI4B_SOURCE();
24013f82:	4b3c      	ldr	r3, [pc, #240]	; (24014074 <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
24013f84:	6d9b      	ldr	r3, [r3, #88]	; 0x58
24013f86:	f003 62e0 	and.w	r2, r3, #117440512	; 0x7000000
24013f8a:	687b      	ldr	r3, [r7, #4]
24013f8c:	f8c3 20a8 	str.w	r2, [r3, #168]	; 0xa8
#endif  /*SAI4*/
  /* Get the RTC clock source ------------------------------------------------*/
  PeriphClkInit->RTCClockSelection          = __HAL_RCC_GET_RTC_SOURCE();
24013f90:	4b38      	ldr	r3, [pc, #224]	; (24014074 <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
24013f92:	6f1b      	ldr	r3, [r3, #112]	; 0x70
24013f94:	f403 7240 	and.w	r2, r3, #768	; 0x300
24013f98:	687b      	ldr	r3, [r7, #4]
24013f9a:	f8c3 20b0 	str.w	r2, [r3, #176]	; 0xb0
  /* Get the USB clock source ------------------------------------------------*/
  PeriphClkInit->UsbClockSelection          = __HAL_RCC_GET_USB_SOURCE();
24013f9e:	4b35      	ldr	r3, [pc, #212]	; (24014074 <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
24013fa0:	6d5b      	ldr	r3, [r3, #84]	; 0x54
24013fa2:	f403 1240 	and.w	r2, r3, #3145728	; 0x300000
24013fa6:	687b      	ldr	r3, [r7, #4]
24013fa8:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
  /* Get the SDMMC clock source ----------------------------------------------*/
  PeriphClkInit->SdmmcClockSelection        = __HAL_RCC_GET_SDMMC_SOURCE();
24013fac:	4b31      	ldr	r3, [pc, #196]	; (24014074 <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
24013fae:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
24013fb0:	f403 3280 	and.w	r2, r3, #65536	; 0x10000
24013fb4:	687b      	ldr	r3, [r7, #4]
24013fb6:	64da      	str	r2, [r3, #76]	; 0x4c
  /* Get the RNG clock source ------------------------------------------------*/
  PeriphClkInit->RngClockSelection          = __HAL_RCC_GET_RNG_SOURCE();
24013fb8:	4b2e      	ldr	r3, [pc, #184]	; (24014074 <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
24013fba:	6d5b      	ldr	r3, [r3, #84]	; 0x54
24013fbc:	f403 7240 	and.w	r2, r3, #768	; 0x300
24013fc0:	687b      	ldr	r3, [r7, #4]
24013fc2:	67da      	str	r2, [r3, #124]	; 0x7c
#if defined(HRTIM1)
  /* Get the HRTIM1 clock source ---------------------------------------------*/
  PeriphClkInit->Hrtim1ClockSelection       = __HAL_RCC_GET_HRTIM1_SOURCE();
24013fc4:	4b2b      	ldr	r3, [pc, #172]	; (24014074 <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
24013fc6:	691b      	ldr	r3, [r3, #16]
24013fc8:	f403 4280 	and.w	r2, r3, #16384	; 0x4000
24013fcc:	687b      	ldr	r3, [r7, #4]
24013fce:	f8c3 20b4 	str.w	r2, [r3, #180]	; 0xb4
#endif /* HRTIM1 */
  /* Get the ADC clock source ------------------------------------------------*/
  PeriphClkInit->AdcClockSelection          = __HAL_RCC_GET_ADC_SOURCE();
24013fd2:	4b28      	ldr	r3, [pc, #160]	; (24014074 <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
24013fd4:	6d9b      	ldr	r3, [r3, #88]	; 0x58
24013fd6:	f403 3240 	and.w	r2, r3, #196608	; 0x30000
24013fda:	687b      	ldr	r3, [r7, #4]
24013fdc:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
  /* Get the SWPMI1 clock source ---------------------------------------------*/
  PeriphClkInit->Swpmi1ClockSelection       = __HAL_RCC_GET_SWPMI1_SOURCE();
24013fe0:	4b24      	ldr	r3, [pc, #144]	; (24014074 <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
24013fe2:	6d1b      	ldr	r3, [r3, #80]	; 0x50
24013fe4:	f003 4200 	and.w	r2, r3, #2147483648	; 0x80000000
24013fe8:	687b      	ldr	r3, [r7, #4]
24013fea:	671a      	str	r2, [r3, #112]	; 0x70
  /* Get the DFSDM1 clock source ---------------------------------------------*/
  PeriphClkInit->Dfsdm1ClockSelection       = __HAL_RCC_GET_DFSDM1_SOURCE();
24013fec:	4b21      	ldr	r3, [pc, #132]	; (24014074 <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
24013fee:	6d1b      	ldr	r3, [r3, #80]	; 0x50
24013ff0:	f003 7280 	and.w	r2, r3, #16777216	; 0x1000000
24013ff4:	687b      	ldr	r3, [r7, #4]
24013ff6:	669a      	str	r2, [r3, #104]	; 0x68
#if defined(DFSDM2_BASE)
  /* Get the DFSDM2 clock source ---------------------------------------------*/
  PeriphClkInit->Dfsdm2ClockSelection       = __HAL_RCC_GET_DFSDM2_SOURCE();
#endif /* DFSDM2 */
  /* Get the SPDIFRX clock source --------------------------------------------*/
  PeriphClkInit->SpdifrxClockSelection      = __HAL_RCC_GET_SPDIFRX_SOURCE();
24013ff8:	4b1e      	ldr	r3, [pc, #120]	; (24014074 <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
24013ffa:	6d1b      	ldr	r3, [r3, #80]	; 0x50
24013ffc:	f403 1240 	and.w	r2, r3, #3145728	; 0x300000
24014000:	687b      	ldr	r3, [r7, #4]
24014002:	665a      	str	r2, [r3, #100]	; 0x64
  /* Get the SPI1/2/3 clock source -------------------------------------------*/
  PeriphClkInit->Spi123ClockSelection       = __HAL_RCC_GET_SPI123_SOURCE();
24014004:	4b1b      	ldr	r3, [pc, #108]	; (24014074 <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
24014006:	6d1b      	ldr	r3, [r3, #80]	; 0x50
24014008:	f403 42e0 	and.w	r2, r3, #28672	; 0x7000
2401400c:	687b      	ldr	r3, [r7, #4]
2401400e:	65da      	str	r2, [r3, #92]	; 0x5c
  /* Get the SPI4/5 clock source ---------------------------------------------*/
  PeriphClkInit->Spi45ClockSelection        = __HAL_RCC_GET_SPI45_SOURCE();
24014010:	4b18      	ldr	r3, [pc, #96]	; (24014074 <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
24014012:	6d1b      	ldr	r3, [r3, #80]	; 0x50
24014014:	f403 22e0 	and.w	r2, r3, #458752	; 0x70000
24014018:	687b      	ldr	r3, [r7, #4]
2401401a:	661a      	str	r2, [r3, #96]	; 0x60
  /* Get the SPI6 clock source -----------------------------------------------*/
  PeriphClkInit->Spi6ClockSelection         = __HAL_RCC_GET_SPI6_SOURCE();
2401401c:	4b15      	ldr	r3, [pc, #84]	; (24014074 <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
2401401e:	6d9b      	ldr	r3, [r3, #88]	; 0x58
24014020:	f003 42e0 	and.w	r2, r3, #1879048192	; 0x70000000
24014024:	687b      	ldr	r3, [r7, #4]
24014026:	f8c3 20ac 	str.w	r2, [r3, #172]	; 0xac
  /* Get the FDCAN clock source ----------------------------------------------*/
  PeriphClkInit->FdcanClockSelection        = __HAL_RCC_GET_FDCAN_SOURCE();
2401402a:	4b12      	ldr	r3, [pc, #72]	; (24014074 <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
2401402c:	6d1b      	ldr	r3, [r3, #80]	; 0x50
2401402e:	f003 5240 	and.w	r2, r3, #805306368	; 0x30000000
24014032:	687b      	ldr	r3, [r7, #4]
24014034:	66da      	str	r2, [r3, #108]	; 0x6c
  /* Get the CEC clock source ------------------------------------------------*/
  PeriphClkInit->CecClockSelection          = __HAL_RCC_GET_CEC_SOURCE();
24014036:	4b0f      	ldr	r3, [pc, #60]	; (24014074 <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
24014038:	6d5b      	ldr	r3, [r3, #84]	; 0x54
2401403a:	f403 0240 	and.w	r2, r3, #12582912	; 0xc00000
2401403e:	687b      	ldr	r3, [r7, #4]
24014040:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
  /* Get the FMC clock source ------------------------------------------------*/
  PeriphClkInit->FmcClockSelection          = __HAL_RCC_GET_FMC_SOURCE();
24014044:	4b0b      	ldr	r3, [pc, #44]	; (24014074 <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
24014046:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
24014048:	f003 0203 	and.w	r2, r3, #3
2401404c:	687b      	ldr	r3, [r7, #4]
2401404e:	645a      	str	r2, [r3, #68]	; 0x44
#if defined(QUADSPI)
  /* Get the QSPI clock source -----------------------------------------------*/
  PeriphClkInit->QspiClockSelection         = __HAL_RCC_GET_QSPI_SOURCE();
24014050:	4b08      	ldr	r3, [pc, #32]	; (24014074 <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
24014052:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
24014054:	f003 0230 	and.w	r2, r3, #48	; 0x30
24014058:	687b      	ldr	r3, [r7, #4]
2401405a:	649a      	str	r2, [r3, #72]	; 0x48
  /* Get the DSI clock source ------------------------------------------------*/
  PeriphClkInit->DsiClockSelection          = __HAL_RCC_GET_DSI_SOURCE();
#endif /*DSI*/

  /* Get the CKPER clock source ----------------------------------------------*/
  PeriphClkInit->CkperClockSelection        = __HAL_RCC_GET_CLKP_SOURCE();
2401405c:	4b05      	ldr	r3, [pc, #20]	; (24014074 <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
2401405e:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
24014060:	f003 5240 	and.w	r2, r3, #805306368	; 0x30000000
24014064:	687b      	ldr	r3, [r7, #4]
24014066:	651a      	str	r2, [r3, #80]	; 0x50

  /* Get the TIM Prescaler configuration -------------------------------------*/
  if ((RCC->CFGR & RCC_CFGR_TIMPRE) == 0U)
24014068:	4b02      	ldr	r3, [pc, #8]	; (24014074 <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
2401406a:	691b      	ldr	r3, [r3, #16]
2401406c:	e004      	b.n	24014078 <HAL_RCCEx_GetPeriphCLKConfig+0x2a0>
2401406e:	bf00      	nop
24014070:	c9fff1f7 	.word	0xc9fff1f7
24014074:	58024400 	.word	0x58024400
24014078:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
2401407c:	2b00      	cmp	r3, #0
2401407e:	d104      	bne.n	2401408a <HAL_RCCEx_GetPeriphCLKConfig+0x2b2>
  {
    PeriphClkInit->TIMPresSelection = RCC_TIMPRES_DESACTIVATED;
24014080:	687b      	ldr	r3, [r7, #4]
24014082:	2200      	movs	r2, #0
24014084:	f8c3 20b8 	str.w	r2, [r3, #184]	; 0xb8
  }
  else
  {
    PeriphClkInit->TIMPresSelection = RCC_TIMPRES_ACTIVATED;
  }
}
24014088:	e004      	b.n	24014094 <HAL_RCCEx_GetPeriphCLKConfig+0x2bc>
    PeriphClkInit->TIMPresSelection = RCC_TIMPRES_ACTIVATED;
2401408a:	687b      	ldr	r3, [r7, #4]
2401408c:	f44f 4200 	mov.w	r2, #32768	; 0x8000
24014090:	f8c3 20b8 	str.w	r2, [r3, #184]	; 0xb8
}
24014094:	bf00      	nop
24014096:	370c      	adds	r7, #12
24014098:	46bd      	mov	sp, r7
2401409a:	f85d 7b04 	ldr.w	r7, [sp], #4
2401409e:	4770      	bx	lr

240140a0 <HAL_RCCEx_GetPeriphCLKFreq>:
  * @retval Frequency in KHz
  *
  *  (*) : Available on some STM32H7 lines only.
  */
uint32_t HAL_RCCEx_GetPeriphCLKFreq(uint32_t PeriphClk)
{
240140a0:	b580      	push	{r7, lr}
240140a2:	b090      	sub	sp, #64	; 0x40
240140a4:	af00      	add	r7, sp, #0
240140a6:	6078      	str	r0, [r7, #4]
  /* This variable is used to store the SAI and CKP clock source */
  uint32_t saiclocksource;
  uint32_t ckpclocksource;
  uint32_t srcclk;

  if (PeriphClk == RCC_PERIPHCLK_SAI1)
240140a8:	687b      	ldr	r3, [r7, #4]
240140aa:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
240140ae:	d150      	bne.n	24014152 <HAL_RCCEx_GetPeriphCLKFreq+0xb2>
    {

      saiclocksource= __HAL_RCC_GET_SAI1_SOURCE();
240140b0:	4ba1      	ldr	r3, [pc, #644]	; (24014338 <HAL_RCCEx_GetPeriphCLKFreq+0x298>)
240140b2:	6d1b      	ldr	r3, [r3, #80]	; 0x50
240140b4:	f003 0307 	and.w	r3, r3, #7
240140b8:	633b      	str	r3, [r7, #48]	; 0x30

      switch (saiclocksource)
240140ba:	6b3b      	ldr	r3, [r7, #48]	; 0x30
240140bc:	2b04      	cmp	r3, #4
240140be:	d844      	bhi.n	2401414a <HAL_RCCEx_GetPeriphCLKFreq+0xaa>
240140c0:	a201      	add	r2, pc, #4	; (adr r2, 240140c8 <HAL_RCCEx_GetPeriphCLKFreq+0x28>)
240140c2:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
240140c6:	bf00      	nop
240140c8:	240140dd 	.word	0x240140dd
240140cc:	240140ed 	.word	0x240140ed
240140d0:	240140fd 	.word	0x240140fd
240140d4:	24014145 	.word	0x24014145
240140d8:	2401410d 	.word	0x2401410d
      {
      case RCC_SAI1CLKSOURCE_PLL: /* PLL1 is the clock source for SAI1 */
        {
          HAL_RCCEx_GetPLL1ClockFreq(&pll1_clocks);
240140dc:	f107 0324 	add.w	r3, r7, #36	; 0x24
240140e0:	4618      	mov	r0, r3
240140e2:	f000 fd19 	bl	24014b18 <HAL_RCCEx_GetPLL1ClockFreq>
          frequency = pll1_clocks.PLL1_Q_Frequency;
240140e6:	6abb      	ldr	r3, [r7, #40]	; 0x28
240140e8:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
240140ea:	e241      	b.n	24014570 <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
        }
      case RCC_SAI1CLKSOURCE_PLL2: /* PLL2 is the clock source for SAI1 */
        {
          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
240140ec:	f107 0318 	add.w	r3, r7, #24
240140f0:	4618      	mov	r0, r3
240140f2:	f000 fa79 	bl	240145e8 <HAL_RCCEx_GetPLL2ClockFreq>
          frequency = pll2_clocks.PLL2_P_Frequency;
240140f6:	69bb      	ldr	r3, [r7, #24]
240140f8:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
240140fa:	e239      	b.n	24014570 <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
        }

      case RCC_SAI1CLKSOURCE_PLL3: /* PLL3 is the clock source for SAI1 */
        {
          HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
240140fc:	f107 030c 	add.w	r3, r7, #12
24014100:	4618      	mov	r0, r3
24014102:	f000 fbbd 	bl	24014880 <HAL_RCCEx_GetPLL3ClockFreq>
          frequency = pll3_clocks.PLL3_P_Frequency;
24014106:	68fb      	ldr	r3, [r7, #12]
24014108:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
2401410a:	e231      	b.n	24014570 <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
        }

      case RCC_SAI1CLKSOURCE_CLKP: /* CKPER is the clock source for SAI1*/
        {

          ckpclocksource= __HAL_RCC_GET_CLKP_SOURCE();
2401410c:	4b8a      	ldr	r3, [pc, #552]	; (24014338 <HAL_RCCEx_GetPeriphCLKFreq+0x298>)
2401410e:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
24014110:	f003 5340 	and.w	r3, r3, #805306368	; 0x30000000
24014114:	637b      	str	r3, [r7, #52]	; 0x34

          if(ckpclocksource== RCC_CLKPSOURCE_HSI)
24014116:	6b7b      	ldr	r3, [r7, #52]	; 0x34
24014118:	2b00      	cmp	r3, #0
2401411a:	d102      	bne.n	24014122 <HAL_RCCEx_GetPeriphCLKFreq+0x82>
          {
            /* In Case the CKPER Source is HSI */
            frequency = HSI_VALUE;
2401411c:	4b87      	ldr	r3, [pc, #540]	; (2401433c <HAL_RCCEx_GetPeriphCLKFreq+0x29c>)
2401411e:	63fb      	str	r3, [r7, #60]	; 0x3c
          {
            /* In Case the CKPER is disabled*/
            frequency = 0;
          }

          break;
24014120:	e226      	b.n	24014570 <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
          else if(ckpclocksource== RCC_CLKPSOURCE_CSI)
24014122:	6b7b      	ldr	r3, [r7, #52]	; 0x34
24014124:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
24014128:	d102      	bne.n	24014130 <HAL_RCCEx_GetPeriphCLKFreq+0x90>
            frequency = CSI_VALUE;
2401412a:	4b85      	ldr	r3, [pc, #532]	; (24014340 <HAL_RCCEx_GetPeriphCLKFreq+0x2a0>)
2401412c:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
2401412e:	e21f      	b.n	24014570 <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
          else if (ckpclocksource== RCC_CLKPSOURCE_HSE)
24014130:	6b7b      	ldr	r3, [r7, #52]	; 0x34
24014132:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
24014136:	d102      	bne.n	2401413e <HAL_RCCEx_GetPeriphCLKFreq+0x9e>
            frequency = HSE_VALUE;
24014138:	4b82      	ldr	r3, [pc, #520]	; (24014344 <HAL_RCCEx_GetPeriphCLKFreq+0x2a4>)
2401413a:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
2401413c:	e218      	b.n	24014570 <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
            frequency = 0;
2401413e:	2300      	movs	r3, #0
24014140:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
24014142:	e215      	b.n	24014570 <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
        }

      case (RCC_SAI1CLKSOURCE_PIN): /* External clock is the clock source for SAI1 */
        {
          frequency = EXTERNAL_CLOCK_VALUE;
24014144:	4b80      	ldr	r3, [pc, #512]	; (24014348 <HAL_RCCEx_GetPeriphCLKFreq+0x2a8>)
24014146:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
24014148:	e212      	b.n	24014570 <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
        }
      default :
        {
          frequency = 0;
2401414a:	2300      	movs	r3, #0
2401414c:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
2401414e:	bf00      	nop
24014150:	e20e      	b.n	24014570 <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
        }
      }
    }

#if defined(SAI3)
  else if (PeriphClk == RCC_PERIPHCLK_SAI23)
24014152:	687b      	ldr	r3, [r7, #4]
24014154:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
24014158:	d14f      	bne.n	240141fa <HAL_RCCEx_GetPeriphCLKFreq+0x15a>
    {

      saiclocksource= __HAL_RCC_GET_SAI23_SOURCE();
2401415a:	4b77      	ldr	r3, [pc, #476]	; (24014338 <HAL_RCCEx_GetPeriphCLKFreq+0x298>)
2401415c:	6d1b      	ldr	r3, [r3, #80]	; 0x50
2401415e:	f403 73e0 	and.w	r3, r3, #448	; 0x1c0
24014162:	633b      	str	r3, [r7, #48]	; 0x30

      switch (saiclocksource)
24014164:	6b3b      	ldr	r3, [r7, #48]	; 0x30
24014166:	2b80      	cmp	r3, #128	; 0x80
24014168:	d01c      	beq.n	240141a4 <HAL_RCCEx_GetPeriphCLKFreq+0x104>
2401416a:	2b80      	cmp	r3, #128	; 0x80
2401416c:	d804      	bhi.n	24014178 <HAL_RCCEx_GetPeriphCLKFreq+0xd8>
2401416e:	2b00      	cmp	r3, #0
24014170:	d008      	beq.n	24014184 <HAL_RCCEx_GetPeriphCLKFreq+0xe4>
24014172:	2b40      	cmp	r3, #64	; 0x40
24014174:	d00e      	beq.n	24014194 <HAL_RCCEx_GetPeriphCLKFreq+0xf4>
24014176:	e03c      	b.n	240141f2 <HAL_RCCEx_GetPeriphCLKFreq+0x152>
24014178:	2bc0      	cmp	r3, #192	; 0xc0
2401417a:	d037      	beq.n	240141ec <HAL_RCCEx_GetPeriphCLKFreq+0x14c>
2401417c:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
24014180:	d018      	beq.n	240141b4 <HAL_RCCEx_GetPeriphCLKFreq+0x114>
24014182:	e036      	b.n	240141f2 <HAL_RCCEx_GetPeriphCLKFreq+0x152>
      {
      case 0: /* PLL1 is the clock source for SAI2/3 */
        {
          HAL_RCCEx_GetPLL1ClockFreq(&pll1_clocks);
24014184:	f107 0324 	add.w	r3, r7, #36	; 0x24
24014188:	4618      	mov	r0, r3
2401418a:	f000 fcc5 	bl	24014b18 <HAL_RCCEx_GetPLL1ClockFreq>
          frequency = pll1_clocks.PLL1_Q_Frequency;
2401418e:	6abb      	ldr	r3, [r7, #40]	; 0x28
24014190:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
24014192:	e1ed      	b.n	24014570 <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
        }
      case RCC_SAI23CLKSOURCE_PLL2: /* PLL2 is the clock source for SAI2/3 */
        {
          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
24014194:	f107 0318 	add.w	r3, r7, #24
24014198:	4618      	mov	r0, r3
2401419a:	f000 fa25 	bl	240145e8 <HAL_RCCEx_GetPLL2ClockFreq>
          frequency = pll2_clocks.PLL2_P_Frequency;
2401419e:	69bb      	ldr	r3, [r7, #24]
240141a0:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
240141a2:	e1e5      	b.n	24014570 <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
        }

      case RCC_SAI23CLKSOURCE_PLL3: /* PLL3 is the clock source for SAI2/3 */
        {
          HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
240141a4:	f107 030c 	add.w	r3, r7, #12
240141a8:	4618      	mov	r0, r3
240141aa:	f000 fb69 	bl	24014880 <HAL_RCCEx_GetPLL3ClockFreq>
          frequency = pll3_clocks.PLL3_P_Frequency;
240141ae:	68fb      	ldr	r3, [r7, #12]
240141b0:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
240141b2:	e1dd      	b.n	24014570 <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
        }

      case RCC_SAI23CLKSOURCE_CLKP: /* CKPER is the clock source for SAI2/3 */
        {

          ckpclocksource= __HAL_RCC_GET_CLKP_SOURCE();
240141b4:	4b60      	ldr	r3, [pc, #384]	; (24014338 <HAL_RCCEx_GetPeriphCLKFreq+0x298>)
240141b6:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
240141b8:	f003 5340 	and.w	r3, r3, #805306368	; 0x30000000
240141bc:	637b      	str	r3, [r7, #52]	; 0x34

          if(ckpclocksource== RCC_CLKPSOURCE_HSI)
240141be:	6b7b      	ldr	r3, [r7, #52]	; 0x34
240141c0:	2b00      	cmp	r3, #0
240141c2:	d102      	bne.n	240141ca <HAL_RCCEx_GetPeriphCLKFreq+0x12a>
          {
            /* In Case the CKPER Source is HSI */
            frequency = HSI_VALUE;
240141c4:	4b5d      	ldr	r3, [pc, #372]	; (2401433c <HAL_RCCEx_GetPeriphCLKFreq+0x29c>)
240141c6:	63fb      	str	r3, [r7, #60]	; 0x3c
          {
            /* In Case the CKPER is disabled*/
            frequency = 0;
          }

          break;
240141c8:	e1d2      	b.n	24014570 <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
          else if(ckpclocksource== RCC_CLKPSOURCE_CSI)
240141ca:	6b7b      	ldr	r3, [r7, #52]	; 0x34
240141cc:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
240141d0:	d102      	bne.n	240141d8 <HAL_RCCEx_GetPeriphCLKFreq+0x138>
            frequency = CSI_VALUE;
240141d2:	4b5b      	ldr	r3, [pc, #364]	; (24014340 <HAL_RCCEx_GetPeriphCLKFreq+0x2a0>)
240141d4:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
240141d6:	e1cb      	b.n	24014570 <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
          else if (ckpclocksource== RCC_CLKPSOURCE_HSE)
240141d8:	6b7b      	ldr	r3, [r7, #52]	; 0x34
240141da:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
240141de:	d102      	bne.n	240141e6 <HAL_RCCEx_GetPeriphCLKFreq+0x146>
            frequency = HSE_VALUE;
240141e0:	4b58      	ldr	r3, [pc, #352]	; (24014344 <HAL_RCCEx_GetPeriphCLKFreq+0x2a4>)
240141e2:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
240141e4:	e1c4      	b.n	24014570 <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
            frequency = 0;
240141e6:	2300      	movs	r3, #0
240141e8:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
240141ea:	e1c1      	b.n	24014570 <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
        }

      case (RCC_SAI23CLKSOURCE_PIN): /* External clock is the clock source for SAI2/3 */
        {
          frequency = EXTERNAL_CLOCK_VALUE;
240141ec:	4b56      	ldr	r3, [pc, #344]	; (24014348 <HAL_RCCEx_GetPeriphCLKFreq+0x2a8>)
240141ee:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
240141f0:	e1be      	b.n	24014570 <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
        }
      default :
        {
          frequency = 0;
240141f2:	2300      	movs	r3, #0
240141f4:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
240141f6:	bf00      	nop
240141f8:	e1ba      	b.n	24014570 <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
      }
    }
#endif

#if defined(SAI4)
  else if (PeriphClk == RCC_PERIPHCLK_SAI4A)
240141fa:	687b      	ldr	r3, [r7, #4]
240141fc:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
24014200:	d153      	bne.n	240142aa <HAL_RCCEx_GetPeriphCLKFreq+0x20a>
    {

      saiclocksource= __HAL_RCC_GET_SAI4A_SOURCE();
24014202:	4b4d      	ldr	r3, [pc, #308]	; (24014338 <HAL_RCCEx_GetPeriphCLKFreq+0x298>)
24014204:	6d9b      	ldr	r3, [r3, #88]	; 0x58
24014206:	f403 0360 	and.w	r3, r3, #14680064	; 0xe00000
2401420a:	633b      	str	r3, [r7, #48]	; 0x30

      switch (saiclocksource)
2401420c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
2401420e:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
24014212:	d01f      	beq.n	24014254 <HAL_RCCEx_GetPeriphCLKFreq+0x1b4>
24014214:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
24014218:	d805      	bhi.n	24014226 <HAL_RCCEx_GetPeriphCLKFreq+0x186>
2401421a:	2b00      	cmp	r3, #0
2401421c:	d00a      	beq.n	24014234 <HAL_RCCEx_GetPeriphCLKFreq+0x194>
2401421e:	f5b3 1f00 	cmp.w	r3, #2097152	; 0x200000
24014222:	d00f      	beq.n	24014244 <HAL_RCCEx_GetPeriphCLKFreq+0x1a4>
24014224:	e03d      	b.n	240142a2 <HAL_RCCEx_GetPeriphCLKFreq+0x202>
24014226:	f5b3 0fc0 	cmp.w	r3, #6291456	; 0x600000
2401422a:	d037      	beq.n	2401429c <HAL_RCCEx_GetPeriphCLKFreq+0x1fc>
2401422c:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
24014230:	d018      	beq.n	24014264 <HAL_RCCEx_GetPeriphCLKFreq+0x1c4>
24014232:	e036      	b.n	240142a2 <HAL_RCCEx_GetPeriphCLKFreq+0x202>
      {
      case 0: /* PLL1 is the clock source for SAI4A */
        {
          HAL_RCCEx_GetPLL1ClockFreq(&pll1_clocks);
24014234:	f107 0324 	add.w	r3, r7, #36	; 0x24
24014238:	4618      	mov	r0, r3
2401423a:	f000 fc6d 	bl	24014b18 <HAL_RCCEx_GetPLL1ClockFreq>
          frequency = pll1_clocks.PLL1_Q_Frequency;
2401423e:	6abb      	ldr	r3, [r7, #40]	; 0x28
24014240:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
24014242:	e195      	b.n	24014570 <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
        }
      case RCC_D3CCIPR_SAI4ASEL_0: /* PLLI2 is the clock source for SAI4A */
        {
          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
24014244:	f107 0318 	add.w	r3, r7, #24
24014248:	4618      	mov	r0, r3
2401424a:	f000 f9cd 	bl	240145e8 <HAL_RCCEx_GetPLL2ClockFreq>
          frequency = pll2_clocks.PLL2_P_Frequency;
2401424e:	69bb      	ldr	r3, [r7, #24]
24014250:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
24014252:	e18d      	b.n	24014570 <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
        }

      case RCC_D3CCIPR_SAI4ASEL_1: /* PLLI3 is the clock source for SAI4A */
        {
          HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
24014254:	f107 030c 	add.w	r3, r7, #12
24014258:	4618      	mov	r0, r3
2401425a:	f000 fb11 	bl	24014880 <HAL_RCCEx_GetPLL3ClockFreq>
          frequency = pll3_clocks.PLL3_P_Frequency;
2401425e:	68fb      	ldr	r3, [r7, #12]
24014260:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
24014262:	e185      	b.n	24014570 <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
        }

      case RCC_D3CCIPR_SAI4ASEL_2: /* CKPER is the clock source for SAI4A*/
        {

          ckpclocksource= __HAL_RCC_GET_CLKP_SOURCE();
24014264:	4b34      	ldr	r3, [pc, #208]	; (24014338 <HAL_RCCEx_GetPeriphCLKFreq+0x298>)
24014266:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
24014268:	f003 5340 	and.w	r3, r3, #805306368	; 0x30000000
2401426c:	637b      	str	r3, [r7, #52]	; 0x34

          if(ckpclocksource== RCC_CLKPSOURCE_HSI)
2401426e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
24014270:	2b00      	cmp	r3, #0
24014272:	d102      	bne.n	2401427a <HAL_RCCEx_GetPeriphCLKFreq+0x1da>
          {
            /* In Case the CKPER Source is HSI */
            frequency = HSI_VALUE;
24014274:	4b31      	ldr	r3, [pc, #196]	; (2401433c <HAL_RCCEx_GetPeriphCLKFreq+0x29c>)
24014276:	63fb      	str	r3, [r7, #60]	; 0x3c
          {
            /* In Case the CKPER is disabled*/
            frequency = 0;
          }

          break;
24014278:	e17a      	b.n	24014570 <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
          else if(ckpclocksource== RCC_CLKPSOURCE_CSI)
2401427a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
2401427c:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
24014280:	d102      	bne.n	24014288 <HAL_RCCEx_GetPeriphCLKFreq+0x1e8>
            frequency = CSI_VALUE;
24014282:	4b2f      	ldr	r3, [pc, #188]	; (24014340 <HAL_RCCEx_GetPeriphCLKFreq+0x2a0>)
24014284:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
24014286:	e173      	b.n	24014570 <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
          else if (ckpclocksource== RCC_CLKPSOURCE_HSE)
24014288:	6b7b      	ldr	r3, [r7, #52]	; 0x34
2401428a:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
2401428e:	d102      	bne.n	24014296 <HAL_RCCEx_GetPeriphCLKFreq+0x1f6>
            frequency = HSE_VALUE;
24014290:	4b2c      	ldr	r3, [pc, #176]	; (24014344 <HAL_RCCEx_GetPeriphCLKFreq+0x2a4>)
24014292:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
24014294:	e16c      	b.n	24014570 <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
            frequency = 0;
24014296:	2300      	movs	r3, #0
24014298:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
2401429a:	e169      	b.n	24014570 <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
        }

      case (RCC_D3CCIPR_SAI4ASEL_0 | RCC_D3CCIPR_SAI4ASEL_1 ): /* External clock is the clock source for SAI4A */
        {
          frequency = EXTERNAL_CLOCK_VALUE;
2401429c:	4b2a      	ldr	r3, [pc, #168]	; (24014348 <HAL_RCCEx_GetPeriphCLKFreq+0x2a8>)
2401429e:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
240142a0:	e166      	b.n	24014570 <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
        }

      default :
        {
          frequency = 0;
240142a2:	2300      	movs	r3, #0
240142a4:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
240142a6:	bf00      	nop
240142a8:	e162      	b.n	24014570 <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
        }
      }
    }

  else if (PeriphClk == RCC_PERIPHCLK_SAI4B)
240142aa:	687b      	ldr	r3, [r7, #4]
240142ac:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
240142b0:	d15d      	bne.n	2401436e <HAL_RCCEx_GetPeriphCLKFreq+0x2ce>
    {

      saiclocksource= __HAL_RCC_GET_SAI4B_SOURCE();
240142b2:	4b21      	ldr	r3, [pc, #132]	; (24014338 <HAL_RCCEx_GetPeriphCLKFreq+0x298>)
240142b4:	6d9b      	ldr	r3, [r3, #88]	; 0x58
240142b6:	f003 63e0 	and.w	r3, r3, #117440512	; 0x7000000
240142ba:	633b      	str	r3, [r7, #48]	; 0x30

      switch (saiclocksource)
240142bc:	6b3b      	ldr	r3, [r7, #48]	; 0x30
240142be:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
240142c2:	d01f      	beq.n	24014304 <HAL_RCCEx_GetPeriphCLKFreq+0x264>
240142c4:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
240142c8:	d805      	bhi.n	240142d6 <HAL_RCCEx_GetPeriphCLKFreq+0x236>
240142ca:	2b00      	cmp	r3, #0
240142cc:	d00a      	beq.n	240142e4 <HAL_RCCEx_GetPeriphCLKFreq+0x244>
240142ce:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
240142d2:	d00f      	beq.n	240142f4 <HAL_RCCEx_GetPeriphCLKFreq+0x254>
240142d4:	e047      	b.n	24014366 <HAL_RCCEx_GetPeriphCLKFreq+0x2c6>
240142d6:	f1b3 7f40 	cmp.w	r3, #50331648	; 0x3000000
240142da:	d041      	beq.n	24014360 <HAL_RCCEx_GetPeriphCLKFreq+0x2c0>
240142dc:	f1b3 6f80 	cmp.w	r3, #67108864	; 0x4000000
240142e0:	d018      	beq.n	24014314 <HAL_RCCEx_GetPeriphCLKFreq+0x274>
240142e2:	e040      	b.n	24014366 <HAL_RCCEx_GetPeriphCLKFreq+0x2c6>
      {
      case 0: /* PLL1 is the clock source for SAI4B */
        {
          HAL_RCCEx_GetPLL1ClockFreq(&pll1_clocks);
240142e4:	f107 0324 	add.w	r3, r7, #36	; 0x24
240142e8:	4618      	mov	r0, r3
240142ea:	f000 fc15 	bl	24014b18 <HAL_RCCEx_GetPLL1ClockFreq>
          frequency = pll1_clocks.PLL1_Q_Frequency;
240142ee:	6abb      	ldr	r3, [r7, #40]	; 0x28
240142f0:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
240142f2:	e13d      	b.n	24014570 <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
        }
      case RCC_D3CCIPR_SAI4BSEL_0: /* PLLI2 is the clock source for SAI4B */
        {
          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
240142f4:	f107 0318 	add.w	r3, r7, #24
240142f8:	4618      	mov	r0, r3
240142fa:	f000 f975 	bl	240145e8 <HAL_RCCEx_GetPLL2ClockFreq>
          frequency = pll2_clocks.PLL2_P_Frequency;
240142fe:	69bb      	ldr	r3, [r7, #24]
24014300:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
24014302:	e135      	b.n	24014570 <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
        }

      case RCC_D3CCIPR_SAI4BSEL_1: /* PLLI3 is the clock source for SAI4B */
        {
          HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
24014304:	f107 030c 	add.w	r3, r7, #12
24014308:	4618      	mov	r0, r3
2401430a:	f000 fab9 	bl	24014880 <HAL_RCCEx_GetPLL3ClockFreq>
          frequency = pll3_clocks.PLL3_P_Frequency;
2401430e:	68fb      	ldr	r3, [r7, #12]
24014310:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
24014312:	e12d      	b.n	24014570 <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
        }

      case RCC_D3CCIPR_SAI4BSEL_2: /* CKPER is the clock source for SAI4B*/
        {

          ckpclocksource= __HAL_RCC_GET_CLKP_SOURCE();
24014314:	4b08      	ldr	r3, [pc, #32]	; (24014338 <HAL_RCCEx_GetPeriphCLKFreq+0x298>)
24014316:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
24014318:	f003 5340 	and.w	r3, r3, #805306368	; 0x30000000
2401431c:	637b      	str	r3, [r7, #52]	; 0x34

          if(ckpclocksource== RCC_CLKPSOURCE_HSI)
2401431e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
24014320:	2b00      	cmp	r3, #0
24014322:	d102      	bne.n	2401432a <HAL_RCCEx_GetPeriphCLKFreq+0x28a>
          {
            /* In Case the CKPER Source is HSI */
            frequency = HSI_VALUE;
24014324:	4b05      	ldr	r3, [pc, #20]	; (2401433c <HAL_RCCEx_GetPeriphCLKFreq+0x29c>)
24014326:	63fb      	str	r3, [r7, #60]	; 0x3c
          {
            /* In Case the CKPER is disabled*/
            frequency = 0;
          }

          break;
24014328:	e122      	b.n	24014570 <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
          else if(ckpclocksource== RCC_CLKPSOURCE_CSI)
2401432a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
2401432c:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
24014330:	d10c      	bne.n	2401434c <HAL_RCCEx_GetPeriphCLKFreq+0x2ac>
            frequency = CSI_VALUE;
24014332:	4b03      	ldr	r3, [pc, #12]	; (24014340 <HAL_RCCEx_GetPeriphCLKFreq+0x2a0>)
24014334:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
24014336:	e11b      	b.n	24014570 <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
24014338:	58024400 	.word	0x58024400
2401433c:	03d09000 	.word	0x03d09000
24014340:	003d0900 	.word	0x003d0900
24014344:	017d7840 	.word	0x017d7840
24014348:	00bb8000 	.word	0x00bb8000
          else if (ckpclocksource== RCC_CLKPSOURCE_HSE)
2401434c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
2401434e:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
24014352:	d102      	bne.n	2401435a <HAL_RCCEx_GetPeriphCLKFreq+0x2ba>
            frequency = HSE_VALUE;
24014354:	4b89      	ldr	r3, [pc, #548]	; (2401457c <HAL_RCCEx_GetPeriphCLKFreq+0x4dc>)
24014356:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
24014358:	e10a      	b.n	24014570 <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
            frequency = 0;
2401435a:	2300      	movs	r3, #0
2401435c:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
2401435e:	e107      	b.n	24014570 <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
        }

      case (RCC_D3CCIPR_SAI4BSEL_0 | RCC_D3CCIPR_SAI4BSEL_1 ): /* External clock is the clock source for SAI4B */
        {
          frequency = EXTERNAL_CLOCK_VALUE;
24014360:	4b87      	ldr	r3, [pc, #540]	; (24014580 <HAL_RCCEx_GetPeriphCLKFreq+0x4e0>)
24014362:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
24014364:	e104      	b.n	24014570 <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
        }

      default :
        {
          frequency = 0;
24014366:	2300      	movs	r3, #0
24014368:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
2401436a:	bf00      	nop
2401436c:	e100      	b.n	24014570 <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
        }
      }
    }
#endif /*SAI4*/
  else if (PeriphClk == RCC_PERIPHCLK_SPI123)
2401436e:	687b      	ldr	r3, [r7, #4]
24014370:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
24014374:	d153      	bne.n	2401441e <HAL_RCCEx_GetPeriphCLKFreq+0x37e>
    {
      /* Get SPI1/2/3 clock source */
      srcclk= __HAL_RCC_GET_SPI123_SOURCE();
24014376:	4b83      	ldr	r3, [pc, #524]	; (24014584 <HAL_RCCEx_GetPeriphCLKFreq+0x4e4>)
24014378:	6d1b      	ldr	r3, [r3, #80]	; 0x50
2401437a:	f403 43e0 	and.w	r3, r3, #28672	; 0x7000
2401437e:	63bb      	str	r3, [r7, #56]	; 0x38

      switch (srcclk)
24014380:	6bbb      	ldr	r3, [r7, #56]	; 0x38
24014382:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
24014386:	d01f      	beq.n	240143c8 <HAL_RCCEx_GetPeriphCLKFreq+0x328>
24014388:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
2401438c:	d805      	bhi.n	2401439a <HAL_RCCEx_GetPeriphCLKFreq+0x2fa>
2401438e:	2b00      	cmp	r3, #0
24014390:	d00a      	beq.n	240143a8 <HAL_RCCEx_GetPeriphCLKFreq+0x308>
24014392:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
24014396:	d00f      	beq.n	240143b8 <HAL_RCCEx_GetPeriphCLKFreq+0x318>
24014398:	e03d      	b.n	24014416 <HAL_RCCEx_GetPeriphCLKFreq+0x376>
2401439a:	f5b3 5f40 	cmp.w	r3, #12288	; 0x3000
2401439e:	d037      	beq.n	24014410 <HAL_RCCEx_GetPeriphCLKFreq+0x370>
240143a0:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
240143a4:	d018      	beq.n	240143d8 <HAL_RCCEx_GetPeriphCLKFreq+0x338>
240143a6:	e036      	b.n	24014416 <HAL_RCCEx_GetPeriphCLKFreq+0x376>
      {
      case RCC_SPI123CLKSOURCE_PLL: /* PLL1 is the clock source for I2S */
        {
          HAL_RCCEx_GetPLL1ClockFreq(&pll1_clocks);
240143a8:	f107 0324 	add.w	r3, r7, #36	; 0x24
240143ac:	4618      	mov	r0, r3
240143ae:	f000 fbb3 	bl	24014b18 <HAL_RCCEx_GetPLL1ClockFreq>
          frequency = pll1_clocks.PLL1_Q_Frequency;
240143b2:	6abb      	ldr	r3, [r7, #40]	; 0x28
240143b4:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
240143b6:	e0db      	b.n	24014570 <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
        }
      case RCC_SPI123CLKSOURCE_PLL2: /* PLL2 is the clock source for I2S */
        {
          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
240143b8:	f107 0318 	add.w	r3, r7, #24
240143bc:	4618      	mov	r0, r3
240143be:	f000 f913 	bl	240145e8 <HAL_RCCEx_GetPLL2ClockFreq>
          frequency = pll2_clocks.PLL2_P_Frequency;
240143c2:	69bb      	ldr	r3, [r7, #24]
240143c4:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
240143c6:	e0d3      	b.n	24014570 <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
        }

      case RCC_SPI123CLKSOURCE_PLL3: /* PLL3 is the clock source for I2S */
        {
          HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
240143c8:	f107 030c 	add.w	r3, r7, #12
240143cc:	4618      	mov	r0, r3
240143ce:	f000 fa57 	bl	24014880 <HAL_RCCEx_GetPLL3ClockFreq>
          frequency = pll3_clocks.PLL3_P_Frequency;
240143d2:	68fb      	ldr	r3, [r7, #12]
240143d4:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
240143d6:	e0cb      	b.n	24014570 <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
        }

      case RCC_SPI123CLKSOURCE_CLKP: /* CKPER is the clock source for I2S */
        {

          ckpclocksource= __HAL_RCC_GET_CLKP_SOURCE();
240143d8:	4b6a      	ldr	r3, [pc, #424]	; (24014584 <HAL_RCCEx_GetPeriphCLKFreq+0x4e4>)
240143da:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
240143dc:	f003 5340 	and.w	r3, r3, #805306368	; 0x30000000
240143e0:	637b      	str	r3, [r7, #52]	; 0x34

          if(ckpclocksource== RCC_CLKPSOURCE_HSI)
240143e2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
240143e4:	2b00      	cmp	r3, #0
240143e6:	d102      	bne.n	240143ee <HAL_RCCEx_GetPeriphCLKFreq+0x34e>
          {
            /* In Case the CKPER Source is HSI */
            frequency = HSI_VALUE;
240143e8:	4b67      	ldr	r3, [pc, #412]	; (24014588 <HAL_RCCEx_GetPeriphCLKFreq+0x4e8>)
240143ea:	63fb      	str	r3, [r7, #60]	; 0x3c
          {
            /* In Case the CKPER is disabled*/
            frequency = 0;
          }

          break;
240143ec:	e0c0      	b.n	24014570 <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
          else if(ckpclocksource== RCC_CLKPSOURCE_CSI)
240143ee:	6b7b      	ldr	r3, [r7, #52]	; 0x34
240143f0:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
240143f4:	d102      	bne.n	240143fc <HAL_RCCEx_GetPeriphCLKFreq+0x35c>
            frequency = CSI_VALUE;
240143f6:	4b65      	ldr	r3, [pc, #404]	; (2401458c <HAL_RCCEx_GetPeriphCLKFreq+0x4ec>)
240143f8:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
240143fa:	e0b9      	b.n	24014570 <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
          else if (ckpclocksource== RCC_CLKPSOURCE_HSE)
240143fc:	6b7b      	ldr	r3, [r7, #52]	; 0x34
240143fe:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
24014402:	d102      	bne.n	2401440a <HAL_RCCEx_GetPeriphCLKFreq+0x36a>
            frequency = HSE_VALUE;
24014404:	4b5d      	ldr	r3, [pc, #372]	; (2401457c <HAL_RCCEx_GetPeriphCLKFreq+0x4dc>)
24014406:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
24014408:	e0b2      	b.n	24014570 <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
            frequency = 0;
2401440a:	2300      	movs	r3, #0
2401440c:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
2401440e:	e0af      	b.n	24014570 <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
        }

      case (RCC_SPI123CLKSOURCE_PIN): /* External clock is the clock source for I2S */
        {
          frequency = EXTERNAL_CLOCK_VALUE;
24014410:	4b5b      	ldr	r3, [pc, #364]	; (24014580 <HAL_RCCEx_GetPeriphCLKFreq+0x4e0>)
24014412:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
24014414:	e0ac      	b.n	24014570 <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
        }
      default :
        {
          frequency = 0;
24014416:	2300      	movs	r3, #0
24014418:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
2401441a:	bf00      	nop
2401441c:	e0a8      	b.n	24014570 <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
        }
      }
    }
  else if (PeriphClk == RCC_PERIPHCLK_ADC)
2401441e:	687b      	ldr	r3, [r7, #4]
24014420:	f5b3 2f00 	cmp.w	r3, #524288	; 0x80000
24014424:	d13d      	bne.n	240144a2 <HAL_RCCEx_GetPeriphCLKFreq+0x402>
    {
      /* Get ADC clock source */
      srcclk= __HAL_RCC_GET_ADC_SOURCE();
24014426:	4b57      	ldr	r3, [pc, #348]	; (24014584 <HAL_RCCEx_GetPeriphCLKFreq+0x4e4>)
24014428:	6d9b      	ldr	r3, [r3, #88]	; 0x58
2401442a:	f403 3340 	and.w	r3, r3, #196608	; 0x30000
2401442e:	63bb      	str	r3, [r7, #56]	; 0x38

      switch (srcclk)
24014430:	6bbb      	ldr	r3, [r7, #56]	; 0x38
24014432:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
24014436:	d00c      	beq.n	24014452 <HAL_RCCEx_GetPeriphCLKFreq+0x3b2>
24014438:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
2401443c:	d011      	beq.n	24014462 <HAL_RCCEx_GetPeriphCLKFreq+0x3c2>
2401443e:	2b00      	cmp	r3, #0
24014440:	d12b      	bne.n	2401449a <HAL_RCCEx_GetPeriphCLKFreq+0x3fa>
      {
      case RCC_ADCCLKSOURCE_PLL2:
        {
          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
24014442:	f107 0318 	add.w	r3, r7, #24
24014446:	4618      	mov	r0, r3
24014448:	f000 f8ce 	bl	240145e8 <HAL_RCCEx_GetPLL2ClockFreq>
          frequency = pll2_clocks.PLL2_P_Frequency;
2401444c:	69bb      	ldr	r3, [r7, #24]
2401444e:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
24014450:	e08e      	b.n	24014570 <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
        }
      case RCC_ADCCLKSOURCE_PLL3:
        {
          HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
24014452:	f107 030c 	add.w	r3, r7, #12
24014456:	4618      	mov	r0, r3
24014458:	f000 fa12 	bl	24014880 <HAL_RCCEx_GetPLL3ClockFreq>
          frequency = pll3_clocks.PLL3_R_Frequency;
2401445c:	697b      	ldr	r3, [r7, #20]
2401445e:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
24014460:	e086      	b.n	24014570 <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
        }

      case RCC_ADCCLKSOURCE_CLKP:
        {

          ckpclocksource= __HAL_RCC_GET_CLKP_SOURCE();
24014462:	4b48      	ldr	r3, [pc, #288]	; (24014584 <HAL_RCCEx_GetPeriphCLKFreq+0x4e4>)
24014464:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
24014466:	f003 5340 	and.w	r3, r3, #805306368	; 0x30000000
2401446a:	637b      	str	r3, [r7, #52]	; 0x34

          if(ckpclocksource== RCC_CLKPSOURCE_HSI)
2401446c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
2401446e:	2b00      	cmp	r3, #0
24014470:	d102      	bne.n	24014478 <HAL_RCCEx_GetPeriphCLKFreq+0x3d8>
          {
            /* In Case the CKPER Source is HSI */
            frequency = HSI_VALUE;
24014472:	4b45      	ldr	r3, [pc, #276]	; (24014588 <HAL_RCCEx_GetPeriphCLKFreq+0x4e8>)
24014474:	63fb      	str	r3, [r7, #60]	; 0x3c
          {
            /* In Case the CKPER is disabled*/
            frequency = 0;
          }

          break;
24014476:	e07b      	b.n	24014570 <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
          else if(ckpclocksource== RCC_CLKPSOURCE_CSI)
24014478:	6b7b      	ldr	r3, [r7, #52]	; 0x34
2401447a:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
2401447e:	d102      	bne.n	24014486 <HAL_RCCEx_GetPeriphCLKFreq+0x3e6>
            frequency = CSI_VALUE;
24014480:	4b42      	ldr	r3, [pc, #264]	; (2401458c <HAL_RCCEx_GetPeriphCLKFreq+0x4ec>)
24014482:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
24014484:	e074      	b.n	24014570 <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
          else if (ckpclocksource== RCC_CLKPSOURCE_HSE)
24014486:	6b7b      	ldr	r3, [r7, #52]	; 0x34
24014488:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
2401448c:	d102      	bne.n	24014494 <HAL_RCCEx_GetPeriphCLKFreq+0x3f4>
            frequency = HSE_VALUE;
2401448e:	4b3b      	ldr	r3, [pc, #236]	; (2401457c <HAL_RCCEx_GetPeriphCLKFreq+0x4dc>)
24014490:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
24014492:	e06d      	b.n	24014570 <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
            frequency = 0;
24014494:	2300      	movs	r3, #0
24014496:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
24014498:	e06a      	b.n	24014570 <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
        }

      default :
        {
          frequency = 0;
2401449a:	2300      	movs	r3, #0
2401449c:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
2401449e:	bf00      	nop
240144a0:	e066      	b.n	24014570 <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
        }
      }
    }
  else if (PeriphClk == RCC_PERIPHCLK_SDMMC)
240144a2:	687b      	ldr	r3, [r7, #4]
240144a4:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
240144a8:	d11f      	bne.n	240144ea <HAL_RCCEx_GetPeriphCLKFreq+0x44a>
    {
      /* Get SDMMC clock source */
      srcclk= __HAL_RCC_GET_SDMMC_SOURCE();
240144aa:	4b36      	ldr	r3, [pc, #216]	; (24014584 <HAL_RCCEx_GetPeriphCLKFreq+0x4e4>)
240144ac:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
240144ae:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
240144b2:	63bb      	str	r3, [r7, #56]	; 0x38

      switch (srcclk)
240144b4:	6bbb      	ldr	r3, [r7, #56]	; 0x38
240144b6:	2b00      	cmp	r3, #0
240144b8:	d003      	beq.n	240144c2 <HAL_RCCEx_GetPeriphCLKFreq+0x422>
240144ba:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
240144be:	d008      	beq.n	240144d2 <HAL_RCCEx_GetPeriphCLKFreq+0x432>
240144c0:	e00f      	b.n	240144e2 <HAL_RCCEx_GetPeriphCLKFreq+0x442>
      {
      case RCC_SDMMCCLKSOURCE_PLL: /* PLL1 is the clock source for SDMMC */
        {
          HAL_RCCEx_GetPLL1ClockFreq(&pll1_clocks);
240144c2:	f107 0324 	add.w	r3, r7, #36	; 0x24
240144c6:	4618      	mov	r0, r3
240144c8:	f000 fb26 	bl	24014b18 <HAL_RCCEx_GetPLL1ClockFreq>
          frequency = pll1_clocks.PLL1_Q_Frequency;
240144cc:	6abb      	ldr	r3, [r7, #40]	; 0x28
240144ce:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
240144d0:	e04e      	b.n	24014570 <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
        }
      case RCC_SDMMCCLKSOURCE_PLL2: /* PLL2 is the clock source for SDMMC */
        {
          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
240144d2:	f107 0318 	add.w	r3, r7, #24
240144d6:	4618      	mov	r0, r3
240144d8:	f000 f886 	bl	240145e8 <HAL_RCCEx_GetPLL2ClockFreq>
          frequency = pll2_clocks.PLL2_R_Frequency;
240144dc:	6a3b      	ldr	r3, [r7, #32]
240144de:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
240144e0:	e046      	b.n	24014570 <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
        }

      default :
        {
          frequency = 0;
240144e2:	2300      	movs	r3, #0
240144e4:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
240144e6:	bf00      	nop
240144e8:	e042      	b.n	24014570 <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
        }
      }
    }
  else if (PeriphClk == RCC_PERIPHCLK_SPI6)
240144ea:	687b      	ldr	r3, [r7, #4]
240144ec:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
240144f0:	d13c      	bne.n	2401456c <HAL_RCCEx_GetPeriphCLKFreq+0x4cc>
    {
      /* Get SPI6 clock source */
      srcclk= __HAL_RCC_GET_SPI6_SOURCE();
240144f2:	4b24      	ldr	r3, [pc, #144]	; (24014584 <HAL_RCCEx_GetPeriphCLKFreq+0x4e4>)
240144f4:	6d9b      	ldr	r3, [r3, #88]	; 0x58
240144f6:	f003 43e0 	and.w	r3, r3, #1879048192	; 0x70000000
240144fa:	63bb      	str	r3, [r7, #56]	; 0x38

      switch (srcclk)
240144fc:	6bbb      	ldr	r3, [r7, #56]	; 0x38
240144fe:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
24014502:	d01e      	beq.n	24014542 <HAL_RCCEx_GetPeriphCLKFreq+0x4a2>
24014504:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
24014508:	d805      	bhi.n	24014516 <HAL_RCCEx_GetPeriphCLKFreq+0x476>
2401450a:	2b00      	cmp	r3, #0
2401450c:	d00d      	beq.n	2401452a <HAL_RCCEx_GetPeriphCLKFreq+0x48a>
2401450e:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
24014512:	d00e      	beq.n	24014532 <HAL_RCCEx_GetPeriphCLKFreq+0x492>
24014514:	e026      	b.n	24014564 <HAL_RCCEx_GetPeriphCLKFreq+0x4c4>
24014516:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
2401451a:	d01d      	beq.n	24014558 <HAL_RCCEx_GetPeriphCLKFreq+0x4b8>
2401451c:	f1b3 4fa0 	cmp.w	r3, #1342177280	; 0x50000000
24014520:	d01d      	beq.n	2401455e <HAL_RCCEx_GetPeriphCLKFreq+0x4be>
24014522:	f1b3 5f40 	cmp.w	r3, #805306368	; 0x30000000
24014526:	d014      	beq.n	24014552 <HAL_RCCEx_GetPeriphCLKFreq+0x4b2>
24014528:	e01c      	b.n	24014564 <HAL_RCCEx_GetPeriphCLKFreq+0x4c4>
      {
      case RCC_SPI6CLKSOURCE_D3PCLK1: /* D3PCLK1 (PCLK4) is the clock source for SPI6 */
        {
          frequency = HAL_RCCEx_GetD3PCLK1Freq();
2401452a:	f000 f847 	bl	240145bc <HAL_RCCEx_GetD3PCLK1Freq>
2401452e:	63f8      	str	r0, [r7, #60]	; 0x3c
          break;
24014530:	e01e      	b.n	24014570 <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
        }
      case RCC_SPI6CLKSOURCE_PLL2: /* PLL2 is the clock source for SPI6 */
        {
          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
24014532:	f107 0318 	add.w	r3, r7, #24
24014536:	4618      	mov	r0, r3
24014538:	f000 f856 	bl	240145e8 <HAL_RCCEx_GetPLL2ClockFreq>
          frequency = pll2_clocks.PLL2_Q_Frequency;
2401453c:	69fb      	ldr	r3, [r7, #28]
2401453e:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
24014540:	e016      	b.n	24014570 <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
        }
      case RCC_SPI6CLKSOURCE_PLL3: /* PLL3 is the clock source for SPI6 */
        {
          HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
24014542:	f107 030c 	add.w	r3, r7, #12
24014546:	4618      	mov	r0, r3
24014548:	f000 f99a 	bl	24014880 <HAL_RCCEx_GetPLL3ClockFreq>
          frequency = pll3_clocks.PLL3_Q_Frequency;
2401454c:	693b      	ldr	r3, [r7, #16]
2401454e:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
24014550:	e00e      	b.n	24014570 <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
        }
      case RCC_SPI6CLKSOURCE_HSI: /* HSI is the clock source for SPI6 */
        {
          frequency = HSI_VALUE;
24014552:	4b0d      	ldr	r3, [pc, #52]	; (24014588 <HAL_RCCEx_GetPeriphCLKFreq+0x4e8>)
24014554:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
24014556:	e00b      	b.n	24014570 <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
        }
      case RCC_SPI6CLKSOURCE_CSI: /* CSI is the clock source for SPI6 */
        {
          frequency = CSI_VALUE;
24014558:	4b0c      	ldr	r3, [pc, #48]	; (2401458c <HAL_RCCEx_GetPeriphCLKFreq+0x4ec>)
2401455a:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
2401455c:	e008      	b.n	24014570 <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
        }
      case RCC_SPI6CLKSOURCE_HSE: /* HSE is the clock source for SPI6 */
        {
          frequency = HSE_VALUE;
2401455e:	4b07      	ldr	r3, [pc, #28]	; (2401457c <HAL_RCCEx_GetPeriphCLKFreq+0x4dc>)
24014560:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
24014562:	e005      	b.n	24014570 <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
          break;
        }
#endif /* RCC_SPI6CLKSOURCE_PIN */
      default :
        {
          frequency = 0;
24014564:	2300      	movs	r3, #0
24014566:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
24014568:	bf00      	nop
2401456a:	e001      	b.n	24014570 <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
        }
      }
    }
  else
    {
      frequency = 0;
2401456c:	2300      	movs	r3, #0
2401456e:	63fb      	str	r3, [r7, #60]	; 0x3c
    }

  return frequency;
24014570:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
}
24014572:	4618      	mov	r0, r3
24014574:	3740      	adds	r7, #64	; 0x40
24014576:	46bd      	mov	sp, r7
24014578:	bd80      	pop	{r7, pc}
2401457a:	bf00      	nop
2401457c:	017d7840 	.word	0x017d7840
24014580:	00bb8000 	.word	0x00bb8000
24014584:	58024400 	.word	0x58024400
24014588:	03d09000 	.word	0x03d09000
2401458c:	003d0900 	.word	0x003d0900

24014590 <HAL_RCCEx_GetD1PCLK1Freq>:
  * @note   Each time D1PCLK1 changes, this function must be called to update the
  *         right D1PCLK1 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval D1PCLK1 frequency
  */
uint32_t HAL_RCCEx_GetD1PCLK1Freq(void)
{
24014590:	b580      	push	{r7, lr}
24014592:	af00      	add	r7, sp, #0
#if defined(RCC_D1CFGR_D1PPRE)
  /* Get HCLK source and Compute D1PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> (D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1PPRE)>> RCC_D1CFGR_D1PPRE_Pos] & 0x1FU));
24014594:	f7fe fb9a 	bl	24012ccc <HAL_RCC_GetHCLKFreq>
24014598:	4601      	mov	r1, r0
2401459a:	4b06      	ldr	r3, [pc, #24]	; (240145b4 <HAL_RCCEx_GetD1PCLK1Freq+0x24>)
2401459c:	699b      	ldr	r3, [r3, #24]
2401459e:	091b      	lsrs	r3, r3, #4
240145a0:	f003 0307 	and.w	r3, r3, #7
240145a4:	4a04      	ldr	r2, [pc, #16]	; (240145b8 <HAL_RCCEx_GetD1PCLK1Freq+0x28>)
240145a6:	5cd3      	ldrb	r3, [r2, r3]
240145a8:	f003 031f 	and.w	r3, r3, #31
240145ac:	fa21 f303 	lsr.w	r3, r1, r3
#else
/* Get HCLK source and Compute D1PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> (D1CorePrescTable[(RCC->CDCFGR1 & RCC_CDCFGR1_CDPPRE)>> RCC_CDCFGR1_CDPPRE_Pos] & 0x1FU));
#endif
}
240145b0:	4618      	mov	r0, r3
240145b2:	bd80      	pop	{r7, pc}
240145b4:	58024400 	.word	0x58024400
240145b8:	24016b70 	.word	0x24016b70

240145bc <HAL_RCCEx_GetD3PCLK1Freq>:
  * @note   Each time D3PCLK1 changes, this function must be called to update the
  *         right D3PCLK1 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval D3PCLK1 frequency
  */
uint32_t HAL_RCCEx_GetD3PCLK1Freq(void)
{
240145bc:	b580      	push	{r7, lr}
240145be:	af00      	add	r7, sp, #0
#if defined(RCC_D3CFGR_D3PPRE)
  /* Get HCLK source and Compute D3PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> (D1CorePrescTable[(RCC->D3CFGR & RCC_D3CFGR_D3PPRE)>> RCC_D3CFGR_D3PPRE_Pos] & 0x1FU));
240145c0:	f7fe fb84 	bl	24012ccc <HAL_RCC_GetHCLKFreq>
240145c4:	4601      	mov	r1, r0
240145c6:	4b06      	ldr	r3, [pc, #24]	; (240145e0 <HAL_RCCEx_GetD3PCLK1Freq+0x24>)
240145c8:	6a1b      	ldr	r3, [r3, #32]
240145ca:	091b      	lsrs	r3, r3, #4
240145cc:	f003 0307 	and.w	r3, r3, #7
240145d0:	4a04      	ldr	r2, [pc, #16]	; (240145e4 <HAL_RCCEx_GetD3PCLK1Freq+0x28>)
240145d2:	5cd3      	ldrb	r3, [r2, r3]
240145d4:	f003 031f 	and.w	r3, r3, #31
240145d8:	fa21 f303 	lsr.w	r3, r1, r3
#else
  /* Get HCLK source and Compute D3PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> (D1CorePrescTable[(RCC->SRDCFGR & RCC_SRDCFGR_SRDPPRE)>> RCC_SRDCFGR_SRDPPRE_Pos] & 0x1FU));
#endif
}
240145dc:	4618      	mov	r0, r3
240145de:	bd80      	pop	{r7, pc}
240145e0:	58024400 	.word	0x58024400
240145e4:	24016b70 	.word	0x24016b70

240145e8 <HAL_RCCEx_GetPLL2ClockFreq>:
  *         right PLL2CLK value. Otherwise, any configuration based on this function will be incorrect.
  * @param  PLL2_Clocks structure.
  * @retval None
  */
void HAL_RCCEx_GetPLL2ClockFreq(PLL2_ClocksTypeDef* PLL2_Clocks)
{
240145e8:	b480      	push	{r7}
240145ea:	b089      	sub	sp, #36	; 0x24
240145ec:	af00      	add	r7, sp, #0
240145ee:	6078      	str	r0, [r7, #4]
  float_t fracn2, pll2vco;

  /* PLL_VCO = (HSE_VALUE or HSI_VALUE or CSI_VALUE/ PLL2M) * PLL2N
     PLL2xCLK = PLL2_VCO / PLL2x
  */
  pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
240145f0:	4b9d      	ldr	r3, [pc, #628]	; (24014868 <HAL_RCCEx_GetPLL2ClockFreq+0x280>)
240145f2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
240145f4:	f003 0303 	and.w	r3, r3, #3
240145f8:	61bb      	str	r3, [r7, #24]
  pll2m = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM2)>> 12);
240145fa:	4b9b      	ldr	r3, [pc, #620]	; (24014868 <HAL_RCCEx_GetPLL2ClockFreq+0x280>)
240145fc:	6a9b      	ldr	r3, [r3, #40]	; 0x28
240145fe:	0b1b      	lsrs	r3, r3, #12
24014600:	f003 033f 	and.w	r3, r3, #63	; 0x3f
24014604:	617b      	str	r3, [r7, #20]
  pll2fracen = (RCC->PLLCFGR & RCC_PLLCFGR_PLL2FRACEN) >> RCC_PLLCFGR_PLL2FRACEN_Pos;
24014606:	4b98      	ldr	r3, [pc, #608]	; (24014868 <HAL_RCCEx_GetPLL2ClockFreq+0x280>)
24014608:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2401460a:	091b      	lsrs	r3, r3, #4
2401460c:	f003 0301 	and.w	r3, r3, #1
24014610:	613b      	str	r3, [r7, #16]
  fracn2 =(float_t)(uint32_t)(pll2fracen* ((RCC->PLL2FRACR & RCC_PLL2FRACR_FRACN2)>> 3));
24014612:	4b95      	ldr	r3, [pc, #596]	; (24014868 <HAL_RCCEx_GetPLL2ClockFreq+0x280>)
24014614:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
24014616:	08db      	lsrs	r3, r3, #3
24014618:	f3c3 030c 	ubfx	r3, r3, #0, #13
2401461c:	693a      	ldr	r2, [r7, #16]
2401461e:	fb02 f303 	mul.w	r3, r2, r3
24014622:	ee07 3a90 	vmov	s15, r3
24014626:	eef8 7a67 	vcvt.f32.u32	s15, s15
2401462a:	edc7 7a03 	vstr	s15, [r7, #12]

  if (pll2m != 0U)
2401462e:	697b      	ldr	r3, [r7, #20]
24014630:	2b00      	cmp	r3, #0
24014632:	f000 810a 	beq.w	2401484a <HAL_RCCEx_GetPLL2ClockFreq+0x262>
  {
    switch (pllsource)
24014636:	69bb      	ldr	r3, [r7, #24]
24014638:	2b01      	cmp	r3, #1
2401463a:	d05a      	beq.n	240146f2 <HAL_RCCEx_GetPLL2ClockFreq+0x10a>
2401463c:	2b01      	cmp	r3, #1
2401463e:	d302      	bcc.n	24014646 <HAL_RCCEx_GetPLL2ClockFreq+0x5e>
24014640:	2b02      	cmp	r3, #2
24014642:	d078      	beq.n	24014736 <HAL_RCCEx_GetPLL2ClockFreq+0x14e>
24014644:	e099      	b.n	2401477a <HAL_RCCEx_GetPLL2ClockFreq+0x192>
    {

    case RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */

      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
24014646:	4b88      	ldr	r3, [pc, #544]	; (24014868 <HAL_RCCEx_GetPLL2ClockFreq+0x280>)
24014648:	681b      	ldr	r3, [r3, #0]
2401464a:	f003 0320 	and.w	r3, r3, #32
2401464e:	2b00      	cmp	r3, #0
24014650:	d02d      	beq.n	240146ae <HAL_RCCEx_GetPLL2ClockFreq+0xc6>
      {
        hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
24014652:	4b85      	ldr	r3, [pc, #532]	; (24014868 <HAL_RCCEx_GetPLL2ClockFreq+0x280>)
24014654:	681b      	ldr	r3, [r3, #0]
24014656:	08db      	lsrs	r3, r3, #3
24014658:	f003 0303 	and.w	r3, r3, #3
2401465c:	4a83      	ldr	r2, [pc, #524]	; (2401486c <HAL_RCCEx_GetPLL2ClockFreq+0x284>)
2401465e:	fa22 f303 	lsr.w	r3, r2, r3
24014662:	60bb      	str	r3, [r7, #8]
        pll2vco = ( (float_t)hsivalue / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2/(float_t)0x2000) +(float_t)1 );
24014664:	68bb      	ldr	r3, [r7, #8]
24014666:	ee07 3a90 	vmov	s15, r3
2401466a:	eef8 6a67 	vcvt.f32.u32	s13, s15
2401466e:	697b      	ldr	r3, [r7, #20]
24014670:	ee07 3a90 	vmov	s15, r3
24014674:	eef8 7a67 	vcvt.f32.u32	s15, s15
24014678:	ee86 7aa7 	vdiv.f32	s14, s13, s15
2401467c:	4b7a      	ldr	r3, [pc, #488]	; (24014868 <HAL_RCCEx_GetPLL2ClockFreq+0x280>)
2401467e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
24014680:	f3c3 0308 	ubfx	r3, r3, #0, #9
24014684:	ee07 3a90 	vmov	s15, r3
24014688:	eef8 6a67 	vcvt.f32.u32	s13, s15
2401468c:	ed97 6a03 	vldr	s12, [r7, #12]
24014690:	eddf 5a77 	vldr	s11, [pc, #476]	; 24014870 <HAL_RCCEx_GetPLL2ClockFreq+0x288>
24014694:	eec6 7a25 	vdiv.f32	s15, s12, s11
24014698:	ee76 7aa7 	vadd.f32	s15, s13, s15
2401469c:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
240146a0:	ee77 7aa6 	vadd.f32	s15, s15, s13
240146a4:	ee67 7a27 	vmul.f32	s15, s14, s15
240146a8:	edc7 7a07 	vstr	s15, [r7, #28]
      }
      else
      {
        pll2vco = ((float_t)HSI_VALUE / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2/(float_t)0x2000) +(float_t)1 );
      }
      break;
240146ac:	e087      	b.n	240147be <HAL_RCCEx_GetPLL2ClockFreq+0x1d6>
        pll2vco = ((float_t)HSI_VALUE / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2/(float_t)0x2000) +(float_t)1 );
240146ae:	697b      	ldr	r3, [r7, #20]
240146b0:	ee07 3a90 	vmov	s15, r3
240146b4:	eef8 7a67 	vcvt.f32.u32	s15, s15
240146b8:	eddf 6a6e 	vldr	s13, [pc, #440]	; 24014874 <HAL_RCCEx_GetPLL2ClockFreq+0x28c>
240146bc:	ee86 7aa7 	vdiv.f32	s14, s13, s15
240146c0:	4b69      	ldr	r3, [pc, #420]	; (24014868 <HAL_RCCEx_GetPLL2ClockFreq+0x280>)
240146c2:	6b9b      	ldr	r3, [r3, #56]	; 0x38
240146c4:	f3c3 0308 	ubfx	r3, r3, #0, #9
240146c8:	ee07 3a90 	vmov	s15, r3
240146cc:	eef8 6a67 	vcvt.f32.u32	s13, s15
240146d0:	ed97 6a03 	vldr	s12, [r7, #12]
240146d4:	eddf 5a66 	vldr	s11, [pc, #408]	; 24014870 <HAL_RCCEx_GetPLL2ClockFreq+0x288>
240146d8:	eec6 7a25 	vdiv.f32	s15, s12, s11
240146dc:	ee76 7aa7 	vadd.f32	s15, s13, s15
240146e0:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
240146e4:	ee77 7aa6 	vadd.f32	s15, s15, s13
240146e8:	ee67 7a27 	vmul.f32	s15, s14, s15
240146ec:	edc7 7a07 	vstr	s15, [r7, #28]
      break;
240146f0:	e065      	b.n	240147be <HAL_RCCEx_GetPLL2ClockFreq+0x1d6>

    case RCC_PLLSOURCE_CSI:  /* CSI used as PLL clock source */
      pll2vco = ((float_t)CSI_VALUE / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2/(float_t)0x2000) +(float_t)1 );
240146f2:	697b      	ldr	r3, [r7, #20]
240146f4:	ee07 3a90 	vmov	s15, r3
240146f8:	eef8 7a67 	vcvt.f32.u32	s15, s15
240146fc:	eddf 6a5e 	vldr	s13, [pc, #376]	; 24014878 <HAL_RCCEx_GetPLL2ClockFreq+0x290>
24014700:	ee86 7aa7 	vdiv.f32	s14, s13, s15
24014704:	4b58      	ldr	r3, [pc, #352]	; (24014868 <HAL_RCCEx_GetPLL2ClockFreq+0x280>)
24014706:	6b9b      	ldr	r3, [r3, #56]	; 0x38
24014708:	f3c3 0308 	ubfx	r3, r3, #0, #9
2401470c:	ee07 3a90 	vmov	s15, r3
24014710:	eef8 6a67 	vcvt.f32.u32	s13, s15
24014714:	ed97 6a03 	vldr	s12, [r7, #12]
24014718:	eddf 5a55 	vldr	s11, [pc, #340]	; 24014870 <HAL_RCCEx_GetPLL2ClockFreq+0x288>
2401471c:	eec6 7a25 	vdiv.f32	s15, s12, s11
24014720:	ee76 7aa7 	vadd.f32	s15, s13, s15
24014724:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
24014728:	ee77 7aa6 	vadd.f32	s15, s15, s13
2401472c:	ee67 7a27 	vmul.f32	s15, s14, s15
24014730:	edc7 7a07 	vstr	s15, [r7, #28]
      break;
24014734:	e043      	b.n	240147be <HAL_RCCEx_GetPLL2ClockFreq+0x1d6>

    case RCC_PLLSOURCE_HSE:  /* HSE used as PLL clock source */
      pll2vco = ((float_t)HSE_VALUE / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2/(float_t)0x2000) +(float_t)1 );
24014736:	697b      	ldr	r3, [r7, #20]
24014738:	ee07 3a90 	vmov	s15, r3
2401473c:	eef8 7a67 	vcvt.f32.u32	s15, s15
24014740:	eddf 6a4e 	vldr	s13, [pc, #312]	; 2401487c <HAL_RCCEx_GetPLL2ClockFreq+0x294>
24014744:	ee86 7aa7 	vdiv.f32	s14, s13, s15
24014748:	4b47      	ldr	r3, [pc, #284]	; (24014868 <HAL_RCCEx_GetPLL2ClockFreq+0x280>)
2401474a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2401474c:	f3c3 0308 	ubfx	r3, r3, #0, #9
24014750:	ee07 3a90 	vmov	s15, r3
24014754:	eef8 6a67 	vcvt.f32.u32	s13, s15
24014758:	ed97 6a03 	vldr	s12, [r7, #12]
2401475c:	eddf 5a44 	vldr	s11, [pc, #272]	; 24014870 <HAL_RCCEx_GetPLL2ClockFreq+0x288>
24014760:	eec6 7a25 	vdiv.f32	s15, s12, s11
24014764:	ee76 7aa7 	vadd.f32	s15, s13, s15
24014768:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
2401476c:	ee77 7aa6 	vadd.f32	s15, s15, s13
24014770:	ee67 7a27 	vmul.f32	s15, s14, s15
24014774:	edc7 7a07 	vstr	s15, [r7, #28]
      break;
24014778:	e021      	b.n	240147be <HAL_RCCEx_GetPLL2ClockFreq+0x1d6>

    default:
      pll2vco = ((float_t)CSI_VALUE / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2/(float_t)0x2000) +(float_t)1 );
2401477a:	697b      	ldr	r3, [r7, #20]
2401477c:	ee07 3a90 	vmov	s15, r3
24014780:	eef8 7a67 	vcvt.f32.u32	s15, s15
24014784:	eddf 6a3c 	vldr	s13, [pc, #240]	; 24014878 <HAL_RCCEx_GetPLL2ClockFreq+0x290>
24014788:	ee86 7aa7 	vdiv.f32	s14, s13, s15
2401478c:	4b36      	ldr	r3, [pc, #216]	; (24014868 <HAL_RCCEx_GetPLL2ClockFreq+0x280>)
2401478e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
24014790:	f3c3 0308 	ubfx	r3, r3, #0, #9
24014794:	ee07 3a90 	vmov	s15, r3
24014798:	eef8 6a67 	vcvt.f32.u32	s13, s15
2401479c:	ed97 6a03 	vldr	s12, [r7, #12]
240147a0:	eddf 5a33 	vldr	s11, [pc, #204]	; 24014870 <HAL_RCCEx_GetPLL2ClockFreq+0x288>
240147a4:	eec6 7a25 	vdiv.f32	s15, s12, s11
240147a8:	ee76 7aa7 	vadd.f32	s15, s13, s15
240147ac:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
240147b0:	ee77 7aa6 	vadd.f32	s15, s15, s13
240147b4:	ee67 7a27 	vmul.f32	s15, s14, s15
240147b8:	edc7 7a07 	vstr	s15, [r7, #28]
      break;
240147bc:	bf00      	nop
    }
    PLL2_Clocks->PLL2_P_Frequency = (uint32_t)(float_t)(pll2vco/((float_t)(uint32_t)((RCC->PLL2DIVR & RCC_PLL2DIVR_P2) >>9)  + (float_t)1 )) ;
240147be:	4b2a      	ldr	r3, [pc, #168]	; (24014868 <HAL_RCCEx_GetPLL2ClockFreq+0x280>)
240147c0:	6b9b      	ldr	r3, [r3, #56]	; 0x38
240147c2:	0a5b      	lsrs	r3, r3, #9
240147c4:	f003 037f 	and.w	r3, r3, #127	; 0x7f
240147c8:	ee07 3a90 	vmov	s15, r3
240147cc:	eef8 7a67 	vcvt.f32.u32	s15, s15
240147d0:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
240147d4:	ee37 7a87 	vadd.f32	s14, s15, s14
240147d8:	edd7 6a07 	vldr	s13, [r7, #28]
240147dc:	eec6 7a87 	vdiv.f32	s15, s13, s14
240147e0:	eefc 7ae7 	vcvt.u32.f32	s15, s15
240147e4:	ee17 2a90 	vmov	r2, s15
240147e8:	687b      	ldr	r3, [r7, #4]
240147ea:	601a      	str	r2, [r3, #0]
    PLL2_Clocks->PLL2_Q_Frequency = (uint32_t)(float_t)(pll2vco/((float_t)(uint32_t)((RCC->PLL2DIVR & RCC_PLL2DIVR_Q2) >>16) + (float_t)1 )) ;
240147ec:	4b1e      	ldr	r3, [pc, #120]	; (24014868 <HAL_RCCEx_GetPLL2ClockFreq+0x280>)
240147ee:	6b9b      	ldr	r3, [r3, #56]	; 0x38
240147f0:	0c1b      	lsrs	r3, r3, #16
240147f2:	f003 037f 	and.w	r3, r3, #127	; 0x7f
240147f6:	ee07 3a90 	vmov	s15, r3
240147fa:	eef8 7a67 	vcvt.f32.u32	s15, s15
240147fe:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
24014802:	ee37 7a87 	vadd.f32	s14, s15, s14
24014806:	edd7 6a07 	vldr	s13, [r7, #28]
2401480a:	eec6 7a87 	vdiv.f32	s15, s13, s14
2401480e:	eefc 7ae7 	vcvt.u32.f32	s15, s15
24014812:	ee17 2a90 	vmov	r2, s15
24014816:	687b      	ldr	r3, [r7, #4]
24014818:	605a      	str	r2, [r3, #4]
    PLL2_Clocks->PLL2_R_Frequency = (uint32_t)(float_t)(pll2vco/((float_t)(uint32_t)((RCC->PLL2DIVR & RCC_PLL2DIVR_R2) >>24) + (float_t)1 )) ;
2401481a:	4b13      	ldr	r3, [pc, #76]	; (24014868 <HAL_RCCEx_GetPLL2ClockFreq+0x280>)
2401481c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2401481e:	0e1b      	lsrs	r3, r3, #24
24014820:	f003 037f 	and.w	r3, r3, #127	; 0x7f
24014824:	ee07 3a90 	vmov	s15, r3
24014828:	eef8 7a67 	vcvt.f32.u32	s15, s15
2401482c:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
24014830:	ee37 7a87 	vadd.f32	s14, s15, s14
24014834:	edd7 6a07 	vldr	s13, [r7, #28]
24014838:	eec6 7a87 	vdiv.f32	s15, s13, s14
2401483c:	eefc 7ae7 	vcvt.u32.f32	s15, s15
24014840:	ee17 2a90 	vmov	r2, s15
24014844:	687b      	ldr	r3, [r7, #4]
24014846:	609a      	str	r2, [r3, #8]
  {
    PLL2_Clocks->PLL2_P_Frequency = 0U;
    PLL2_Clocks->PLL2_Q_Frequency = 0U;
    PLL2_Clocks->PLL2_R_Frequency = 0U;
  }
}
24014848:	e008      	b.n	2401485c <HAL_RCCEx_GetPLL2ClockFreq+0x274>
    PLL2_Clocks->PLL2_P_Frequency = 0U;
2401484a:	687b      	ldr	r3, [r7, #4]
2401484c:	2200      	movs	r2, #0
2401484e:	601a      	str	r2, [r3, #0]
    PLL2_Clocks->PLL2_Q_Frequency = 0U;
24014850:	687b      	ldr	r3, [r7, #4]
24014852:	2200      	movs	r2, #0
24014854:	605a      	str	r2, [r3, #4]
    PLL2_Clocks->PLL2_R_Frequency = 0U;
24014856:	687b      	ldr	r3, [r7, #4]
24014858:	2200      	movs	r2, #0
2401485a:	609a      	str	r2, [r3, #8]
}
2401485c:	bf00      	nop
2401485e:	3724      	adds	r7, #36	; 0x24
24014860:	46bd      	mov	sp, r7
24014862:	f85d 7b04 	ldr.w	r7, [sp], #4
24014866:	4770      	bx	lr
24014868:	58024400 	.word	0x58024400
2401486c:	03d09000 	.word	0x03d09000
24014870:	46000000 	.word	0x46000000
24014874:	4c742400 	.word	0x4c742400
24014878:	4a742400 	.word	0x4a742400
2401487c:	4bbebc20 	.word	0x4bbebc20

24014880 <HAL_RCCEx_GetPLL3ClockFreq>:
  *         right PLL3CLK value. Otherwise, any configuration based on this function will be incorrect.
  * @param  PLL3_Clocks structure.
  * @retval None
  */
void HAL_RCCEx_GetPLL3ClockFreq(PLL3_ClocksTypeDef* PLL3_Clocks)
{
24014880:	b480      	push	{r7}
24014882:	b089      	sub	sp, #36	; 0x24
24014884:	af00      	add	r7, sp, #0
24014886:	6078      	str	r0, [r7, #4]
  float_t fracn3, pll3vco;

  /* PLL3_VCO = (HSE_VALUE or HSI_VALUE or CSI_VALUE/ PLL3M) * PLL3N
     PLL3xCLK = PLL3_VCO / PLLxR
  */
  pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
24014888:	4b9d      	ldr	r3, [pc, #628]	; (24014b00 <HAL_RCCEx_GetPLL3ClockFreq+0x280>)
2401488a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
2401488c:	f003 0303 	and.w	r3, r3, #3
24014890:	61bb      	str	r3, [r7, #24]
  pll3m = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM3)>> 20)  ;
24014892:	4b9b      	ldr	r3, [pc, #620]	; (24014b00 <HAL_RCCEx_GetPLL3ClockFreq+0x280>)
24014894:	6a9b      	ldr	r3, [r3, #40]	; 0x28
24014896:	0d1b      	lsrs	r3, r3, #20
24014898:	f003 033f 	and.w	r3, r3, #63	; 0x3f
2401489c:	617b      	str	r3, [r7, #20]
  pll3fracen = (RCC->PLLCFGR & RCC_PLLCFGR_PLL3FRACEN) >> RCC_PLLCFGR_PLL3FRACEN_Pos;
2401489e:	4b98      	ldr	r3, [pc, #608]	; (24014b00 <HAL_RCCEx_GetPLL3ClockFreq+0x280>)
240148a0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
240148a2:	0a1b      	lsrs	r3, r3, #8
240148a4:	f003 0301 	and.w	r3, r3, #1
240148a8:	613b      	str	r3, [r7, #16]
  fracn3 = (float_t)(uint32_t)(pll3fracen* ((RCC->PLL3FRACR & RCC_PLL3FRACR_FRACN3)>> 3));
240148aa:	4b95      	ldr	r3, [pc, #596]	; (24014b00 <HAL_RCCEx_GetPLL3ClockFreq+0x280>)
240148ac:	6c5b      	ldr	r3, [r3, #68]	; 0x44
240148ae:	08db      	lsrs	r3, r3, #3
240148b0:	f3c3 030c 	ubfx	r3, r3, #0, #13
240148b4:	693a      	ldr	r2, [r7, #16]
240148b6:	fb02 f303 	mul.w	r3, r2, r3
240148ba:	ee07 3a90 	vmov	s15, r3
240148be:	eef8 7a67 	vcvt.f32.u32	s15, s15
240148c2:	edc7 7a03 	vstr	s15, [r7, #12]

  if (pll3m != 0U)
240148c6:	697b      	ldr	r3, [r7, #20]
240148c8:	2b00      	cmp	r3, #0
240148ca:	f000 810a 	beq.w	24014ae2 <HAL_RCCEx_GetPLL3ClockFreq+0x262>
  {
    switch (pllsource)
240148ce:	69bb      	ldr	r3, [r7, #24]
240148d0:	2b01      	cmp	r3, #1
240148d2:	d05a      	beq.n	2401498a <HAL_RCCEx_GetPLL3ClockFreq+0x10a>
240148d4:	2b01      	cmp	r3, #1
240148d6:	d302      	bcc.n	240148de <HAL_RCCEx_GetPLL3ClockFreq+0x5e>
240148d8:	2b02      	cmp	r3, #2
240148da:	d078      	beq.n	240149ce <HAL_RCCEx_GetPLL3ClockFreq+0x14e>
240148dc:	e099      	b.n	24014a12 <HAL_RCCEx_GetPLL3ClockFreq+0x192>
    {
    case RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */

      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
240148de:	4b88      	ldr	r3, [pc, #544]	; (24014b00 <HAL_RCCEx_GetPLL3ClockFreq+0x280>)
240148e0:	681b      	ldr	r3, [r3, #0]
240148e2:	f003 0320 	and.w	r3, r3, #32
240148e6:	2b00      	cmp	r3, #0
240148e8:	d02d      	beq.n	24014946 <HAL_RCCEx_GetPLL3ClockFreq+0xc6>
      {
        hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
240148ea:	4b85      	ldr	r3, [pc, #532]	; (24014b00 <HAL_RCCEx_GetPLL3ClockFreq+0x280>)
240148ec:	681b      	ldr	r3, [r3, #0]
240148ee:	08db      	lsrs	r3, r3, #3
240148f0:	f003 0303 	and.w	r3, r3, #3
240148f4:	4a83      	ldr	r2, [pc, #524]	; (24014b04 <HAL_RCCEx_GetPLL3ClockFreq+0x284>)
240148f6:	fa22 f303 	lsr.w	r3, r2, r3
240148fa:	60bb      	str	r3, [r7, #8]
        pll3vco = ((float_t)hsivalue / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3/(float_t)0x2000) +(float_t)1 );
240148fc:	68bb      	ldr	r3, [r7, #8]
240148fe:	ee07 3a90 	vmov	s15, r3
24014902:	eef8 6a67 	vcvt.f32.u32	s13, s15
24014906:	697b      	ldr	r3, [r7, #20]
24014908:	ee07 3a90 	vmov	s15, r3
2401490c:	eef8 7a67 	vcvt.f32.u32	s15, s15
24014910:	ee86 7aa7 	vdiv.f32	s14, s13, s15
24014914:	4b7a      	ldr	r3, [pc, #488]	; (24014b00 <HAL_RCCEx_GetPLL3ClockFreq+0x280>)
24014916:	6c1b      	ldr	r3, [r3, #64]	; 0x40
24014918:	f3c3 0308 	ubfx	r3, r3, #0, #9
2401491c:	ee07 3a90 	vmov	s15, r3
24014920:	eef8 6a67 	vcvt.f32.u32	s13, s15
24014924:	ed97 6a03 	vldr	s12, [r7, #12]
24014928:	eddf 5a77 	vldr	s11, [pc, #476]	; 24014b08 <HAL_RCCEx_GetPLL3ClockFreq+0x288>
2401492c:	eec6 7a25 	vdiv.f32	s15, s12, s11
24014930:	ee76 7aa7 	vadd.f32	s15, s13, s15
24014934:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
24014938:	ee77 7aa6 	vadd.f32	s15, s15, s13
2401493c:	ee67 7a27 	vmul.f32	s15, s14, s15
24014940:	edc7 7a07 	vstr	s15, [r7, #28]
      }
      else
      {
        pll3vco = ((float_t)HSI_VALUE / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3/(float_t)0x2000) +(float_t)1 );
      }
      break;
24014944:	e087      	b.n	24014a56 <HAL_RCCEx_GetPLL3ClockFreq+0x1d6>
        pll3vco = ((float_t)HSI_VALUE / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3/(float_t)0x2000) +(float_t)1 );
24014946:	697b      	ldr	r3, [r7, #20]
24014948:	ee07 3a90 	vmov	s15, r3
2401494c:	eef8 7a67 	vcvt.f32.u32	s15, s15
24014950:	eddf 6a6e 	vldr	s13, [pc, #440]	; 24014b0c <HAL_RCCEx_GetPLL3ClockFreq+0x28c>
24014954:	ee86 7aa7 	vdiv.f32	s14, s13, s15
24014958:	4b69      	ldr	r3, [pc, #420]	; (24014b00 <HAL_RCCEx_GetPLL3ClockFreq+0x280>)
2401495a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
2401495c:	f3c3 0308 	ubfx	r3, r3, #0, #9
24014960:	ee07 3a90 	vmov	s15, r3
24014964:	eef8 6a67 	vcvt.f32.u32	s13, s15
24014968:	ed97 6a03 	vldr	s12, [r7, #12]
2401496c:	eddf 5a66 	vldr	s11, [pc, #408]	; 24014b08 <HAL_RCCEx_GetPLL3ClockFreq+0x288>
24014970:	eec6 7a25 	vdiv.f32	s15, s12, s11
24014974:	ee76 7aa7 	vadd.f32	s15, s13, s15
24014978:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
2401497c:	ee77 7aa6 	vadd.f32	s15, s15, s13
24014980:	ee67 7a27 	vmul.f32	s15, s14, s15
24014984:	edc7 7a07 	vstr	s15, [r7, #28]
      break;
24014988:	e065      	b.n	24014a56 <HAL_RCCEx_GetPLL3ClockFreq+0x1d6>
    case RCC_PLLSOURCE_CSI:  /* CSI used as PLL clock source */
      pll3vco = ((float_t)CSI_VALUE / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3/(float_t)0x2000) +(float_t)1 );
2401498a:	697b      	ldr	r3, [r7, #20]
2401498c:	ee07 3a90 	vmov	s15, r3
24014990:	eef8 7a67 	vcvt.f32.u32	s15, s15
24014994:	eddf 6a5e 	vldr	s13, [pc, #376]	; 24014b10 <HAL_RCCEx_GetPLL3ClockFreq+0x290>
24014998:	ee86 7aa7 	vdiv.f32	s14, s13, s15
2401499c:	4b58      	ldr	r3, [pc, #352]	; (24014b00 <HAL_RCCEx_GetPLL3ClockFreq+0x280>)
2401499e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
240149a0:	f3c3 0308 	ubfx	r3, r3, #0, #9
240149a4:	ee07 3a90 	vmov	s15, r3
240149a8:	eef8 6a67 	vcvt.f32.u32	s13, s15
240149ac:	ed97 6a03 	vldr	s12, [r7, #12]
240149b0:	eddf 5a55 	vldr	s11, [pc, #340]	; 24014b08 <HAL_RCCEx_GetPLL3ClockFreq+0x288>
240149b4:	eec6 7a25 	vdiv.f32	s15, s12, s11
240149b8:	ee76 7aa7 	vadd.f32	s15, s13, s15
240149bc:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
240149c0:	ee77 7aa6 	vadd.f32	s15, s15, s13
240149c4:	ee67 7a27 	vmul.f32	s15, s14, s15
240149c8:	edc7 7a07 	vstr	s15, [r7, #28]
      break;
240149cc:	e043      	b.n	24014a56 <HAL_RCCEx_GetPLL3ClockFreq+0x1d6>

    case RCC_PLLSOURCE_HSE:  /* HSE used as PLL clock source */
      pll3vco = ((float_t)HSE_VALUE / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3/(float_t)0x2000) +(float_t)1 );
240149ce:	697b      	ldr	r3, [r7, #20]
240149d0:	ee07 3a90 	vmov	s15, r3
240149d4:	eef8 7a67 	vcvt.f32.u32	s15, s15
240149d8:	eddf 6a4e 	vldr	s13, [pc, #312]	; 24014b14 <HAL_RCCEx_GetPLL3ClockFreq+0x294>
240149dc:	ee86 7aa7 	vdiv.f32	s14, s13, s15
240149e0:	4b47      	ldr	r3, [pc, #284]	; (24014b00 <HAL_RCCEx_GetPLL3ClockFreq+0x280>)
240149e2:	6c1b      	ldr	r3, [r3, #64]	; 0x40
240149e4:	f3c3 0308 	ubfx	r3, r3, #0, #9
240149e8:	ee07 3a90 	vmov	s15, r3
240149ec:	eef8 6a67 	vcvt.f32.u32	s13, s15
240149f0:	ed97 6a03 	vldr	s12, [r7, #12]
240149f4:	eddf 5a44 	vldr	s11, [pc, #272]	; 24014b08 <HAL_RCCEx_GetPLL3ClockFreq+0x288>
240149f8:	eec6 7a25 	vdiv.f32	s15, s12, s11
240149fc:	ee76 7aa7 	vadd.f32	s15, s13, s15
24014a00:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
24014a04:	ee77 7aa6 	vadd.f32	s15, s15, s13
24014a08:	ee67 7a27 	vmul.f32	s15, s14, s15
24014a0c:	edc7 7a07 	vstr	s15, [r7, #28]
      break;
24014a10:	e021      	b.n	24014a56 <HAL_RCCEx_GetPLL3ClockFreq+0x1d6>

    default:
      pll3vco = ((float_t)CSI_VALUE / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3/(float_t)0x2000) +(float_t)1 );
24014a12:	697b      	ldr	r3, [r7, #20]
24014a14:	ee07 3a90 	vmov	s15, r3
24014a18:	eef8 7a67 	vcvt.f32.u32	s15, s15
24014a1c:	eddf 6a3c 	vldr	s13, [pc, #240]	; 24014b10 <HAL_RCCEx_GetPLL3ClockFreq+0x290>
24014a20:	ee86 7aa7 	vdiv.f32	s14, s13, s15
24014a24:	4b36      	ldr	r3, [pc, #216]	; (24014b00 <HAL_RCCEx_GetPLL3ClockFreq+0x280>)
24014a26:	6c1b      	ldr	r3, [r3, #64]	; 0x40
24014a28:	f3c3 0308 	ubfx	r3, r3, #0, #9
24014a2c:	ee07 3a90 	vmov	s15, r3
24014a30:	eef8 6a67 	vcvt.f32.u32	s13, s15
24014a34:	ed97 6a03 	vldr	s12, [r7, #12]
24014a38:	eddf 5a33 	vldr	s11, [pc, #204]	; 24014b08 <HAL_RCCEx_GetPLL3ClockFreq+0x288>
24014a3c:	eec6 7a25 	vdiv.f32	s15, s12, s11
24014a40:	ee76 7aa7 	vadd.f32	s15, s13, s15
24014a44:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
24014a48:	ee77 7aa6 	vadd.f32	s15, s15, s13
24014a4c:	ee67 7a27 	vmul.f32	s15, s14, s15
24014a50:	edc7 7a07 	vstr	s15, [r7, #28]
      break;
24014a54:	bf00      	nop
    }
    PLL3_Clocks->PLL3_P_Frequency = (uint32_t)(float_t)(pll3vco/((float_t)(uint32_t)((RCC->PLL3DIVR & RCC_PLL3DIVR_P3) >>9)  + (float_t)1 )) ;
24014a56:	4b2a      	ldr	r3, [pc, #168]	; (24014b00 <HAL_RCCEx_GetPLL3ClockFreq+0x280>)
24014a58:	6c1b      	ldr	r3, [r3, #64]	; 0x40
24014a5a:	0a5b      	lsrs	r3, r3, #9
24014a5c:	f003 037f 	and.w	r3, r3, #127	; 0x7f
24014a60:	ee07 3a90 	vmov	s15, r3
24014a64:	eef8 7a67 	vcvt.f32.u32	s15, s15
24014a68:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
24014a6c:	ee37 7a87 	vadd.f32	s14, s15, s14
24014a70:	edd7 6a07 	vldr	s13, [r7, #28]
24014a74:	eec6 7a87 	vdiv.f32	s15, s13, s14
24014a78:	eefc 7ae7 	vcvt.u32.f32	s15, s15
24014a7c:	ee17 2a90 	vmov	r2, s15
24014a80:	687b      	ldr	r3, [r7, #4]
24014a82:	601a      	str	r2, [r3, #0]
    PLL3_Clocks->PLL3_Q_Frequency = (uint32_t)(float_t)(pll3vco/((float_t)(uint32_t)((RCC->PLL3DIVR & RCC_PLL3DIVR_Q3) >>16) + (float_t)1 )) ;
24014a84:	4b1e      	ldr	r3, [pc, #120]	; (24014b00 <HAL_RCCEx_GetPLL3ClockFreq+0x280>)
24014a86:	6c1b      	ldr	r3, [r3, #64]	; 0x40
24014a88:	0c1b      	lsrs	r3, r3, #16
24014a8a:	f003 037f 	and.w	r3, r3, #127	; 0x7f
24014a8e:	ee07 3a90 	vmov	s15, r3
24014a92:	eef8 7a67 	vcvt.f32.u32	s15, s15
24014a96:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
24014a9a:	ee37 7a87 	vadd.f32	s14, s15, s14
24014a9e:	edd7 6a07 	vldr	s13, [r7, #28]
24014aa2:	eec6 7a87 	vdiv.f32	s15, s13, s14
24014aa6:	eefc 7ae7 	vcvt.u32.f32	s15, s15
24014aaa:	ee17 2a90 	vmov	r2, s15
24014aae:	687b      	ldr	r3, [r7, #4]
24014ab0:	605a      	str	r2, [r3, #4]
    PLL3_Clocks->PLL3_R_Frequency = (uint32_t)(float_t)(pll3vco/((float_t)(uint32_t)((RCC->PLL3DIVR & RCC_PLL3DIVR_R3) >>24) + (float_t)1 )) ;
24014ab2:	4b13      	ldr	r3, [pc, #76]	; (24014b00 <HAL_RCCEx_GetPLL3ClockFreq+0x280>)
24014ab4:	6c1b      	ldr	r3, [r3, #64]	; 0x40
24014ab6:	0e1b      	lsrs	r3, r3, #24
24014ab8:	f003 037f 	and.w	r3, r3, #127	; 0x7f
24014abc:	ee07 3a90 	vmov	s15, r3
24014ac0:	eef8 7a67 	vcvt.f32.u32	s15, s15
24014ac4:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
24014ac8:	ee37 7a87 	vadd.f32	s14, s15, s14
24014acc:	edd7 6a07 	vldr	s13, [r7, #28]
24014ad0:	eec6 7a87 	vdiv.f32	s15, s13, s14
24014ad4:	eefc 7ae7 	vcvt.u32.f32	s15, s15
24014ad8:	ee17 2a90 	vmov	r2, s15
24014adc:	687b      	ldr	r3, [r7, #4]
24014ade:	609a      	str	r2, [r3, #8]
    PLL3_Clocks->PLL3_P_Frequency = 0U;
    PLL3_Clocks->PLL3_Q_Frequency = 0U;
    PLL3_Clocks->PLL3_R_Frequency = 0U;
  }

}
24014ae0:	e008      	b.n	24014af4 <HAL_RCCEx_GetPLL3ClockFreq+0x274>
    PLL3_Clocks->PLL3_P_Frequency = 0U;
24014ae2:	687b      	ldr	r3, [r7, #4]
24014ae4:	2200      	movs	r2, #0
24014ae6:	601a      	str	r2, [r3, #0]
    PLL3_Clocks->PLL3_Q_Frequency = 0U;
24014ae8:	687b      	ldr	r3, [r7, #4]
24014aea:	2200      	movs	r2, #0
24014aec:	605a      	str	r2, [r3, #4]
    PLL3_Clocks->PLL3_R_Frequency = 0U;
24014aee:	687b      	ldr	r3, [r7, #4]
24014af0:	2200      	movs	r2, #0
24014af2:	609a      	str	r2, [r3, #8]
}
24014af4:	bf00      	nop
24014af6:	3724      	adds	r7, #36	; 0x24
24014af8:	46bd      	mov	sp, r7
24014afa:	f85d 7b04 	ldr.w	r7, [sp], #4
24014afe:	4770      	bx	lr
24014b00:	58024400 	.word	0x58024400
24014b04:	03d09000 	.word	0x03d09000
24014b08:	46000000 	.word	0x46000000
24014b0c:	4c742400 	.word	0x4c742400
24014b10:	4a742400 	.word	0x4a742400
24014b14:	4bbebc20 	.word	0x4bbebc20

24014b18 <HAL_RCCEx_GetPLL1ClockFreq>:
  *         right PLL1CLK value. Otherwise, any configuration based on this function will be incorrect.
  * @param  PLL1_Clocks structure.
  * @retval None
  */
void HAL_RCCEx_GetPLL1ClockFreq(PLL1_ClocksTypeDef* PLL1_Clocks)
{
24014b18:	b480      	push	{r7}
24014b1a:	b089      	sub	sp, #36	; 0x24
24014b1c:	af00      	add	r7, sp, #0
24014b1e:	6078      	str	r0, [r7, #4]
  uint32_t pllsource, pll1m, pll1fracen, hsivalue;
  float_t fracn1, pll1vco;

  pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
24014b20:	4b9d      	ldr	r3, [pc, #628]	; (24014d98 <HAL_RCCEx_GetPLL1ClockFreq+0x280>)
24014b22:	6a9b      	ldr	r3, [r3, #40]	; 0x28
24014b24:	f003 0303 	and.w	r3, r3, #3
24014b28:	61bb      	str	r3, [r7, #24]
  pll1m = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM1)>> 4);
24014b2a:	4b9b      	ldr	r3, [pc, #620]	; (24014d98 <HAL_RCCEx_GetPLL1ClockFreq+0x280>)
24014b2c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
24014b2e:	091b      	lsrs	r3, r3, #4
24014b30:	f003 033f 	and.w	r3, r3, #63	; 0x3f
24014b34:	617b      	str	r3, [r7, #20]
  pll1fracen = RCC->PLLCFGR & RCC_PLLCFGR_PLL1FRACEN;
24014b36:	4b98      	ldr	r3, [pc, #608]	; (24014d98 <HAL_RCCEx_GetPLL1ClockFreq+0x280>)
24014b38:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24014b3a:	f003 0301 	and.w	r3, r3, #1
24014b3e:	613b      	str	r3, [r7, #16]
  fracn1 = (float_t)(uint32_t)(pll1fracen * ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1)>> 3));
24014b40:	4b95      	ldr	r3, [pc, #596]	; (24014d98 <HAL_RCCEx_GetPLL1ClockFreq+0x280>)
24014b42:	6b5b      	ldr	r3, [r3, #52]	; 0x34
24014b44:	08db      	lsrs	r3, r3, #3
24014b46:	f3c3 030c 	ubfx	r3, r3, #0, #13
24014b4a:	693a      	ldr	r2, [r7, #16]
24014b4c:	fb02 f303 	mul.w	r3, r2, r3
24014b50:	ee07 3a90 	vmov	s15, r3
24014b54:	eef8 7a67 	vcvt.f32.u32	s15, s15
24014b58:	edc7 7a03 	vstr	s15, [r7, #12]

  if (pll1m != 0U)
24014b5c:	697b      	ldr	r3, [r7, #20]
24014b5e:	2b00      	cmp	r3, #0
24014b60:	f000 810a 	beq.w	24014d78 <HAL_RCCEx_GetPLL1ClockFreq+0x260>
  {
    switch (pllsource)
24014b64:	69bb      	ldr	r3, [r7, #24]
24014b66:	2b01      	cmp	r3, #1
24014b68:	d05a      	beq.n	24014c20 <HAL_RCCEx_GetPLL1ClockFreq+0x108>
24014b6a:	2b01      	cmp	r3, #1
24014b6c:	d302      	bcc.n	24014b74 <HAL_RCCEx_GetPLL1ClockFreq+0x5c>
24014b6e:	2b02      	cmp	r3, #2
24014b70:	d078      	beq.n	24014c64 <HAL_RCCEx_GetPLL1ClockFreq+0x14c>
24014b72:	e099      	b.n	24014ca8 <HAL_RCCEx_GetPLL1ClockFreq+0x190>
    {

    case RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */

      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
24014b74:	4b88      	ldr	r3, [pc, #544]	; (24014d98 <HAL_RCCEx_GetPLL1ClockFreq+0x280>)
24014b76:	681b      	ldr	r3, [r3, #0]
24014b78:	f003 0320 	and.w	r3, r3, #32
24014b7c:	2b00      	cmp	r3, #0
24014b7e:	d02d      	beq.n	24014bdc <HAL_RCCEx_GetPLL1ClockFreq+0xc4>
      {
        hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
24014b80:	4b85      	ldr	r3, [pc, #532]	; (24014d98 <HAL_RCCEx_GetPLL1ClockFreq+0x280>)
24014b82:	681b      	ldr	r3, [r3, #0]
24014b84:	08db      	lsrs	r3, r3, #3
24014b86:	f003 0303 	and.w	r3, r3, #3
24014b8a:	4a84      	ldr	r2, [pc, #528]	; (24014d9c <HAL_RCCEx_GetPLL1ClockFreq+0x284>)
24014b8c:	fa22 f303 	lsr.w	r3, r2, r3
24014b90:	60bb      	str	r3, [r7, #8]
        pll1vco = ((float_t)hsivalue / (float_t)pll1m) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
24014b92:	68bb      	ldr	r3, [r7, #8]
24014b94:	ee07 3a90 	vmov	s15, r3
24014b98:	eef8 6a67 	vcvt.f32.u32	s13, s15
24014b9c:	697b      	ldr	r3, [r7, #20]
24014b9e:	ee07 3a90 	vmov	s15, r3
24014ba2:	eef8 7a67 	vcvt.f32.u32	s15, s15
24014ba6:	ee86 7aa7 	vdiv.f32	s14, s13, s15
24014baa:	4b7b      	ldr	r3, [pc, #492]	; (24014d98 <HAL_RCCEx_GetPLL1ClockFreq+0x280>)
24014bac:	6b1b      	ldr	r3, [r3, #48]	; 0x30
24014bae:	f3c3 0308 	ubfx	r3, r3, #0, #9
24014bb2:	ee07 3a90 	vmov	s15, r3
24014bb6:	eef8 6a67 	vcvt.f32.u32	s13, s15
24014bba:	ed97 6a03 	vldr	s12, [r7, #12]
24014bbe:	eddf 5a78 	vldr	s11, [pc, #480]	; 24014da0 <HAL_RCCEx_GetPLL1ClockFreq+0x288>
24014bc2:	eec6 7a25 	vdiv.f32	s15, s12, s11
24014bc6:	ee76 7aa7 	vadd.f32	s15, s13, s15
24014bca:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
24014bce:	ee77 7aa6 	vadd.f32	s15, s15, s13
24014bd2:	ee67 7a27 	vmul.f32	s15, s14, s15
24014bd6:	edc7 7a07 	vstr	s15, [r7, #28]
      }
      else
      {
        pll1vco = ((float_t)HSI_VALUE / (float_t)pll1m) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
      }
      break;
24014bda:	e087      	b.n	24014cec <HAL_RCCEx_GetPLL1ClockFreq+0x1d4>
        pll1vco = ((float_t)HSI_VALUE / (float_t)pll1m) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
24014bdc:	697b      	ldr	r3, [r7, #20]
24014bde:	ee07 3a90 	vmov	s15, r3
24014be2:	eef8 7a67 	vcvt.f32.u32	s15, s15
24014be6:	eddf 6a6f 	vldr	s13, [pc, #444]	; 24014da4 <HAL_RCCEx_GetPLL1ClockFreq+0x28c>
24014bea:	ee86 7aa7 	vdiv.f32	s14, s13, s15
24014bee:	4b6a      	ldr	r3, [pc, #424]	; (24014d98 <HAL_RCCEx_GetPLL1ClockFreq+0x280>)
24014bf0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
24014bf2:	f3c3 0308 	ubfx	r3, r3, #0, #9
24014bf6:	ee07 3a90 	vmov	s15, r3
24014bfa:	eef8 6a67 	vcvt.f32.u32	s13, s15
24014bfe:	ed97 6a03 	vldr	s12, [r7, #12]
24014c02:	eddf 5a67 	vldr	s11, [pc, #412]	; 24014da0 <HAL_RCCEx_GetPLL1ClockFreq+0x288>
24014c06:	eec6 7a25 	vdiv.f32	s15, s12, s11
24014c0a:	ee76 7aa7 	vadd.f32	s15, s13, s15
24014c0e:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
24014c12:	ee77 7aa6 	vadd.f32	s15, s15, s13
24014c16:	ee67 7a27 	vmul.f32	s15, s14, s15
24014c1a:	edc7 7a07 	vstr	s15, [r7, #28]
      break;
24014c1e:	e065      	b.n	24014cec <HAL_RCCEx_GetPLL1ClockFreq+0x1d4>
    case RCC_PLLSOURCE_CSI:  /* CSI used as PLL clock source */
      pll1vco = ((float_t)CSI_VALUE / (float_t)pll1m) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
24014c20:	697b      	ldr	r3, [r7, #20]
24014c22:	ee07 3a90 	vmov	s15, r3
24014c26:	eef8 7a67 	vcvt.f32.u32	s15, s15
24014c2a:	eddf 6a5f 	vldr	s13, [pc, #380]	; 24014da8 <HAL_RCCEx_GetPLL1ClockFreq+0x290>
24014c2e:	ee86 7aa7 	vdiv.f32	s14, s13, s15
24014c32:	4b59      	ldr	r3, [pc, #356]	; (24014d98 <HAL_RCCEx_GetPLL1ClockFreq+0x280>)
24014c34:	6b1b      	ldr	r3, [r3, #48]	; 0x30
24014c36:	f3c3 0308 	ubfx	r3, r3, #0, #9
24014c3a:	ee07 3a90 	vmov	s15, r3
24014c3e:	eef8 6a67 	vcvt.f32.u32	s13, s15
24014c42:	ed97 6a03 	vldr	s12, [r7, #12]
24014c46:	eddf 5a56 	vldr	s11, [pc, #344]	; 24014da0 <HAL_RCCEx_GetPLL1ClockFreq+0x288>
24014c4a:	eec6 7a25 	vdiv.f32	s15, s12, s11
24014c4e:	ee76 7aa7 	vadd.f32	s15, s13, s15
24014c52:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
24014c56:	ee77 7aa6 	vadd.f32	s15, s15, s13
24014c5a:	ee67 7a27 	vmul.f32	s15, s14, s15
24014c5e:	edc7 7a07 	vstr	s15, [r7, #28]
      break;
24014c62:	e043      	b.n	24014cec <HAL_RCCEx_GetPLL1ClockFreq+0x1d4>

    case RCC_PLLSOURCE_HSE:  /* HSE used as PLL clock source */
      pll1vco = ((float_t)HSE_VALUE / (float_t)pll1m) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
24014c64:	697b      	ldr	r3, [r7, #20]
24014c66:	ee07 3a90 	vmov	s15, r3
24014c6a:	eef8 7a67 	vcvt.f32.u32	s15, s15
24014c6e:	eddf 6a4f 	vldr	s13, [pc, #316]	; 24014dac <HAL_RCCEx_GetPLL1ClockFreq+0x294>
24014c72:	ee86 7aa7 	vdiv.f32	s14, s13, s15
24014c76:	4b48      	ldr	r3, [pc, #288]	; (24014d98 <HAL_RCCEx_GetPLL1ClockFreq+0x280>)
24014c78:	6b1b      	ldr	r3, [r3, #48]	; 0x30
24014c7a:	f3c3 0308 	ubfx	r3, r3, #0, #9
24014c7e:	ee07 3a90 	vmov	s15, r3
24014c82:	eef8 6a67 	vcvt.f32.u32	s13, s15
24014c86:	ed97 6a03 	vldr	s12, [r7, #12]
24014c8a:	eddf 5a45 	vldr	s11, [pc, #276]	; 24014da0 <HAL_RCCEx_GetPLL1ClockFreq+0x288>
24014c8e:	eec6 7a25 	vdiv.f32	s15, s12, s11
24014c92:	ee76 7aa7 	vadd.f32	s15, s13, s15
24014c96:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
24014c9a:	ee77 7aa6 	vadd.f32	s15, s15, s13
24014c9e:	ee67 7a27 	vmul.f32	s15, s14, s15
24014ca2:	edc7 7a07 	vstr	s15, [r7, #28]
      break;
24014ca6:	e021      	b.n	24014cec <HAL_RCCEx_GetPLL1ClockFreq+0x1d4>

    default:
      pll1vco = ((float_t)CSI_VALUE / (float_t)pll1m) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
24014ca8:	697b      	ldr	r3, [r7, #20]
24014caa:	ee07 3a90 	vmov	s15, r3
24014cae:	eef8 7a67 	vcvt.f32.u32	s15, s15
24014cb2:	eddf 6a3d 	vldr	s13, [pc, #244]	; 24014da8 <HAL_RCCEx_GetPLL1ClockFreq+0x290>
24014cb6:	ee86 7aa7 	vdiv.f32	s14, s13, s15
24014cba:	4b37      	ldr	r3, [pc, #220]	; (24014d98 <HAL_RCCEx_GetPLL1ClockFreq+0x280>)
24014cbc:	6b1b      	ldr	r3, [r3, #48]	; 0x30
24014cbe:	f3c3 0308 	ubfx	r3, r3, #0, #9
24014cc2:	ee07 3a90 	vmov	s15, r3
24014cc6:	eef8 6a67 	vcvt.f32.u32	s13, s15
24014cca:	ed97 6a03 	vldr	s12, [r7, #12]
24014cce:	eddf 5a34 	vldr	s11, [pc, #208]	; 24014da0 <HAL_RCCEx_GetPLL1ClockFreq+0x288>
24014cd2:	eec6 7a25 	vdiv.f32	s15, s12, s11
24014cd6:	ee76 7aa7 	vadd.f32	s15, s13, s15
24014cda:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
24014cde:	ee77 7aa6 	vadd.f32	s15, s15, s13
24014ce2:	ee67 7a27 	vmul.f32	s15, s14, s15
24014ce6:	edc7 7a07 	vstr	s15, [r7, #28]
      break;
24014cea:	bf00      	nop
    }

    PLL1_Clocks->PLL1_P_Frequency = (uint32_t)(float_t)(pll1vco/((float_t)(uint32_t)((RCC->PLL1DIVR & RCC_PLL1DIVR_P1) >>9)  + (float_t)1 )) ;
24014cec:	4b2a      	ldr	r3, [pc, #168]	; (24014d98 <HAL_RCCEx_GetPLL1ClockFreq+0x280>)
24014cee:	6b1b      	ldr	r3, [r3, #48]	; 0x30
24014cf0:	0a5b      	lsrs	r3, r3, #9
24014cf2:	f003 037f 	and.w	r3, r3, #127	; 0x7f
24014cf6:	ee07 3a90 	vmov	s15, r3
24014cfa:	eef8 7a67 	vcvt.f32.u32	s15, s15
24014cfe:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
24014d02:	ee37 7a87 	vadd.f32	s14, s15, s14
24014d06:	edd7 6a07 	vldr	s13, [r7, #28]
24014d0a:	eec6 7a87 	vdiv.f32	s15, s13, s14
24014d0e:	eefc 7ae7 	vcvt.u32.f32	s15, s15
24014d12:	ee17 2a90 	vmov	r2, s15
24014d16:	687b      	ldr	r3, [r7, #4]
24014d18:	601a      	str	r2, [r3, #0]
    PLL1_Clocks->PLL1_Q_Frequency = (uint32_t)(float_t)(pll1vco/((float_t)(uint32_t)((RCC->PLL1DIVR & RCC_PLL1DIVR_Q1) >>16) + (float_t)1 )) ;
24014d1a:	4b1f      	ldr	r3, [pc, #124]	; (24014d98 <HAL_RCCEx_GetPLL1ClockFreq+0x280>)
24014d1c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
24014d1e:	0c1b      	lsrs	r3, r3, #16
24014d20:	f003 037f 	and.w	r3, r3, #127	; 0x7f
24014d24:	ee07 3a90 	vmov	s15, r3
24014d28:	eef8 7a67 	vcvt.f32.u32	s15, s15
24014d2c:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
24014d30:	ee37 7a87 	vadd.f32	s14, s15, s14
24014d34:	edd7 6a07 	vldr	s13, [r7, #28]
24014d38:	eec6 7a87 	vdiv.f32	s15, s13, s14
24014d3c:	eefc 7ae7 	vcvt.u32.f32	s15, s15
24014d40:	ee17 2a90 	vmov	r2, s15
24014d44:	687b      	ldr	r3, [r7, #4]
24014d46:	605a      	str	r2, [r3, #4]
    PLL1_Clocks->PLL1_R_Frequency = (uint32_t)(float_t)(pll1vco/((float_t)(uint32_t)((RCC->PLL1DIVR & RCC_PLL1DIVR_R1) >>24) + (float_t)1 )) ;
24014d48:	4b13      	ldr	r3, [pc, #76]	; (24014d98 <HAL_RCCEx_GetPLL1ClockFreq+0x280>)
24014d4a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
24014d4c:	0e1b      	lsrs	r3, r3, #24
24014d4e:	f003 037f 	and.w	r3, r3, #127	; 0x7f
24014d52:	ee07 3a90 	vmov	s15, r3
24014d56:	eef8 7a67 	vcvt.f32.u32	s15, s15
24014d5a:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
24014d5e:	ee37 7a87 	vadd.f32	s14, s15, s14
24014d62:	edd7 6a07 	vldr	s13, [r7, #28]
24014d66:	eec6 7a87 	vdiv.f32	s15, s13, s14
24014d6a:	eefc 7ae7 	vcvt.u32.f32	s15, s15
24014d6e:	ee17 2a90 	vmov	r2, s15
24014d72:	687b      	ldr	r3, [r7, #4]
24014d74:	609a      	str	r2, [r3, #8]
    PLL1_Clocks->PLL1_P_Frequency = 0U;
    PLL1_Clocks->PLL1_Q_Frequency = 0U;
    PLL1_Clocks->PLL1_R_Frequency = 0U;
  }

}
24014d76:	e008      	b.n	24014d8a <HAL_RCCEx_GetPLL1ClockFreq+0x272>
    PLL1_Clocks->PLL1_P_Frequency = 0U;
24014d78:	687b      	ldr	r3, [r7, #4]
24014d7a:	2200      	movs	r2, #0
24014d7c:	601a      	str	r2, [r3, #0]
    PLL1_Clocks->PLL1_Q_Frequency = 0U;
24014d7e:	687b      	ldr	r3, [r7, #4]
24014d80:	2200      	movs	r2, #0
24014d82:	605a      	str	r2, [r3, #4]
    PLL1_Clocks->PLL1_R_Frequency = 0U;
24014d84:	687b      	ldr	r3, [r7, #4]
24014d86:	2200      	movs	r2, #0
24014d88:	609a      	str	r2, [r3, #8]
}
24014d8a:	bf00      	nop
24014d8c:	3724      	adds	r7, #36	; 0x24
24014d8e:	46bd      	mov	sp, r7
24014d90:	f85d 7b04 	ldr.w	r7, [sp], #4
24014d94:	4770      	bx	lr
24014d96:	bf00      	nop
24014d98:	58024400 	.word	0x58024400
24014d9c:	03d09000 	.word	0x03d09000
24014da0:	46000000 	.word	0x46000000
24014da4:	4c742400 	.word	0x4c742400
24014da8:	4a742400 	.word	0x4a742400
24014dac:	4bbebc20 	.word	0x4bbebc20

24014db0 <HAL_RCCEx_GetD1SysClockFreq>:
  * @note   The SystemCoreClock CMSIS variable is used to store System current Core Clock Frequency
  *         and updated within this function
  * @retval HCLK frequency
  */
uint32_t HAL_RCCEx_GetD1SysClockFreq(void)
{
24014db0:	b580      	push	{r7, lr}
24014db2:	b082      	sub	sp, #8
24014db4:	af00      	add	r7, sp, #0
uint32_t common_system_clock;

#if defined(RCC_D1CFGR_D1CPRE)
  common_system_clock = HAL_RCC_GetSysClockFreq() >> (D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos] & 0x1FU);
24014db6:	f7fd fe17 	bl	240129e8 <HAL_RCC_GetSysClockFreq>
24014dba:	4601      	mov	r1, r0
24014dbc:	4b10      	ldr	r3, [pc, #64]	; (24014e00 <HAL_RCCEx_GetD1SysClockFreq+0x50>)
24014dbe:	699b      	ldr	r3, [r3, #24]
24014dc0:	0a1b      	lsrs	r3, r3, #8
24014dc2:	f003 030f 	and.w	r3, r3, #15
24014dc6:	4a0f      	ldr	r2, [pc, #60]	; (24014e04 <HAL_RCCEx_GetD1SysClockFreq+0x54>)
24014dc8:	5cd3      	ldrb	r3, [r2, r3]
24014dca:	f003 031f 	and.w	r3, r3, #31
24014dce:	fa21 f303 	lsr.w	r3, r1, r3
24014dd2:	607b      	str	r3, [r7, #4]
  common_system_clock = HAL_RCC_GetSysClockFreq() >> (D1CorePrescTable[(RCC->CDCFGR1 & RCC_CDCFGR1_CDCPRE)>> RCC_CDCFGR1_CDCPRE_Pos] & 0x1FU);
#endif

  /* Update the SystemD2Clock global variable */
#if defined(RCC_D1CFGR_HPRE)
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
24014dd4:	4b0a      	ldr	r3, [pc, #40]	; (24014e00 <HAL_RCCEx_GetD1SysClockFreq+0x50>)
24014dd6:	699b      	ldr	r3, [r3, #24]
24014dd8:	f003 030f 	and.w	r3, r3, #15
24014ddc:	4a09      	ldr	r2, [pc, #36]	; (24014e04 <HAL_RCCEx_GetD1SysClockFreq+0x54>)
24014dde:	5cd3      	ldrb	r3, [r2, r3]
24014de0:	f003 031f 	and.w	r3, r3, #31
24014de4:	687a      	ldr	r2, [r7, #4]
24014de6:	fa22 f303 	lsr.w	r3, r2, r3
24014dea:	4a07      	ldr	r2, [pc, #28]	; (24014e08 <HAL_RCCEx_GetD1SysClockFreq+0x58>)
24014dec:	6013      	str	r3, [r2, #0]
#endif

#if defined(DUAL_CORE) && defined(CORE_CM4)
  SystemCoreClock = SystemD2Clock;
#else
  SystemCoreClock = common_system_clock;
24014dee:	4a07      	ldr	r2, [pc, #28]	; (24014e0c <HAL_RCCEx_GetD1SysClockFreq+0x5c>)
24014df0:	687b      	ldr	r3, [r7, #4]
24014df2:	6013      	str	r3, [r2, #0]
#endif /* DUAL_CORE && CORE_CM4 */

  return common_system_clock;
24014df4:	687b      	ldr	r3, [r7, #4]
}
24014df6:	4618      	mov	r0, r3
24014df8:	3708      	adds	r7, #8
24014dfa:	46bd      	mov	sp, r7
24014dfc:	bd80      	pop	{r7, pc}
24014dfe:	bf00      	nop
24014e00:	58024400 	.word	0x58024400
24014e04:	24016b70 	.word	0x24016b70
24014e08:	240004bc 	.word	0x240004bc
24014e0c:	240004b8 	.word	0x240004b8

24014e10 <HAL_RCCEx_EnableLSECSS>:
  *         with HAL_RCC_OscConfig() and the LSE oscillator clock is to be selected as RTC
  *         clock with HAL_RCCEx_PeriphCLKConfig().
  * @retval None
  */
void HAL_RCCEx_EnableLSECSS(void)
{
24014e10:	b480      	push	{r7}
24014e12:	af00      	add	r7, sp, #0
  SET_BIT(RCC->BDCR, RCC_BDCR_LSECSSON) ;
24014e14:	4b05      	ldr	r3, [pc, #20]	; (24014e2c <HAL_RCCEx_EnableLSECSS+0x1c>)
24014e16:	6f1b      	ldr	r3, [r3, #112]	; 0x70
24014e18:	4a04      	ldr	r2, [pc, #16]	; (24014e2c <HAL_RCCEx_EnableLSECSS+0x1c>)
24014e1a:	f043 0320 	orr.w	r3, r3, #32
24014e1e:	6713      	str	r3, [r2, #112]	; 0x70
}
24014e20:	bf00      	nop
24014e22:	46bd      	mov	sp, r7
24014e24:	f85d 7b04 	ldr.w	r7, [sp], #4
24014e28:	4770      	bx	lr
24014e2a:	bf00      	nop
24014e2c:	58024400 	.word	0x58024400

24014e30 <HAL_RCCEx_DisableLSECSS>:
  * @brief  Disables the LSE Clock Security System.
  * @note   LSE Clock Security System can only be disabled after a LSE failure detection.
  * @retval None
  */
void HAL_RCCEx_DisableLSECSS(void)
{
24014e30:	b480      	push	{r7}
24014e32:	af00      	add	r7, sp, #0
  CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSECSSON) ;
24014e34:	4b08      	ldr	r3, [pc, #32]	; (24014e58 <HAL_RCCEx_DisableLSECSS+0x28>)
24014e36:	6f1b      	ldr	r3, [r3, #112]	; 0x70
24014e38:	4a07      	ldr	r2, [pc, #28]	; (24014e58 <HAL_RCCEx_DisableLSECSS+0x28>)
24014e3a:	f023 0320 	bic.w	r3, r3, #32
24014e3e:	6713      	str	r3, [r2, #112]	; 0x70
  /* Disable LSE CSS IT if any */
  __HAL_RCC_DISABLE_IT(RCC_IT_LSECSS);
24014e40:	4b05      	ldr	r3, [pc, #20]	; (24014e58 <HAL_RCCEx_DisableLSECSS+0x28>)
24014e42:	6e1b      	ldr	r3, [r3, #96]	; 0x60
24014e44:	4a04      	ldr	r2, [pc, #16]	; (24014e58 <HAL_RCCEx_DisableLSECSS+0x28>)
24014e46:	f423 7300 	bic.w	r3, r3, #512	; 0x200
24014e4a:	6613      	str	r3, [r2, #96]	; 0x60
}
24014e4c:	bf00      	nop
24014e4e:	46bd      	mov	sp, r7
24014e50:	f85d 7b04 	ldr.w	r7, [sp], #4
24014e54:	4770      	bx	lr
24014e56:	bf00      	nop
24014e58:	58024400 	.word	0x58024400

24014e5c <HAL_RCCEx_EnableLSECSS_IT>:
  * @brief  Enable the LSE Clock Security System Interrupt & corresponding EXTI line.
  * @note   LSE Clock Security System Interrupt is mapped on EXTI line 18
  * @retval None
  */
void HAL_RCCEx_EnableLSECSS_IT(void)
{
24014e5c:	b480      	push	{r7}
24014e5e:	af00      	add	r7, sp, #0
  /* Enable LSE CSS */
  SET_BIT(RCC->BDCR, RCC_BDCR_LSECSSON) ;
24014e60:	4b11      	ldr	r3, [pc, #68]	; (24014ea8 <HAL_RCCEx_EnableLSECSS_IT+0x4c>)
24014e62:	6f1b      	ldr	r3, [r3, #112]	; 0x70
24014e64:	4a10      	ldr	r2, [pc, #64]	; (24014ea8 <HAL_RCCEx_EnableLSECSS_IT+0x4c>)
24014e66:	f043 0320 	orr.w	r3, r3, #32
24014e6a:	6713      	str	r3, [r2, #112]	; 0x70

  /* Enable LSE CSS IT */
  __HAL_RCC_ENABLE_IT(RCC_IT_LSECSS);
24014e6c:	4b0e      	ldr	r3, [pc, #56]	; (24014ea8 <HAL_RCCEx_EnableLSECSS_IT+0x4c>)
24014e6e:	6e1b      	ldr	r3, [r3, #96]	; 0x60
24014e70:	4a0d      	ldr	r2, [pc, #52]	; (24014ea8 <HAL_RCCEx_EnableLSECSS_IT+0x4c>)
24014e72:	f443 7300 	orr.w	r3, r3, #512	; 0x200
24014e76:	6613      	str	r3, [r2, #96]	; 0x60

  /* Enable IT on EXTI Line 18 */
#if defined(DUAL_CORE) && defined(CORE_CM4)
  __HAL_RCC_C2_LSECSS_EXTI_ENABLE_IT();
#else
  __HAL_RCC_LSECSS_EXTI_ENABLE_IT();
24014e78:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
24014e7c:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
24014e80:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
24014e84:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
24014e88:	f8c2 3080 	str.w	r3, [r2, #128]	; 0x80
#endif /* DUAL_CORE && CORE_CM4 */
  __HAL_RCC_LSECSS_EXTI_ENABLE_RISING_EDGE();
24014e8c:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
24014e90:	681b      	ldr	r3, [r3, #0]
24014e92:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
24014e96:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
24014e9a:	6013      	str	r3, [r2, #0]
}
24014e9c:	bf00      	nop
24014e9e:	46bd      	mov	sp, r7
24014ea0:	f85d 7b04 	ldr.w	r7, [sp], #4
24014ea4:	4770      	bx	lr
24014ea6:	bf00      	nop
24014ea8:	58024400 	.word	0x58024400

24014eac <HAL_RCCEx_WakeUpStopCLKConfig>:
  * @note   This function shall not be called after the Clock Security System on HSE has been
  *         enabled.
  * @retval None
  */
void HAL_RCCEx_WakeUpStopCLKConfig(uint32_t WakeUpClk)
{
24014eac:	b480      	push	{r7}
24014eae:	b083      	sub	sp, #12
24014eb0:	af00      	add	r7, sp, #0
24014eb2:	6078      	str	r0, [r7, #4]
  assert_param(IS_RCC_STOP_WAKEUPCLOCK(WakeUpClk));

  __HAL_RCC_WAKEUPSTOP_CLK_CONFIG(WakeUpClk);
24014eb4:	4b06      	ldr	r3, [pc, #24]	; (24014ed0 <HAL_RCCEx_WakeUpStopCLKConfig+0x24>)
24014eb6:	691b      	ldr	r3, [r3, #16]
24014eb8:	f023 0240 	bic.w	r2, r3, #64	; 0x40
24014ebc:	4904      	ldr	r1, [pc, #16]	; (24014ed0 <HAL_RCCEx_WakeUpStopCLKConfig+0x24>)
24014ebe:	687b      	ldr	r3, [r7, #4]
24014ec0:	4313      	orrs	r3, r2
24014ec2:	610b      	str	r3, [r1, #16]
}
24014ec4:	bf00      	nop
24014ec6:	370c      	adds	r7, #12
24014ec8:	46bd      	mov	sp, r7
24014eca:	f85d 7b04 	ldr.w	r7, [sp], #4
24014ece:	4770      	bx	lr
24014ed0:	58024400 	.word	0x58024400

24014ed4 <HAL_RCCEx_KerWakeUpStopCLKConfig>:
  *            @arg RCC_STOP_KERWAKEUPCLOCK_CSI: CSI oscillator selection
  *            @arg RCC_STOP_KERWAKEUPCLOCK_HSI: HSI oscillator selection
  * @retval None
  */
void HAL_RCCEx_KerWakeUpStopCLKConfig(uint32_t WakeUpClk)
{
24014ed4:	b480      	push	{r7}
24014ed6:	b083      	sub	sp, #12
24014ed8:	af00      	add	r7, sp, #0
24014eda:	6078      	str	r0, [r7, #4]
  assert_param(IS_RCC_STOP_KERWAKEUPCLOCK(WakeUpClk));

  __HAL_RCC_KERWAKEUPSTOP_CLK_CONFIG(WakeUpClk);
24014edc:	4b06      	ldr	r3, [pc, #24]	; (24014ef8 <HAL_RCCEx_KerWakeUpStopCLKConfig+0x24>)
24014ede:	691b      	ldr	r3, [r3, #16]
24014ee0:	f023 0280 	bic.w	r2, r3, #128	; 0x80
24014ee4:	4904      	ldr	r1, [pc, #16]	; (24014ef8 <HAL_RCCEx_KerWakeUpStopCLKConfig+0x24>)
24014ee6:	687b      	ldr	r3, [r7, #4]
24014ee8:	4313      	orrs	r3, r2
24014eea:	610b      	str	r3, [r1, #16]
}
24014eec:	bf00      	nop
24014eee:	370c      	adds	r7, #12
24014ef0:	46bd      	mov	sp, r7
24014ef2:	f85d 7b04 	ldr.w	r7, [sp], #4
24014ef6:	4770      	bx	lr
24014ef8:	58024400 	.word	0x58024400

24014efc <HAL_RCCEx_WWDGxSysResetConfig>:
  * @note   This bit can be set by software but is cleared by hardware during a system reset
  *
  * @retval None
  */
void HAL_RCCEx_WWDGxSysResetConfig(uint32_t RCC_WWDGx)
{
24014efc:	b480      	push	{r7}
24014efe:	b083      	sub	sp, #12
24014f00:	af00      	add	r7, sp, #0
24014f02:	6078      	str	r0, [r7, #4]
  assert_param(IS_RCC_SCOPE_WWDG(RCC_WWDGx));
  SET_BIT(RCC->GCR, RCC_WWDGx) ;
24014f04:	4b06      	ldr	r3, [pc, #24]	; (24014f20 <HAL_RCCEx_WWDGxSysResetConfig+0x24>)
24014f06:	f8d3 20a0 	ldr.w	r2, [r3, #160]	; 0xa0
24014f0a:	4905      	ldr	r1, [pc, #20]	; (24014f20 <HAL_RCCEx_WWDGxSysResetConfig+0x24>)
24014f0c:	687b      	ldr	r3, [r7, #4]
24014f0e:	4313      	orrs	r3, r2
24014f10:	f8c1 30a0 	str.w	r3, [r1, #160]	; 0xa0
}
24014f14:	bf00      	nop
24014f16:	370c      	adds	r7, #12
24014f18:	46bd      	mov	sp, r7
24014f1a:	f85d 7b04 	ldr.w	r7, [sp], #4
24014f1e:	4770      	bx	lr
24014f20:	58024400 	.word	0x58024400

24014f24 <HAL_RCCEx_CRSConfig>:
  * @brief  Start automatic synchronization for polling mode
  * @param  pInit Pointer on RCC_CRSInitTypeDef structure
  * @retval None
  */
void HAL_RCCEx_CRSConfig(RCC_CRSInitTypeDef *pInit)
{
24014f24:	b580      	push	{r7, lr}
24014f26:	b084      	sub	sp, #16
24014f28:	af00      	add	r7, sp, #0
24014f2a:	6078      	str	r0, [r7, #4]
  assert_param(IS_RCC_CRS_HSI48CALIBRATION(pInit->HSI48CalibrationValue));

  /* CONFIGURATION */

  /* Before configuration, reset CRS registers to their default values*/
  __HAL_RCC_CRS_FORCE_RESET();
24014f2c:	4b26      	ldr	r3, [pc, #152]	; (24014fc8 <HAL_RCCEx_CRSConfig+0xa4>)
24014f2e:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
24014f32:	4a25      	ldr	r2, [pc, #148]	; (24014fc8 <HAL_RCCEx_CRSConfig+0xa4>)
24014f34:	f043 0302 	orr.w	r3, r3, #2
24014f38:	f8c2 3094 	str.w	r3, [r2, #148]	; 0x94
  __HAL_RCC_CRS_RELEASE_RESET();
24014f3c:	4b22      	ldr	r3, [pc, #136]	; (24014fc8 <HAL_RCCEx_CRSConfig+0xa4>)
24014f3e:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
24014f42:	4a21      	ldr	r2, [pc, #132]	; (24014fc8 <HAL_RCCEx_CRSConfig+0xa4>)
24014f44:	f023 0302 	bic.w	r3, r3, #2
24014f48:	f8c2 3094 	str.w	r3, [r2, #148]	; 0x94

  /* Set the SYNCDIV[2:0] bits according to Pre-scaler value */
  /* Set the SYNCSRC[1:0] bits according to Source value */
  /* Set the SYNCSPOL bit according to Polarity value */
  if ((HAL_GetREVID() <= REV_ID_Y) && (pInit->Source == RCC_CRS_SYNC_SOURCE_USB2))
24014f4c:	f7eb fd1a 	bl	24000984 <HAL_GetREVID>
24014f50:	4602      	mov	r2, r0
24014f52:	f241 0303 	movw	r3, #4099	; 0x1003
24014f56:	429a      	cmp	r2, r3
24014f58:	d80b      	bhi.n	24014f72 <HAL_RCCEx_CRSConfig+0x4e>
24014f5a:	687b      	ldr	r3, [r7, #4]
24014f5c:	685b      	ldr	r3, [r3, #4]
24014f5e:	f1b3 5f40 	cmp.w	r3, #805306368	; 0x30000000
24014f62:	d106      	bne.n	24014f72 <HAL_RCCEx_CRSConfig+0x4e>
  {
    /* Use Rev.Y value of USB2 */
    value = (pInit->Prescaler | RCC_CRS_SYNC_SOURCE_PIN | pInit->Polarity);
24014f64:	687b      	ldr	r3, [r7, #4]
24014f66:	681a      	ldr	r2, [r3, #0]
24014f68:	687b      	ldr	r3, [r7, #4]
24014f6a:	689b      	ldr	r3, [r3, #8]
24014f6c:	4313      	orrs	r3, r2
24014f6e:	60fb      	str	r3, [r7, #12]
24014f70:	e008      	b.n	24014f84 <HAL_RCCEx_CRSConfig+0x60>
  }
  else
  {
    value = (pInit->Prescaler | pInit->Source | pInit->Polarity);
24014f72:	687b      	ldr	r3, [r7, #4]
24014f74:	681a      	ldr	r2, [r3, #0]
24014f76:	687b      	ldr	r3, [r7, #4]
24014f78:	685b      	ldr	r3, [r3, #4]
24014f7a:	431a      	orrs	r2, r3
24014f7c:	687b      	ldr	r3, [r7, #4]
24014f7e:	689b      	ldr	r3, [r3, #8]
24014f80:	4313      	orrs	r3, r2
24014f82:	60fb      	str	r3, [r7, #12]
  }
  /* Set the RELOAD[15:0] bits according to ReloadValue value */
  value |= pInit->ReloadValue;
24014f84:	687b      	ldr	r3, [r7, #4]
24014f86:	68db      	ldr	r3, [r3, #12]
24014f88:	68fa      	ldr	r2, [r7, #12]
24014f8a:	4313      	orrs	r3, r2
24014f8c:	60fb      	str	r3, [r7, #12]
  /* Set the FELIM[7:0] bits according to ErrorLimitValue value */
  value |= (pInit->ErrorLimitValue << CRS_CFGR_FELIM_Pos);
24014f8e:	687b      	ldr	r3, [r7, #4]
24014f90:	691b      	ldr	r3, [r3, #16]
24014f92:	041b      	lsls	r3, r3, #16
24014f94:	68fa      	ldr	r2, [r7, #12]
24014f96:	4313      	orrs	r3, r2
24014f98:	60fb      	str	r3, [r7, #12]
  WRITE_REG(CRS->CFGR, value);
24014f9a:	4a0c      	ldr	r2, [pc, #48]	; (24014fcc <HAL_RCCEx_CRSConfig+0xa8>)
24014f9c:	68fb      	ldr	r3, [r7, #12]
24014f9e:	6053      	str	r3, [r2, #4]

  /* Adjust HSI48 oscillator smooth trimming */
  /* Set the TRIM[5:0] bits according to RCC_CRS_HSI48CalibrationValue value */
  MODIFY_REG(CRS->CR, CRS_CR_TRIM, (pInit->HSI48CalibrationValue << CRS_CR_TRIM_Pos));
24014fa0:	4b0a      	ldr	r3, [pc, #40]	; (24014fcc <HAL_RCCEx_CRSConfig+0xa8>)
24014fa2:	681b      	ldr	r3, [r3, #0]
24014fa4:	f423 527c 	bic.w	r2, r3, #16128	; 0x3f00
24014fa8:	687b      	ldr	r3, [r7, #4]
24014faa:	695b      	ldr	r3, [r3, #20]
24014fac:	021b      	lsls	r3, r3, #8
24014fae:	4907      	ldr	r1, [pc, #28]	; (24014fcc <HAL_RCCEx_CRSConfig+0xa8>)
24014fb0:	4313      	orrs	r3, r2
24014fb2:	600b      	str	r3, [r1, #0]

  /* START AUTOMATIC SYNCHRONIZATION*/

  /* Enable Automatic trimming & Frequency error counter */
  SET_BIT(CRS->CR, CRS_CR_AUTOTRIMEN | CRS_CR_CEN);
24014fb4:	4b05      	ldr	r3, [pc, #20]	; (24014fcc <HAL_RCCEx_CRSConfig+0xa8>)
24014fb6:	681b      	ldr	r3, [r3, #0]
24014fb8:	4a04      	ldr	r2, [pc, #16]	; (24014fcc <HAL_RCCEx_CRSConfig+0xa8>)
24014fba:	f043 0360 	orr.w	r3, r3, #96	; 0x60
24014fbe:	6013      	str	r3, [r2, #0]
}
24014fc0:	bf00      	nop
24014fc2:	3710      	adds	r7, #16
24014fc4:	46bd      	mov	sp, r7
24014fc6:	bd80      	pop	{r7, pc}
24014fc8:	58024400 	.word	0x58024400
24014fcc:	40008400 	.word	0x40008400

24014fd0 <HAL_RCCEx_CRSSoftwareSynchronizationGenerate>:
/**
  * @brief  Generate the software synchronization event
  * @retval None
  */
void HAL_RCCEx_CRSSoftwareSynchronizationGenerate(void)
{
24014fd0:	b480      	push	{r7}
24014fd2:	af00      	add	r7, sp, #0
  SET_BIT(CRS->CR, CRS_CR_SWSYNC);
24014fd4:	4b05      	ldr	r3, [pc, #20]	; (24014fec <HAL_RCCEx_CRSSoftwareSynchronizationGenerate+0x1c>)
24014fd6:	681b      	ldr	r3, [r3, #0]
24014fd8:	4a04      	ldr	r2, [pc, #16]	; (24014fec <HAL_RCCEx_CRSSoftwareSynchronizationGenerate+0x1c>)
24014fda:	f043 0380 	orr.w	r3, r3, #128	; 0x80
24014fde:	6013      	str	r3, [r2, #0]
}
24014fe0:	bf00      	nop
24014fe2:	46bd      	mov	sp, r7
24014fe4:	f85d 7b04 	ldr.w	r7, [sp], #4
24014fe8:	4770      	bx	lr
24014fea:	bf00      	nop
24014fec:	40008400 	.word	0x40008400

24014ff0 <HAL_RCCEx_CRSGetSynchronizationInfo>:
  * @brief  Return synchronization info
  * @param  pSynchroInfo Pointer on RCC_CRSSynchroInfoTypeDef structure
  * @retval None
  */
void HAL_RCCEx_CRSGetSynchronizationInfo(RCC_CRSSynchroInfoTypeDef *pSynchroInfo)
{
24014ff0:	b480      	push	{r7}
24014ff2:	b083      	sub	sp, #12
24014ff4:	af00      	add	r7, sp, #0
24014ff6:	6078      	str	r0, [r7, #4]
  /* Check the parameter */
  assert_param(pSynchroInfo != (void *)NULL);

  /* Get the reload value */
  pSynchroInfo->ReloadValue = (uint32_t)(READ_BIT(CRS->CFGR, CRS_CFGR_RELOAD));
24014ff8:	4b0e      	ldr	r3, [pc, #56]	; (24015034 <HAL_RCCEx_CRSGetSynchronizationInfo+0x44>)
24014ffa:	685b      	ldr	r3, [r3, #4]
24014ffc:	b29a      	uxth	r2, r3
24014ffe:	687b      	ldr	r3, [r7, #4]
24015000:	601a      	str	r2, [r3, #0]

  /* Get HSI48 oscillator smooth trimming */
  pSynchroInfo->HSI48CalibrationValue = (uint32_t)(READ_BIT(CRS->CR, CRS_CR_TRIM) >> CRS_CR_TRIM_Pos);
24015002:	4b0c      	ldr	r3, [pc, #48]	; (24015034 <HAL_RCCEx_CRSGetSynchronizationInfo+0x44>)
24015004:	681b      	ldr	r3, [r3, #0]
24015006:	0a1b      	lsrs	r3, r3, #8
24015008:	f003 023f 	and.w	r2, r3, #63	; 0x3f
2401500c:	687b      	ldr	r3, [r7, #4]
2401500e:	605a      	str	r2, [r3, #4]

  /* Get Frequency error capture */
  pSynchroInfo->FreqErrorCapture = (uint32_t)(READ_BIT(CRS->ISR, CRS_ISR_FECAP) >> CRS_ISR_FECAP_Pos);
24015010:	4b08      	ldr	r3, [pc, #32]	; (24015034 <HAL_RCCEx_CRSGetSynchronizationInfo+0x44>)
24015012:	689b      	ldr	r3, [r3, #8]
24015014:	0c1b      	lsrs	r3, r3, #16
24015016:	b29a      	uxth	r2, r3
24015018:	687b      	ldr	r3, [r7, #4]
2401501a:	609a      	str	r2, [r3, #8]

  /* Get Frequency error direction */
  pSynchroInfo->FreqErrorDirection = (uint32_t)(READ_BIT(CRS->ISR, CRS_ISR_FEDIR));
2401501c:	4b05      	ldr	r3, [pc, #20]	; (24015034 <HAL_RCCEx_CRSGetSynchronizationInfo+0x44>)
2401501e:	689b      	ldr	r3, [r3, #8]
24015020:	f403 4200 	and.w	r2, r3, #32768	; 0x8000
24015024:	687b      	ldr	r3, [r7, #4]
24015026:	60da      	str	r2, [r3, #12]
}
24015028:	bf00      	nop
2401502a:	370c      	adds	r7, #12
2401502c:	46bd      	mov	sp, r7
2401502e:	f85d 7b04 	ldr.w	r7, [sp], #4
24015032:	4770      	bx	lr
24015034:	40008400 	.word	0x40008400

24015038 <HAL_RCCEx_CRSWaitSynchronization>:
*            @arg @ref RCC_CRS_SYNCERR
*            @arg @ref RCC_CRS_SYNCMISS
*            @arg @ref RCC_CRS_TRIMOVF
*/
uint32_t HAL_RCCEx_CRSWaitSynchronization(uint32_t Timeout)
{
24015038:	b580      	push	{r7, lr}
2401503a:	b084      	sub	sp, #16
2401503c:	af00      	add	r7, sp, #0
2401503e:	6078      	str	r0, [r7, #4]
  uint32_t crsstatus = RCC_CRS_NONE;
24015040:	2300      	movs	r3, #0
24015042:	60fb      	str	r3, [r7, #12]
  uint32_t tickstart;

  /* Get time-out */
  tickstart = HAL_GetTick();
24015044:	f7eb fc06 	bl	24000854 <HAL_GetTick>
24015048:	60b8      	str	r0, [r7, #8]

  /* Wait for CRS flag or time-out detection */
  do
  {
    if(Timeout != HAL_MAX_DELAY)
2401504a:	687b      	ldr	r3, [r7, #4]
2401504c:	f1b3 3fff 	cmp.w	r3, #4294967295
24015050:	d00c      	beq.n	2401506c <HAL_RCCEx_CRSWaitSynchronization+0x34>
    {
      if(((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
24015052:	f7eb fbff 	bl	24000854 <HAL_GetTick>
24015056:	4602      	mov	r2, r0
24015058:	68bb      	ldr	r3, [r7, #8]
2401505a:	1ad3      	subs	r3, r2, r3
2401505c:	687a      	ldr	r2, [r7, #4]
2401505e:	429a      	cmp	r2, r3
24015060:	d302      	bcc.n	24015068 <HAL_RCCEx_CRSWaitSynchronization+0x30>
24015062:	687b      	ldr	r3, [r7, #4]
24015064:	2b00      	cmp	r3, #0
24015066:	d101      	bne.n	2401506c <HAL_RCCEx_CRSWaitSynchronization+0x34>
      {
        crsstatus = RCC_CRS_TIMEOUT;
24015068:	2301      	movs	r3, #1
2401506a:	60fb      	str	r3, [r7, #12]
      }
    }
    /* Check CRS SYNCOK flag  */
    if(__HAL_RCC_CRS_GET_FLAG(RCC_CRS_FLAG_SYNCOK))
2401506c:	4b2a      	ldr	r3, [pc, #168]	; (24015118 <HAL_RCCEx_CRSWaitSynchronization+0xe0>)
2401506e:	689b      	ldr	r3, [r3, #8]
24015070:	f003 0301 	and.w	r3, r3, #1
24015074:	2b01      	cmp	r3, #1
24015076:	d106      	bne.n	24015086 <HAL_RCCEx_CRSWaitSynchronization+0x4e>
    {
      /* CRS SYNC event OK */
      crsstatus |= RCC_CRS_SYNCOK;
24015078:	68fb      	ldr	r3, [r7, #12]
2401507a:	f043 0302 	orr.w	r3, r3, #2
2401507e:	60fb      	str	r3, [r7, #12]

      /* Clear CRS SYNC event OK bit */
      __HAL_RCC_CRS_CLEAR_FLAG(RCC_CRS_FLAG_SYNCOK);
24015080:	4b25      	ldr	r3, [pc, #148]	; (24015118 <HAL_RCCEx_CRSWaitSynchronization+0xe0>)
24015082:	2201      	movs	r2, #1
24015084:	60da      	str	r2, [r3, #12]
    }

    /* Check CRS SYNCWARN flag  */
    if(__HAL_RCC_CRS_GET_FLAG(RCC_CRS_FLAG_SYNCWARN))
24015086:	4b24      	ldr	r3, [pc, #144]	; (24015118 <HAL_RCCEx_CRSWaitSynchronization+0xe0>)
24015088:	689b      	ldr	r3, [r3, #8]
2401508a:	f003 0302 	and.w	r3, r3, #2
2401508e:	2b02      	cmp	r3, #2
24015090:	d106      	bne.n	240150a0 <HAL_RCCEx_CRSWaitSynchronization+0x68>
    {
      /* CRS SYNC warning */
      crsstatus |= RCC_CRS_SYNCWARN;
24015092:	68fb      	ldr	r3, [r7, #12]
24015094:	f043 0304 	orr.w	r3, r3, #4
24015098:	60fb      	str	r3, [r7, #12]

      /* Clear CRS SYNCWARN bit */
      __HAL_RCC_CRS_CLEAR_FLAG(RCC_CRS_FLAG_SYNCWARN);
2401509a:	4b1f      	ldr	r3, [pc, #124]	; (24015118 <HAL_RCCEx_CRSWaitSynchronization+0xe0>)
2401509c:	2202      	movs	r2, #2
2401509e:	60da      	str	r2, [r3, #12]
    }

    /* Check CRS TRIM overflow flag  */
    if(__HAL_RCC_CRS_GET_FLAG(RCC_CRS_FLAG_TRIMOVF))
240150a0:	4b1d      	ldr	r3, [pc, #116]	; (24015118 <HAL_RCCEx_CRSWaitSynchronization+0xe0>)
240150a2:	689b      	ldr	r3, [r3, #8]
240150a4:	f403 6380 	and.w	r3, r3, #1024	; 0x400
240150a8:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
240150ac:	d106      	bne.n	240150bc <HAL_RCCEx_CRSWaitSynchronization+0x84>
    {
      /* CRS SYNC Error */
      crsstatus |= RCC_CRS_TRIMOVF;
240150ae:	68fb      	ldr	r3, [r7, #12]
240150b0:	f043 0320 	orr.w	r3, r3, #32
240150b4:	60fb      	str	r3, [r7, #12]

      /* Clear CRS Error bit */
      __HAL_RCC_CRS_CLEAR_FLAG(RCC_CRS_FLAG_TRIMOVF);
240150b6:	4b18      	ldr	r3, [pc, #96]	; (24015118 <HAL_RCCEx_CRSWaitSynchronization+0xe0>)
240150b8:	2204      	movs	r2, #4
240150ba:	60da      	str	r2, [r3, #12]
    }

    /* Check CRS Error flag  */
    if(__HAL_RCC_CRS_GET_FLAG(RCC_CRS_FLAG_SYNCERR))
240150bc:	4b16      	ldr	r3, [pc, #88]	; (24015118 <HAL_RCCEx_CRSWaitSynchronization+0xe0>)
240150be:	689b      	ldr	r3, [r3, #8]
240150c0:	f403 7380 	and.w	r3, r3, #256	; 0x100
240150c4:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
240150c8:	d106      	bne.n	240150d8 <HAL_RCCEx_CRSWaitSynchronization+0xa0>
    {
      /* CRS SYNC Error */
      crsstatus |= RCC_CRS_SYNCERR;
240150ca:	68fb      	ldr	r3, [r7, #12]
240150cc:	f043 0308 	orr.w	r3, r3, #8
240150d0:	60fb      	str	r3, [r7, #12]

      /* Clear CRS Error bit */
      __HAL_RCC_CRS_CLEAR_FLAG(RCC_CRS_FLAG_SYNCERR);
240150d2:	4b11      	ldr	r3, [pc, #68]	; (24015118 <HAL_RCCEx_CRSWaitSynchronization+0xe0>)
240150d4:	2204      	movs	r2, #4
240150d6:	60da      	str	r2, [r3, #12]
    }

    /* Check CRS SYNC Missed flag  */
    if(__HAL_RCC_CRS_GET_FLAG(RCC_CRS_FLAG_SYNCMISS))
240150d8:	4b0f      	ldr	r3, [pc, #60]	; (24015118 <HAL_RCCEx_CRSWaitSynchronization+0xe0>)
240150da:	689b      	ldr	r3, [r3, #8]
240150dc:	f403 7300 	and.w	r3, r3, #512	; 0x200
240150e0:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
240150e4:	d106      	bne.n	240150f4 <HAL_RCCEx_CRSWaitSynchronization+0xbc>
    {
      /* CRS SYNC Missed */
      crsstatus |= RCC_CRS_SYNCMISS;
240150e6:	68fb      	ldr	r3, [r7, #12]
240150e8:	f043 0310 	orr.w	r3, r3, #16
240150ec:	60fb      	str	r3, [r7, #12]

      /* Clear CRS SYNC Missed bit */
      __HAL_RCC_CRS_CLEAR_FLAG(RCC_CRS_FLAG_SYNCMISS);
240150ee:	4b0a      	ldr	r3, [pc, #40]	; (24015118 <HAL_RCCEx_CRSWaitSynchronization+0xe0>)
240150f0:	2204      	movs	r2, #4
240150f2:	60da      	str	r2, [r3, #12]
    }

    /* Check CRS Expected SYNC flag  */
    if(__HAL_RCC_CRS_GET_FLAG(RCC_CRS_FLAG_ESYNC))
240150f4:	4b08      	ldr	r3, [pc, #32]	; (24015118 <HAL_RCCEx_CRSWaitSynchronization+0xe0>)
240150f6:	689b      	ldr	r3, [r3, #8]
240150f8:	f003 0308 	and.w	r3, r3, #8
240150fc:	2b08      	cmp	r3, #8
240150fe:	d102      	bne.n	24015106 <HAL_RCCEx_CRSWaitSynchronization+0xce>
    {
      /* frequency error counter reached a zero value */
      __HAL_RCC_CRS_CLEAR_FLAG(RCC_CRS_FLAG_ESYNC);
24015100:	4b05      	ldr	r3, [pc, #20]	; (24015118 <HAL_RCCEx_CRSWaitSynchronization+0xe0>)
24015102:	2208      	movs	r2, #8
24015104:	60da      	str	r2, [r3, #12]
    }
  } while(RCC_CRS_NONE == crsstatus);
24015106:	68fb      	ldr	r3, [r7, #12]
24015108:	2b00      	cmp	r3, #0
2401510a:	d09e      	beq.n	2401504a <HAL_RCCEx_CRSWaitSynchronization+0x12>

  return crsstatus;
2401510c:	68fb      	ldr	r3, [r7, #12]
}
2401510e:	4618      	mov	r0, r3
24015110:	3710      	adds	r7, #16
24015112:	46bd      	mov	sp, r7
24015114:	bd80      	pop	{r7, pc}
24015116:	bf00      	nop
24015118:	40008400 	.word	0x40008400

2401511c <HAL_RCCEx_CRS_IRQHandler>:
/**
  * @brief Handle the Clock Recovery System interrupt request.
  * @retval None
  */
void HAL_RCCEx_CRS_IRQHandler(void)
{
2401511c:	b580      	push	{r7, lr}
2401511e:	b084      	sub	sp, #16
24015120:	af00      	add	r7, sp, #0
  uint32_t crserror = RCC_CRS_NONE;
24015122:	2300      	movs	r3, #0
24015124:	60fb      	str	r3, [r7, #12]
  /* Get current IT flags and IT sources values */
  uint32_t itflags = READ_REG(CRS->ISR);
24015126:	4b33      	ldr	r3, [pc, #204]	; (240151f4 <HAL_RCCEx_CRS_IRQHandler+0xd8>)
24015128:	689b      	ldr	r3, [r3, #8]
2401512a:	60bb      	str	r3, [r7, #8]
  uint32_t itsources = READ_REG(CRS->CR);
2401512c:	4b31      	ldr	r3, [pc, #196]	; (240151f4 <HAL_RCCEx_CRS_IRQHandler+0xd8>)
2401512e:	681b      	ldr	r3, [r3, #0]
24015130:	607b      	str	r3, [r7, #4]

  /* Check CRS SYNCOK flag  */
  if(((itflags & RCC_CRS_FLAG_SYNCOK) != 0U) && ((itsources & RCC_CRS_IT_SYNCOK) != 0U))
24015132:	68bb      	ldr	r3, [r7, #8]
24015134:	f003 0301 	and.w	r3, r3, #1
24015138:	2b00      	cmp	r3, #0
2401513a:	d00a      	beq.n	24015152 <HAL_RCCEx_CRS_IRQHandler+0x36>
2401513c:	687b      	ldr	r3, [r7, #4]
2401513e:	f003 0301 	and.w	r3, r3, #1
24015142:	2b00      	cmp	r3, #0
24015144:	d005      	beq.n	24015152 <HAL_RCCEx_CRS_IRQHandler+0x36>
  {
    /* Clear CRS SYNC event OK flag */
    WRITE_REG(CRS->ICR, CRS_ICR_SYNCOKC);
24015146:	4b2b      	ldr	r3, [pc, #172]	; (240151f4 <HAL_RCCEx_CRS_IRQHandler+0xd8>)
24015148:	2201      	movs	r2, #1
2401514a:	60da      	str	r2, [r3, #12]

    /* user callback */
    HAL_RCCEx_CRS_SyncOkCallback();
2401514c:	f000 f854 	bl	240151f8 <HAL_RCCEx_CRS_SyncOkCallback>
24015150:	e04b      	b.n	240151ea <HAL_RCCEx_CRS_IRQHandler+0xce>
  }
  /* Check CRS SYNCWARN flag  */
  else if(((itflags & RCC_CRS_FLAG_SYNCWARN) != 0U) && ((itsources & RCC_CRS_IT_SYNCWARN) != 0U))
24015152:	68bb      	ldr	r3, [r7, #8]
24015154:	f003 0302 	and.w	r3, r3, #2
24015158:	2b00      	cmp	r3, #0
2401515a:	d00a      	beq.n	24015172 <HAL_RCCEx_CRS_IRQHandler+0x56>
2401515c:	687b      	ldr	r3, [r7, #4]
2401515e:	f003 0302 	and.w	r3, r3, #2
24015162:	2b00      	cmp	r3, #0
24015164:	d005      	beq.n	24015172 <HAL_RCCEx_CRS_IRQHandler+0x56>
  {
    /* Clear CRS SYNCWARN flag */
    WRITE_REG(CRS->ICR, CRS_ICR_SYNCWARNC);
24015166:	4b23      	ldr	r3, [pc, #140]	; (240151f4 <HAL_RCCEx_CRS_IRQHandler+0xd8>)
24015168:	2202      	movs	r2, #2
2401516a:	60da      	str	r2, [r3, #12]

    /* user callback */
    HAL_RCCEx_CRS_SyncWarnCallback();
2401516c:	f000 f84b 	bl	24015206 <HAL_RCCEx_CRS_SyncWarnCallback>
24015170:	e03b      	b.n	240151ea <HAL_RCCEx_CRS_IRQHandler+0xce>
  }
  /* Check CRS Expected SYNC flag  */
  else if(((itflags & RCC_CRS_FLAG_ESYNC) != 0U) && ((itsources & RCC_CRS_IT_ESYNC) != 0U))
24015172:	68bb      	ldr	r3, [r7, #8]
24015174:	f003 0308 	and.w	r3, r3, #8
24015178:	2b00      	cmp	r3, #0
2401517a:	d00a      	beq.n	24015192 <HAL_RCCEx_CRS_IRQHandler+0x76>
2401517c:	687b      	ldr	r3, [r7, #4]
2401517e:	f003 0308 	and.w	r3, r3, #8
24015182:	2b00      	cmp	r3, #0
24015184:	d005      	beq.n	24015192 <HAL_RCCEx_CRS_IRQHandler+0x76>
  {
    /* frequency error counter reached a zero value */
    WRITE_REG(CRS->ICR, CRS_ICR_ESYNCC);
24015186:	4b1b      	ldr	r3, [pc, #108]	; (240151f4 <HAL_RCCEx_CRS_IRQHandler+0xd8>)
24015188:	2208      	movs	r2, #8
2401518a:	60da      	str	r2, [r3, #12]

    /* user callback */
    HAL_RCCEx_CRS_ExpectedSyncCallback();
2401518c:	f000 f842 	bl	24015214 <HAL_RCCEx_CRS_ExpectedSyncCallback>
24015190:	e02b      	b.n	240151ea <HAL_RCCEx_CRS_IRQHandler+0xce>
  }
  /* Check CRS Error flags  */
  else
  {
    if(((itflags & RCC_CRS_FLAG_ERR) != 0U) && ((itsources & RCC_CRS_IT_ERR) != 0U))
24015192:	68bb      	ldr	r3, [r7, #8]
24015194:	f003 0304 	and.w	r3, r3, #4
24015198:	2b00      	cmp	r3, #0
2401519a:	d026      	beq.n	240151ea <HAL_RCCEx_CRS_IRQHandler+0xce>
2401519c:	687b      	ldr	r3, [r7, #4]
2401519e:	f003 0304 	and.w	r3, r3, #4
240151a2:	2b00      	cmp	r3, #0
240151a4:	d021      	beq.n	240151ea <HAL_RCCEx_CRS_IRQHandler+0xce>
    {
      if((itflags & RCC_CRS_FLAG_SYNCERR) != 0U)
240151a6:	68bb      	ldr	r3, [r7, #8]
240151a8:	f403 7380 	and.w	r3, r3, #256	; 0x100
240151ac:	2b00      	cmp	r3, #0
240151ae:	d003      	beq.n	240151b8 <HAL_RCCEx_CRS_IRQHandler+0x9c>
      {
        crserror |= RCC_CRS_SYNCERR;
240151b0:	68fb      	ldr	r3, [r7, #12]
240151b2:	f043 0308 	orr.w	r3, r3, #8
240151b6:	60fb      	str	r3, [r7, #12]
      }
      if((itflags & RCC_CRS_FLAG_SYNCMISS) != 0U)
240151b8:	68bb      	ldr	r3, [r7, #8]
240151ba:	f403 7300 	and.w	r3, r3, #512	; 0x200
240151be:	2b00      	cmp	r3, #0
240151c0:	d003      	beq.n	240151ca <HAL_RCCEx_CRS_IRQHandler+0xae>
      {
        crserror |= RCC_CRS_SYNCMISS;
240151c2:	68fb      	ldr	r3, [r7, #12]
240151c4:	f043 0310 	orr.w	r3, r3, #16
240151c8:	60fb      	str	r3, [r7, #12]
      }
      if((itflags & RCC_CRS_FLAG_TRIMOVF) != 0U)
240151ca:	68bb      	ldr	r3, [r7, #8]
240151cc:	f403 6380 	and.w	r3, r3, #1024	; 0x400
240151d0:	2b00      	cmp	r3, #0
240151d2:	d003      	beq.n	240151dc <HAL_RCCEx_CRS_IRQHandler+0xc0>
      {
        crserror |= RCC_CRS_TRIMOVF;
240151d4:	68fb      	ldr	r3, [r7, #12]
240151d6:	f043 0320 	orr.w	r3, r3, #32
240151da:	60fb      	str	r3, [r7, #12]
      }

      /* Clear CRS Error flags */
      WRITE_REG(CRS->ICR, CRS_ICR_ERRC);
240151dc:	4b05      	ldr	r3, [pc, #20]	; (240151f4 <HAL_RCCEx_CRS_IRQHandler+0xd8>)
240151de:	2204      	movs	r2, #4
240151e0:	60da      	str	r2, [r3, #12]

      /* user error callback */
      HAL_RCCEx_CRS_ErrorCallback(crserror);
240151e2:	68f8      	ldr	r0, [r7, #12]
240151e4:	f000 f81d 	bl	24015222 <HAL_RCCEx_CRS_ErrorCallback>
    }
  }
}
240151e8:	e7ff      	b.n	240151ea <HAL_RCCEx_CRS_IRQHandler+0xce>
240151ea:	bf00      	nop
240151ec:	3710      	adds	r7, #16
240151ee:	46bd      	mov	sp, r7
240151f0:	bd80      	pop	{r7, pc}
240151f2:	bf00      	nop
240151f4:	40008400 	.word	0x40008400

240151f8 <HAL_RCCEx_CRS_SyncOkCallback>:
/**
  * @brief  RCCEx Clock Recovery System SYNCOK interrupt callback.
  * @retval none
  */
__weak void HAL_RCCEx_CRS_SyncOkCallback(void)
{
240151f8:	b480      	push	{r7}
240151fa:	af00      	add	r7, sp, #0
  /* NOTE : This function should not be modified, when the callback is needed,
            the @ref HAL_RCCEx_CRS_SyncOkCallback should be implemented in the user file
   */
}
240151fc:	bf00      	nop
240151fe:	46bd      	mov	sp, r7
24015200:	f85d 7b04 	ldr.w	r7, [sp], #4
24015204:	4770      	bx	lr

24015206 <HAL_RCCEx_CRS_SyncWarnCallback>:
/**
  * @brief  RCCEx Clock Recovery System SYNCWARN interrupt callback.
  * @retval none
  */
__weak void HAL_RCCEx_CRS_SyncWarnCallback(void)
{
24015206:	b480      	push	{r7}
24015208:	af00      	add	r7, sp, #0
  /* NOTE : This function should not be modified, when the callback is needed,
            the @ref HAL_RCCEx_CRS_SyncWarnCallback should be implemented in the user file
   */
}
2401520a:	bf00      	nop
2401520c:	46bd      	mov	sp, r7
2401520e:	f85d 7b04 	ldr.w	r7, [sp], #4
24015212:	4770      	bx	lr

24015214 <HAL_RCCEx_CRS_ExpectedSyncCallback>:
/**
  * @brief  RCCEx Clock Recovery System Expected SYNC interrupt callback.
  * @retval none
  */
__weak void HAL_RCCEx_CRS_ExpectedSyncCallback(void)
{
24015214:	b480      	push	{r7}
24015216:	af00      	add	r7, sp, #0
  /* NOTE : This function should not be modified, when the callback is needed,
            the @ref HAL_RCCEx_CRS_ExpectedSyncCallback should be implemented in the user file
   */
}
24015218:	bf00      	nop
2401521a:	46bd      	mov	sp, r7
2401521c:	f85d 7b04 	ldr.w	r7, [sp], #4
24015220:	4770      	bx	lr

24015222 <HAL_RCCEx_CRS_ErrorCallback>:
  *           @arg @ref RCC_CRS_SYNCMISS
  *           @arg @ref RCC_CRS_TRIMOVF
  * @retval none
  */
__weak void HAL_RCCEx_CRS_ErrorCallback(uint32_t Error)
{
24015222:	b480      	push	{r7}
24015224:	b083      	sub	sp, #12
24015226:	af00      	add	r7, sp, #0
24015228:	6078      	str	r0, [r7, #4]
  UNUSED(Error);

  /* NOTE : This function should not be modified, when the callback is needed,
            the @ref HAL_RCCEx_CRS_ErrorCallback should be implemented in the user file
   */
}
2401522a:	bf00      	nop
2401522c:	370c      	adds	r7, #12
2401522e:	46bd      	mov	sp, r7
24015230:	f85d 7b04 	ldr.w	r7, [sp], #4
24015234:	4770      	bx	lr
	...

24015238 <RCCEx_PLL2_Config>:
  * @note   PLL2 is temporary disabled to apply new parameters
  *
  * @retval HAL status
  */
static HAL_StatusTypeDef RCCEx_PLL2_Config(RCC_PLL2InitTypeDef *pll2, uint32_t Divider)
{
24015238:	b580      	push	{r7, lr}
2401523a:	b084      	sub	sp, #16
2401523c:	af00      	add	r7, sp, #0
2401523e:	6078      	str	r0, [r7, #4]
24015240:	6039      	str	r1, [r7, #0]

  uint32_t tickstart;
  HAL_StatusTypeDef status = HAL_OK;
24015242:	2300      	movs	r3, #0
24015244:	73fb      	strb	r3, [r7, #15]
  assert_param(IS_RCC_PLL2RGE_VALUE(pll2->PLL2RGE));
  assert_param(IS_RCC_PLL2VCO_VALUE(pll2->PLL2VCOSEL));
  assert_param(IS_RCC_PLLFRACN_VALUE(pll2->PLL2FRACN));

  /* Check that PLL2 OSC clock source is already set */
  if(__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_NONE)
24015246:	4b53      	ldr	r3, [pc, #332]	; (24015394 <RCCEx_PLL2_Config+0x15c>)
24015248:	6a9b      	ldr	r3, [r3, #40]	; 0x28
2401524a:	f003 0303 	and.w	r3, r3, #3
2401524e:	2b03      	cmp	r3, #3
24015250:	d101      	bne.n	24015256 <RCCEx_PLL2_Config+0x1e>
  {
    return HAL_ERROR;
24015252:	2301      	movs	r3, #1
24015254:	e099      	b.n	2401538a <RCCEx_PLL2_Config+0x152>


  else
  {
    /* Disable  PLL2. */
    __HAL_RCC_PLL2_DISABLE();
24015256:	4b4f      	ldr	r3, [pc, #316]	; (24015394 <RCCEx_PLL2_Config+0x15c>)
24015258:	681b      	ldr	r3, [r3, #0]
2401525a:	4a4e      	ldr	r2, [pc, #312]	; (24015394 <RCCEx_PLL2_Config+0x15c>)
2401525c:	f023 6380 	bic.w	r3, r3, #67108864	; 0x4000000
24015260:	6013      	str	r3, [r2, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
24015262:	f7eb faf7 	bl	24000854 <HAL_GetTick>
24015266:	60b8      	str	r0, [r7, #8]

    /* Wait till PLL is disabled */
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY) != 0U)
24015268:	e008      	b.n	2401527c <RCCEx_PLL2_Config+0x44>
    {
      if( (HAL_GetTick() - tickstart ) > PLL2_TIMEOUT_VALUE)
2401526a:	f7eb faf3 	bl	24000854 <HAL_GetTick>
2401526e:	4602      	mov	r2, r0
24015270:	68bb      	ldr	r3, [r7, #8]
24015272:	1ad3      	subs	r3, r2, r3
24015274:	2b02      	cmp	r3, #2
24015276:	d901      	bls.n	2401527c <RCCEx_PLL2_Config+0x44>
      {
        return HAL_TIMEOUT;
24015278:	2303      	movs	r3, #3
2401527a:	e086      	b.n	2401538a <RCCEx_PLL2_Config+0x152>
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY) != 0U)
2401527c:	4b45      	ldr	r3, [pc, #276]	; (24015394 <RCCEx_PLL2_Config+0x15c>)
2401527e:	681b      	ldr	r3, [r3, #0]
24015280:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
24015284:	2b00      	cmp	r3, #0
24015286:	d1f0      	bne.n	2401526a <RCCEx_PLL2_Config+0x32>
      }
    }

    /* Configure PLL2 multiplication and division factors. */
    __HAL_RCC_PLL2_CONFIG(pll2->PLL2M,
24015288:	4b42      	ldr	r3, [pc, #264]	; (24015394 <RCCEx_PLL2_Config+0x15c>)
2401528a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
2401528c:	f423 327c 	bic.w	r2, r3, #258048	; 0x3f000
24015290:	687b      	ldr	r3, [r7, #4]
24015292:	681b      	ldr	r3, [r3, #0]
24015294:	031b      	lsls	r3, r3, #12
24015296:	493f      	ldr	r1, [pc, #252]	; (24015394 <RCCEx_PLL2_Config+0x15c>)
24015298:	4313      	orrs	r3, r2
2401529a:	628b      	str	r3, [r1, #40]	; 0x28
2401529c:	687b      	ldr	r3, [r7, #4]
2401529e:	685b      	ldr	r3, [r3, #4]
240152a0:	3b01      	subs	r3, #1
240152a2:	f3c3 0208 	ubfx	r2, r3, #0, #9
240152a6:	687b      	ldr	r3, [r7, #4]
240152a8:	689b      	ldr	r3, [r3, #8]
240152aa:	3b01      	subs	r3, #1
240152ac:	025b      	lsls	r3, r3, #9
240152ae:	b29b      	uxth	r3, r3
240152b0:	431a      	orrs	r2, r3
240152b2:	687b      	ldr	r3, [r7, #4]
240152b4:	68db      	ldr	r3, [r3, #12]
240152b6:	3b01      	subs	r3, #1
240152b8:	041b      	lsls	r3, r3, #16
240152ba:	f403 03fe 	and.w	r3, r3, #8323072	; 0x7f0000
240152be:	431a      	orrs	r2, r3
240152c0:	687b      	ldr	r3, [r7, #4]
240152c2:	691b      	ldr	r3, [r3, #16]
240152c4:	3b01      	subs	r3, #1
240152c6:	061b      	lsls	r3, r3, #24
240152c8:	f003 43fe 	and.w	r3, r3, #2130706432	; 0x7f000000
240152cc:	4931      	ldr	r1, [pc, #196]	; (24015394 <RCCEx_PLL2_Config+0x15c>)
240152ce:	4313      	orrs	r3, r2
240152d0:	638b      	str	r3, [r1, #56]	; 0x38
                          pll2->PLL2P,
                          pll2->PLL2Q,
                          pll2->PLL2R);

    /* Select PLL2 input reference frequency range: VCI */
    __HAL_RCC_PLL2_VCIRANGE(pll2->PLL2RGE) ;
240152d2:	4b30      	ldr	r3, [pc, #192]	; (24015394 <RCCEx_PLL2_Config+0x15c>)
240152d4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
240152d6:	f023 02c0 	bic.w	r2, r3, #192	; 0xc0
240152da:	687b      	ldr	r3, [r7, #4]
240152dc:	695b      	ldr	r3, [r3, #20]
240152de:	492d      	ldr	r1, [pc, #180]	; (24015394 <RCCEx_PLL2_Config+0x15c>)
240152e0:	4313      	orrs	r3, r2
240152e2:	62cb      	str	r3, [r1, #44]	; 0x2c

    /* Select PLL2 output frequency range : VCO */
    __HAL_RCC_PLL2_VCORANGE(pll2->PLL2VCOSEL) ;
240152e4:	4b2b      	ldr	r3, [pc, #172]	; (24015394 <RCCEx_PLL2_Config+0x15c>)
240152e6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
240152e8:	f023 0220 	bic.w	r2, r3, #32
240152ec:	687b      	ldr	r3, [r7, #4]
240152ee:	699b      	ldr	r3, [r3, #24]
240152f0:	4928      	ldr	r1, [pc, #160]	; (24015394 <RCCEx_PLL2_Config+0x15c>)
240152f2:	4313      	orrs	r3, r2
240152f4:	62cb      	str	r3, [r1, #44]	; 0x2c

    /* Disable PLL2FRACN . */
    __HAL_RCC_PLL2FRACN_DISABLE();
240152f6:	4b27      	ldr	r3, [pc, #156]	; (24015394 <RCCEx_PLL2_Config+0x15c>)
240152f8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
240152fa:	4a26      	ldr	r2, [pc, #152]	; (24015394 <RCCEx_PLL2_Config+0x15c>)
240152fc:	f023 0310 	bic.w	r3, r3, #16
24015300:	62d3      	str	r3, [r2, #44]	; 0x2c

    /* Configures PLL2 clock Fractional Part Of The Multiplication Factor */
    __HAL_RCC_PLL2FRACN_CONFIG(pll2->PLL2FRACN);
24015302:	4b24      	ldr	r3, [pc, #144]	; (24015394 <RCCEx_PLL2_Config+0x15c>)
24015304:	6bda      	ldr	r2, [r3, #60]	; 0x3c
24015306:	4b24      	ldr	r3, [pc, #144]	; (24015398 <RCCEx_PLL2_Config+0x160>)
24015308:	4013      	ands	r3, r2
2401530a:	687a      	ldr	r2, [r7, #4]
2401530c:	69d2      	ldr	r2, [r2, #28]
2401530e:	00d2      	lsls	r2, r2, #3
24015310:	4920      	ldr	r1, [pc, #128]	; (24015394 <RCCEx_PLL2_Config+0x15c>)
24015312:	4313      	orrs	r3, r2
24015314:	63cb      	str	r3, [r1, #60]	; 0x3c

    /* Enable PLL2FRACN . */
    __HAL_RCC_PLL2FRACN_ENABLE();
24015316:	4b1f      	ldr	r3, [pc, #124]	; (24015394 <RCCEx_PLL2_Config+0x15c>)
24015318:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2401531a:	4a1e      	ldr	r2, [pc, #120]	; (24015394 <RCCEx_PLL2_Config+0x15c>)
2401531c:	f043 0310 	orr.w	r3, r3, #16
24015320:	62d3      	str	r3, [r2, #44]	; 0x2c

    /* Enable the PLL2 clock output */
    if(Divider == DIVIDER_P_UPDATE)
24015322:	683b      	ldr	r3, [r7, #0]
24015324:	2b00      	cmp	r3, #0
24015326:	d106      	bne.n	24015336 <RCCEx_PLL2_Config+0xfe>
    {
      __HAL_RCC_PLL2CLKOUT_ENABLE(RCC_PLL2_DIVP);
24015328:	4b1a      	ldr	r3, [pc, #104]	; (24015394 <RCCEx_PLL2_Config+0x15c>)
2401532a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2401532c:	4a19      	ldr	r2, [pc, #100]	; (24015394 <RCCEx_PLL2_Config+0x15c>)
2401532e:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
24015332:	62d3      	str	r3, [r2, #44]	; 0x2c
24015334:	e00f      	b.n	24015356 <RCCEx_PLL2_Config+0x11e>
    }
    else if(Divider == DIVIDER_Q_UPDATE)
24015336:	683b      	ldr	r3, [r7, #0]
24015338:	2b01      	cmp	r3, #1
2401533a:	d106      	bne.n	2401534a <RCCEx_PLL2_Config+0x112>
    {
      __HAL_RCC_PLL2CLKOUT_ENABLE(RCC_PLL2_DIVQ);
2401533c:	4b15      	ldr	r3, [pc, #84]	; (24015394 <RCCEx_PLL2_Config+0x15c>)
2401533e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24015340:	4a14      	ldr	r2, [pc, #80]	; (24015394 <RCCEx_PLL2_Config+0x15c>)
24015342:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
24015346:	62d3      	str	r3, [r2, #44]	; 0x2c
24015348:	e005      	b.n	24015356 <RCCEx_PLL2_Config+0x11e>
    }
    else
    {
      __HAL_RCC_PLL2CLKOUT_ENABLE(RCC_PLL2_DIVR);
2401534a:	4b12      	ldr	r3, [pc, #72]	; (24015394 <RCCEx_PLL2_Config+0x15c>)
2401534c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2401534e:	4a11      	ldr	r2, [pc, #68]	; (24015394 <RCCEx_PLL2_Config+0x15c>)
24015350:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
24015354:	62d3      	str	r3, [r2, #44]	; 0x2c
    }

    /* Enable  PLL2. */
    __HAL_RCC_PLL2_ENABLE();
24015356:	4b0f      	ldr	r3, [pc, #60]	; (24015394 <RCCEx_PLL2_Config+0x15c>)
24015358:	681b      	ldr	r3, [r3, #0]
2401535a:	4a0e      	ldr	r2, [pc, #56]	; (24015394 <RCCEx_PLL2_Config+0x15c>)
2401535c:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
24015360:	6013      	str	r3, [r2, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
24015362:	f7eb fa77 	bl	24000854 <HAL_GetTick>
24015366:	60b8      	str	r0, [r7, #8]

    /* Wait till PLL2 is ready */
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY) == 0U)
24015368:	e008      	b.n	2401537c <RCCEx_PLL2_Config+0x144>
    {
      if( (HAL_GetTick() - tickstart ) > PLL2_TIMEOUT_VALUE)
2401536a:	f7eb fa73 	bl	24000854 <HAL_GetTick>
2401536e:	4602      	mov	r2, r0
24015370:	68bb      	ldr	r3, [r7, #8]
24015372:	1ad3      	subs	r3, r2, r3
24015374:	2b02      	cmp	r3, #2
24015376:	d901      	bls.n	2401537c <RCCEx_PLL2_Config+0x144>
      {
        return HAL_TIMEOUT;
24015378:	2303      	movs	r3, #3
2401537a:	e006      	b.n	2401538a <RCCEx_PLL2_Config+0x152>
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY) == 0U)
2401537c:	4b05      	ldr	r3, [pc, #20]	; (24015394 <RCCEx_PLL2_Config+0x15c>)
2401537e:	681b      	ldr	r3, [r3, #0]
24015380:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
24015384:	2b00      	cmp	r3, #0
24015386:	d0f0      	beq.n	2401536a <RCCEx_PLL2_Config+0x132>
    }

  }


  return status;
24015388:	7bfb      	ldrb	r3, [r7, #15]
}
2401538a:	4618      	mov	r0, r3
2401538c:	3710      	adds	r7, #16
2401538e:	46bd      	mov	sp, r7
24015390:	bd80      	pop	{r7, pc}
24015392:	bf00      	nop
24015394:	58024400 	.word	0x58024400
24015398:	ffff0007 	.word	0xffff0007

2401539c <RCCEx_PLL3_Config>:
  * @note   PLL3 is temporary disabled to apply new parameters
  *
  * @retval HAL status
  */
static HAL_StatusTypeDef RCCEx_PLL3_Config(RCC_PLL3InitTypeDef *pll3, uint32_t Divider)
{
2401539c:	b580      	push	{r7, lr}
2401539e:	b084      	sub	sp, #16
240153a0:	af00      	add	r7, sp, #0
240153a2:	6078      	str	r0, [r7, #4]
240153a4:	6039      	str	r1, [r7, #0]
  uint32_t tickstart;
  HAL_StatusTypeDef status = HAL_OK;
240153a6:	2300      	movs	r3, #0
240153a8:	73fb      	strb	r3, [r7, #15]
  assert_param(IS_RCC_PLL3RGE_VALUE(pll3->PLL3RGE));
  assert_param(IS_RCC_PLL3VCO_VALUE(pll3->PLL3VCOSEL));
  assert_param(IS_RCC_PLLFRACN_VALUE(pll3->PLL3FRACN));

  /* Check that PLL3 OSC clock source is already set */
  if(__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_NONE)
240153aa:	4b53      	ldr	r3, [pc, #332]	; (240154f8 <RCCEx_PLL3_Config+0x15c>)
240153ac:	6a9b      	ldr	r3, [r3, #40]	; 0x28
240153ae:	f003 0303 	and.w	r3, r3, #3
240153b2:	2b03      	cmp	r3, #3
240153b4:	d101      	bne.n	240153ba <RCCEx_PLL3_Config+0x1e>
  {
    return HAL_ERROR;
240153b6:	2301      	movs	r3, #1
240153b8:	e099      	b.n	240154ee <RCCEx_PLL3_Config+0x152>


  else
  {
    /* Disable  PLL3. */
    __HAL_RCC_PLL3_DISABLE();
240153ba:	4b4f      	ldr	r3, [pc, #316]	; (240154f8 <RCCEx_PLL3_Config+0x15c>)
240153bc:	681b      	ldr	r3, [r3, #0]
240153be:	4a4e      	ldr	r2, [pc, #312]	; (240154f8 <RCCEx_PLL3_Config+0x15c>)
240153c0:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
240153c4:	6013      	str	r3, [r2, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
240153c6:	f7eb fa45 	bl	24000854 <HAL_GetTick>
240153ca:	60b8      	str	r0, [r7, #8]
    /* Wait till PLL3 is ready */
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL3RDY) != 0U)
240153cc:	e008      	b.n	240153e0 <RCCEx_PLL3_Config+0x44>
    {
      if( (HAL_GetTick() - tickstart ) > PLL3_TIMEOUT_VALUE)
240153ce:	f7eb fa41 	bl	24000854 <HAL_GetTick>
240153d2:	4602      	mov	r2, r0
240153d4:	68bb      	ldr	r3, [r7, #8]
240153d6:	1ad3      	subs	r3, r2, r3
240153d8:	2b02      	cmp	r3, #2
240153da:	d901      	bls.n	240153e0 <RCCEx_PLL3_Config+0x44>
      {
        return HAL_TIMEOUT;
240153dc:	2303      	movs	r3, #3
240153de:	e086      	b.n	240154ee <RCCEx_PLL3_Config+0x152>
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL3RDY) != 0U)
240153e0:	4b45      	ldr	r3, [pc, #276]	; (240154f8 <RCCEx_PLL3_Config+0x15c>)
240153e2:	681b      	ldr	r3, [r3, #0]
240153e4:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
240153e8:	2b00      	cmp	r3, #0
240153ea:	d1f0      	bne.n	240153ce <RCCEx_PLL3_Config+0x32>
      }
    }

    /* Configure the PLL3  multiplication and division factors. */
    __HAL_RCC_PLL3_CONFIG(pll3->PLL3M,
240153ec:	4b42      	ldr	r3, [pc, #264]	; (240154f8 <RCCEx_PLL3_Config+0x15c>)
240153ee:	6a9b      	ldr	r3, [r3, #40]	; 0x28
240153f0:	f023 727c 	bic.w	r2, r3, #66060288	; 0x3f00000
240153f4:	687b      	ldr	r3, [r7, #4]
240153f6:	681b      	ldr	r3, [r3, #0]
240153f8:	051b      	lsls	r3, r3, #20
240153fa:	493f      	ldr	r1, [pc, #252]	; (240154f8 <RCCEx_PLL3_Config+0x15c>)
240153fc:	4313      	orrs	r3, r2
240153fe:	628b      	str	r3, [r1, #40]	; 0x28
24015400:	687b      	ldr	r3, [r7, #4]
24015402:	685b      	ldr	r3, [r3, #4]
24015404:	3b01      	subs	r3, #1
24015406:	f3c3 0208 	ubfx	r2, r3, #0, #9
2401540a:	687b      	ldr	r3, [r7, #4]
2401540c:	689b      	ldr	r3, [r3, #8]
2401540e:	3b01      	subs	r3, #1
24015410:	025b      	lsls	r3, r3, #9
24015412:	b29b      	uxth	r3, r3
24015414:	431a      	orrs	r2, r3
24015416:	687b      	ldr	r3, [r7, #4]
24015418:	68db      	ldr	r3, [r3, #12]
2401541a:	3b01      	subs	r3, #1
2401541c:	041b      	lsls	r3, r3, #16
2401541e:	f403 03fe 	and.w	r3, r3, #8323072	; 0x7f0000
24015422:	431a      	orrs	r2, r3
24015424:	687b      	ldr	r3, [r7, #4]
24015426:	691b      	ldr	r3, [r3, #16]
24015428:	3b01      	subs	r3, #1
2401542a:	061b      	lsls	r3, r3, #24
2401542c:	f003 43fe 	and.w	r3, r3, #2130706432	; 0x7f000000
24015430:	4931      	ldr	r1, [pc, #196]	; (240154f8 <RCCEx_PLL3_Config+0x15c>)
24015432:	4313      	orrs	r3, r2
24015434:	640b      	str	r3, [r1, #64]	; 0x40
                          pll3->PLL3P,
                          pll3->PLL3Q,
                          pll3->PLL3R);

    /* Select PLL3 input reference frequency range: VCI */
    __HAL_RCC_PLL3_VCIRANGE(pll3->PLL3RGE) ;
24015436:	4b30      	ldr	r3, [pc, #192]	; (240154f8 <RCCEx_PLL3_Config+0x15c>)
24015438:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2401543a:	f423 6240 	bic.w	r2, r3, #3072	; 0xc00
2401543e:	687b      	ldr	r3, [r7, #4]
24015440:	695b      	ldr	r3, [r3, #20]
24015442:	492d      	ldr	r1, [pc, #180]	; (240154f8 <RCCEx_PLL3_Config+0x15c>)
24015444:	4313      	orrs	r3, r2
24015446:	62cb      	str	r3, [r1, #44]	; 0x2c

    /* Select PLL3 output frequency range : VCO */
    __HAL_RCC_PLL3_VCORANGE(pll3->PLL3VCOSEL) ;
24015448:	4b2b      	ldr	r3, [pc, #172]	; (240154f8 <RCCEx_PLL3_Config+0x15c>)
2401544a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2401544c:	f423 7200 	bic.w	r2, r3, #512	; 0x200
24015450:	687b      	ldr	r3, [r7, #4]
24015452:	699b      	ldr	r3, [r3, #24]
24015454:	4928      	ldr	r1, [pc, #160]	; (240154f8 <RCCEx_PLL3_Config+0x15c>)
24015456:	4313      	orrs	r3, r2
24015458:	62cb      	str	r3, [r1, #44]	; 0x2c

    /* Disable PLL3FRACN . */
    __HAL_RCC_PLL3FRACN_DISABLE();
2401545a:	4b27      	ldr	r3, [pc, #156]	; (240154f8 <RCCEx_PLL3_Config+0x15c>)
2401545c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2401545e:	4a26      	ldr	r2, [pc, #152]	; (240154f8 <RCCEx_PLL3_Config+0x15c>)
24015460:	f423 7380 	bic.w	r3, r3, #256	; 0x100
24015464:	62d3      	str	r3, [r2, #44]	; 0x2c

    /* Configures PLL3 clock Fractional Part Of The Multiplication Factor */
    __HAL_RCC_PLL3FRACN_CONFIG(pll3->PLL3FRACN);
24015466:	4b24      	ldr	r3, [pc, #144]	; (240154f8 <RCCEx_PLL3_Config+0x15c>)
24015468:	6c5a      	ldr	r2, [r3, #68]	; 0x44
2401546a:	4b24      	ldr	r3, [pc, #144]	; (240154fc <RCCEx_PLL3_Config+0x160>)
2401546c:	4013      	ands	r3, r2
2401546e:	687a      	ldr	r2, [r7, #4]
24015470:	69d2      	ldr	r2, [r2, #28]
24015472:	00d2      	lsls	r2, r2, #3
24015474:	4920      	ldr	r1, [pc, #128]	; (240154f8 <RCCEx_PLL3_Config+0x15c>)
24015476:	4313      	orrs	r3, r2
24015478:	644b      	str	r3, [r1, #68]	; 0x44

    /* Enable PLL3FRACN . */
    __HAL_RCC_PLL3FRACN_ENABLE();
2401547a:	4b1f      	ldr	r3, [pc, #124]	; (240154f8 <RCCEx_PLL3_Config+0x15c>)
2401547c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2401547e:	4a1e      	ldr	r2, [pc, #120]	; (240154f8 <RCCEx_PLL3_Config+0x15c>)
24015480:	f443 7380 	orr.w	r3, r3, #256	; 0x100
24015484:	62d3      	str	r3, [r2, #44]	; 0x2c

    /* Enable the PLL3 clock output */
    if(Divider == DIVIDER_P_UPDATE)
24015486:	683b      	ldr	r3, [r7, #0]
24015488:	2b00      	cmp	r3, #0
2401548a:	d106      	bne.n	2401549a <RCCEx_PLL3_Config+0xfe>
    {
      __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL3_DIVP);
2401548c:	4b1a      	ldr	r3, [pc, #104]	; (240154f8 <RCCEx_PLL3_Config+0x15c>)
2401548e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24015490:	4a19      	ldr	r2, [pc, #100]	; (240154f8 <RCCEx_PLL3_Config+0x15c>)
24015492:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
24015496:	62d3      	str	r3, [r2, #44]	; 0x2c
24015498:	e00f      	b.n	240154ba <RCCEx_PLL3_Config+0x11e>
    }
    else if(Divider == DIVIDER_Q_UPDATE)
2401549a:	683b      	ldr	r3, [r7, #0]
2401549c:	2b01      	cmp	r3, #1
2401549e:	d106      	bne.n	240154ae <RCCEx_PLL3_Config+0x112>
    {
      __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL3_DIVQ);
240154a0:	4b15      	ldr	r3, [pc, #84]	; (240154f8 <RCCEx_PLL3_Config+0x15c>)
240154a2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
240154a4:	4a14      	ldr	r2, [pc, #80]	; (240154f8 <RCCEx_PLL3_Config+0x15c>)
240154a6:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
240154aa:	62d3      	str	r3, [r2, #44]	; 0x2c
240154ac:	e005      	b.n	240154ba <RCCEx_PLL3_Config+0x11e>
    }
    else
    {
      __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL3_DIVR);
240154ae:	4b12      	ldr	r3, [pc, #72]	; (240154f8 <RCCEx_PLL3_Config+0x15c>)
240154b0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
240154b2:	4a11      	ldr	r2, [pc, #68]	; (240154f8 <RCCEx_PLL3_Config+0x15c>)
240154b4:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
240154b8:	62d3      	str	r3, [r2, #44]	; 0x2c
    }

    /* Enable  PLL3. */
    __HAL_RCC_PLL3_ENABLE();
240154ba:	4b0f      	ldr	r3, [pc, #60]	; (240154f8 <RCCEx_PLL3_Config+0x15c>)
240154bc:	681b      	ldr	r3, [r3, #0]
240154be:	4a0e      	ldr	r2, [pc, #56]	; (240154f8 <RCCEx_PLL3_Config+0x15c>)
240154c0:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
240154c4:	6013      	str	r3, [r2, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
240154c6:	f7eb f9c5 	bl	24000854 <HAL_GetTick>
240154ca:	60b8      	str	r0, [r7, #8]

    /* Wait till PLL3 is ready */
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL3RDY) == 0U)
240154cc:	e008      	b.n	240154e0 <RCCEx_PLL3_Config+0x144>
    {
      if( (HAL_GetTick() - tickstart ) > PLL3_TIMEOUT_VALUE)
240154ce:	f7eb f9c1 	bl	24000854 <HAL_GetTick>
240154d2:	4602      	mov	r2, r0
240154d4:	68bb      	ldr	r3, [r7, #8]
240154d6:	1ad3      	subs	r3, r2, r3
240154d8:	2b02      	cmp	r3, #2
240154da:	d901      	bls.n	240154e0 <RCCEx_PLL3_Config+0x144>
      {
        return HAL_TIMEOUT;
240154dc:	2303      	movs	r3, #3
240154de:	e006      	b.n	240154ee <RCCEx_PLL3_Config+0x152>
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL3RDY) == 0U)
240154e0:	4b05      	ldr	r3, [pc, #20]	; (240154f8 <RCCEx_PLL3_Config+0x15c>)
240154e2:	681b      	ldr	r3, [r3, #0]
240154e4:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
240154e8:	2b00      	cmp	r3, #0
240154ea:	d0f0      	beq.n	240154ce <RCCEx_PLL3_Config+0x132>
    }

  }


  return status;
240154ec:	7bfb      	ldrb	r3, [r7, #15]
}
240154ee:	4618      	mov	r0, r3
240154f0:	3710      	adds	r7, #16
240154f2:	46bd      	mov	sp, r7
240154f4:	bd80      	pop	{r7, pc}
240154f6:	bf00      	nop
240154f8:	58024400 	.word	0x58024400
240154fc:	ffff0007 	.word	0xffff0007

24015500 <HAL_RCCEx_LSECSS_IRQHandler>:
/**
  * @brief Handle the RCC LSE Clock Security System interrupt request.
  * @retval None
  */
void HAL_RCCEx_LSECSS_IRQHandler(void)
{
24015500:	b580      	push	{r7, lr}
24015502:	af00      	add	r7, sp, #0
  /* Check RCC LSE CSSF flag  */
  if(__HAL_RCC_GET_IT(RCC_IT_LSECSS))
24015504:	4b07      	ldr	r3, [pc, #28]	; (24015524 <HAL_RCCEx_LSECSS_IRQHandler+0x24>)
24015506:	6e5b      	ldr	r3, [r3, #100]	; 0x64
24015508:	f403 7300 	and.w	r3, r3, #512	; 0x200
2401550c:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
24015510:	d105      	bne.n	2401551e <HAL_RCCEx_LSECSS_IRQHandler+0x1e>
  {

    /* Clear RCC LSE CSS pending bit */
    __HAL_RCC_CLEAR_IT(RCC_IT_LSECSS);
24015512:	4b04      	ldr	r3, [pc, #16]	; (24015524 <HAL_RCCEx_LSECSS_IRQHandler+0x24>)
24015514:	f44f 7200 	mov.w	r2, #512	; 0x200
24015518:	669a      	str	r2, [r3, #104]	; 0x68

    /* RCC LSE Clock Security System interrupt user callback */
    HAL_RCCEx_LSECSS_Callback();
2401551a:	f000 f805 	bl	24015528 <HAL_RCCEx_LSECSS_Callback>

  }
}
2401551e:	bf00      	nop
24015520:	bd80      	pop	{r7, pc}
24015522:	bf00      	nop
24015524:	58024400 	.word	0x58024400

24015528 <HAL_RCCEx_LSECSS_Callback>:
/**
  * @brief  RCCEx LSE Clock Security System interrupt callback.
  * @retval none
  */
__weak void HAL_RCCEx_LSECSS_Callback(void)
{
24015528:	b480      	push	{r7}
2401552a:	af00      	add	r7, sp, #0
  /* NOTE : This function should not be modified, when the callback is needed,
            the @ref HAL_RCCEx_LSECSS_Callback should be implemented in the user file
   */
}
2401552c:	bf00      	nop
2401552e:	46bd      	mov	sp, r7
24015530:	f85d 7b04 	ldr.w	r7, [sp], #4
24015534:	4770      	bx	lr
	...

24015538 <Init>:
 * @param  None
 * @retval  LOADER_OK = 1   : Operation succeeded
 * @retval  LOADER_FAIL = 0 : Operation failed
 */
int Init(uint8_t configureMemoryMappedMode)
{
24015538:	b580      	push	{r7, lr}
2401553a:	b086      	sub	sp, #24
2401553c:	af00      	add	r7, sp, #0
2401553e:	4603      	mov	r3, r0
24015540:	71fb      	strb	r3, [r7, #7]

    *(uint32_t*)0xE000EDF0 = 0xA05F0000; //enable interrupts in debug
24015542:	4b21      	ldr	r3, [pc, #132]	; (240155c8 <Init+0x90>)
24015544:	4a21      	ldr	r2, [pc, #132]	; (240155cc <Init+0x94>)
24015546:	601a      	str	r2, [r3, #0]


    SystemInit();
24015548:	f001 f868 	bl	2401661c <SystemInit>
     * change VTOR setting for other devices
     * SCB->VTOR = 0x20000000 | 0x200;
     *
     * */

    SCB->VTOR = 0x24000000 | 0x200;
2401554c:	4b20      	ldr	r3, [pc, #128]	; (240155d0 <Init+0x98>)
2401554e:	4a21      	ldr	r2, [pc, #132]	; (240155d4 <Init+0x9c>)
24015550:	609a      	str	r2, [r3, #8]
24015552:	2300      	movs	r3, #0
24015554:	617b      	str	r3, [r7, #20]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
24015556:	697b      	ldr	r3, [r7, #20]
24015558:	f383 8810 	msr	PRIMASK, r3

    __set_PRIMASK(0); //enable interrupts

    HAL_Init();
2401555c:	f7eb f88e 	bl	2400067c <HAL_Init>

    SystemClock_Config();
24015560:	f000 fa30 	bl	240159c4 <SystemClock_Config>

    __HAL_RCC_QSPI_FORCE_RESET();  //completely reset peripheral
24015564:	4b1c      	ldr	r3, [pc, #112]	; (240155d8 <Init+0xa0>)
24015566:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
24015568:	4a1b      	ldr	r2, [pc, #108]	; (240155d8 <Init+0xa0>)
2401556a:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
2401556e:	67d3      	str	r3, [r2, #124]	; 0x7c
    __HAL_RCC_QSPI_RELEASE_RESET();
24015570:	4b19      	ldr	r3, [pc, #100]	; (240155d8 <Init+0xa0>)
24015572:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
24015574:	4a18      	ldr	r2, [pc, #96]	; (240155d8 <Init+0xa0>)
24015576:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
2401557a:	67d3      	str	r3, [r2, #124]	; 0x7c

    if (CSP_QUADSPI_Init() != HAL_OK)
2401557c:	f000 fba0 	bl	24015cc0 <CSP_QUADSPI_Init>
24015580:	4603      	mov	r3, r0
24015582:	2b00      	cmp	r3, #0
24015584:	d006      	beq.n	24015594 <Init+0x5c>
24015586:	2301      	movs	r3, #1
24015588:	613b      	str	r3, [r7, #16]
2401558a:	693b      	ldr	r3, [r7, #16]
2401558c:	f383 8810 	msr	PRIMASK, r3
    {
        __set_PRIMASK(1); //disable interrupts
        return LOADER_FAIL;
24015590:	2300      	movs	r3, #0
24015592:	e014      	b.n	240155be <Init+0x86>
    }

    if(!configureMemoryMappedMode)
24015594:	79fb      	ldrb	r3, [r7, #7]
24015596:	2b00      	cmp	r3, #0
24015598:	d10b      	bne.n	240155b2 <Init+0x7a>
		if (CSP_QSPI_EnableMemoryMappedMode() != HAL_OK)
2401559a:	f000 fd7d 	bl	24016098 <CSP_QSPI_EnableMemoryMappedMode>
2401559e:	4603      	mov	r3, r0
240155a0:	2b00      	cmp	r3, #0
240155a2:	d006      	beq.n	240155b2 <Init+0x7a>
240155a4:	2301      	movs	r3, #1
240155a6:	60fb      	str	r3, [r7, #12]
240155a8:	68fb      	ldr	r3, [r7, #12]
240155aa:	f383 8810 	msr	PRIMASK, r3
		{
			__set_PRIMASK(1); //disable interrupts
			return LOADER_FAIL;
240155ae:	2300      	movs	r3, #0
240155b0:	e005      	b.n	240155be <Init+0x86>
240155b2:	2301      	movs	r3, #1
240155b4:	60bb      	str	r3, [r7, #8]
240155b6:	68bb      	ldr	r3, [r7, #8]
240155b8:	f383 8810 	msr	PRIMASK, r3
		}

    __set_PRIMASK(1); //disable interrupts
    return LOADER_OK;
240155bc:	2301      	movs	r3, #1
}
240155be:	4618      	mov	r0, r3
240155c0:	3718      	adds	r7, #24
240155c2:	46bd      	mov	sp, r7
240155c4:	bd80      	pop	{r7, pc}
240155c6:	bf00      	nop
240155c8:	e000edf0 	.word	0xe000edf0
240155cc:	a05f0000 	.word	0xa05f0000
240155d0:	e000ed00 	.word	0xe000ed00
240155d4:	24000200 	.word	0x24000200
240155d8:	58024400 	.word	0x58024400

240155dc <Write>:
 * @param   buffer : pointer to data buffer
 * @retval  LOADER_OK = 1       : Operation succeeded
 * @retval  LOADER_FAIL = 0 : Operation failed
 */
int Write(uint32_t Address, uint32_t Size, uint8_t* buffer)
{
240155dc:	b580      	push	{r7, lr}
240155de:	b088      	sub	sp, #32
240155e0:	af00      	add	r7, sp, #0
240155e2:	60f8      	str	r0, [r7, #12]
240155e4:	60b9      	str	r1, [r7, #8]
240155e6:	607a      	str	r2, [r7, #4]
240155e8:	2300      	movs	r3, #0
240155ea:	61fb      	str	r3, [r7, #28]
240155ec:	69fb      	ldr	r3, [r7, #28]
240155ee:	f383 8810 	msr	PRIMASK, r3
    __set_PRIMASK(0); //enable interrupts

    if(HAL_QSPI_Abort(&hqspi) != HAL_OK)
240155f2:	4814      	ldr	r0, [pc, #80]	; (24015644 <Write+0x68>)
240155f4:	f7fb ff21 	bl	2401143a <HAL_QSPI_Abort>
240155f8:	4603      	mov	r3, r0
240155fa:	2b00      	cmp	r3, #0
240155fc:	d006      	beq.n	2401560c <Write+0x30>
240155fe:	2301      	movs	r3, #1
24015600:	61bb      	str	r3, [r7, #24]
24015602:	69bb      	ldr	r3, [r7, #24]
24015604:	f383 8810 	msr	PRIMASK, r3
    {
        __set_PRIMASK(1); //disable interrupts
        return LOADER_FAIL;
24015608:	2300      	movs	r3, #0
2401560a:	e017      	b.n	2401563c <Write+0x60>
    }


    if(CSP_QSPI_WriteMemory((uint8_t*) buffer, (Address & (0x00ffffff)), Size) != HAL_OK)
2401560c:	68fb      	ldr	r3, [r7, #12]
2401560e:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
24015612:	68ba      	ldr	r2, [r7, #8]
24015614:	4619      	mov	r1, r3
24015616:	6878      	ldr	r0, [r7, #4]
24015618:	f000 fcb0 	bl	24015f7c <CSP_QSPI_WriteMemory>
2401561c:	4603      	mov	r3, r0
2401561e:	2b00      	cmp	r3, #0
24015620:	d006      	beq.n	24015630 <Write+0x54>
24015622:	2301      	movs	r3, #1
24015624:	617b      	str	r3, [r7, #20]
24015626:	697b      	ldr	r3, [r7, #20]
24015628:	f383 8810 	msr	PRIMASK, r3
    {
        __set_PRIMASK(1); //disable interrupts
        return LOADER_FAIL;
2401562c:	2300      	movs	r3, #0
2401562e:	e005      	b.n	2401563c <Write+0x60>
24015630:	2301      	movs	r3, #1
24015632:	613b      	str	r3, [r7, #16]
24015634:	693b      	ldr	r3, [r7, #16]
24015636:	f383 8810 	msr	PRIMASK, r3
    }
    __set_PRIMASK(1); //disable interrupts
    return LOADER_OK;
2401563a:	2301      	movs	r3, #1
}
2401563c:	4618      	mov	r0, r3
2401563e:	3720      	adds	r7, #32
24015640:	46bd      	mov	sp, r7
24015642:	bd80      	pop	{r7, pc}
24015644:	24000568 	.word	0x24000568

24015648 <SectorErase>:
 * @param   EraseEndAddress   :  erase end address
 * @retval  LOADER_OK = 1       : Operation succeeded
 * @retval  LOADER_FAIL = 0 : Operation failed
 */
int SectorErase(uint32_t EraseStartAddress, uint32_t EraseEndAddress)
{
24015648:	b580      	push	{r7, lr}
2401564a:	b086      	sub	sp, #24
2401564c:	af00      	add	r7, sp, #0
2401564e:	6078      	str	r0, [r7, #4]
24015650:	6039      	str	r1, [r7, #0]
24015652:	2300      	movs	r3, #0
24015654:	617b      	str	r3, [r7, #20]
24015656:	697b      	ldr	r3, [r7, #20]
24015658:	f383 8810 	msr	PRIMASK, r3

    __set_PRIMASK(0); //enable interrupts
    if (HAL_QSPI_Abort(&hqspi) != HAL_OK)
2401565c:	4812      	ldr	r0, [pc, #72]	; (240156a8 <SectorErase+0x60>)
2401565e:	f7fb feec 	bl	2401143a <HAL_QSPI_Abort>
24015662:	4603      	mov	r3, r0
24015664:	2b00      	cmp	r3, #0
24015666:	d006      	beq.n	24015676 <SectorErase+0x2e>
24015668:	2301      	movs	r3, #1
2401566a:	613b      	str	r3, [r7, #16]
2401566c:	693b      	ldr	r3, [r7, #16]
2401566e:	f383 8810 	msr	PRIMASK, r3
    {
        __set_PRIMASK(1); //disable interrupts
        return LOADER_FAIL;
24015672:	2300      	movs	r3, #0
24015674:	e013      	b.n	2401569e <SectorErase+0x56>
    }


    if (CSP_QSPI_EraseSector(EraseStartAddress, EraseEndAddress) != HAL_OK)
24015676:	6839      	ldr	r1, [r7, #0]
24015678:	6878      	ldr	r0, [r7, #4]
2401567a:	f000 fc2b 	bl	24015ed4 <CSP_QSPI_EraseSector>
2401567e:	4603      	mov	r3, r0
24015680:	2b00      	cmp	r3, #0
24015682:	d006      	beq.n	24015692 <SectorErase+0x4a>
24015684:	2301      	movs	r3, #1
24015686:	60fb      	str	r3, [r7, #12]
24015688:	68fb      	ldr	r3, [r7, #12]
2401568a:	f383 8810 	msr	PRIMASK, r3
    {
        __set_PRIMASK(1); //disable interrupts
        return LOADER_FAIL;
2401568e:	2300      	movs	r3, #0
24015690:	e005      	b.n	2401569e <SectorErase+0x56>
24015692:	2301      	movs	r3, #1
24015694:	60bb      	str	r3, [r7, #8]
24015696:	68bb      	ldr	r3, [r7, #8]
24015698:	f383 8810 	msr	PRIMASK, r3
    }

    __set_PRIMASK(1); //disable interrupts
    return LOADER_OK;
2401569c:	2301      	movs	r3, #1
}
2401569e:	4618      	mov	r0, r3
240156a0:	3718      	adds	r7, #24
240156a2:	46bd      	mov	sp, r7
240156a4:	bd80      	pop	{r7, pc}
240156a6:	bf00      	nop
240156a8:	24000568 	.word	0x24000568

240156ac <MassErase>:
 * outputs   :
 *     none
 * Note: Optional for all types of device
 */
int MassErase(void)
{
240156ac:	b580      	push	{r7, lr}
240156ae:	b084      	sub	sp, #16
240156b0:	af00      	add	r7, sp, #0
240156b2:	2300      	movs	r3, #0
240156b4:	60fb      	str	r3, [r7, #12]
240156b6:	68fb      	ldr	r3, [r7, #12]
240156b8:	f383 8810 	msr	PRIMASK, r3

    __set_PRIMASK(0); //enable interrupts

    if (HAL_QSPI_Abort(&hqspi) != HAL_OK)
240156bc:	4811      	ldr	r0, [pc, #68]	; (24015704 <MassErase+0x58>)
240156be:	f7fb febc 	bl	2401143a <HAL_QSPI_Abort>
240156c2:	4603      	mov	r3, r0
240156c4:	2b00      	cmp	r3, #0
240156c6:	d006      	beq.n	240156d6 <MassErase+0x2a>
240156c8:	2301      	movs	r3, #1
240156ca:	60bb      	str	r3, [r7, #8]
240156cc:	68bb      	ldr	r3, [r7, #8]
240156ce:	f383 8810 	msr	PRIMASK, r3
    {
        __set_PRIMASK(1); //disable interrupts
        return LOADER_FAIL;
240156d2:	2300      	movs	r3, #0
240156d4:	e011      	b.n	240156fa <MassErase+0x4e>
    }


    if (CSP_QSPI_Erase_Chip() != HAL_OK)
240156d6:	f000 fb17 	bl	24015d08 <CSP_QSPI_Erase_Chip>
240156da:	4603      	mov	r3, r0
240156dc:	2b00      	cmp	r3, #0
240156de:	d006      	beq.n	240156ee <MassErase+0x42>
240156e0:	2301      	movs	r3, #1
240156e2:	607b      	str	r3, [r7, #4]
240156e4:	687b      	ldr	r3, [r7, #4]
240156e6:	f383 8810 	msr	PRIMASK, r3
    {
        __set_PRIMASK(1); //disable interrupts
        return LOADER_FAIL;
240156ea:	2300      	movs	r3, #0
240156ec:	e005      	b.n	240156fa <MassErase+0x4e>
240156ee:	2301      	movs	r3, #1
240156f0:	603b      	str	r3, [r7, #0]
240156f2:	683b      	ldr	r3, [r7, #0]
240156f4:	f383 8810 	msr	PRIMASK, r3
    }

    __set_PRIMASK(1); //disable interrupts
    return LOADER_OK;
240156f8:	2301      	movs	r3, #1
}
240156fa:	4618      	mov	r0, r3
240156fc:	3710      	adds	r7, #16
240156fe:	46bd      	mov	sp, r7
24015700:	bd80      	pop	{r7, pc}
24015702:	bf00      	nop
24015704:	24000568 	.word	0x24000568

24015708 <CheckSum>:
 * outputs   :
 *     R0             : Checksum value
 * Note: Optional for all types of device
 */
uint32_t CheckSum(uint32_t StartAddress, uint32_t Size, uint32_t InitVal)
{
24015708:	b480      	push	{r7}
2401570a:	b089      	sub	sp, #36	; 0x24
2401570c:	af00      	add	r7, sp, #0
2401570e:	60f8      	str	r0, [r7, #12]
24015710:	60b9      	str	r1, [r7, #8]
24015712:	607a      	str	r2, [r7, #4]
    uint8_t missalignementAddress = StartAddress % 4;
24015714:	68fb      	ldr	r3, [r7, #12]
24015716:	b2db      	uxtb	r3, r3
24015718:	f003 0303 	and.w	r3, r3, #3
2401571c:	77fb      	strb	r3, [r7, #31]
    uint8_t missalignementSize = Size;
2401571e:	68bb      	ldr	r3, [r7, #8]
24015720:	77bb      	strb	r3, [r7, #30]
    int cnt;
    uint32_t Val;

    StartAddress -= StartAddress % 4;
24015722:	68fb      	ldr	r3, [r7, #12]
24015724:	f023 0303 	bic.w	r3, r3, #3
24015728:	60fb      	str	r3, [r7, #12]
    Size += (Size % 4 == 0) ? 0 : 4 - (Size % 4);
2401572a:	68bb      	ldr	r3, [r7, #8]
2401572c:	f003 0303 	and.w	r3, r3, #3
24015730:	2b00      	cmp	r3, #0
24015732:	d005      	beq.n	24015740 <CheckSum+0x38>
24015734:	68bb      	ldr	r3, [r7, #8]
24015736:	f003 0303 	and.w	r3, r3, #3
2401573a:	f1c3 0304 	rsb	r3, r3, #4
2401573e:	e000      	b.n	24015742 <CheckSum+0x3a>
24015740:	2300      	movs	r3, #0
24015742:	68ba      	ldr	r2, [r7, #8]
24015744:	4413      	add	r3, r2
24015746:	60bb      	str	r3, [r7, #8]

    for (cnt = 0; cnt < Size; cnt += 4)
24015748:	2300      	movs	r3, #0
2401574a:	61bb      	str	r3, [r7, #24]
2401574c:	e0af      	b.n	240158ae <CheckSum+0x1a6>
    {
        Val = *(uint32_t*) StartAddress;
2401574e:	68fb      	ldr	r3, [r7, #12]
24015750:	681b      	ldr	r3, [r3, #0]
24015752:	617b      	str	r3, [r7, #20]
        if (missalignementAddress)
24015754:	7ffb      	ldrb	r3, [r7, #31]
24015756:	2b00      	cmp	r3, #0
24015758:	d03e      	beq.n	240157d8 <CheckSum+0xd0>
        {
            switch (missalignementAddress)
2401575a:	7ffb      	ldrb	r3, [r7, #31]
2401575c:	2b02      	cmp	r3, #2
2401575e:	d01d      	beq.n	2401579c <CheckSum+0x94>
24015760:	2b03      	cmp	r3, #3
24015762:	d02d      	beq.n	240157c0 <CheckSum+0xb8>
24015764:	2b01      	cmp	r3, #1
24015766:	f040 809c 	bne.w	240158a2 <CheckSum+0x19a>
            {
                case 1:
                    InitVal += (uint8_t) (Val >> 8 & 0xff);
2401576a:	697b      	ldr	r3, [r7, #20]
2401576c:	0a1b      	lsrs	r3, r3, #8
2401576e:	b2db      	uxtb	r3, r3
24015770:	461a      	mov	r2, r3
24015772:	687b      	ldr	r3, [r7, #4]
24015774:	4413      	add	r3, r2
24015776:	607b      	str	r3, [r7, #4]
                    InitVal += (uint8_t) (Val >> 16 & 0xff);
24015778:	697b      	ldr	r3, [r7, #20]
2401577a:	0c1b      	lsrs	r3, r3, #16
2401577c:	b2db      	uxtb	r3, r3
2401577e:	461a      	mov	r2, r3
24015780:	687b      	ldr	r3, [r7, #4]
24015782:	4413      	add	r3, r2
24015784:	607b      	str	r3, [r7, #4]
                    InitVal += (uint8_t) (Val >> 24 & 0xff);
24015786:	697b      	ldr	r3, [r7, #20]
24015788:	0e1b      	lsrs	r3, r3, #24
2401578a:	b2db      	uxtb	r3, r3
2401578c:	461a      	mov	r2, r3
2401578e:	687b      	ldr	r3, [r7, #4]
24015790:	4413      	add	r3, r2
24015792:	607b      	str	r3, [r7, #4]
                    missalignementAddress -= 1;
24015794:	7ffb      	ldrb	r3, [r7, #31]
24015796:	3b01      	subs	r3, #1
24015798:	77fb      	strb	r3, [r7, #31]
                    break;
2401579a:	e082      	b.n	240158a2 <CheckSum+0x19a>
                case 2:
                    InitVal += (uint8_t) (Val >> 16 & 0xff);
2401579c:	697b      	ldr	r3, [r7, #20]
2401579e:	0c1b      	lsrs	r3, r3, #16
240157a0:	b2db      	uxtb	r3, r3
240157a2:	461a      	mov	r2, r3
240157a4:	687b      	ldr	r3, [r7, #4]
240157a6:	4413      	add	r3, r2
240157a8:	607b      	str	r3, [r7, #4]
                    InitVal += (uint8_t) (Val >> 24 & 0xff);
240157aa:	697b      	ldr	r3, [r7, #20]
240157ac:	0e1b      	lsrs	r3, r3, #24
240157ae:	b2db      	uxtb	r3, r3
240157b0:	461a      	mov	r2, r3
240157b2:	687b      	ldr	r3, [r7, #4]
240157b4:	4413      	add	r3, r2
240157b6:	607b      	str	r3, [r7, #4]
                    missalignementAddress -= 2;
240157b8:	7ffb      	ldrb	r3, [r7, #31]
240157ba:	3b02      	subs	r3, #2
240157bc:	77fb      	strb	r3, [r7, #31]
                    break;
240157be:	e070      	b.n	240158a2 <CheckSum+0x19a>
                case 3:
                    InitVal += (uint8_t) (Val >> 24 & 0xff);
240157c0:	697b      	ldr	r3, [r7, #20]
240157c2:	0e1b      	lsrs	r3, r3, #24
240157c4:	b2db      	uxtb	r3, r3
240157c6:	461a      	mov	r2, r3
240157c8:	687b      	ldr	r3, [r7, #4]
240157ca:	4413      	add	r3, r2
240157cc:	607b      	str	r3, [r7, #4]
                    missalignementAddress -= 3;
240157ce:	7ffb      	ldrb	r3, [r7, #31]
240157d0:	3b03      	subs	r3, #3
240157d2:	77fb      	strb	r3, [r7, #31]
                    break;
240157d4:	bf00      	nop
240157d6:	e064      	b.n	240158a2 <CheckSum+0x19a>
            }
        }else if ((Size - missalignementSize) % 4 && (Size - cnt) <= 4)
240157d8:	7fbb      	ldrb	r3, [r7, #30]
240157da:	68ba      	ldr	r2, [r7, #8]
240157dc:	1ad3      	subs	r3, r2, r3
240157de:	f003 0303 	and.w	r3, r3, #3
240157e2:	2b00      	cmp	r3, #0
240157e4:	d042      	beq.n	2401586c <CheckSum+0x164>
240157e6:	69bb      	ldr	r3, [r7, #24]
240157e8:	68ba      	ldr	r2, [r7, #8]
240157ea:	1ad3      	subs	r3, r2, r3
240157ec:	2b04      	cmp	r3, #4
240157ee:	d83d      	bhi.n	2401586c <CheckSum+0x164>
        {
            switch (Size - missalignementSize)
240157f0:	7fbb      	ldrb	r3, [r7, #30]
240157f2:	68ba      	ldr	r2, [r7, #8]
240157f4:	1ad3      	subs	r3, r2, r3
240157f6:	2b02      	cmp	r3, #2
240157f8:	d01c      	beq.n	24015834 <CheckSum+0x12c>
240157fa:	2b03      	cmp	r3, #3
240157fc:	d02b      	beq.n	24015856 <CheckSum+0x14e>
240157fe:	2b01      	cmp	r3, #1
24015800:	d000      	beq.n	24015804 <CheckSum+0xfc>
                case 3:
                    InitVal += (uint8_t) Val;
                    missalignementSize -= 3;
                    break;
            }
        }else
24015802:	e04e      	b.n	240158a2 <CheckSum+0x19a>
                    InitVal += (uint8_t) Val;
24015804:	697b      	ldr	r3, [r7, #20]
24015806:	b2db      	uxtb	r3, r3
24015808:	461a      	mov	r2, r3
2401580a:	687b      	ldr	r3, [r7, #4]
2401580c:	4413      	add	r3, r2
2401580e:	607b      	str	r3, [r7, #4]
                    InitVal += (uint8_t) (Val >> 8 & 0xff);
24015810:	697b      	ldr	r3, [r7, #20]
24015812:	0a1b      	lsrs	r3, r3, #8
24015814:	b2db      	uxtb	r3, r3
24015816:	461a      	mov	r2, r3
24015818:	687b      	ldr	r3, [r7, #4]
2401581a:	4413      	add	r3, r2
2401581c:	607b      	str	r3, [r7, #4]
                    InitVal += (uint8_t) (Val >> 16 & 0xff);
2401581e:	697b      	ldr	r3, [r7, #20]
24015820:	0c1b      	lsrs	r3, r3, #16
24015822:	b2db      	uxtb	r3, r3
24015824:	461a      	mov	r2, r3
24015826:	687b      	ldr	r3, [r7, #4]
24015828:	4413      	add	r3, r2
2401582a:	607b      	str	r3, [r7, #4]
                    missalignementSize -= 1;
2401582c:	7fbb      	ldrb	r3, [r7, #30]
2401582e:	3b01      	subs	r3, #1
24015830:	77bb      	strb	r3, [r7, #30]
                    break;
24015832:	e01a      	b.n	2401586a <CheckSum+0x162>
                    InitVal += (uint8_t) Val;
24015834:	697b      	ldr	r3, [r7, #20]
24015836:	b2db      	uxtb	r3, r3
24015838:	461a      	mov	r2, r3
2401583a:	687b      	ldr	r3, [r7, #4]
2401583c:	4413      	add	r3, r2
2401583e:	607b      	str	r3, [r7, #4]
                    InitVal += (uint8_t) (Val >> 8 & 0xff);
24015840:	697b      	ldr	r3, [r7, #20]
24015842:	0a1b      	lsrs	r3, r3, #8
24015844:	b2db      	uxtb	r3, r3
24015846:	461a      	mov	r2, r3
24015848:	687b      	ldr	r3, [r7, #4]
2401584a:	4413      	add	r3, r2
2401584c:	607b      	str	r3, [r7, #4]
                    missalignementSize -= 2;
2401584e:	7fbb      	ldrb	r3, [r7, #30]
24015850:	3b02      	subs	r3, #2
24015852:	77bb      	strb	r3, [r7, #30]
                    break;
24015854:	e009      	b.n	2401586a <CheckSum+0x162>
                    InitVal += (uint8_t) Val;
24015856:	697b      	ldr	r3, [r7, #20]
24015858:	b2db      	uxtb	r3, r3
2401585a:	461a      	mov	r2, r3
2401585c:	687b      	ldr	r3, [r7, #4]
2401585e:	4413      	add	r3, r2
24015860:	607b      	str	r3, [r7, #4]
                    missalignementSize -= 3;
24015862:	7fbb      	ldrb	r3, [r7, #30]
24015864:	3b03      	subs	r3, #3
24015866:	77bb      	strb	r3, [r7, #30]
                    break;
24015868:	bf00      	nop
        }else
2401586a:	e01a      	b.n	240158a2 <CheckSum+0x19a>
        {
            InitVal += (uint8_t) Val;
2401586c:	697b      	ldr	r3, [r7, #20]
2401586e:	b2db      	uxtb	r3, r3
24015870:	461a      	mov	r2, r3
24015872:	687b      	ldr	r3, [r7, #4]
24015874:	4413      	add	r3, r2
24015876:	607b      	str	r3, [r7, #4]
            InitVal += (uint8_t) (Val >> 8 & 0xff);
24015878:	697b      	ldr	r3, [r7, #20]
2401587a:	0a1b      	lsrs	r3, r3, #8
2401587c:	b2db      	uxtb	r3, r3
2401587e:	461a      	mov	r2, r3
24015880:	687b      	ldr	r3, [r7, #4]
24015882:	4413      	add	r3, r2
24015884:	607b      	str	r3, [r7, #4]
            InitVal += (uint8_t) (Val >> 16 & 0xff);
24015886:	697b      	ldr	r3, [r7, #20]
24015888:	0c1b      	lsrs	r3, r3, #16
2401588a:	b2db      	uxtb	r3, r3
2401588c:	461a      	mov	r2, r3
2401588e:	687b      	ldr	r3, [r7, #4]
24015890:	4413      	add	r3, r2
24015892:	607b      	str	r3, [r7, #4]
            InitVal += (uint8_t) (Val >> 24 & 0xff);
24015894:	697b      	ldr	r3, [r7, #20]
24015896:	0e1b      	lsrs	r3, r3, #24
24015898:	b2db      	uxtb	r3, r3
2401589a:	461a      	mov	r2, r3
2401589c:	687b      	ldr	r3, [r7, #4]
2401589e:	4413      	add	r3, r2
240158a0:	607b      	str	r3, [r7, #4]
        }
        StartAddress += 4;
240158a2:	68fb      	ldr	r3, [r7, #12]
240158a4:	3304      	adds	r3, #4
240158a6:	60fb      	str	r3, [r7, #12]
    for (cnt = 0; cnt < Size; cnt += 4)
240158a8:	69bb      	ldr	r3, [r7, #24]
240158aa:	3304      	adds	r3, #4
240158ac:	61bb      	str	r3, [r7, #24]
240158ae:	69bb      	ldr	r3, [r7, #24]
240158b0:	68ba      	ldr	r2, [r7, #8]
240158b2:	429a      	cmp	r2, r3
240158b4:	f63f af4b 	bhi.w	2401574e <CheckSum+0x46>
    }

    return (InitVal);
240158b8:	687b      	ldr	r3, [r7, #4]
}
240158ba:	4618      	mov	r0, r3
240158bc:	3724      	adds	r7, #36	; 0x24
240158be:	46bd      	mov	sp, r7
240158c0:	f85d 7b04 	ldr.w	r7, [sp], #4
240158c4:	4770      	bx	lr

240158c6 <Verify>:
 *     R0             : Operation failed (address of failure)
 *     R1             : Checksum value
 * Note: Optional for all types of device
 */
uint64_t Verify(uint32_t MemoryAddr, uint32_t RAMBufferAddr, uint32_t Size, uint32_t missalignement)
{
240158c6:	e92d 4890 	stmdb	sp!, {r4, r7, fp, lr}
240158ca:	b08c      	sub	sp, #48	; 0x30
240158cc:	af00      	add	r7, sp, #0
240158ce:	60f8      	str	r0, [r7, #12]
240158d0:	60b9      	str	r1, [r7, #8]
240158d2:	607a      	str	r2, [r7, #4]
240158d4:	603b      	str	r3, [r7, #0]
240158d6:	2300      	movs	r3, #0
240158d8:	61fb      	str	r3, [r7, #28]
240158da:	69fb      	ldr	r3, [r7, #28]
240158dc:	f383 8810 	msr	PRIMASK, r3

    __set_PRIMASK(0); //enable interrupts
    uint32_t VerifiedData = 0, InitVal = 0;
240158e0:	2300      	movs	r3, #0
240158e2:	62fb      	str	r3, [r7, #44]	; 0x2c
240158e4:	2300      	movs	r3, #0
240158e6:	62bb      	str	r3, [r7, #40]	; 0x28
    uint64_t checksum;
    Size *= 4;
240158e8:	687b      	ldr	r3, [r7, #4]
240158ea:	009b      	lsls	r3, r3, #2
240158ec:	607b      	str	r3, [r7, #4]

    if (CSP_QSPI_EnableMemoryMappedMode() != HAL_OK)
240158ee:	f000 fbd3 	bl	24016098 <CSP_QSPI_EnableMemoryMappedMode>
240158f2:	4603      	mov	r3, r0
240158f4:	2b00      	cmp	r3, #0
240158f6:	d009      	beq.n	2401590c <Verify+0x46>
240158f8:	2301      	movs	r3, #1
240158fa:	61bb      	str	r3, [r7, #24]
240158fc:	69bb      	ldr	r3, [r7, #24]
240158fe:	f383 8810 	msr	PRIMASK, r3
    {
        __set_PRIMASK(1); //disable interrupts
        return LOADER_FAIL;
24015902:	f04f 0b00 	mov.w	fp, #0
24015906:	f04f 0c00 	mov.w	ip, #0
2401590a:	e04b      	b.n	240159a4 <Verify+0xde>
    }

    checksum = CheckSum((uint32_t) MemoryAddr + (missalignement & 0xf), Size - ((missalignement >> 16) & 0xF), InitVal);
2401590c:	683b      	ldr	r3, [r7, #0]
2401590e:	f003 020f 	and.w	r2, r3, #15
24015912:	68fb      	ldr	r3, [r7, #12]
24015914:	18d0      	adds	r0, r2, r3
24015916:	683b      	ldr	r3, [r7, #0]
24015918:	0c1b      	lsrs	r3, r3, #16
2401591a:	f003 030f 	and.w	r3, r3, #15
2401591e:	687a      	ldr	r2, [r7, #4]
24015920:	1ad3      	subs	r3, r2, r3
24015922:	6aba      	ldr	r2, [r7, #40]	; 0x28
24015924:	4619      	mov	r1, r3
24015926:	f7ff feef 	bl	24015708 <CheckSum>
2401592a:	4603      	mov	r3, r0
2401592c:	f04f 0400 	mov.w	r4, #0
24015930:	e9c7 3408 	strd	r3, r4, [r7, #32]
    while(Size > VerifiedData)
24015934:	e024      	b.n	24015980 <Verify+0xba>
    {
        if(*(uint8_t*) MemoryAddr++ != *((uint8_t*) RAMBufferAddr + VerifiedData))
24015936:	68fb      	ldr	r3, [r7, #12]
24015938:	1c5a      	adds	r2, r3, #1
2401593a:	60fa      	str	r2, [r7, #12]
2401593c:	781a      	ldrb	r2, [r3, #0]
2401593e:	6af9      	ldr	r1, [r7, #44]	; 0x2c
24015940:	68bb      	ldr	r3, [r7, #8]
24015942:	440b      	add	r3, r1
24015944:	781b      	ldrb	r3, [r3, #0]
24015946:	429a      	cmp	r2, r3
24015948:	d017      	beq.n	2401597a <Verify+0xb4>
2401594a:	2301      	movs	r3, #1
2401594c:	617b      	str	r3, [r7, #20]
2401594e:	697b      	ldr	r3, [r7, #20]
24015950:	f383 8810 	msr	PRIMASK, r3
        {
            __set_PRIMASK(1); //disable interrupts
            return ((checksum << 32) + (MemoryAddr + VerifiedData));
24015954:	e9d7 1208 	ldrd	r1, r2, [r7, #32]
24015958:	f04f 0300 	mov.w	r3, #0
2401595c:	f04f 0400 	mov.w	r4, #0
24015960:	000c      	movs	r4, r1
24015962:	2300      	movs	r3, #0
24015964:	68f9      	ldr	r1, [r7, #12]
24015966:	6afa      	ldr	r2, [r7, #44]	; 0x2c
24015968:	440a      	add	r2, r1
2401596a:	4611      	mov	r1, r2
2401596c:	f04f 0200 	mov.w	r2, #0
24015970:	eb13 0b01 	adds.w	fp, r3, r1
24015974:	eb44 0c02 	adc.w	ip, r4, r2
24015978:	e014      	b.n	240159a4 <Verify+0xde>
        }
        VerifiedData++;
2401597a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
2401597c:	3301      	adds	r3, #1
2401597e:	62fb      	str	r3, [r7, #44]	; 0x2c
    while(Size > VerifiedData)
24015980:	687a      	ldr	r2, [r7, #4]
24015982:	6afb      	ldr	r3, [r7, #44]	; 0x2c
24015984:	429a      	cmp	r2, r3
24015986:	d8d6      	bhi.n	24015936 <Verify+0x70>
24015988:	2301      	movs	r3, #1
2401598a:	613b      	str	r3, [r7, #16]
2401598c:	693b      	ldr	r3, [r7, #16]
2401598e:	f383 8810 	msr	PRIMASK, r3
    }

    __set_PRIMASK(1); //disable interrupts
    return (checksum << 32);
24015992:	e9d7 1208 	ldrd	r1, r2, [r7, #32]
24015996:	f04f 0b00 	mov.w	fp, #0
2401599a:	f04f 0c00 	mov.w	ip, #0
2401599e:	468c      	mov	ip, r1
240159a0:	f04f 0b00 	mov.w	fp, #0
240159a4:	465b      	mov	r3, fp
240159a6:	4664      	mov	r4, ip
}
240159a8:	4618      	mov	r0, r3
240159aa:	4621      	mov	r1, r4
240159ac:	3730      	adds	r7, #48	; 0x30
240159ae:	46bd      	mov	sp, r7
240159b0:	e8bd 8890 	ldmia.w	sp!, {r4, r7, fp, pc}

240159b4 <main>:
/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{
240159b4:	b580      	push	{r7, lr}
240159b6:	af00      	add	r7, sp, #0

	/* Reset of all peripherals, Initializes the Flash interface and the Systick. */
	HAL_Init();
240159b8:	f7ea fe60 	bl	2400067c <HAL_Init>


	/* Configure the system clock */
	SystemClock_Config();
240159bc:	f000 f802 	bl	240159c4 <SystemClock_Config>


	while (1)
240159c0:	e7fe      	b.n	240159c0 <main+0xc>
	...

240159c4 <SystemClock_Config>:
/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
240159c4:	b580      	push	{r7, lr}
240159c6:	b0cc      	sub	sp, #304	; 0x130
240159c8:	af00      	add	r7, sp, #0
	RCC_OscInitTypeDef RCC_OscInitStruct = {0};
240159ca:	f107 03e4 	add.w	r3, r7, #228	; 0xe4
240159ce:	224c      	movs	r2, #76	; 0x4c
240159d0:	2100      	movs	r1, #0
240159d2:	4618      	mov	r0, r3
240159d4:	f001 f84e 	bl	24016a74 <memset>
	RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
240159d8:	f107 03c4 	add.w	r3, r7, #196	; 0xc4
240159dc:	2220      	movs	r2, #32
240159de:	2100      	movs	r1, #0
240159e0:	4618      	mov	r0, r3
240159e2:	f001 f847 	bl	24016a74 <memset>
	RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
240159e6:	f107 0308 	add.w	r3, r7, #8
240159ea:	4618      	mov	r0, r3
240159ec:	23bc      	movs	r3, #188	; 0xbc
240159ee:	461a      	mov	r2, r3
240159f0:	2100      	movs	r1, #0
240159f2:	f001 f83f 	bl	24016a74 <memset>

	/** Supply configuration update enable
	*/
	HAL_PWREx_ConfigSupply(PWR_LDO_SUPPLY);
240159f6:	2002      	movs	r0, #2
240159f8:	f7f9 ff3c 	bl	2400f874 <HAL_PWREx_ConfigSupply>
	/** Configure the main internal regulator output voltage
	*/
	__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
240159fc:	1d3b      	adds	r3, r7, #4
240159fe:	2200      	movs	r2, #0
24015a00:	601a      	str	r2, [r3, #0]
24015a02:	4b46      	ldr	r3, [pc, #280]	; (24015b1c <SystemClock_Config+0x158>)
24015a04:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24015a06:	4a45      	ldr	r2, [pc, #276]	; (24015b1c <SystemClock_Config+0x158>)
24015a08:	f023 0301 	bic.w	r3, r3, #1
24015a0c:	62d3      	str	r3, [r2, #44]	; 0x2c
24015a0e:	4b43      	ldr	r3, [pc, #268]	; (24015b1c <SystemClock_Config+0x158>)
24015a10:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24015a12:	f003 0201 	and.w	r2, r3, #1
24015a16:	1d3b      	adds	r3, r7, #4
24015a18:	601a      	str	r2, [r3, #0]
24015a1a:	4b41      	ldr	r3, [pc, #260]	; (24015b20 <SystemClock_Config+0x15c>)
24015a1c:	699b      	ldr	r3, [r3, #24]
24015a1e:	4a40      	ldr	r2, [pc, #256]	; (24015b20 <SystemClock_Config+0x15c>)
24015a20:	f443 4340 	orr.w	r3, r3, #49152	; 0xc000
24015a24:	6193      	str	r3, [r2, #24]
24015a26:	4b3e      	ldr	r3, [pc, #248]	; (24015b20 <SystemClock_Config+0x15c>)
24015a28:	699b      	ldr	r3, [r3, #24]
24015a2a:	f403 4240 	and.w	r2, r3, #49152	; 0xc000
24015a2e:	1d3b      	adds	r3, r7, #4
24015a30:	601a      	str	r2, [r3, #0]
24015a32:	1d3b      	adds	r3, r7, #4
24015a34:	681b      	ldr	r3, [r3, #0]

	while(!__HAL_PWR_GET_FLAG(PWR_FLAG_VOSRDY)) {}
24015a36:	bf00      	nop
24015a38:	4b39      	ldr	r3, [pc, #228]	; (24015b20 <SystemClock_Config+0x15c>)
24015a3a:	699b      	ldr	r3, [r3, #24]
24015a3c:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
24015a40:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
24015a44:	d1f8      	bne.n	24015a38 <SystemClock_Config+0x74>
	/** Initializes the CPU, AHB and APB busses clocks
	*/
	RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
24015a46:	2301      	movs	r3, #1
24015a48:	f8c7 30e4 	str.w	r3, [r7, #228]	; 0xe4
	RCC_OscInitStruct.HSEState = RCC_HSE_ON;
24015a4c:	f44f 3380 	mov.w	r3, #65536	; 0x10000
24015a50:	f8c7 30e8 	str.w	r3, [r7, #232]	; 0xe8
	RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
24015a54:	2302      	movs	r3, #2
24015a56:	f8c7 3108 	str.w	r3, [r7, #264]	; 0x108
	RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
24015a5a:	2302      	movs	r3, #2
24015a5c:	f8c7 310c 	str.w	r3, [r7, #268]	; 0x10c
	RCC_OscInitStruct.PLL.PLLM = 5;
24015a60:	2305      	movs	r3, #5
24015a62:	f8c7 3110 	str.w	r3, [r7, #272]	; 0x110
	RCC_OscInitStruct.PLL.PLLN = 160;
24015a66:	23a0      	movs	r3, #160	; 0xa0
24015a68:	f8c7 3114 	str.w	r3, [r7, #276]	; 0x114
	RCC_OscInitStruct.PLL.PLLP = 2;
24015a6c:	2302      	movs	r3, #2
24015a6e:	f8c7 3118 	str.w	r3, [r7, #280]	; 0x118
	RCC_OscInitStruct.PLL.PLLQ = 2;
24015a72:	2302      	movs	r3, #2
24015a74:	f8c7 311c 	str.w	r3, [r7, #284]	; 0x11c
	RCC_OscInitStruct.PLL.PLLR = 2;
24015a78:	2302      	movs	r3, #2
24015a7a:	f8c7 3120 	str.w	r3, [r7, #288]	; 0x120
	RCC_OscInitStruct.PLL.PLLRGE = RCC_PLL1VCIRANGE_2;
24015a7e:	2308      	movs	r3, #8
24015a80:	f8c7 3124 	str.w	r3, [r7, #292]	; 0x124
	RCC_OscInitStruct.PLL.PLLVCOSEL = RCC_PLL1VCOWIDE;
24015a84:	2300      	movs	r3, #0
24015a86:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
	RCC_OscInitStruct.PLL.PLLFRACN = 0;
24015a8a:	2300      	movs	r3, #0
24015a8c:	f8c7 312c 	str.w	r3, [r7, #300]	; 0x12c
	if(HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
24015a90:	f107 03e4 	add.w	r3, r7, #228	; 0xe4
24015a94:	4618      	mov	r0, r3
24015a96:	f7fc f98f 	bl	24011db8 <HAL_RCC_OscConfig>
24015a9a:	4603      	mov	r3, r0
24015a9c:	2b00      	cmp	r3, #0
24015a9e:	d001      	beq.n	24015aa4 <SystemClock_Config+0xe0>
	{
		Error_Handler();
24015aa0:	f000 f840 	bl	24015b24 <Error_Handler>
	}
	/** Initializes the CPU, AHB and APB busses clocks
	*/
	RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
24015aa4:	233f      	movs	r3, #63	; 0x3f
24015aa6:	f8c7 30c4 	str.w	r3, [r7, #196]	; 0xc4
							  |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2
							  |RCC_CLOCKTYPE_D3PCLK1|RCC_CLOCKTYPE_D1PCLK1;
	RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
24015aaa:	2303      	movs	r3, #3
24015aac:	f8c7 30c8 	str.w	r3, [r7, #200]	; 0xc8
	RCC_ClkInitStruct.SYSCLKDivider = RCC_SYSCLK_DIV1;
24015ab0:	2300      	movs	r3, #0
24015ab2:	f8c7 30cc 	str.w	r3, [r7, #204]	; 0xcc
	RCC_ClkInitStruct.AHBCLKDivider = RCC_HCLK_DIV2;
24015ab6:	2308      	movs	r3, #8
24015ab8:	f8c7 30d0 	str.w	r3, [r7, #208]	; 0xd0
	RCC_ClkInitStruct.APB3CLKDivider = RCC_APB3_DIV2;
24015abc:	2340      	movs	r3, #64	; 0x40
24015abe:	f8c7 30d4 	str.w	r3, [r7, #212]	; 0xd4
	RCC_ClkInitStruct.APB1CLKDivider = RCC_APB1_DIV2;
24015ac2:	2340      	movs	r3, #64	; 0x40
24015ac4:	f8c7 30d8 	str.w	r3, [r7, #216]	; 0xd8
	RCC_ClkInitStruct.APB2CLKDivider = RCC_APB2_DIV2;
24015ac8:	f44f 6380 	mov.w	r3, #1024	; 0x400
24015acc:	f8c7 30dc 	str.w	r3, [r7, #220]	; 0xdc
	RCC_ClkInitStruct.APB4CLKDivider = RCC_APB4_DIV2;
24015ad0:	2340      	movs	r3, #64	; 0x40
24015ad2:	f8c7 30e0 	str.w	r3, [r7, #224]	; 0xe0

	if(HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK)
24015ad6:	f107 03c4 	add.w	r3, r7, #196	; 0xc4
24015ada:	2102      	movs	r1, #2
24015adc:	4618      	mov	r0, r3
24015ade:	f7fc fd43 	bl	24012568 <HAL_RCC_ClockConfig>
24015ae2:	4603      	mov	r3, r0
24015ae4:	2b00      	cmp	r3, #0
24015ae6:	d001      	beq.n	24015aec <SystemClock_Config+0x128>
	{
		Error_Handler();
24015ae8:	f000 f81c 	bl	24015b24 <Error_Handler>
	}
	PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_QSPI;
24015aec:	f107 0308 	add.w	r3, r7, #8
24015af0:	f04f 7200 	mov.w	r2, #33554432	; 0x2000000
24015af4:	601a      	str	r2, [r3, #0]
	PeriphClkInitStruct.QspiClockSelection = RCC_QSPICLKSOURCE_D1HCLK;
24015af6:	f107 0308 	add.w	r3, r7, #8
24015afa:	2200      	movs	r2, #0
24015afc:	649a      	str	r2, [r3, #72]	; 0x48
	if(HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
24015afe:	f107 0308 	add.w	r3, r7, #8
24015b02:	4618      	mov	r0, r3
24015b04:	f7fd fa8a 	bl	2401301c <HAL_RCCEx_PeriphCLKConfig>
24015b08:	4603      	mov	r3, r0
24015b0a:	2b00      	cmp	r3, #0
24015b0c:	d001      	beq.n	24015b12 <SystemClock_Config+0x14e>
	{
		Error_Handler();
24015b0e:	f000 f809 	bl	24015b24 <Error_Handler>
	}
}
24015b12:	bf00      	nop
24015b14:	f507 7798 	add.w	r7, r7, #304	; 0x130
24015b18:	46bd      	mov	sp, r7
24015b1a:	bd80      	pop	{r7, pc}
24015b1c:	58000400 	.word	0x58000400
24015b20:	58024800 	.word	0x58024800

24015b24 <Error_Handler>:
/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
24015b24:	b480      	push	{r7}
24015b26:	af00      	add	r7, sp, #0

}
24015b28:	bf00      	nop
24015b2a:	46bd      	mov	sp, r7
24015b2c:	f85d 7b04 	ldr.w	r7, [sp], #4
24015b30:	4770      	bx	lr
	...

24015b34 <QSPI_ReadStatus>:
static uint8_t QSPI_WriteStatus(uint8_t command, uint8_t* value, uint32_t length);

extern void Error_Handler(void);

static uint8_t QSPI_ReadStatus(uint8_t command, uint8_t* value)
{
24015b34:	b580      	push	{r7, lr}
24015b36:	b092      	sub	sp, #72	; 0x48
24015b38:	af00      	add	r7, sp, #0
24015b3a:	4603      	mov	r3, r0
24015b3c:	6039      	str	r1, [r7, #0]
24015b3e:	71fb      	strb	r3, [r7, #7]
	QSPI_CommandTypeDef sCommand;
	uint8_t reg;

	sCommand.InstructionMode = QSPI_INSTRUCTION_1_LINE;
24015b40:	f44f 7380 	mov.w	r3, #256	; 0x100
24015b44:	62bb      	str	r3, [r7, #40]	; 0x28
	sCommand.Instruction = (uint32_t)command;
24015b46:	79fb      	ldrb	r3, [r7, #7]
24015b48:	613b      	str	r3, [r7, #16]
	sCommand.AddressMode       = QSPI_ADDRESS_NONE;
24015b4a:	2300      	movs	r3, #0
24015b4c:	62fb      	str	r3, [r7, #44]	; 0x2c
	sCommand.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;
24015b4e:	2300      	movs	r3, #0
24015b50:	633b      	str	r3, [r7, #48]	; 0x30
	sCommand.DataMode          = QSPI_DATA_1_LINE;
24015b52:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
24015b56:	637b      	str	r3, [r7, #52]	; 0x34
	sCommand.DummyCycles       = 0;
24015b58:	2300      	movs	r3, #0
24015b5a:	627b      	str	r3, [r7, #36]	; 0x24
	sCommand.NbData            = 1;
24015b5c:	2301      	movs	r3, #1
24015b5e:	63bb      	str	r3, [r7, #56]	; 0x38
	sCommand.DdrMode           = QSPI_DDR_MODE_DISABLE;
24015b60:	2300      	movs	r3, #0
24015b62:	63fb      	str	r3, [r7, #60]	; 0x3c
	sCommand.DdrHoldHalfCycle  = QSPI_DDR_HHC_ANALOG_DELAY;
24015b64:	2300      	movs	r3, #0
24015b66:	643b      	str	r3, [r7, #64]	; 0x40
	sCommand.SIOOMode          = QSPI_SIOO_INST_EVERY_CMD;
24015b68:	2300      	movs	r3, #0
24015b6a:	647b      	str	r3, [r7, #68]	; 0x44

	/* Configure the command */
	if(HAL_QSPI_Command(&hqspi, &sCommand, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
24015b6c:	f107 0310 	add.w	r3, r7, #16
24015b70:	f241 3288 	movw	r2, #5000	; 0x1388
24015b74:	4619      	mov	r1, r3
24015b76:	480e      	ldr	r0, [pc, #56]	; (24015bb0 <QSPI_ReadStatus+0x7c>)
24015b78:	f7fa fdf6 	bl	24010768 <HAL_QSPI_Command>
24015b7c:	4603      	mov	r3, r0
24015b7e:	2b00      	cmp	r3, #0
24015b80:	d001      	beq.n	24015b86 <QSPI_ReadStatus+0x52>
	{
		return HAL_ERROR;
24015b82:	2301      	movs	r3, #1
24015b84:	e010      	b.n	24015ba8 <QSPI_ReadStatus+0x74>
	}

	/* Reception of the data */
	if(HAL_QSPI_Receive(&hqspi, &reg, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
24015b86:	f107 030f 	add.w	r3, r7, #15
24015b8a:	f241 3288 	movw	r2, #5000	; 0x1388
24015b8e:	4619      	mov	r1, r3
24015b90:	4807      	ldr	r0, [pc, #28]	; (24015bb0 <QSPI_ReadStatus+0x7c>)
24015b92:	f7fa ff3f 	bl	24010a14 <HAL_QSPI_Receive>
24015b96:	4603      	mov	r3, r0
24015b98:	2b00      	cmp	r3, #0
24015b9a:	d001      	beq.n	24015ba0 <QSPI_ReadStatus+0x6c>
	{
		return HAL_ERROR;
24015b9c:	2301      	movs	r3, #1
24015b9e:	e003      	b.n	24015ba8 <QSPI_ReadStatus+0x74>
	}

	*value = reg;
24015ba0:	7bfa      	ldrb	r2, [r7, #15]
24015ba2:	683b      	ldr	r3, [r7, #0]
24015ba4:	701a      	strb	r2, [r3, #0]

	return HAL_OK;
24015ba6:	2300      	movs	r3, #0
}
24015ba8:	4618      	mov	r0, r3
24015baa:	3748      	adds	r7, #72	; 0x48
24015bac:	46bd      	mov	sp, r7
24015bae:	bd80      	pop	{r7, pc}
24015bb0:	24000568 	.word	0x24000568

24015bb4 <QSPI_WriteStatus>:
static uint8_t QSPI_WriteStatus(uint8_t command, uint8_t* value, uint32_t length)
{
24015bb4:	b580      	push	{r7, lr}
24015bb6:	b092      	sub	sp, #72	; 0x48
24015bb8:	af00      	add	r7, sp, #0
24015bba:	4603      	mov	r3, r0
24015bbc:	60b9      	str	r1, [r7, #8]
24015bbe:	607a      	str	r2, [r7, #4]
24015bc0:	73fb      	strb	r3, [r7, #15]
	QSPI_CommandTypeDef sCommand;

	/* Initialize the program command */
	sCommand.InstructionMode   = QSPI_INSTRUCTION_1_LINE;
24015bc2:	f44f 7380 	mov.w	r3, #256	; 0x100
24015bc6:	62bb      	str	r3, [r7, #40]	; 0x28
	sCommand.Instruction       = command;
24015bc8:	7bfb      	ldrb	r3, [r7, #15]
24015bca:	613b      	str	r3, [r7, #16]
	sCommand.AddressMode       = QSPI_ADDRESS_NONE;
24015bcc:	2300      	movs	r3, #0
24015bce:	62fb      	str	r3, [r7, #44]	; 0x2c
	sCommand.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;
24015bd0:	2300      	movs	r3, #0
24015bd2:	633b      	str	r3, [r7, #48]	; 0x30
	sCommand.DataMode          = QSPI_DATA_1_LINE;
24015bd4:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
24015bd8:	637b      	str	r3, [r7, #52]	; 0x34
	sCommand.DummyCycles       = 0;
24015bda:	2300      	movs	r3, #0
24015bdc:	627b      	str	r3, [r7, #36]	; 0x24
	sCommand.NbData            = length;
24015bde:	687b      	ldr	r3, [r7, #4]
24015be0:	63bb      	str	r3, [r7, #56]	; 0x38
	sCommand.DdrMode           = QSPI_DDR_MODE_DISABLE;
24015be2:	2300      	movs	r3, #0
24015be4:	63fb      	str	r3, [r7, #60]	; 0x3c
	sCommand.DdrHoldHalfCycle  = QSPI_DDR_HHC_ANALOG_DELAY;
24015be6:	2300      	movs	r3, #0
24015be8:	643b      	str	r3, [r7, #64]	; 0x40
	sCommand.SIOOMode          = QSPI_SIOO_INST_EVERY_CMD;
24015bea:	2300      	movs	r3, #0
24015bec:	647b      	str	r3, [r7, #68]	; 0x44

	/* Enable write operations */
	if(QSPI_WriteEnable() != HAL_OK)
24015bee:	f000 f901 	bl	24015df4 <QSPI_WriteEnable>
24015bf2:	4603      	mov	r3, r0
24015bf4:	2b00      	cmp	r3, #0
24015bf6:	d001      	beq.n	24015bfc <QSPI_WriteStatus+0x48>
	{
		return HAL_ERROR;
24015bf8:	2301      	movs	r3, #1
24015bfa:	e021      	b.n	24015c40 <QSPI_WriteStatus+0x8c>
	}

	/* Configure the command */
	if(HAL_QSPI_Command(&hqspi, &sCommand, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
24015bfc:	f107 0310 	add.w	r3, r7, #16
24015c00:	f241 3288 	movw	r2, #5000	; 0x1388
24015c04:	4619      	mov	r1, r3
24015c06:	4810      	ldr	r0, [pc, #64]	; (24015c48 <QSPI_WriteStatus+0x94>)
24015c08:	f7fa fdae 	bl	24010768 <HAL_QSPI_Command>
24015c0c:	4603      	mov	r3, r0
24015c0e:	2b00      	cmp	r3, #0
24015c10:	d001      	beq.n	24015c16 <QSPI_WriteStatus+0x62>
	{
		return HAL_ERROR;
24015c12:	2301      	movs	r3, #1
24015c14:	e014      	b.n	24015c40 <QSPI_WriteStatus+0x8c>
	}

	/* Transmission of the data */
	if(HAL_QSPI_Transmit(&hqspi, value, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
24015c16:	f241 3288 	movw	r2, #5000	; 0x1388
24015c1a:	68b9      	ldr	r1, [r7, #8]
24015c1c:	480a      	ldr	r0, [pc, #40]	; (24015c48 <QSPI_WriteStatus+0x94>)
24015c1e:	f7fa fe67 	bl	240108f0 <HAL_QSPI_Transmit>
24015c22:	4603      	mov	r3, r0
24015c24:	2b00      	cmp	r3, #0
24015c26:	d001      	beq.n	24015c2c <QSPI_WriteStatus+0x78>
	{
		return HAL_ERROR;
24015c28:	2301      	movs	r3, #1
24015c2a:	e009      	b.n	24015c40 <QSPI_WriteStatus+0x8c>
	}

	/* Configure automatic polling mode to wait for end of program */
	if(QSPI_AutoPollingMemReady(HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
24015c2c:	f241 3088 	movw	r0, #5000	; 0x1388
24015c30:	f000 f8a6 	bl	24015d80 <QSPI_AutoPollingMemReady>
24015c34:	4603      	mov	r3, r0
24015c36:	2b00      	cmp	r3, #0
24015c38:	d001      	beq.n	24015c3e <QSPI_WriteStatus+0x8a>
	{
		return HAL_ERROR;
24015c3a:	2301      	movs	r3, #1
24015c3c:	e000      	b.n	24015c40 <QSPI_WriteStatus+0x8c>
	}

	return HAL_OK;
24015c3e:	2300      	movs	r3, #0

}
24015c40:	4618      	mov	r0, r3
24015c42:	3748      	adds	r7, #72	; 0x48
24015c44:	46bd      	mov	sp, r7
24015c46:	bd80      	pop	{r7, pc}
24015c48:	24000568 	.word	0x24000568

24015c4c <MX_QUADSPI_Init>:
void MX_QUADSPI_Init(void)
{
24015c4c:	b580      	push	{r7, lr}
24015c4e:	b082      	sub	sp, #8
24015c50:	af00      	add	r7, sp, #0
    hqspi.Instance = QUADSPI;
24015c52:	4b19      	ldr	r3, [pc, #100]	; (24015cb8 <MX_QUADSPI_Init+0x6c>)
24015c54:	4a19      	ldr	r2, [pc, #100]	; (24015cbc <MX_QUADSPI_Init+0x70>)
24015c56:	601a      	str	r2, [r3, #0]
    hqspi.Init.ClockPrescaler = 1;
24015c58:	4b17      	ldr	r3, [pc, #92]	; (24015cb8 <MX_QUADSPI_Init+0x6c>)
24015c5a:	2201      	movs	r2, #1
24015c5c:	605a      	str	r2, [r3, #4]
    hqspi.Init.FifoThreshold = 4;
24015c5e:	4b16      	ldr	r3, [pc, #88]	; (24015cb8 <MX_QUADSPI_Init+0x6c>)
24015c60:	2204      	movs	r2, #4
24015c62:	609a      	str	r2, [r3, #8]
    hqspi.Init.SampleShifting = QSPI_SAMPLE_SHIFTING_NONE;
24015c64:	4b14      	ldr	r3, [pc, #80]	; (24015cb8 <MX_QUADSPI_Init+0x6c>)
24015c66:	2200      	movs	r2, #0
24015c68:	60da      	str	r2, [r3, #12]
24015c6a:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
24015c6e:	607b      	str	r3, [r7, #4]
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
24015c70:	687b      	ldr	r3, [r7, #4]
24015c72:	fa93 f3a3 	rbit	r3, r3
24015c76:	603b      	str	r3, [r7, #0]
  return result;
24015c78:	683b      	ldr	r3, [r7, #0]
    hqspi.Init.FlashSize = POSITION_VAL(MEMORY_FLASH_SIZE) - 1;
24015c7a:	fab3 f383 	clz	r3, r3
24015c7e:	b2db      	uxtb	r3, r3
24015c80:	3b01      	subs	r3, #1
24015c82:	461a      	mov	r2, r3
24015c84:	4b0c      	ldr	r3, [pc, #48]	; (24015cb8 <MX_QUADSPI_Init+0x6c>)
24015c86:	611a      	str	r2, [r3, #16]
    hqspi.Init.ChipSelectHighTime = QSPI_CS_HIGH_TIME_1_CYCLE;
24015c88:	4b0b      	ldr	r3, [pc, #44]	; (24015cb8 <MX_QUADSPI_Init+0x6c>)
24015c8a:	2200      	movs	r2, #0
24015c8c:	615a      	str	r2, [r3, #20]
    hqspi.Init.ClockMode = QSPI_CLOCK_MODE_0;
24015c8e:	4b0a      	ldr	r3, [pc, #40]	; (24015cb8 <MX_QUADSPI_Init+0x6c>)
24015c90:	2200      	movs	r2, #0
24015c92:	619a      	str	r2, [r3, #24]
    hqspi.Init.FlashID = QSPI_FLASH_ID_1;
24015c94:	4b08      	ldr	r3, [pc, #32]	; (24015cb8 <MX_QUADSPI_Init+0x6c>)
24015c96:	2200      	movs	r2, #0
24015c98:	61da      	str	r2, [r3, #28]
    hqspi.Init.DualFlash = QSPI_DUALFLASH_DISABLE;
24015c9a:	4b07      	ldr	r3, [pc, #28]	; (24015cb8 <MX_QUADSPI_Init+0x6c>)
24015c9c:	2200      	movs	r2, #0
24015c9e:	621a      	str	r2, [r3, #32]
    if(HAL_QSPI_Init(&hqspi) != HAL_OK)
24015ca0:	4805      	ldr	r0, [pc, #20]	; (24015cb8 <MX_QUADSPI_Init+0x6c>)
24015ca2:	f7fa faff 	bl	240102a4 <HAL_QSPI_Init>
24015ca6:	4603      	mov	r3, r0
24015ca8:	2b00      	cmp	r3, #0
24015caa:	d001      	beq.n	24015cb0 <MX_QUADSPI_Init+0x64>
    {
        Error_Handler();
24015cac:	f7ff ff3a 	bl	24015b24 <Error_Handler>
    }
}
24015cb0:	bf00      	nop
24015cb2:	3708      	adds	r7, #8
24015cb4:	46bd      	mov	sp, r7
24015cb6:	bd80      	pop	{r7, pc}
24015cb8:	24000568 	.word	0x24000568
24015cbc:	52005000 	.word	0x52005000

24015cc0 <CSP_QUADSPI_Init>:


uint8_t CSP_QUADSPI_Init(void)
{
24015cc0:	b580      	push	{r7, lr}
24015cc2:	af00      	add	r7, sp, #0
    //prepare QSPI peripheral for ST-Link Utility operations
	hqspi.Instance = QUADSPI;
24015cc4:	4b0e      	ldr	r3, [pc, #56]	; (24015d00 <CSP_QUADSPI_Init+0x40>)
24015cc6:	4a0f      	ldr	r2, [pc, #60]	; (24015d04 <CSP_QUADSPI_Init+0x44>)
24015cc8:	601a      	str	r2, [r3, #0]
    if (HAL_QSPI_DeInit(&hqspi) != HAL_OK)
24015cca:	480d      	ldr	r0, [pc, #52]	; (24015d00 <CSP_QUADSPI_Init+0x40>)
24015ccc:	f7fa fb5e 	bl	2401038c <HAL_QSPI_DeInit>
24015cd0:	4603      	mov	r3, r0
24015cd2:	2b00      	cmp	r3, #0
24015cd4:	d001      	beq.n	24015cda <CSP_QUADSPI_Init+0x1a>
    {
        return HAL_ERROR;
24015cd6:	2301      	movs	r3, #1
24015cd8:	e010      	b.n	24015cfc <CSP_QUADSPI_Init+0x3c>
    }

    MX_QUADSPI_Init();
24015cda:	f7ff ffb7 	bl	24015c4c <MX_QUADSPI_Init>

    if (QSPI_ResetChip() != HAL_OK)
24015cde:	f000 fa11 	bl	24016104 <QSPI_ResetChip>
24015ce2:	4603      	mov	r3, r0
24015ce4:	2b00      	cmp	r3, #0
24015ce6:	d001      	beq.n	24015cec <CSP_QUADSPI_Init+0x2c>
    {
        return HAL_ERROR;
24015ce8:	2301      	movs	r3, #1
24015cea:	e007      	b.n	24015cfc <CSP_QUADSPI_Init+0x3c>
    }

    if (QSPI_Configuration() != HAL_OK)
24015cec:	f000 f8cc 	bl	24015e88 <QSPI_Configuration>
24015cf0:	4603      	mov	r3, r0
24015cf2:	2b00      	cmp	r3, #0
24015cf4:	d001      	beq.n	24015cfa <CSP_QUADSPI_Init+0x3a>
    {
        return HAL_ERROR;
24015cf6:	2301      	movs	r3, #1
24015cf8:	e000      	b.n	24015cfc <CSP_QUADSPI_Init+0x3c>
    }

    return HAL_OK;
24015cfa:	2300      	movs	r3, #0
}
24015cfc:	4618      	mov	r0, r3
24015cfe:	bd80      	pop	{r7, pc}
24015d00:	24000568 	.word	0x24000568
24015d04:	52005000 	.word	0x52005000

24015d08 <CSP_QSPI_Erase_Chip>:


uint8_t CSP_QSPI_Erase_Chip(void)
{
24015d08:	b580      	push	{r7, lr}
24015d0a:	b08e      	sub	sp, #56	; 0x38
24015d0c:	af00      	add	r7, sp, #0
    QSPI_CommandTypeDef sCommand;

    /* Erasing Sequence --------------------------------- */
    sCommand.Instruction = CHIP_ERASE_CMD;
24015d0e:	23c7      	movs	r3, #199	; 0xc7
24015d10:	603b      	str	r3, [r7, #0]
    sCommand.InstructionMode = QSPI_INSTRUCTION_1_LINE;
24015d12:	f44f 7380 	mov.w	r3, #256	; 0x100
24015d16:	61bb      	str	r3, [r7, #24]
    sCommand.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;
24015d18:	2300      	movs	r3, #0
24015d1a:	623b      	str	r3, [r7, #32]
    sCommand.DdrMode = QSPI_DDR_MODE_DISABLE;
24015d1c:	2300      	movs	r3, #0
24015d1e:	62fb      	str	r3, [r7, #44]	; 0x2c
    sCommand.DdrHoldHalfCycle = QSPI_DDR_HHC_ANALOG_DELAY;
24015d20:	2300      	movs	r3, #0
24015d22:	633b      	str	r3, [r7, #48]	; 0x30
    sCommand.SIOOMode = QSPI_SIOO_INST_EVERY_CMD;
24015d24:	2300      	movs	r3, #0
24015d26:	637b      	str	r3, [r7, #52]	; 0x34
    sCommand.AddressMode = QSPI_ADDRESS_NONE;
24015d28:	2300      	movs	r3, #0
24015d2a:	61fb      	str	r3, [r7, #28]
    sCommand.Address = 0;
24015d2c:	2300      	movs	r3, #0
24015d2e:	607b      	str	r3, [r7, #4]
    sCommand.DataMode = QSPI_DATA_NONE;
24015d30:	2300      	movs	r3, #0
24015d32:	627b      	str	r3, [r7, #36]	; 0x24
    sCommand.DummyCycles = 0;
24015d34:	2300      	movs	r3, #0
24015d36:	617b      	str	r3, [r7, #20]

    if(QSPI_WriteEnable() != HAL_OK)
24015d38:	f000 f85c 	bl	24015df4 <QSPI_WriteEnable>
24015d3c:	4603      	mov	r3, r0
24015d3e:	2b00      	cmp	r3, #0
24015d40:	d001      	beq.n	24015d46 <CSP_QSPI_Erase_Chip+0x3e>
  	{
      	return HAL_ERROR;
24015d42:	2301      	movs	r3, #1
24015d44:	e014      	b.n	24015d70 <CSP_QSPI_Erase_Chip+0x68>
  	}

    if(HAL_QSPI_Command(&hqspi, &sCommand, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
24015d46:	463b      	mov	r3, r7
24015d48:	f241 3288 	movw	r2, #5000	; 0x1388
24015d4c:	4619      	mov	r1, r3
24015d4e:	480a      	ldr	r0, [pc, #40]	; (24015d78 <CSP_QSPI_Erase_Chip+0x70>)
24015d50:	f7fa fd0a 	bl	24010768 <HAL_QSPI_Command>
24015d54:	4603      	mov	r3, r0
24015d56:	2b00      	cmp	r3, #0
24015d58:	d001      	beq.n	24015d5e <CSP_QSPI_Erase_Chip+0x56>
    {
        return HAL_ERROR;
24015d5a:	2301      	movs	r3, #1
24015d5c:	e008      	b.n	24015d70 <CSP_QSPI_Erase_Chip+0x68>
    }

    if(QSPI_AutoPollingMemReady(BULK_ERASE_MAX_TIME) != HAL_OK)
24015d5e:	4807      	ldr	r0, [pc, #28]	; (24015d7c <CSP_QSPI_Erase_Chip+0x74>)
24015d60:	f000 f80e 	bl	24015d80 <QSPI_AutoPollingMemReady>
24015d64:	4603      	mov	r3, r0
24015d66:	2b00      	cmp	r3, #0
24015d68:	d001      	beq.n	24015d6e <CSP_QSPI_Erase_Chip+0x66>
    {
        return HAL_ERROR;
24015d6a:	2301      	movs	r3, #1
24015d6c:	e000      	b.n	24015d70 <CSP_QSPI_Erase_Chip+0x68>
    }

    return HAL_OK;
24015d6e:	2300      	movs	r3, #0
}
24015d70:	4618      	mov	r0, r3
24015d72:	3738      	adds	r7, #56	; 0x38
24015d74:	46bd      	mov	sp, r7
24015d76:	bd80      	pop	{r7, pc}
24015d78:	24000568 	.word	0x24000568
24015d7c:	0003d090 	.word	0x0003d090

24015d80 <QSPI_AutoPollingMemReady>:

uint8_t QSPI_AutoPollingMemReady(uint32_t time)
{
24015d80:	b580      	push	{r7, lr}
24015d82:	b096      	sub	sp, #88	; 0x58
24015d84:	af00      	add	r7, sp, #0
24015d86:	6078      	str	r0, [r7, #4]

    QSPI_CommandTypeDef sCommand;
    QSPI_AutoPollingTypeDef sConfig;

    /* Configure automatic polling mode to wait for memory ready ------ */
    sCommand.InstructionMode = QSPI_INSTRUCTION_1_LINE;
24015d88:	f44f 7380 	mov.w	r3, #256	; 0x100
24015d8c:	63bb      	str	r3, [r7, #56]	; 0x38
    sCommand.Instruction = READ_STATUS_REG_CMD;
24015d8e:	2305      	movs	r3, #5
24015d90:	623b      	str	r3, [r7, #32]
    sCommand.AddressMode = QSPI_ADDRESS_NONE;
24015d92:	2300      	movs	r3, #0
24015d94:	63fb      	str	r3, [r7, #60]	; 0x3c
    sCommand.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;
24015d96:	2300      	movs	r3, #0
24015d98:	643b      	str	r3, [r7, #64]	; 0x40
    sCommand.DataMode = QSPI_DATA_1_LINE;
24015d9a:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
24015d9e:	647b      	str	r3, [r7, #68]	; 0x44
    sCommand.DummyCycles = 0;
24015da0:	2300      	movs	r3, #0
24015da2:	637b      	str	r3, [r7, #52]	; 0x34
    sCommand.DdrMode = QSPI_DDR_MODE_DISABLE;
24015da4:	2300      	movs	r3, #0
24015da6:	64fb      	str	r3, [r7, #76]	; 0x4c
    sCommand.DdrHoldHalfCycle = QSPI_DDR_HHC_ANALOG_DELAY;
24015da8:	2300      	movs	r3, #0
24015daa:	653b      	str	r3, [r7, #80]	; 0x50
    sCommand.SIOOMode = QSPI_SIOO_INST_EVERY_CMD;
24015dac:	2300      	movs	r3, #0
24015dae:	657b      	str	r3, [r7, #84]	; 0x54

    sConfig.Match = 0x00;
24015db0:	2300      	movs	r3, #0
24015db2:	60bb      	str	r3, [r7, #8]
    sConfig.Mask = 0x01;
24015db4:	2301      	movs	r3, #1
24015db6:	60fb      	str	r3, [r7, #12]
    sConfig.MatchMode = QSPI_MATCH_MODE_AND;
24015db8:	2300      	movs	r3, #0
24015dba:	61bb      	str	r3, [r7, #24]
    sConfig.StatusBytesSize = 1;
24015dbc:	2301      	movs	r3, #1
24015dbe:	617b      	str	r3, [r7, #20]
    sConfig.Interval = 0x10;
24015dc0:	2310      	movs	r3, #16
24015dc2:	613b      	str	r3, [r7, #16]
    sConfig.AutomaticStop = QSPI_AUTOMATIC_STOP_ENABLE;
24015dc4:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
24015dc8:	61fb      	str	r3, [r7, #28]

    if (HAL_QSPI_AutoPolling(&hqspi, &sCommand, &sConfig, time) != HAL_OK)
24015dca:	f107 0208 	add.w	r2, r7, #8
24015dce:	f107 0120 	add.w	r1, r7, #32
24015dd2:	687b      	ldr	r3, [r7, #4]
24015dd4:	4806      	ldr	r0, [pc, #24]	; (24015df0 <QSPI_AutoPollingMemReady+0x70>)
24015dd6:	f7fb f975 	bl	240110c4 <HAL_QSPI_AutoPolling>
24015dda:	4603      	mov	r3, r0
24015ddc:	2b00      	cmp	r3, #0
24015dde:	d001      	beq.n	24015de4 <QSPI_AutoPollingMemReady+0x64>
    {
        return HAL_ERROR;
24015de0:	2301      	movs	r3, #1
24015de2:	e000      	b.n	24015de6 <QSPI_AutoPollingMemReady+0x66>
    }

    return HAL_OK;
24015de4:	2300      	movs	r3, #0
}
24015de6:	4618      	mov	r0, r3
24015de8:	3758      	adds	r7, #88	; 0x58
24015dea:	46bd      	mov	sp, r7
24015dec:	bd80      	pop	{r7, pc}
24015dee:	bf00      	nop
24015df0:	24000568 	.word	0x24000568

24015df4 <QSPI_WriteEnable>:

static uint8_t QSPI_WriteEnable(void)
{
24015df4:	b580      	push	{r7, lr}
24015df6:	b094      	sub	sp, #80	; 0x50
24015df8:	af00      	add	r7, sp, #0
    QSPI_CommandTypeDef sCommand;
    QSPI_AutoPollingTypeDef sConfig;

    /* Enable write operations ------------------------------------------ */
    sCommand.InstructionMode = QSPI_INSTRUCTION_1_LINE;
24015dfa:	f44f 7380 	mov.w	r3, #256	; 0x100
24015dfe:	633b      	str	r3, [r7, #48]	; 0x30
    sCommand.Instruction = WRITE_ENABLE_CMD;
24015e00:	2306      	movs	r3, #6
24015e02:	61bb      	str	r3, [r7, #24]
    sCommand.AddressMode = QSPI_ADDRESS_NONE;
24015e04:	2300      	movs	r3, #0
24015e06:	637b      	str	r3, [r7, #52]	; 0x34
    sCommand.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;
24015e08:	2300      	movs	r3, #0
24015e0a:	63bb      	str	r3, [r7, #56]	; 0x38
    sCommand.DataMode = QSPI_DATA_NONE;
24015e0c:	2300      	movs	r3, #0
24015e0e:	63fb      	str	r3, [r7, #60]	; 0x3c
    sCommand.DummyCycles = 0;
24015e10:	2300      	movs	r3, #0
24015e12:	62fb      	str	r3, [r7, #44]	; 0x2c
    sCommand.DdrMode = QSPI_DDR_MODE_DISABLE;
24015e14:	2300      	movs	r3, #0
24015e16:	647b      	str	r3, [r7, #68]	; 0x44
    sCommand.DdrHoldHalfCycle = QSPI_DDR_HHC_ANALOG_DELAY;
24015e18:	2300      	movs	r3, #0
24015e1a:	64bb      	str	r3, [r7, #72]	; 0x48
    sCommand.SIOOMode = QSPI_SIOO_INST_EVERY_CMD;
24015e1c:	2300      	movs	r3, #0
24015e1e:	64fb      	str	r3, [r7, #76]	; 0x4c

    if(HAL_QSPI_Command(&hqspi, &sCommand, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
24015e20:	f107 0318 	add.w	r3, r7, #24
24015e24:	f241 3288 	movw	r2, #5000	; 0x1388
24015e28:	4619      	mov	r1, r3
24015e2a:	4816      	ldr	r0, [pc, #88]	; (24015e84 <QSPI_WriteEnable+0x90>)
24015e2c:	f7fa fc9c 	bl	24010768 <HAL_QSPI_Command>
24015e30:	4603      	mov	r3, r0
24015e32:	2b00      	cmp	r3, #0
24015e34:	d001      	beq.n	24015e3a <QSPI_WriteEnable+0x46>
    {
        return HAL_ERROR;
24015e36:	2301      	movs	r3, #1
24015e38:	e01f      	b.n	24015e7a <QSPI_WriteEnable+0x86>
    }

    /* Configure automatic polling mode to wait for write enabling ---- */
    sConfig.Match = 0x02;
24015e3a:	2302      	movs	r3, #2
24015e3c:	603b      	str	r3, [r7, #0]
    sConfig.Mask = 0x02;
24015e3e:	2302      	movs	r3, #2
24015e40:	607b      	str	r3, [r7, #4]
    sConfig.MatchMode = QSPI_MATCH_MODE_AND;
24015e42:	2300      	movs	r3, #0
24015e44:	613b      	str	r3, [r7, #16]
    sConfig.StatusBytesSize = 1;
24015e46:	2301      	movs	r3, #1
24015e48:	60fb      	str	r3, [r7, #12]
    sConfig.Interval = 0x10;
24015e4a:	2310      	movs	r3, #16
24015e4c:	60bb      	str	r3, [r7, #8]
    sConfig.AutomaticStop = QSPI_AUTOMATIC_STOP_ENABLE;
24015e4e:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
24015e52:	617b      	str	r3, [r7, #20]

    sCommand.Instruction = READ_STATUS_REG_CMD;
24015e54:	2305      	movs	r3, #5
24015e56:	61bb      	str	r3, [r7, #24]
    sCommand.DataMode = QSPI_DATA_1_LINE;
24015e58:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
24015e5c:	63fb      	str	r3, [r7, #60]	; 0x3c
    if(HAL_QSPI_AutoPolling(&hqspi, &sCommand, &sConfig, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
24015e5e:	463a      	mov	r2, r7
24015e60:	f107 0118 	add.w	r1, r7, #24
24015e64:	f241 3388 	movw	r3, #5000	; 0x1388
24015e68:	4806      	ldr	r0, [pc, #24]	; (24015e84 <QSPI_WriteEnable+0x90>)
24015e6a:	f7fb f92b 	bl	240110c4 <HAL_QSPI_AutoPolling>
24015e6e:	4603      	mov	r3, r0
24015e70:	2b00      	cmp	r3, #0
24015e72:	d001      	beq.n	24015e78 <QSPI_WriteEnable+0x84>
    {
        return HAL_ERROR;
24015e74:	2301      	movs	r3, #1
24015e76:	e000      	b.n	24015e7a <QSPI_WriteEnable+0x86>
    }

    return HAL_OK;
24015e78:	2300      	movs	r3, #0
}
24015e7a:	4618      	mov	r0, r3
24015e7c:	3750      	adds	r7, #80	; 0x50
24015e7e:	46bd      	mov	sp, r7
24015e80:	bd80      	pop	{r7, pc}
24015e82:	bf00      	nop
24015e84:	24000568 	.word	0x24000568

24015e88 <QSPI_Configuration>:
/*Enable quad mode and set dummy cycles count*/
uint8_t QSPI_Configuration(void)
{
24015e88:	b580      	push	{r7, lr}
24015e8a:	b082      	sub	sp, #8
24015e8c:	af00      	add	r7, sp, #0
	uint8_t reg = 0;
24015e8e:	2300      	movs	r3, #0
24015e90:	71fb      	strb	r3, [r7, #7]
	uint8_t regs[2] = {2, 0};
24015e92:	2302      	movs	r3, #2
24015e94:	713b      	strb	r3, [r7, #4]
24015e96:	2300      	movs	r3, #0
24015e98:	717b      	strb	r3, [r7, #5]


	if(QSPI_ReadStatus(READ_STATUS_REGISTER_2, &reg) != HAL_OK)
24015e9a:	1dfb      	adds	r3, r7, #7
24015e9c:	4619      	mov	r1, r3
24015e9e:	2035      	movs	r0, #53	; 0x35
24015ea0:	f7ff fe48 	bl	24015b34 <QSPI_ReadStatus>
24015ea4:	4603      	mov	r3, r0
24015ea6:	2b00      	cmp	r3, #0
24015ea8:	d001      	beq.n	24015eae <QSPI_Configuration+0x26>
	{
		return HAL_ERROR;
24015eaa:	2301      	movs	r3, #1
24015eac:	e00d      	b.n	24015eca <QSPI_Configuration+0x42>
	}

	reg = 2;
24015eae:	2302      	movs	r3, #2
24015eb0:	71fb      	strb	r3, [r7, #7]
	if(QSPI_WriteStatus(WRITE_STATUS_REGISTER_1, regs, 2) != HAL_OK)
24015eb2:	1d3b      	adds	r3, r7, #4
24015eb4:	2202      	movs	r2, #2
24015eb6:	4619      	mov	r1, r3
24015eb8:	2001      	movs	r0, #1
24015eba:	f7ff fe7b 	bl	24015bb4 <QSPI_WriteStatus>
24015ebe:	4603      	mov	r3, r0
24015ec0:	2b00      	cmp	r3, #0
24015ec2:	d001      	beq.n	24015ec8 <QSPI_Configuration+0x40>
	{
		return HAL_ERROR;
24015ec4:	2301      	movs	r3, #1
24015ec6:	e000      	b.n	24015eca <QSPI_Configuration+0x42>
	}

	return HAL_OK;
24015ec8:	2300      	movs	r3, #0

}
24015eca:	4618      	mov	r0, r3
24015ecc:	3708      	adds	r7, #8
24015ece:	46bd      	mov	sp, r7
24015ed0:	bd80      	pop	{r7, pc}
	...

24015ed4 <CSP_QSPI_EraseSector>:
uint8_t CSP_QSPI_EraseSector(uint32_t EraseStartAddress, uint32_t EraseEndAddress)
{
24015ed4:	b580      	push	{r7, lr}
24015ed6:	b090      	sub	sp, #64	; 0x40
24015ed8:	af00      	add	r7, sp, #0
24015eda:	6078      	str	r0, [r7, #4]
24015edc:	6039      	str	r1, [r7, #0]

    QSPI_CommandTypeDef sCommand;

    EraseStartAddress = EraseStartAddress
24015ede:	687a      	ldr	r2, [r7, #4]
24015ee0:	4b24      	ldr	r3, [pc, #144]	; (24015f74 <CSP_QSPI_EraseSector+0xa0>)
24015ee2:	4013      	ands	r3, r2
24015ee4:	607b      	str	r3, [r7, #4]
                        - EraseStartAddress % MEMORY_SECTOR_SIZE;

    /* Erasing Sequence -------------------------------------------------- */
    sCommand.InstructionMode = QSPI_INSTRUCTION_1_LINE;
24015ee6:	f44f 7380 	mov.w	r3, #256	; 0x100
24015eea:	623b      	str	r3, [r7, #32]
    sCommand.AddressSize = QSPI_ADDRESS_24_BITS;
24015eec:	f44f 5300 	mov.w	r3, #8192	; 0x2000
24015ef0:	617b      	str	r3, [r7, #20]
    sCommand.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;
24015ef2:	2300      	movs	r3, #0
24015ef4:	62bb      	str	r3, [r7, #40]	; 0x28
    sCommand.DdrMode = QSPI_DDR_MODE_DISABLE;
24015ef6:	2300      	movs	r3, #0
24015ef8:	637b      	str	r3, [r7, #52]	; 0x34
    sCommand.DdrHoldHalfCycle = QSPI_DDR_HHC_ANALOG_DELAY;
24015efa:	2300      	movs	r3, #0
24015efc:	63bb      	str	r3, [r7, #56]	; 0x38
    sCommand.SIOOMode = QSPI_SIOO_INST_EVERY_CMD;
24015efe:	2300      	movs	r3, #0
24015f00:	63fb      	str	r3, [r7, #60]	; 0x3c
    sCommand.Instruction = SECTOR_ERASE_CMD;
24015f02:	23d8      	movs	r3, #216	; 0xd8
24015f04:	60bb      	str	r3, [r7, #8]
    sCommand.AddressMode = QSPI_ADDRESS_1_LINE;
24015f06:	f44f 6380 	mov.w	r3, #1024	; 0x400
24015f0a:	627b      	str	r3, [r7, #36]	; 0x24

    sCommand.DataMode = QSPI_DATA_NONE;
24015f0c:	2300      	movs	r3, #0
24015f0e:	62fb      	str	r3, [r7, #44]	; 0x2c
    sCommand.DummyCycles = 0;
24015f10:	2300      	movs	r3, #0
24015f12:	61fb      	str	r3, [r7, #28]

    while(EraseEndAddress >= EraseStartAddress)
24015f14:	e024      	b.n	24015f60 <CSP_QSPI_EraseSector+0x8c>
    {

    	sCommand.Address = (EraseStartAddress & 0x0fFFFFFF);
24015f16:	687b      	ldr	r3, [r7, #4]
24015f18:	f023 4370 	bic.w	r3, r3, #4026531840	; 0xf0000000
24015f1c:	60fb      	str	r3, [r7, #12]

        if(QSPI_WriteEnable() != HAL_OK)
24015f1e:	f7ff ff69 	bl	24015df4 <QSPI_WriteEnable>
24015f22:	4603      	mov	r3, r0
24015f24:	2b00      	cmp	r3, #0
24015f26:	d001      	beq.n	24015f2c <CSP_QSPI_EraseSector+0x58>
        {
            return HAL_ERROR;
24015f28:	2301      	movs	r3, #1
24015f2a:	e01e      	b.n	24015f6a <CSP_QSPI_EraseSector+0x96>
        }

        if(HAL_QSPI_Command(&hqspi, &sCommand, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
24015f2c:	f107 0308 	add.w	r3, r7, #8
24015f30:	f241 3288 	movw	r2, #5000	; 0x1388
24015f34:	4619      	mov	r1, r3
24015f36:	4810      	ldr	r0, [pc, #64]	; (24015f78 <CSP_QSPI_EraseSector+0xa4>)
24015f38:	f7fa fc16 	bl	24010768 <HAL_QSPI_Command>
24015f3c:	4603      	mov	r3, r0
24015f3e:	2b00      	cmp	r3, #0
24015f40:	d001      	beq.n	24015f46 <CSP_QSPI_EraseSector+0x72>
        {
            return HAL_ERROR;
24015f42:	2301      	movs	r3, #1
24015f44:	e011      	b.n	24015f6a <CSP_QSPI_EraseSector+0x96>
        }
        EraseStartAddress += MEMORY_SECTOR_SIZE;
24015f46:	687b      	ldr	r3, [r7, #4]
24015f48:	f503 3380 	add.w	r3, r3, #65536	; 0x10000
24015f4c:	607b      	str	r3, [r7, #4]

        if (QSPI_AutoPollingMemReady(SECTOR_ERASE_MAX_TIME) != HAL_OK)
24015f4e:	f640 30b8 	movw	r0, #3000	; 0xbb8
24015f52:	f7ff ff15 	bl	24015d80 <QSPI_AutoPollingMemReady>
24015f56:	4603      	mov	r3, r0
24015f58:	2b00      	cmp	r3, #0
24015f5a:	d001      	beq.n	24015f60 <CSP_QSPI_EraseSector+0x8c>
        {
            return HAL_ERROR;
24015f5c:	2301      	movs	r3, #1
24015f5e:	e004      	b.n	24015f6a <CSP_QSPI_EraseSector+0x96>
    while(EraseEndAddress >= EraseStartAddress)
24015f60:	683a      	ldr	r2, [r7, #0]
24015f62:	687b      	ldr	r3, [r7, #4]
24015f64:	429a      	cmp	r2, r3
24015f66:	d2d6      	bcs.n	24015f16 <CSP_QSPI_EraseSector+0x42>
        }
    }

    return HAL_OK;
24015f68:	2300      	movs	r3, #0
}
24015f6a:	4618      	mov	r0, r3
24015f6c:	3740      	adds	r7, #64	; 0x40
24015f6e:	46bd      	mov	sp, r7
24015f70:	bd80      	pop	{r7, pc}
24015f72:	bf00      	nop
24015f74:	ffff0000 	.word	0xffff0000
24015f78:	24000568 	.word	0x24000568

24015f7c <CSP_QSPI_WriteMemory>:

uint8_t CSP_QSPI_WriteMemory(uint8_t* buffer, uint32_t address, uint32_t buffer_size)
{
24015f7c:	b580      	push	{r7, lr}
24015f7e:	b096      	sub	sp, #88	; 0x58
24015f80:	af00      	add	r7, sp, #0
24015f82:	60f8      	str	r0, [r7, #12]
24015f84:	60b9      	str	r1, [r7, #8]
24015f86:	607a      	str	r2, [r7, #4]

    QSPI_CommandTypeDef sCommand;
    uint32_t end_addr, current_size, current_addr;

    /* Calculation of the size between the write address and the end of the page */
    current_addr = 0;
24015f88:	2300      	movs	r3, #0
24015f8a:	653b      	str	r3, [r7, #80]	; 0x50


    //
    while (current_addr <= address)
24015f8c:	e003      	b.n	24015f96 <CSP_QSPI_WriteMemory+0x1a>
    {
        current_addr += MEMORY_PAGE_SIZE;
24015f8e:	6d3b      	ldr	r3, [r7, #80]	; 0x50
24015f90:	f503 7380 	add.w	r3, r3, #256	; 0x100
24015f94:	653b      	str	r3, [r7, #80]	; 0x50
    while (current_addr <= address)
24015f96:	6d3a      	ldr	r2, [r7, #80]	; 0x50
24015f98:	68bb      	ldr	r3, [r7, #8]
24015f9a:	429a      	cmp	r2, r3
24015f9c:	d9f7      	bls.n	24015f8e <CSP_QSPI_WriteMemory+0x12>
    }
    current_size = current_addr - address;
24015f9e:	6d3a      	ldr	r2, [r7, #80]	; 0x50
24015fa0:	68bb      	ldr	r3, [r7, #8]
24015fa2:	1ad3      	subs	r3, r2, r3
24015fa4:	657b      	str	r3, [r7, #84]	; 0x54

    /* Check if the size of the data is less than the remaining place in the page */
    if (current_size > buffer_size)
24015fa6:	6d7a      	ldr	r2, [r7, #84]	; 0x54
24015fa8:	687b      	ldr	r3, [r7, #4]
24015faa:	429a      	cmp	r2, r3
24015fac:	d901      	bls.n	24015fb2 <CSP_QSPI_WriteMemory+0x36>
    {
        current_size = buffer_size;
24015fae:	687b      	ldr	r3, [r7, #4]
24015fb0:	657b      	str	r3, [r7, #84]	; 0x54
    }

    /* Initialize the adress variables */
    current_addr = address;
24015fb2:	68bb      	ldr	r3, [r7, #8]
24015fb4:	653b      	str	r3, [r7, #80]	; 0x50
    end_addr = address + buffer_size;
24015fb6:	68ba      	ldr	r2, [r7, #8]
24015fb8:	687b      	ldr	r3, [r7, #4]
24015fba:	4413      	add	r3, r2
24015fbc:	64fb      	str	r3, [r7, #76]	; 0x4c

    sCommand.InstructionMode = QSPI_INSTRUCTION_1_LINE;
24015fbe:	f44f 7380 	mov.w	r3, #256	; 0x100
24015fc2:	62fb      	str	r3, [r7, #44]	; 0x2c
    sCommand.AddressSize = QSPI_ADDRESS_24_BITS;
24015fc4:	f44f 5300 	mov.w	r3, #8192	; 0x2000
24015fc8:	623b      	str	r3, [r7, #32]
    sCommand.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;
24015fca:	2300      	movs	r3, #0
24015fcc:	637b      	str	r3, [r7, #52]	; 0x34
    sCommand.DdrMode = QSPI_DDR_MODE_DISABLE;
24015fce:	2300      	movs	r3, #0
24015fd0:	643b      	str	r3, [r7, #64]	; 0x40
    sCommand.DdrHoldHalfCycle = QSPI_DDR_HHC_ANALOG_DELAY;
24015fd2:	2300      	movs	r3, #0
24015fd4:	647b      	str	r3, [r7, #68]	; 0x44
    sCommand.SIOOMode = QSPI_SIOO_INST_EVERY_CMD;
24015fd6:	2300      	movs	r3, #0
24015fd8:	64bb      	str	r3, [r7, #72]	; 0x48
    sCommand.Instruction = QUAD_IN_FAST_PROG_CMD;
24015fda:	2332      	movs	r3, #50	; 0x32
24015fdc:	617b      	str	r3, [r7, #20]
    sCommand.AddressMode = QSPI_ADDRESS_1_LINE;
24015fde:	f44f 6380 	mov.w	r3, #1024	; 0x400
24015fe2:	633b      	str	r3, [r7, #48]	; 0x30
    sCommand.DataMode = QSPI_DATA_4_LINES;
24015fe4:	f04f 7340 	mov.w	r3, #50331648	; 0x3000000
24015fe8:	63bb      	str	r3, [r7, #56]	; 0x38
    sCommand.NbData = buffer_size;
24015fea:	687b      	ldr	r3, [r7, #4]
24015fec:	63fb      	str	r3, [r7, #60]	; 0x3c
    sCommand.Address = address;
24015fee:	68bb      	ldr	r3, [r7, #8]
24015ff0:	61bb      	str	r3, [r7, #24]
    sCommand.DummyCycles = 0;
24015ff2:	2300      	movs	r3, #0
24015ff4:	62bb      	str	r3, [r7, #40]	; 0x28

    /* Perform the write page by page */
    do
    {
        sCommand.Address = current_addr;
24015ff6:	6d3b      	ldr	r3, [r7, #80]	; 0x50
24015ff8:	61bb      	str	r3, [r7, #24]
        sCommand.NbData = current_size;
24015ffa:	6d7b      	ldr	r3, [r7, #84]	; 0x54
24015ffc:	63fb      	str	r3, [r7, #60]	; 0x3c

        if (current_size == 0)
24015ffe:	6d7b      	ldr	r3, [r7, #84]	; 0x54
24016000:	2b00      	cmp	r3, #0
24016002:	d101      	bne.n	24016008 <CSP_QSPI_WriteMemory+0x8c>
        {
            return HAL_OK;
24016004:	2300      	movs	r3, #0
24016006:	e041      	b.n	2401608c <CSP_QSPI_WriteMemory+0x110>
        }

        /* Enable write operations */
        if (QSPI_WriteEnable() != HAL_OK)
24016008:	f7ff fef4 	bl	24015df4 <QSPI_WriteEnable>
2401600c:	4603      	mov	r3, r0
2401600e:	2b00      	cmp	r3, #0
24016010:	d001      	beq.n	24016016 <CSP_QSPI_WriteMemory+0x9a>
        {
            return HAL_ERROR;
24016012:	2301      	movs	r3, #1
24016014:	e03a      	b.n	2401608c <CSP_QSPI_WriteMemory+0x110>
        }

        /* Configure the command */
        if (HAL_QSPI_Command(&hqspi, &sCommand, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
24016016:	f107 0314 	add.w	r3, r7, #20
2401601a:	f241 3288 	movw	r2, #5000	; 0x1388
2401601e:	4619      	mov	r1, r3
24016020:	481c      	ldr	r0, [pc, #112]	; (24016094 <CSP_QSPI_WriteMemory+0x118>)
24016022:	f7fa fba1 	bl	24010768 <HAL_QSPI_Command>
24016026:	4603      	mov	r3, r0
24016028:	2b00      	cmp	r3, #0
2401602a:	d001      	beq.n	24016030 <CSP_QSPI_WriteMemory+0xb4>
        {

            return HAL_ERROR;
2401602c:	2301      	movs	r3, #1
2401602e:	e02d      	b.n	2401608c <CSP_QSPI_WriteMemory+0x110>
        }

        /* Transmission of the data */
        if (HAL_QSPI_Transmit(&hqspi, buffer, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
24016030:	f241 3288 	movw	r2, #5000	; 0x1388
24016034:	68f9      	ldr	r1, [r7, #12]
24016036:	4817      	ldr	r0, [pc, #92]	; (24016094 <CSP_QSPI_WriteMemory+0x118>)
24016038:	f7fa fc5a 	bl	240108f0 <HAL_QSPI_Transmit>
2401603c:	4603      	mov	r3, r0
2401603e:	2b00      	cmp	r3, #0
24016040:	d001      	beq.n	24016046 <CSP_QSPI_WriteMemory+0xca>
        {

            return HAL_ERROR;
24016042:	2301      	movs	r3, #1
24016044:	e022      	b.n	2401608c <CSP_QSPI_WriteMemory+0x110>
        }

        /* Configure automatic polling mode to wait for end of program */
        if (QSPI_AutoPollingMemReady(HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
24016046:	f241 3088 	movw	r0, #5000	; 0x1388
2401604a:	f7ff fe99 	bl	24015d80 <QSPI_AutoPollingMemReady>
2401604e:	4603      	mov	r3, r0
24016050:	2b00      	cmp	r3, #0
24016052:	d001      	beq.n	24016058 <CSP_QSPI_WriteMemory+0xdc>
        {
            return HAL_ERROR;
24016054:	2301      	movs	r3, #1
24016056:	e019      	b.n	2401608c <CSP_QSPI_WriteMemory+0x110>
        }

        /* Update the address and size variables for next page programming */
        current_addr += current_size;
24016058:	6d3a      	ldr	r2, [r7, #80]	; 0x50
2401605a:	6d7b      	ldr	r3, [r7, #84]	; 0x54
2401605c:	4413      	add	r3, r2
2401605e:	653b      	str	r3, [r7, #80]	; 0x50
        buffer += current_size;
24016060:	68fa      	ldr	r2, [r7, #12]
24016062:	6d7b      	ldr	r3, [r7, #84]	; 0x54
24016064:	4413      	add	r3, r2
24016066:	60fb      	str	r3, [r7, #12]
        current_size =
            ((current_addr + MEMORY_PAGE_SIZE) > end_addr) ?
24016068:	6d3b      	ldr	r3, [r7, #80]	; 0x50
2401606a:	f503 7380 	add.w	r3, r3, #256	; 0x100
            (end_addr - current_addr) : MEMORY_PAGE_SIZE;
2401606e:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
24016070:	429a      	cmp	r2, r3
24016072:	d203      	bcs.n	2401607c <CSP_QSPI_WriteMemory+0x100>
24016074:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
24016076:	6d3b      	ldr	r3, [r7, #80]	; 0x50
24016078:	1ad3      	subs	r3, r2, r3
2401607a:	e001      	b.n	24016080 <CSP_QSPI_WriteMemory+0x104>
2401607c:	f44f 7380 	mov.w	r3, #256	; 0x100
        current_size =
24016080:	657b      	str	r3, [r7, #84]	; 0x54
    } while (current_addr <= end_addr);
24016082:	6d3a      	ldr	r2, [r7, #80]	; 0x50
24016084:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
24016086:	429a      	cmp	r2, r3
24016088:	d9b5      	bls.n	24015ff6 <CSP_QSPI_WriteMemory+0x7a>

    return HAL_OK;
2401608a:	2300      	movs	r3, #0
}
2401608c:	4618      	mov	r0, r3
2401608e:	3758      	adds	r7, #88	; 0x58
24016090:	46bd      	mov	sp, r7
24016092:	bd80      	pop	{r7, pc}
24016094:	24000568 	.word	0x24000568

24016098 <CSP_QSPI_EnableMemoryMappedMode>:


uint8_t CSP_QSPI_EnableMemoryMappedMode(void)
{
24016098:	b580      	push	{r7, lr}
2401609a:	b090      	sub	sp, #64	; 0x40
2401609c:	af00      	add	r7, sp, #0
    QSPI_MemoryMappedTypeDef sMemMappedCfg;

    /* Enable Memory-Mapped mode-------------------------------------------------- */

    /* Configure the command for the read instruction */
    sCommand.InstructionMode   = QSPI_INSTRUCTION_1_LINE;
2401609e:	f44f 7380 	mov.w	r3, #256	; 0x100
240160a2:	623b      	str	r3, [r7, #32]
    sCommand.Instruction       = QUAD_OUT_FAST_READ_CMD;
240160a4:	23eb      	movs	r3, #235	; 0xeb
240160a6:	60bb      	str	r3, [r7, #8]
    sCommand.AddressMode       = QSPI_ADDRESS_4_LINES;
240160a8:	f44f 6340 	mov.w	r3, #3072	; 0xc00
240160ac:	627b      	str	r3, [r7, #36]	; 0x24
    sCommand.AddressSize       = QSPI_ADDRESS_24_BITS;
240160ae:	f44f 5300 	mov.w	r3, #8192	; 0x2000
240160b2:	617b      	str	r3, [r7, #20]

    sCommand.AlternateByteMode = QSPI_ALTERNATE_BYTES_4_LINES;
240160b4:	f44f 4340 	mov.w	r3, #49152	; 0xc000
240160b8:	62bb      	str	r3, [r7, #40]	; 0x28
    sCommand.AlternateBytesSize= QSPI_ALTERNATE_BYTES_8_BITS;
240160ba:	2300      	movs	r3, #0
240160bc:	61bb      	str	r3, [r7, #24]
    sCommand.AlternateBytes    = 0;
240160be:	2300      	movs	r3, #0
240160c0:	613b      	str	r3, [r7, #16]

    sCommand.DataMode          = QSPI_DATA_4_LINES;
240160c2:	f04f 7340 	mov.w	r3, #50331648	; 0x3000000
240160c6:	62fb      	str	r3, [r7, #44]	; 0x2c
    sCommand.DummyCycles       = 4;
240160c8:	2304      	movs	r3, #4
240160ca:	61fb      	str	r3, [r7, #28]
    sCommand.DdrMode           = QSPI_DDR_MODE_DISABLE;
240160cc:	2300      	movs	r3, #0
240160ce:	637b      	str	r3, [r7, #52]	; 0x34
    sCommand.DdrHoldHalfCycle  = QSPI_DDR_HHC_ANALOG_DELAY;
240160d0:	2300      	movs	r3, #0
240160d2:	63bb      	str	r3, [r7, #56]	; 0x38
    sCommand.SIOOMode          = QSPI_SIOO_INST_EVERY_CMD;
240160d4:	2300      	movs	r3, #0
240160d6:	63fb      	str	r3, [r7, #60]	; 0x3c

    /* Configure the memory mapped mode */
    sMemMappedCfg.TimeOutActivation = QSPI_TIMEOUT_COUNTER_DISABLE;
240160d8:	2300      	movs	r3, #0
240160da:	607b      	str	r3, [r7, #4]
    if (HAL_QSPI_MemoryMapped(&hqspi, &sCommand, &sMemMappedCfg) != HAL_OK)
240160dc:	463a      	mov	r2, r7
240160de:	f107 0308 	add.w	r3, r7, #8
240160e2:	4619      	mov	r1, r3
240160e4:	4806      	ldr	r0, [pc, #24]	; (24016100 <CSP_QSPI_EnableMemoryMappedMode+0x68>)
240160e6:	f7fb f8dc 	bl	240112a2 <HAL_QSPI_MemoryMapped>
240160ea:	4603      	mov	r3, r0
240160ec:	2b00      	cmp	r3, #0
240160ee:	d001      	beq.n	240160f4 <CSP_QSPI_EnableMemoryMappedMode+0x5c>
    {
        return HAL_ERROR;
240160f0:	2301      	movs	r3, #1
240160f2:	e000      	b.n	240160f6 <CSP_QSPI_EnableMemoryMappedMode+0x5e>
    }
    return HAL_OK;
240160f4:	2300      	movs	r3, #0
}
240160f6:	4618      	mov	r0, r3
240160f8:	3740      	adds	r7, #64	; 0x40
240160fa:	46bd      	mov	sp, r7
240160fc:	bd80      	pop	{r7, pc}
240160fe:	bf00      	nop
24016100:	24000568 	.word	0x24000568

24016104 <QSPI_ResetChip>:

uint8_t QSPI_ResetChip()
{
24016104:	b580      	push	{r7, lr}
24016106:	b090      	sub	sp, #64	; 0x40
24016108:	af00      	add	r7, sp, #0
    QSPI_CommandTypeDef sCommand;
    uint32_t temp = 0;
2401610a:	2300      	movs	r3, #0
2401610c:	63fb      	str	r3, [r7, #60]	; 0x3c
    /* Erasing Sequence -------------------------------------------------- */
    sCommand.InstructionMode = QSPI_INSTRUCTION_1_LINE;
2401610e:	f44f 7380 	mov.w	r3, #256	; 0x100
24016112:	61fb      	str	r3, [r7, #28]
    sCommand.AddressSize = QSPI_ADDRESS_24_BITS;
24016114:	f44f 5300 	mov.w	r3, #8192	; 0x2000
24016118:	613b      	str	r3, [r7, #16]
    sCommand.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;
2401611a:	2300      	movs	r3, #0
2401611c:	627b      	str	r3, [r7, #36]	; 0x24
    sCommand.DdrMode = QSPI_DDR_MODE_DISABLE;
2401611e:	2300      	movs	r3, #0
24016120:	633b      	str	r3, [r7, #48]	; 0x30
    sCommand.DdrHoldHalfCycle = QSPI_DDR_HHC_ANALOG_DELAY;
24016122:	2300      	movs	r3, #0
24016124:	637b      	str	r3, [r7, #52]	; 0x34
    sCommand.SIOOMode = QSPI_SIOO_INST_EVERY_CMD;
24016126:	2300      	movs	r3, #0
24016128:	63bb      	str	r3, [r7, #56]	; 0x38
    sCommand.Instruction = RESET_ENABLE_CMD;
2401612a:	2366      	movs	r3, #102	; 0x66
2401612c:	607b      	str	r3, [r7, #4]
    sCommand.AddressMode = QSPI_ADDRESS_NONE;
2401612e:	2300      	movs	r3, #0
24016130:	623b      	str	r3, [r7, #32]
    sCommand.Address = 0;
24016132:	2300      	movs	r3, #0
24016134:	60bb      	str	r3, [r7, #8]
    sCommand.DataMode = QSPI_DATA_NONE;
24016136:	2300      	movs	r3, #0
24016138:	62bb      	str	r3, [r7, #40]	; 0x28
    sCommand.DummyCycles = 0;
2401613a:	2300      	movs	r3, #0
2401613c:	61bb      	str	r3, [r7, #24]

    if (HAL_QSPI_Command(&hqspi, &sCommand, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
2401613e:	1d3b      	adds	r3, r7, #4
24016140:	f241 3288 	movw	r2, #5000	; 0x1388
24016144:	4619      	mov	r1, r3
24016146:	4817      	ldr	r0, [pc, #92]	; (240161a4 <QSPI_ResetChip+0xa0>)
24016148:	f7fa fb0e 	bl	24010768 <HAL_QSPI_Command>
2401614c:	4603      	mov	r3, r0
2401614e:	2b00      	cmp	r3, #0
24016150:	d001      	beq.n	24016156 <QSPI_ResetChip+0x52>
    {
        return HAL_ERROR;
24016152:	2301      	movs	r3, #1
24016154:	e021      	b.n	2401619a <QSPI_ResetChip+0x96>
    }
    for (temp = 0; temp < 200; temp++)
24016156:	2300      	movs	r3, #0
24016158:	63fb      	str	r3, [r7, #60]	; 0x3c
2401615a:	e003      	b.n	24016164 <QSPI_ResetChip+0x60>
    {
        __NOP();
2401615c:	bf00      	nop
    for (temp = 0; temp < 200; temp++)
2401615e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
24016160:	3301      	adds	r3, #1
24016162:	63fb      	str	r3, [r7, #60]	; 0x3c
24016164:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
24016166:	2bc7      	cmp	r3, #199	; 0xc7
24016168:	d9f8      	bls.n	2401615c <QSPI_ResetChip+0x58>
    }

    sCommand.Instruction = RESET_EXECUTE_CMD;
2401616a:	2399      	movs	r3, #153	; 0x99
2401616c:	607b      	str	r3, [r7, #4]

    if (HAL_QSPI_Command(&hqspi, &sCommand, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
2401616e:	1d3b      	adds	r3, r7, #4
24016170:	f241 3288 	movw	r2, #5000	; 0x1388
24016174:	4619      	mov	r1, r3
24016176:	480b      	ldr	r0, [pc, #44]	; (240161a4 <QSPI_ResetChip+0xa0>)
24016178:	f7fa faf6 	bl	24010768 <HAL_QSPI_Command>
2401617c:	4603      	mov	r3, r0
2401617e:	2b00      	cmp	r3, #0
24016180:	d001      	beq.n	24016186 <QSPI_ResetChip+0x82>
    {
        return HAL_ERROR;
24016182:	2301      	movs	r3, #1
24016184:	e009      	b.n	2401619a <QSPI_ResetChip+0x96>
    }

    if(QSPI_AutoPollingMemReady(HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
24016186:	f241 3088 	movw	r0, #5000	; 0x1388
2401618a:	f7ff fdf9 	bl	24015d80 <QSPI_AutoPollingMemReady>
2401618e:	4603      	mov	r3, r0
24016190:	2b00      	cmp	r3, #0
24016192:	d001      	beq.n	24016198 <QSPI_ResetChip+0x94>
	{
    	return HAL_ERROR;
24016194:	2301      	movs	r3, #1
24016196:	e000      	b.n	2401619a <QSPI_ResetChip+0x96>
	}

    return HAL_OK;
24016198:	2300      	movs	r3, #0
}
2401619a:	4618      	mov	r0, r3
2401619c:	3740      	adds	r7, #64	; 0x40
2401619e:	46bd      	mov	sp, r7
240161a0:	bd80      	pop	{r7, pc}
240161a2:	bf00      	nop
240161a4:	24000568 	.word	0x24000568

240161a8 <HAL_QSPI_MspInit>:
* This function configures the hardware resources used in this example
* @param hqspi: QSPI handle pointer
* @retval None
*/
void HAL_QSPI_MspInit(QSPI_HandleTypeDef* hqspi)
{
240161a8:	b580      	push	{r7, lr}
240161aa:	b08c      	sub	sp, #48	; 0x30
240161ac:	af00      	add	r7, sp, #0
240161ae:	6078      	str	r0, [r7, #4]
	GPIO_InitTypeDef GPIO_InitStruct = {0};
240161b0:	f107 031c 	add.w	r3, r7, #28
240161b4:	2200      	movs	r2, #0
240161b6:	601a      	str	r2, [r3, #0]
240161b8:	605a      	str	r2, [r3, #4]
240161ba:	609a      	str	r2, [r3, #8]
240161bc:	60da      	str	r2, [r3, #12]
240161be:	611a      	str	r2, [r3, #16]
	if(hqspi->Instance==QUADSPI)
240161c0:	687b      	ldr	r3, [r7, #4]
240161c2:	681b      	ldr	r3, [r3, #0]
240161c4:	4a3a      	ldr	r2, [pc, #232]	; (240162b0 <HAL_QSPI_MspInit+0x108>)
240161c6:	4293      	cmp	r3, r2
240161c8:	d16d      	bne.n	240162a6 <HAL_QSPI_MspInit+0xfe>
	{
		/* Peripheral clock enable */
		__HAL_RCC_QSPI_CLK_ENABLE();
240161ca:	4b3a      	ldr	r3, [pc, #232]	; (240162b4 <HAL_QSPI_MspInit+0x10c>)
240161cc:	f8d3 30d4 	ldr.w	r3, [r3, #212]	; 0xd4
240161d0:	4a38      	ldr	r2, [pc, #224]	; (240162b4 <HAL_QSPI_MspInit+0x10c>)
240161d2:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
240161d6:	f8c2 30d4 	str.w	r3, [r2, #212]	; 0xd4
240161da:	4b36      	ldr	r3, [pc, #216]	; (240162b4 <HAL_QSPI_MspInit+0x10c>)
240161dc:	f8d3 30d4 	ldr.w	r3, [r3, #212]	; 0xd4
240161e0:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
240161e4:	61bb      	str	r3, [r7, #24]
240161e6:	69bb      	ldr	r3, [r7, #24]

		__HAL_RCC_GPIOE_CLK_ENABLE();
240161e8:	4b32      	ldr	r3, [pc, #200]	; (240162b4 <HAL_QSPI_MspInit+0x10c>)
240161ea:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
240161ee:	4a31      	ldr	r2, [pc, #196]	; (240162b4 <HAL_QSPI_MspInit+0x10c>)
240161f0:	f043 0310 	orr.w	r3, r3, #16
240161f4:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
240161f8:	4b2e      	ldr	r3, [pc, #184]	; (240162b4 <HAL_QSPI_MspInit+0x10c>)
240161fa:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
240161fe:	f003 0310 	and.w	r3, r3, #16
24016202:	617b      	str	r3, [r7, #20]
24016204:	697b      	ldr	r3, [r7, #20]
		__HAL_RCC_GPIOB_CLK_ENABLE();
24016206:	4b2b      	ldr	r3, [pc, #172]	; (240162b4 <HAL_QSPI_MspInit+0x10c>)
24016208:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
2401620c:	4a29      	ldr	r2, [pc, #164]	; (240162b4 <HAL_QSPI_MspInit+0x10c>)
2401620e:	f043 0302 	orr.w	r3, r3, #2
24016212:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
24016216:	4b27      	ldr	r3, [pc, #156]	; (240162b4 <HAL_QSPI_MspInit+0x10c>)
24016218:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
2401621c:	f003 0302 	and.w	r3, r3, #2
24016220:	613b      	str	r3, [r7, #16]
24016222:	693b      	ldr	r3, [r7, #16]
		__HAL_RCC_GPIOD_CLK_ENABLE();
24016224:	4b23      	ldr	r3, [pc, #140]	; (240162b4 <HAL_QSPI_MspInit+0x10c>)
24016226:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
2401622a:	4a22      	ldr	r2, [pc, #136]	; (240162b4 <HAL_QSPI_MspInit+0x10c>)
2401622c:	f043 0308 	orr.w	r3, r3, #8
24016230:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
24016234:	4b1f      	ldr	r3, [pc, #124]	; (240162b4 <HAL_QSPI_MspInit+0x10c>)
24016236:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
2401623a:	f003 0308 	and.w	r3, r3, #8
2401623e:	60fb      	str	r3, [r7, #12]
24016240:	68fb      	ldr	r3, [r7, #12]
		PB10     ------> QUADSPI_BK1_NCS
		PD11     ------> QUADSPI_BK1_IO0
		PD12     ------> QUADSPI_BK1_IO1
		PD13     ------> QUADSPI_BK1_IO3
		*/
		GPIO_InitStruct.Pin = GPIO_PIN_2;
24016242:	2304      	movs	r3, #4
24016244:	61fb      	str	r3, [r7, #28]
		GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
24016246:	2302      	movs	r3, #2
24016248:	623b      	str	r3, [r7, #32]
		GPIO_InitStruct.Pull = GPIO_NOPULL;
2401624a:	2300      	movs	r3, #0
2401624c:	627b      	str	r3, [r7, #36]	; 0x24
		GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
2401624e:	2302      	movs	r3, #2
24016250:	62bb      	str	r3, [r7, #40]	; 0x28
		GPIO_InitStruct.Alternate = GPIO_AF9_QUADSPI;
24016252:	2309      	movs	r3, #9
24016254:	62fb      	str	r3, [r7, #44]	; 0x2c
		HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
24016256:	f107 031c 	add.w	r3, r7, #28
2401625a:	4619      	mov	r1, r3
2401625c:	4816      	ldr	r0, [pc, #88]	; (240162b8 <HAL_QSPI_MspInit+0x110>)
2401625e:	f7f2 f995 	bl	2400858c <HAL_GPIO_Init>

		GPIO_InitStruct.Pin = GPIO_PIN_2|GPIO_PIN_10;
24016262:	f240 4304 	movw	r3, #1028	; 0x404
24016266:	61fb      	str	r3, [r7, #28]
		GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
24016268:	2302      	movs	r3, #2
2401626a:	623b      	str	r3, [r7, #32]
		GPIO_InitStruct.Pull = GPIO_NOPULL;
2401626c:	2300      	movs	r3, #0
2401626e:	627b      	str	r3, [r7, #36]	; 0x24
		GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
24016270:	2303      	movs	r3, #3
24016272:	62bb      	str	r3, [r7, #40]	; 0x28
		GPIO_InitStruct.Alternate = GPIO_AF9_QUADSPI;
24016274:	2309      	movs	r3, #9
24016276:	62fb      	str	r3, [r7, #44]	; 0x2c
		HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
24016278:	f107 031c 	add.w	r3, r7, #28
2401627c:	4619      	mov	r1, r3
2401627e:	480f      	ldr	r0, [pc, #60]	; (240162bc <HAL_QSPI_MspInit+0x114>)
24016280:	f7f2 f984 	bl	2400858c <HAL_GPIO_Init>

		GPIO_InitStruct.Pin = GPIO_PIN_11|GPIO_PIN_12|GPIO_PIN_13;
24016284:	f44f 5360 	mov.w	r3, #14336	; 0x3800
24016288:	61fb      	str	r3, [r7, #28]
		GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
2401628a:	2302      	movs	r3, #2
2401628c:	623b      	str	r3, [r7, #32]
		GPIO_InitStruct.Pull = GPIO_NOPULL;
2401628e:	2300      	movs	r3, #0
24016290:	627b      	str	r3, [r7, #36]	; 0x24
		GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
24016292:	2303      	movs	r3, #3
24016294:	62bb      	str	r3, [r7, #40]	; 0x28
		GPIO_InitStruct.Alternate = GPIO_AF9_QUADSPI;
24016296:	2309      	movs	r3, #9
24016298:	62fb      	str	r3, [r7, #44]	; 0x2c
		HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
2401629a:	f107 031c 	add.w	r3, r7, #28
2401629e:	4619      	mov	r1, r3
240162a0:	4807      	ldr	r0, [pc, #28]	; (240162c0 <HAL_QSPI_MspInit+0x118>)
240162a2:	f7f2 f973 	bl	2400858c <HAL_GPIO_Init>

	}
}
240162a6:	bf00      	nop
240162a8:	3730      	adds	r7, #48	; 0x30
240162aa:	46bd      	mov	sp, r7
240162ac:	bd80      	pop	{r7, pc}
240162ae:	bf00      	nop
240162b0:	52005000 	.word	0x52005000
240162b4:	58024400 	.word	0x58024400
240162b8:	58021000 	.word	0x58021000
240162bc:	58020400 	.word	0x58020400
240162c0:	58020c00 	.word	0x58020c00

240162c4 <HAL_QSPI_MspDeInit>:
* This function freeze the hardware resources used in this example
* @param hqspi: QSPI handle pointer
* @retval None
*/
void HAL_QSPI_MspDeInit(QSPI_HandleTypeDef* hqspi)
{
240162c4:	b580      	push	{r7, lr}
240162c6:	b082      	sub	sp, #8
240162c8:	af00      	add	r7, sp, #0
240162ca:	6078      	str	r0, [r7, #4]
	if(hqspi->Instance==QUADSPI)
240162cc:	687b      	ldr	r3, [r7, #4]
240162ce:	681b      	ldr	r3, [r3, #0]
240162d0:	4a0e      	ldr	r2, [pc, #56]	; (2401630c <HAL_QSPI_MspDeInit+0x48>)
240162d2:	4293      	cmp	r3, r2
240162d4:	d115      	bne.n	24016302 <HAL_QSPI_MspDeInit+0x3e>
	{
		__HAL_RCC_QSPI_CLK_DISABLE();
240162d6:	4b0e      	ldr	r3, [pc, #56]	; (24016310 <HAL_QSPI_MspDeInit+0x4c>)
240162d8:	f8d3 30d4 	ldr.w	r3, [r3, #212]	; 0xd4
240162dc:	4a0c      	ldr	r2, [pc, #48]	; (24016310 <HAL_QSPI_MspDeInit+0x4c>)
240162de:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
240162e2:	f8c2 30d4 	str.w	r3, [r2, #212]	; 0xd4
		PB10     ------> QUADSPI_BK1_NCS
		PD11     ------> QUADSPI_BK1_IO0
		PD12     ------> QUADSPI_BK1_IO1
		PD13     ------> QUADSPI_BK1_IO3
		*/
		HAL_GPIO_DeInit(GPIOE, GPIO_PIN_2);
240162e6:	2104      	movs	r1, #4
240162e8:	480a      	ldr	r0, [pc, #40]	; (24016314 <HAL_QSPI_MspDeInit+0x50>)
240162ea:	f7f2 faff 	bl	240088ec <HAL_GPIO_DeInit>

		HAL_GPIO_DeInit(GPIOB, GPIO_PIN_2|GPIO_PIN_10);
240162ee:	f240 4104 	movw	r1, #1028	; 0x404
240162f2:	4809      	ldr	r0, [pc, #36]	; (24016318 <HAL_QSPI_MspDeInit+0x54>)
240162f4:	f7f2 fafa 	bl	240088ec <HAL_GPIO_DeInit>

		HAL_GPIO_DeInit(GPIOD, GPIO_PIN_11|GPIO_PIN_12|GPIO_PIN_13);
240162f8:	f44f 5160 	mov.w	r1, #14336	; 0x3800
240162fc:	4807      	ldr	r0, [pc, #28]	; (2401631c <HAL_QSPI_MspDeInit+0x58>)
240162fe:	f7f2 faf5 	bl	240088ec <HAL_GPIO_DeInit>

	}
}
24016302:	bf00      	nop
24016304:	3708      	adds	r7, #8
24016306:	46bd      	mov	sp, r7
24016308:	bd80      	pop	{r7, pc}
2401630a:	bf00      	nop
2401630c:	52005000 	.word	0x52005000
24016310:	58024400 	.word	0x58024400
24016314:	58021000 	.word	0x58021000
24016318:	58020400 	.word	0x58020400
2401631c:	58020c00 	.word	0x58020c00

24016320 <HAL_MspInit>:

/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
24016320:	b480      	push	{r7}
24016322:	b083      	sub	sp, #12
24016324:	af00      	add	r7, sp, #0
	__HAL_RCC_SYSCFG_CLK_ENABLE();
24016326:	4b0a      	ldr	r3, [pc, #40]	; (24016350 <HAL_MspInit+0x30>)
24016328:	f8d3 30f4 	ldr.w	r3, [r3, #244]	; 0xf4
2401632c:	4a08      	ldr	r2, [pc, #32]	; (24016350 <HAL_MspInit+0x30>)
2401632e:	f043 0302 	orr.w	r3, r3, #2
24016332:	f8c2 30f4 	str.w	r3, [r2, #244]	; 0xf4
24016336:	4b06      	ldr	r3, [pc, #24]	; (24016350 <HAL_MspInit+0x30>)
24016338:	f8d3 30f4 	ldr.w	r3, [r3, #244]	; 0xf4
2401633c:	f003 0302 	and.w	r3, r3, #2
24016340:	607b      	str	r3, [r7, #4]
24016342:	687b      	ldr	r3, [r7, #4]
}
24016344:	bf00      	nop
24016346:	370c      	adds	r7, #12
24016348:	46bd      	mov	sp, r7
2401634a:	f85d 7b04 	ldr.w	r7, [sp], #4
2401634e:	4770      	bx	lr
24016350:	58024400 	.word	0x58024400

24016354 <NMI_Handler>:
/******************************************************************************/
/**
  * @brief This function handles Non maskable interrupt.
  */
void NMI_Handler(void)
{
24016354:	b480      	push	{r7}
24016356:	af00      	add	r7, sp, #0

  /* USER CODE END NonMaskableInt_IRQn 0 */
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */

  /* USER CODE END NonMaskableInt_IRQn 1 */
}
24016358:	bf00      	nop
2401635a:	46bd      	mov	sp, r7
2401635c:	f85d 7b04 	ldr.w	r7, [sp], #4
24016360:	4770      	bx	lr

24016362 <HardFault_Handler>:

/**
  * @brief This function handles Hard fault interrupt.
  */
void HardFault_Handler(void)
{
24016362:	b480      	push	{r7}
24016364:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN HardFault_IRQn 0 */

  /* USER CODE END HardFault_IRQn 0 */
  while (1)
24016366:	e7fe      	b.n	24016366 <HardFault_Handler+0x4>

24016368 <MemManage_Handler>:

/**
  * @brief This function handles Memory management fault.
  */
void MemManage_Handler(void)
{
24016368:	b480      	push	{r7}
2401636a:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN MemoryManagement_IRQn 0 */

  /* USER CODE END MemoryManagement_IRQn 0 */
  while (1)
2401636c:	e7fe      	b.n	2401636c <MemManage_Handler+0x4>

2401636e <BusFault_Handler>:

/**
  * @brief This function handles Pre-fetch fault, memory access fault.
  */
void BusFault_Handler(void)
{
2401636e:	b480      	push	{r7}
24016370:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN BusFault_IRQn 0 */

  /* USER CODE END BusFault_IRQn 0 */
  while (1)
24016372:	e7fe      	b.n	24016372 <BusFault_Handler+0x4>

24016374 <UsageFault_Handler>:

/**
  * @brief This function handles Undefined instruction or illegal state.
  */
void UsageFault_Handler(void)
{
24016374:	b480      	push	{r7}
24016376:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN UsageFault_IRQn 0 */

  /* USER CODE END UsageFault_IRQn 0 */
  while (1)
24016378:	e7fe      	b.n	24016378 <UsageFault_Handler+0x4>

2401637a <SVC_Handler>:

/**
  * @brief This function handles System service call via SWI instruction.
  */
void SVC_Handler(void)
{
2401637a:	b480      	push	{r7}
2401637c:	af00      	add	r7, sp, #0

  /* USER CODE END SVCall_IRQn 0 */
  /* USER CODE BEGIN SVCall_IRQn 1 */

  /* USER CODE END SVCall_IRQn 1 */
}
2401637e:	bf00      	nop
24016380:	46bd      	mov	sp, r7
24016382:	f85d 7b04 	ldr.w	r7, [sp], #4
24016386:	4770      	bx	lr

24016388 <DebugMon_Handler>:

/**
  * @brief This function handles Debug monitor.
  */
void DebugMon_Handler(void)
{
24016388:	b480      	push	{r7}
2401638a:	af00      	add	r7, sp, #0

  /* USER CODE END DebugMonitor_IRQn 0 */
  /* USER CODE BEGIN DebugMonitor_IRQn 1 */

  /* USER CODE END DebugMonitor_IRQn 1 */
}
2401638c:	bf00      	nop
2401638e:	46bd      	mov	sp, r7
24016390:	f85d 7b04 	ldr.w	r7, [sp], #4
24016394:	4770      	bx	lr

24016396 <PendSV_Handler>:

/**
  * @brief This function handles Pendable request for system service.
  */
void PendSV_Handler(void)
{
24016396:	b480      	push	{r7}
24016398:	af00      	add	r7, sp, #0

  /* USER CODE END PendSV_IRQn 0 */
  /* USER CODE BEGIN PendSV_IRQn 1 */

  /* USER CODE END PendSV_IRQn 1 */
}
2401639a:	bf00      	nop
2401639c:	46bd      	mov	sp, r7
2401639e:	f85d 7b04 	ldr.w	r7, [sp], #4
240163a2:	4770      	bx	lr

240163a4 <SysTick_Handler>:

/**
  * @brief This function handles System tick timer.
  */
void SysTick_Handler(void)
{
240163a4:	b580      	push	{r7, lr}
240163a6:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
240163a8:	f7ea fa40 	bl	2400082c <HAL_IncTick>
  /* USER CODE BEGIN SysTick_IRQn 1 */

  /* USER CODE END SysTick_IRQn 1 */
}
240163ac:	bf00      	nop
240163ae:	bd80      	pop	{r7, pc}

240163b0 <initialise_monitor_handles>:
char **environ = __env;


/* Functions */
void initialise_monitor_handles()
{
240163b0:	b480      	push	{r7}
240163b2:	af00      	add	r7, sp, #0
}
240163b4:	bf00      	nop
240163b6:	46bd      	mov	sp, r7
240163b8:	f85d 7b04 	ldr.w	r7, [sp], #4
240163bc:	4770      	bx	lr

240163be <_getpid>:

int _getpid(void)
{
240163be:	b480      	push	{r7}
240163c0:	af00      	add	r7, sp, #0
	return 1;
240163c2:	2301      	movs	r3, #1
}
240163c4:	4618      	mov	r0, r3
240163c6:	46bd      	mov	sp, r7
240163c8:	f85d 7b04 	ldr.w	r7, [sp], #4
240163cc:	4770      	bx	lr

240163ce <_kill>:

int _kill(int pid, int sig)
{
240163ce:	b580      	push	{r7, lr}
240163d0:	b082      	sub	sp, #8
240163d2:	af00      	add	r7, sp, #0
240163d4:	6078      	str	r0, [r7, #4]
240163d6:	6039      	str	r1, [r7, #0]
	errno = EINVAL;
240163d8:	f000 fb0e 	bl	240169f8 <__errno>
240163dc:	4602      	mov	r2, r0
240163de:	2316      	movs	r3, #22
240163e0:	6013      	str	r3, [r2, #0]
	return -1;
240163e2:	f04f 33ff 	mov.w	r3, #4294967295
}
240163e6:	4618      	mov	r0, r3
240163e8:	3708      	adds	r7, #8
240163ea:	46bd      	mov	sp, r7
240163ec:	bd80      	pop	{r7, pc}

240163ee <_exit>:

void _exit (int status)
{
240163ee:	b580      	push	{r7, lr}
240163f0:	b082      	sub	sp, #8
240163f2:	af00      	add	r7, sp, #0
240163f4:	6078      	str	r0, [r7, #4]
	_kill(status, -1);
240163f6:	f04f 31ff 	mov.w	r1, #4294967295
240163fa:	6878      	ldr	r0, [r7, #4]
240163fc:	f7ff ffe7 	bl	240163ce <_kill>
	while (1) {}		/* Make sure we hang here */
24016400:	e7fe      	b.n	24016400 <_exit+0x12>

24016402 <_read>:
}

__attribute__((weak)) int _read(int file, char *ptr, int len)
{
24016402:	b580      	push	{r7, lr}
24016404:	b086      	sub	sp, #24
24016406:	af00      	add	r7, sp, #0
24016408:	60f8      	str	r0, [r7, #12]
2401640a:	60b9      	str	r1, [r7, #8]
2401640c:	607a      	str	r2, [r7, #4]
	int DataIdx;

	for (DataIdx = 0; DataIdx < len; DataIdx++)
2401640e:	2300      	movs	r3, #0
24016410:	617b      	str	r3, [r7, #20]
24016412:	e00a      	b.n	2401642a <_read+0x28>
	{
		*ptr++ = __io_getchar();
24016414:	f3af 8000 	nop.w
24016418:	4601      	mov	r1, r0
2401641a:	68bb      	ldr	r3, [r7, #8]
2401641c:	1c5a      	adds	r2, r3, #1
2401641e:	60ba      	str	r2, [r7, #8]
24016420:	b2ca      	uxtb	r2, r1
24016422:	701a      	strb	r2, [r3, #0]
	for (DataIdx = 0; DataIdx < len; DataIdx++)
24016424:	697b      	ldr	r3, [r7, #20]
24016426:	3301      	adds	r3, #1
24016428:	617b      	str	r3, [r7, #20]
2401642a:	697a      	ldr	r2, [r7, #20]
2401642c:	687b      	ldr	r3, [r7, #4]
2401642e:	429a      	cmp	r2, r3
24016430:	dbf0      	blt.n	24016414 <_read+0x12>
	}

return len;
24016432:	687b      	ldr	r3, [r7, #4]
}
24016434:	4618      	mov	r0, r3
24016436:	3718      	adds	r7, #24
24016438:	46bd      	mov	sp, r7
2401643a:	bd80      	pop	{r7, pc}

2401643c <_write>:

__attribute__((weak)) int _write(int file, char *ptr, int len)
{
2401643c:	b580      	push	{r7, lr}
2401643e:	b086      	sub	sp, #24
24016440:	af00      	add	r7, sp, #0
24016442:	60f8      	str	r0, [r7, #12]
24016444:	60b9      	str	r1, [r7, #8]
24016446:	607a      	str	r2, [r7, #4]
	int DataIdx;

	for (DataIdx = 0; DataIdx < len; DataIdx++)
24016448:	2300      	movs	r3, #0
2401644a:	617b      	str	r3, [r7, #20]
2401644c:	e009      	b.n	24016462 <_write+0x26>
	{
		__io_putchar(*ptr++);
2401644e:	68bb      	ldr	r3, [r7, #8]
24016450:	1c5a      	adds	r2, r3, #1
24016452:	60ba      	str	r2, [r7, #8]
24016454:	781b      	ldrb	r3, [r3, #0]
24016456:	4618      	mov	r0, r3
24016458:	f3af 8000 	nop.w
	for (DataIdx = 0; DataIdx < len; DataIdx++)
2401645c:	697b      	ldr	r3, [r7, #20]
2401645e:	3301      	adds	r3, #1
24016460:	617b      	str	r3, [r7, #20]
24016462:	697a      	ldr	r2, [r7, #20]
24016464:	687b      	ldr	r3, [r7, #4]
24016466:	429a      	cmp	r2, r3
24016468:	dbf1      	blt.n	2401644e <_write+0x12>
	}
	return len;
2401646a:	687b      	ldr	r3, [r7, #4]
}
2401646c:	4618      	mov	r0, r3
2401646e:	3718      	adds	r7, #24
24016470:	46bd      	mov	sp, r7
24016472:	bd80      	pop	{r7, pc}

24016474 <_close>:

int _close(int file)
{
24016474:	b480      	push	{r7}
24016476:	b083      	sub	sp, #12
24016478:	af00      	add	r7, sp, #0
2401647a:	6078      	str	r0, [r7, #4]
	return -1;
2401647c:	f04f 33ff 	mov.w	r3, #4294967295
}
24016480:	4618      	mov	r0, r3
24016482:	370c      	adds	r7, #12
24016484:	46bd      	mov	sp, r7
24016486:	f85d 7b04 	ldr.w	r7, [sp], #4
2401648a:	4770      	bx	lr

2401648c <_fstat>:


int _fstat(int file, struct stat *st)
{
2401648c:	b480      	push	{r7}
2401648e:	b083      	sub	sp, #12
24016490:	af00      	add	r7, sp, #0
24016492:	6078      	str	r0, [r7, #4]
24016494:	6039      	str	r1, [r7, #0]
	st->st_mode = S_IFCHR;
24016496:	683b      	ldr	r3, [r7, #0]
24016498:	f44f 5200 	mov.w	r2, #8192	; 0x2000
2401649c:	605a      	str	r2, [r3, #4]
	return 0;
2401649e:	2300      	movs	r3, #0
}
240164a0:	4618      	mov	r0, r3
240164a2:	370c      	adds	r7, #12
240164a4:	46bd      	mov	sp, r7
240164a6:	f85d 7b04 	ldr.w	r7, [sp], #4
240164aa:	4770      	bx	lr

240164ac <_isatty>:

int _isatty(int file)
{
240164ac:	b480      	push	{r7}
240164ae:	b083      	sub	sp, #12
240164b0:	af00      	add	r7, sp, #0
240164b2:	6078      	str	r0, [r7, #4]
	return 1;
240164b4:	2301      	movs	r3, #1
}
240164b6:	4618      	mov	r0, r3
240164b8:	370c      	adds	r7, #12
240164ba:	46bd      	mov	sp, r7
240164bc:	f85d 7b04 	ldr.w	r7, [sp], #4
240164c0:	4770      	bx	lr

240164c2 <_lseek>:

int _lseek(int file, int ptr, int dir)
{
240164c2:	b480      	push	{r7}
240164c4:	b085      	sub	sp, #20
240164c6:	af00      	add	r7, sp, #0
240164c8:	60f8      	str	r0, [r7, #12]
240164ca:	60b9      	str	r1, [r7, #8]
240164cc:	607a      	str	r2, [r7, #4]
	return 0;
240164ce:	2300      	movs	r3, #0
}
240164d0:	4618      	mov	r0, r3
240164d2:	3714      	adds	r7, #20
240164d4:	46bd      	mov	sp, r7
240164d6:	f85d 7b04 	ldr.w	r7, [sp], #4
240164da:	4770      	bx	lr

240164dc <_open>:

int _open(char *path, int flags, ...)
{
240164dc:	b40e      	push	{r1, r2, r3}
240164de:	b480      	push	{r7}
240164e0:	b082      	sub	sp, #8
240164e2:	af00      	add	r7, sp, #0
240164e4:	6078      	str	r0, [r7, #4]
	/* Pretend like we always fail */
	return -1;
240164e6:	f04f 33ff 	mov.w	r3, #4294967295
}
240164ea:	4618      	mov	r0, r3
240164ec:	3708      	adds	r7, #8
240164ee:	46bd      	mov	sp, r7
240164f0:	f85d 7b04 	ldr.w	r7, [sp], #4
240164f4:	b003      	add	sp, #12
240164f6:	4770      	bx	lr

240164f8 <_wait>:

int _wait(int *status)
{
240164f8:	b580      	push	{r7, lr}
240164fa:	b082      	sub	sp, #8
240164fc:	af00      	add	r7, sp, #0
240164fe:	6078      	str	r0, [r7, #4]
	errno = ECHILD;
24016500:	f000 fa7a 	bl	240169f8 <__errno>
24016504:	4602      	mov	r2, r0
24016506:	230a      	movs	r3, #10
24016508:	6013      	str	r3, [r2, #0]
	return -1;
2401650a:	f04f 33ff 	mov.w	r3, #4294967295
}
2401650e:	4618      	mov	r0, r3
24016510:	3708      	adds	r7, #8
24016512:	46bd      	mov	sp, r7
24016514:	bd80      	pop	{r7, pc}

24016516 <_unlink>:

int _unlink(char *name)
{
24016516:	b580      	push	{r7, lr}
24016518:	b082      	sub	sp, #8
2401651a:	af00      	add	r7, sp, #0
2401651c:	6078      	str	r0, [r7, #4]
	errno = ENOENT;
2401651e:	f000 fa6b 	bl	240169f8 <__errno>
24016522:	4602      	mov	r2, r0
24016524:	2302      	movs	r3, #2
24016526:	6013      	str	r3, [r2, #0]
	return -1;
24016528:	f04f 33ff 	mov.w	r3, #4294967295
}
2401652c:	4618      	mov	r0, r3
2401652e:	3708      	adds	r7, #8
24016530:	46bd      	mov	sp, r7
24016532:	bd80      	pop	{r7, pc}

24016534 <_times>:

int _times(struct tms *buf)
{
24016534:	b480      	push	{r7}
24016536:	b083      	sub	sp, #12
24016538:	af00      	add	r7, sp, #0
2401653a:	6078      	str	r0, [r7, #4]
	return -1;
2401653c:	f04f 33ff 	mov.w	r3, #4294967295
}
24016540:	4618      	mov	r0, r3
24016542:	370c      	adds	r7, #12
24016544:	46bd      	mov	sp, r7
24016546:	f85d 7b04 	ldr.w	r7, [sp], #4
2401654a:	4770      	bx	lr

2401654c <_stat>:

int _stat(char *file, struct stat *st)
{
2401654c:	b480      	push	{r7}
2401654e:	b083      	sub	sp, #12
24016550:	af00      	add	r7, sp, #0
24016552:	6078      	str	r0, [r7, #4]
24016554:	6039      	str	r1, [r7, #0]
	st->st_mode = S_IFCHR;
24016556:	683b      	ldr	r3, [r7, #0]
24016558:	f44f 5200 	mov.w	r2, #8192	; 0x2000
2401655c:	605a      	str	r2, [r3, #4]
	return 0;
2401655e:	2300      	movs	r3, #0
}
24016560:	4618      	mov	r0, r3
24016562:	370c      	adds	r7, #12
24016564:	46bd      	mov	sp, r7
24016566:	f85d 7b04 	ldr.w	r7, [sp], #4
2401656a:	4770      	bx	lr

2401656c <_link>:

int _link(char *old, char *new)
{
2401656c:	b580      	push	{r7, lr}
2401656e:	b082      	sub	sp, #8
24016570:	af00      	add	r7, sp, #0
24016572:	6078      	str	r0, [r7, #4]
24016574:	6039      	str	r1, [r7, #0]
	errno = EMLINK;
24016576:	f000 fa3f 	bl	240169f8 <__errno>
2401657a:	4602      	mov	r2, r0
2401657c:	231f      	movs	r3, #31
2401657e:	6013      	str	r3, [r2, #0]
	return -1;
24016580:	f04f 33ff 	mov.w	r3, #4294967295
}
24016584:	4618      	mov	r0, r3
24016586:	3708      	adds	r7, #8
24016588:	46bd      	mov	sp, r7
2401658a:	bd80      	pop	{r7, pc}

2401658c <_fork>:

int _fork(void)
{
2401658c:	b580      	push	{r7, lr}
2401658e:	af00      	add	r7, sp, #0
	errno = EAGAIN;
24016590:	f000 fa32 	bl	240169f8 <__errno>
24016594:	4602      	mov	r2, r0
24016596:	230b      	movs	r3, #11
24016598:	6013      	str	r3, [r2, #0]
	return -1;
2401659a:	f04f 33ff 	mov.w	r3, #4294967295
}
2401659e:	4618      	mov	r0, r3
240165a0:	bd80      	pop	{r7, pc}

240165a2 <_execve>:

int _execve(char *name, char **argv, char **env)
{
240165a2:	b580      	push	{r7, lr}
240165a4:	b084      	sub	sp, #16
240165a6:	af00      	add	r7, sp, #0
240165a8:	60f8      	str	r0, [r7, #12]
240165aa:	60b9      	str	r1, [r7, #8]
240165ac:	607a      	str	r2, [r7, #4]
	errno = ENOMEM;
240165ae:	f000 fa23 	bl	240169f8 <__errno>
240165b2:	4602      	mov	r2, r0
240165b4:	230c      	movs	r3, #12
240165b6:	6013      	str	r3, [r2, #0]
	return -1;
240165b8:	f04f 33ff 	mov.w	r3, #4294967295
}
240165bc:	4618      	mov	r0, r3
240165be:	3710      	adds	r7, #16
240165c0:	46bd      	mov	sp, r7
240165c2:	bd80      	pop	{r7, pc}

240165c4 <_sbrk>:
/**
 _sbrk
 Increase program data space. Malloc and related functions depend on this
**/
caddr_t _sbrk(int incr)
{
240165c4:	b580      	push	{r7, lr}
240165c6:	b084      	sub	sp, #16
240165c8:	af00      	add	r7, sp, #0
240165ca:	6078      	str	r0, [r7, #4]
	extern char end asm("end");
	static char *heap_end;
	char *prev_heap_end;

	if (heap_end == 0)
240165cc:	4b11      	ldr	r3, [pc, #68]	; (24016614 <_sbrk+0x50>)
240165ce:	681b      	ldr	r3, [r3, #0]
240165d0:	2b00      	cmp	r3, #0
240165d2:	d102      	bne.n	240165da <_sbrk+0x16>
		heap_end = &end;
240165d4:	4b0f      	ldr	r3, [pc, #60]	; (24016614 <_sbrk+0x50>)
240165d6:	4a10      	ldr	r2, [pc, #64]	; (24016618 <_sbrk+0x54>)
240165d8:	601a      	str	r2, [r3, #0]

	prev_heap_end = heap_end;
240165da:	4b0e      	ldr	r3, [pc, #56]	; (24016614 <_sbrk+0x50>)
240165dc:	681b      	ldr	r3, [r3, #0]
240165de:	60fb      	str	r3, [r7, #12]
	if (heap_end + incr > stack_ptr)
240165e0:	4b0c      	ldr	r3, [pc, #48]	; (24016614 <_sbrk+0x50>)
240165e2:	681a      	ldr	r2, [r3, #0]
240165e4:	687b      	ldr	r3, [r7, #4]
240165e6:	4413      	add	r3, r2
240165e8:	466a      	mov	r2, sp
240165ea:	4293      	cmp	r3, r2
240165ec:	d907      	bls.n	240165fe <_sbrk+0x3a>
	{
		errno = ENOMEM;
240165ee:	f000 fa03 	bl	240169f8 <__errno>
240165f2:	4602      	mov	r2, r0
240165f4:	230c      	movs	r3, #12
240165f6:	6013      	str	r3, [r2, #0]
		return (caddr_t) -1;
240165f8:	f04f 33ff 	mov.w	r3, #4294967295
240165fc:	e006      	b.n	2401660c <_sbrk+0x48>
	}

	heap_end += incr;
240165fe:	4b05      	ldr	r3, [pc, #20]	; (24016614 <_sbrk+0x50>)
24016600:	681a      	ldr	r2, [r3, #0]
24016602:	687b      	ldr	r3, [r7, #4]
24016604:	4413      	add	r3, r2
24016606:	4a03      	ldr	r2, [pc, #12]	; (24016614 <_sbrk+0x50>)
24016608:	6013      	str	r3, [r2, #0]

	return (caddr_t) prev_heap_end;
2401660a:	68fb      	ldr	r3, [r7, #12]
}
2401660c:	4618      	mov	r0, r3
2401660e:	3710      	adds	r7, #16
24016610:	46bd      	mov	sp, r7
24016612:	bd80      	pop	{r7, pc}
24016614:	24000544 	.word	0x24000544
24016618:	24016b84 	.word	0x24016b84

2401661c <SystemInit>:
  *         configuration.
  * @param  None
  * @retval None
  */
void SystemInit (void)
{
2401661c:	b480      	push	{r7}
2401661e:	af00      	add	r7, sp, #0
 __IO uint32_t tmpreg;
#endif /* DATA_IN_D2_SRAM */

  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << (10*2))|(3UL << (11*2)));  /* set CP10 and CP11 Full Access */
24016620:	4b29      	ldr	r3, [pc, #164]	; (240166c8 <SystemInit+0xac>)
24016622:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
24016626:	4a28      	ldr	r2, [pc, #160]	; (240166c8 <SystemInit+0xac>)
24016628:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
2401662c:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
  #endif
  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set HSION bit */
  RCC->CR |= RCC_CR_HSION;
24016630:	4b26      	ldr	r3, [pc, #152]	; (240166cc <SystemInit+0xb0>)
24016632:	681b      	ldr	r3, [r3, #0]
24016634:	4a25      	ldr	r2, [pc, #148]	; (240166cc <SystemInit+0xb0>)
24016636:	f043 0301 	orr.w	r3, r3, #1
2401663a:	6013      	str	r3, [r2, #0]

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000;
2401663c:	4b23      	ldr	r3, [pc, #140]	; (240166cc <SystemInit+0xb0>)
2401663e:	2200      	movs	r2, #0
24016640:	611a      	str	r2, [r3, #16]

  /* Reset HSEON, CSSON , CSION,RC48ON, CSIKERON PLL1ON, PLL2ON and PLL3ON bits */
  RCC->CR &= 0xEAF6ED7FU;
24016642:	4b22      	ldr	r3, [pc, #136]	; (240166cc <SystemInit+0xb0>)
24016644:	681a      	ldr	r2, [r3, #0]
24016646:	4921      	ldr	r1, [pc, #132]	; (240166cc <SystemInit+0xb0>)
24016648:	4b21      	ldr	r3, [pc, #132]	; (240166d0 <SystemInit+0xb4>)
2401664a:	4013      	ands	r3, r2
2401664c:	600b      	str	r3, [r1, #0]

#if defined(D3_SRAM_BASE)
  /* Reset D1CFGR register */
  RCC->D1CFGR = 0x00000000;
2401664e:	4b1f      	ldr	r3, [pc, #124]	; (240166cc <SystemInit+0xb0>)
24016650:	2200      	movs	r2, #0
24016652:	619a      	str	r2, [r3, #24]

  /* Reset D2CFGR register */
  RCC->D2CFGR = 0x00000000;
24016654:	4b1d      	ldr	r3, [pc, #116]	; (240166cc <SystemInit+0xb0>)
24016656:	2200      	movs	r2, #0
24016658:	61da      	str	r2, [r3, #28]

  /* Reset D3CFGR register */
  RCC->D3CFGR = 0x00000000;
2401665a:	4b1c      	ldr	r3, [pc, #112]	; (240166cc <SystemInit+0xb0>)
2401665c:	2200      	movs	r2, #0
2401665e:	621a      	str	r2, [r3, #32]

  /* Reset SRDCFGR register */
  RCC->SRDCFGR = 0x00000000;
#endif
  /* Reset PLLCKSELR register */
  RCC->PLLCKSELR = 0x00000000;
24016660:	4b1a      	ldr	r3, [pc, #104]	; (240166cc <SystemInit+0xb0>)
24016662:	2200      	movs	r2, #0
24016664:	629a      	str	r2, [r3, #40]	; 0x28

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x00000000;
24016666:	4b19      	ldr	r3, [pc, #100]	; (240166cc <SystemInit+0xb0>)
24016668:	2200      	movs	r2, #0
2401666a:	62da      	str	r2, [r3, #44]	; 0x2c
  /* Reset PLL1DIVR register */
  RCC->PLL1DIVR = 0x00000000;
2401666c:	4b17      	ldr	r3, [pc, #92]	; (240166cc <SystemInit+0xb0>)
2401666e:	2200      	movs	r2, #0
24016670:	631a      	str	r2, [r3, #48]	; 0x30
  /* Reset PLL1FRACR register */
  RCC->PLL1FRACR = 0x00000000;
24016672:	4b16      	ldr	r3, [pc, #88]	; (240166cc <SystemInit+0xb0>)
24016674:	2200      	movs	r2, #0
24016676:	635a      	str	r2, [r3, #52]	; 0x34

  /* Reset PLL2DIVR register */
  RCC->PLL2DIVR = 0x00000000;
24016678:	4b14      	ldr	r3, [pc, #80]	; (240166cc <SystemInit+0xb0>)
2401667a:	2200      	movs	r2, #0
2401667c:	639a      	str	r2, [r3, #56]	; 0x38

  /* Reset PLL2FRACR register */

  RCC->PLL2FRACR = 0x00000000;
2401667e:	4b13      	ldr	r3, [pc, #76]	; (240166cc <SystemInit+0xb0>)
24016680:	2200      	movs	r2, #0
24016682:	63da      	str	r2, [r3, #60]	; 0x3c
  /* Reset PLL3DIVR register */
  RCC->PLL3DIVR = 0x00000000;
24016684:	4b11      	ldr	r3, [pc, #68]	; (240166cc <SystemInit+0xb0>)
24016686:	2200      	movs	r2, #0
24016688:	641a      	str	r2, [r3, #64]	; 0x40

  /* Reset PLL3FRACR register */
  RCC->PLL3FRACR = 0x00000000;
2401668a:	4b10      	ldr	r3, [pc, #64]	; (240166cc <SystemInit+0xb0>)
2401668c:	2200      	movs	r2, #0
2401668e:	645a      	str	r2, [r3, #68]	; 0x44

  /* Reset HSEBYP bit */
  RCC->CR &= 0xFFFBFFFFU;
24016690:	4b0e      	ldr	r3, [pc, #56]	; (240166cc <SystemInit+0xb0>)
24016692:	681b      	ldr	r3, [r3, #0]
24016694:	4a0d      	ldr	r2, [pc, #52]	; (240166cc <SystemInit+0xb0>)
24016696:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
2401669a:	6013      	str	r3, [r2, #0]

  /* Disable all interrupts */
  RCC->CIER = 0x00000000;
2401669c:	4b0b      	ldr	r3, [pc, #44]	; (240166cc <SystemInit+0xb0>)
2401669e:	2200      	movs	r2, #0
240166a0:	661a      	str	r2, [r3, #96]	; 0x60

#if (STM32H7_DEV_ID == 0x450UL)
  /* dual core CM7 or single core line */
  if((DBGMCU->IDCODE & 0xFFFF0000U) < 0x20000000U)
240166a2:	4b0c      	ldr	r3, [pc, #48]	; (240166d4 <SystemInit+0xb8>)
240166a4:	681a      	ldr	r2, [r3, #0]
240166a6:	4b0c      	ldr	r3, [pc, #48]	; (240166d8 <SystemInit+0xbc>)
240166a8:	4013      	ands	r3, r2
240166aa:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
240166ae:	d202      	bcs.n	240166b6 <SystemInit+0x9a>
  {
    /* if stm32h7 revY*/
    /* Change  the switch matrix read issuing capability to 1 for the AXI SRAM target (Target 7) */
    *((__IO uint32_t*)0x51008108) = 0x000000001U;
240166b0:	4b0a      	ldr	r3, [pc, #40]	; (240166dc <SystemInit+0xc0>)
240166b2:	2201      	movs	r2, #1
240166b4:	601a      	str	r2, [r3, #0]

  /* Configure the Vector Table location add offset address for cortex-M7 ------------------*/
#ifdef VECT_TAB_SRAM
  SCB->VTOR = D1_AXISRAM_BASE  | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal AXI-RAM */
#else
  SCB->VTOR = FLASH_BANK1_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
240166b6:	4b04      	ldr	r3, [pc, #16]	; (240166c8 <SystemInit+0xac>)
240166b8:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
240166bc:	609a      	str	r2, [r3, #8]
#endif

#endif /*DUAL_CORE && CORE_CM4*/

}
240166be:	bf00      	nop
240166c0:	46bd      	mov	sp, r7
240166c2:	f85d 7b04 	ldr.w	r7, [sp], #4
240166c6:	4770      	bx	lr
240166c8:	e000ed00 	.word	0xe000ed00
240166cc:	58024400 	.word	0x58024400
240166d0:	eaf6ed7f 	.word	0xeaf6ed7f
240166d4:	5c001000 	.word	0x5c001000
240166d8:	ffff0000 	.word	0xffff0000
240166dc:	51008108 	.word	0x51008108

240166e0 <SystemCoreClockUpdate>:
  *           value for HSE crystal.
  * @param  None
  * @retval None
  */
void SystemCoreClockUpdate (void)
{
240166e0:	b480      	push	{r7}
240166e2:	b08b      	sub	sp, #44	; 0x2c
240166e4:	af00      	add	r7, sp, #0
  float_t fracn1, pllvco;


  /* Get SYSCLK source -------------------------------------------------------*/

  switch (RCC->CFGR & RCC_CFGR_SWS)
240166e6:	4ba5      	ldr	r3, [pc, #660]	; (2401697c <SystemCoreClockUpdate+0x29c>)
240166e8:	691b      	ldr	r3, [r3, #16]
240166ea:	f003 0338 	and.w	r3, r3, #56	; 0x38
240166ee:	2b18      	cmp	r3, #24
240166f0:	f200 811d 	bhi.w	2401692e <SystemCoreClockUpdate+0x24e>
240166f4:	a201      	add	r2, pc, #4	; (adr r2, 240166fc <SystemCoreClockUpdate+0x1c>)
240166f6:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
240166fa:	bf00      	nop
240166fc:	24016761 	.word	0x24016761
24016700:	2401692f 	.word	0x2401692f
24016704:	2401692f 	.word	0x2401692f
24016708:	2401692f 	.word	0x2401692f
2401670c:	2401692f 	.word	0x2401692f
24016710:	2401692f 	.word	0x2401692f
24016714:	2401692f 	.word	0x2401692f
24016718:	2401692f 	.word	0x2401692f
2401671c:	24016775 	.word	0x24016775
24016720:	2401692f 	.word	0x2401692f
24016724:	2401692f 	.word	0x2401692f
24016728:	2401692f 	.word	0x2401692f
2401672c:	2401692f 	.word	0x2401692f
24016730:	2401692f 	.word	0x2401692f
24016734:	2401692f 	.word	0x2401692f
24016738:	2401692f 	.word	0x2401692f
2401673c:	2401677b 	.word	0x2401677b
24016740:	2401692f 	.word	0x2401692f
24016744:	2401692f 	.word	0x2401692f
24016748:	2401692f 	.word	0x2401692f
2401674c:	2401692f 	.word	0x2401692f
24016750:	2401692f 	.word	0x2401692f
24016754:	2401692f 	.word	0x2401692f
24016758:	2401692f 	.word	0x2401692f
2401675c:	24016781 	.word	0x24016781
  {
  case RCC_CFGR_SWS_HSI:  /* HSI used as system clock source */
    common_system_clock = (uint32_t) (HSI_VALUE >> ((RCC->CR & RCC_CR_HSIDIV)>> 3));
24016760:	4b86      	ldr	r3, [pc, #536]	; (2401697c <SystemCoreClockUpdate+0x29c>)
24016762:	681b      	ldr	r3, [r3, #0]
24016764:	08db      	lsrs	r3, r3, #3
24016766:	f003 0303 	and.w	r3, r3, #3
2401676a:	4a85      	ldr	r2, [pc, #532]	; (24016980 <SystemCoreClockUpdate+0x2a0>)
2401676c:	fa22 f303 	lsr.w	r3, r2, r3
24016770:	627b      	str	r3, [r7, #36]	; 0x24
    break;
24016772:	e0df      	b.n	24016934 <SystemCoreClockUpdate+0x254>

  case RCC_CFGR_SWS_CSI:  /* CSI used as system clock  source */
    common_system_clock = CSI_VALUE;
24016774:	4b83      	ldr	r3, [pc, #524]	; (24016984 <SystemCoreClockUpdate+0x2a4>)
24016776:	627b      	str	r3, [r7, #36]	; 0x24
    break;
24016778:	e0dc      	b.n	24016934 <SystemCoreClockUpdate+0x254>

  case RCC_CFGR_SWS_HSE:  /* HSE used as system clock  source */
    common_system_clock = HSE_VALUE;
2401677a:	4b83      	ldr	r3, [pc, #524]	; (24016988 <SystemCoreClockUpdate+0x2a8>)
2401677c:	627b      	str	r3, [r7, #36]	; 0x24
    break;
2401677e:	e0d9      	b.n	24016934 <SystemCoreClockUpdate+0x254>
  case RCC_CFGR_SWS_PLL1:  /* PLL1 used as system clock  source */

    /* PLL_VCO = (HSE_VALUE or HSI_VALUE or CSI_VALUE/ PLLM) * PLLN
    SYSCLK = PLL_VCO / PLLR
    */
    pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
24016780:	4b7e      	ldr	r3, [pc, #504]	; (2401697c <SystemCoreClockUpdate+0x29c>)
24016782:	6a9b      	ldr	r3, [r3, #40]	; 0x28
24016784:	f003 0303 	and.w	r3, r3, #3
24016788:	61fb      	str	r3, [r7, #28]
    pllm = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM1)>> 4)  ;
2401678a:	4b7c      	ldr	r3, [pc, #496]	; (2401697c <SystemCoreClockUpdate+0x29c>)
2401678c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
2401678e:	091b      	lsrs	r3, r3, #4
24016790:	f003 033f 	and.w	r3, r3, #63	; 0x3f
24016794:	61bb      	str	r3, [r7, #24]
    pllfracen = ((RCC->PLLCFGR & RCC_PLLCFGR_PLL1FRACEN)>>RCC_PLLCFGR_PLL1FRACEN_Pos);
24016796:	4b79      	ldr	r3, [pc, #484]	; (2401697c <SystemCoreClockUpdate+0x29c>)
24016798:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2401679a:	f003 0301 	and.w	r3, r3, #1
2401679e:	617b      	str	r3, [r7, #20]
    fracn1 = (float_t)(uint32_t)(pllfracen* ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1)>> 3));
240167a0:	4b76      	ldr	r3, [pc, #472]	; (2401697c <SystemCoreClockUpdate+0x29c>)
240167a2:	6b5b      	ldr	r3, [r3, #52]	; 0x34
240167a4:	08db      	lsrs	r3, r3, #3
240167a6:	f3c3 030c 	ubfx	r3, r3, #0, #13
240167aa:	697a      	ldr	r2, [r7, #20]
240167ac:	fb02 f303 	mul.w	r3, r2, r3
240167b0:	ee07 3a90 	vmov	s15, r3
240167b4:	eef8 7a67 	vcvt.f32.u32	s15, s15
240167b8:	edc7 7a04 	vstr	s15, [r7, #16]

    if (pllm != 0U)
240167bc:	69bb      	ldr	r3, [r7, #24]
240167be:	2b00      	cmp	r3, #0
240167c0:	f000 80b2 	beq.w	24016928 <SystemCoreClockUpdate+0x248>
    {
      switch (pllsource)
240167c4:	69fb      	ldr	r3, [r7, #28]
240167c6:	2b01      	cmp	r3, #1
240167c8:	d032      	beq.n	24016830 <SystemCoreClockUpdate+0x150>
240167ca:	2b01      	cmp	r3, #1
240167cc:	d302      	bcc.n	240167d4 <SystemCoreClockUpdate+0xf4>
240167ce:	2b02      	cmp	r3, #2
240167d0:	d050      	beq.n	24016874 <SystemCoreClockUpdate+0x194>
240167d2:	e071      	b.n	240168b8 <SystemCoreClockUpdate+0x1d8>
      {
        case RCC_PLLCKSELR_PLLSRC_HSI:  /* HSI used as PLL clock source */

        hsivalue = (HSI_VALUE >> ((RCC->CR & RCC_CR_HSIDIV)>> 3)) ;
240167d4:	4b69      	ldr	r3, [pc, #420]	; (2401697c <SystemCoreClockUpdate+0x29c>)
240167d6:	681b      	ldr	r3, [r3, #0]
240167d8:	08db      	lsrs	r3, r3, #3
240167da:	f003 0303 	and.w	r3, r3, #3
240167de:	4a68      	ldr	r2, [pc, #416]	; (24016980 <SystemCoreClockUpdate+0x2a0>)
240167e0:	fa22 f303 	lsr.w	r3, r2, r3
240167e4:	60fb      	str	r3, [r7, #12]
        pllvco = ( (float_t)hsivalue / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
240167e6:	68fb      	ldr	r3, [r7, #12]
240167e8:	ee07 3a90 	vmov	s15, r3
240167ec:	eef8 6a67 	vcvt.f32.u32	s13, s15
240167f0:	69bb      	ldr	r3, [r7, #24]
240167f2:	ee07 3a90 	vmov	s15, r3
240167f6:	eef8 7a67 	vcvt.f32.u32	s15, s15
240167fa:	ee86 7aa7 	vdiv.f32	s14, s13, s15
240167fe:	4b5f      	ldr	r3, [pc, #380]	; (2401697c <SystemCoreClockUpdate+0x29c>)
24016800:	6b1b      	ldr	r3, [r3, #48]	; 0x30
24016802:	f3c3 0308 	ubfx	r3, r3, #0, #9
24016806:	ee07 3a90 	vmov	s15, r3
2401680a:	eef8 6a67 	vcvt.f32.u32	s13, s15
2401680e:	ed97 6a04 	vldr	s12, [r7, #16]
24016812:	eddf 5a5e 	vldr	s11, [pc, #376]	; 2401698c <SystemCoreClockUpdate+0x2ac>
24016816:	eec6 7a25 	vdiv.f32	s15, s12, s11
2401681a:	ee76 7aa7 	vadd.f32	s15, s13, s15
2401681e:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
24016822:	ee77 7aa6 	vadd.f32	s15, s15, s13
24016826:	ee67 7a27 	vmul.f32	s15, s14, s15
2401682a:	edc7 7a08 	vstr	s15, [r7, #32]

        break;
2401682e:	e065      	b.n	240168fc <SystemCoreClockUpdate+0x21c>

        case RCC_PLLCKSELR_PLLSRC_CSI:  /* CSI used as PLL clock source */
          pllvco = ((float_t)CSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
24016830:	69bb      	ldr	r3, [r7, #24]
24016832:	ee07 3a90 	vmov	s15, r3
24016836:	eef8 7a67 	vcvt.f32.u32	s15, s15
2401683a:	eddf 6a55 	vldr	s13, [pc, #340]	; 24016990 <SystemCoreClockUpdate+0x2b0>
2401683e:	ee86 7aa7 	vdiv.f32	s14, s13, s15
24016842:	4b4e      	ldr	r3, [pc, #312]	; (2401697c <SystemCoreClockUpdate+0x29c>)
24016844:	6b1b      	ldr	r3, [r3, #48]	; 0x30
24016846:	f3c3 0308 	ubfx	r3, r3, #0, #9
2401684a:	ee07 3a90 	vmov	s15, r3
2401684e:	eef8 6a67 	vcvt.f32.u32	s13, s15
24016852:	ed97 6a04 	vldr	s12, [r7, #16]
24016856:	eddf 5a4d 	vldr	s11, [pc, #308]	; 2401698c <SystemCoreClockUpdate+0x2ac>
2401685a:	eec6 7a25 	vdiv.f32	s15, s12, s11
2401685e:	ee76 7aa7 	vadd.f32	s15, s13, s15
24016862:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
24016866:	ee77 7aa6 	vadd.f32	s15, s15, s13
2401686a:	ee67 7a27 	vmul.f32	s15, s14, s15
2401686e:	edc7 7a08 	vstr	s15, [r7, #32]
        break;
24016872:	e043      	b.n	240168fc <SystemCoreClockUpdate+0x21c>

        case RCC_PLLCKSELR_PLLSRC_HSE:  /* HSE used as PLL clock source */
          pllvco = ((float_t)HSE_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
24016874:	69bb      	ldr	r3, [r7, #24]
24016876:	ee07 3a90 	vmov	s15, r3
2401687a:	eef8 7a67 	vcvt.f32.u32	s15, s15
2401687e:	eddf 6a45 	vldr	s13, [pc, #276]	; 24016994 <SystemCoreClockUpdate+0x2b4>
24016882:	ee86 7aa7 	vdiv.f32	s14, s13, s15
24016886:	4b3d      	ldr	r3, [pc, #244]	; (2401697c <SystemCoreClockUpdate+0x29c>)
24016888:	6b1b      	ldr	r3, [r3, #48]	; 0x30
2401688a:	f3c3 0308 	ubfx	r3, r3, #0, #9
2401688e:	ee07 3a90 	vmov	s15, r3
24016892:	eef8 6a67 	vcvt.f32.u32	s13, s15
24016896:	ed97 6a04 	vldr	s12, [r7, #16]
2401689a:	eddf 5a3c 	vldr	s11, [pc, #240]	; 2401698c <SystemCoreClockUpdate+0x2ac>
2401689e:	eec6 7a25 	vdiv.f32	s15, s12, s11
240168a2:	ee76 7aa7 	vadd.f32	s15, s13, s15
240168a6:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
240168aa:	ee77 7aa6 	vadd.f32	s15, s15, s13
240168ae:	ee67 7a27 	vmul.f32	s15, s14, s15
240168b2:	edc7 7a08 	vstr	s15, [r7, #32]
        break;
240168b6:	e021      	b.n	240168fc <SystemCoreClockUpdate+0x21c>

      default:
          pllvco = ((float_t)CSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
240168b8:	69bb      	ldr	r3, [r7, #24]
240168ba:	ee07 3a90 	vmov	s15, r3
240168be:	eef8 7a67 	vcvt.f32.u32	s15, s15
240168c2:	eddf 6a33 	vldr	s13, [pc, #204]	; 24016990 <SystemCoreClockUpdate+0x2b0>
240168c6:	ee86 7aa7 	vdiv.f32	s14, s13, s15
240168ca:	4b2c      	ldr	r3, [pc, #176]	; (2401697c <SystemCoreClockUpdate+0x29c>)
240168cc:	6b1b      	ldr	r3, [r3, #48]	; 0x30
240168ce:	f3c3 0308 	ubfx	r3, r3, #0, #9
240168d2:	ee07 3a90 	vmov	s15, r3
240168d6:	eef8 6a67 	vcvt.f32.u32	s13, s15
240168da:	ed97 6a04 	vldr	s12, [r7, #16]
240168de:	eddf 5a2b 	vldr	s11, [pc, #172]	; 2401698c <SystemCoreClockUpdate+0x2ac>
240168e2:	eec6 7a25 	vdiv.f32	s15, s12, s11
240168e6:	ee76 7aa7 	vadd.f32	s15, s13, s15
240168ea:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
240168ee:	ee77 7aa6 	vadd.f32	s15, s15, s13
240168f2:	ee67 7a27 	vmul.f32	s15, s14, s15
240168f6:	edc7 7a08 	vstr	s15, [r7, #32]
        break;
240168fa:	bf00      	nop
      }
      pllp = (((RCC->PLL1DIVR & RCC_PLL1DIVR_P1) >>9) + 1U ) ;
240168fc:	4b1f      	ldr	r3, [pc, #124]	; (2401697c <SystemCoreClockUpdate+0x29c>)
240168fe:	6b1b      	ldr	r3, [r3, #48]	; 0x30
24016900:	0a5b      	lsrs	r3, r3, #9
24016902:	f003 037f 	and.w	r3, r3, #127	; 0x7f
24016906:	3301      	adds	r3, #1
24016908:	60bb      	str	r3, [r7, #8]
      common_system_clock =  (uint32_t)(float_t)(pllvco/(float_t)pllp);
2401690a:	68bb      	ldr	r3, [r7, #8]
2401690c:	ee07 3a90 	vmov	s15, r3
24016910:	eeb8 7a67 	vcvt.f32.u32	s14, s15
24016914:	edd7 6a08 	vldr	s13, [r7, #32]
24016918:	eec6 7a87 	vdiv.f32	s15, s13, s14
2401691c:	eefc 7ae7 	vcvt.u32.f32	s15, s15
24016920:	ee17 3a90 	vmov	r3, s15
24016924:	627b      	str	r3, [r7, #36]	; 0x24
    }
    else
    {
      common_system_clock = 0U;
    }
    break;
24016926:	e005      	b.n	24016934 <SystemCoreClockUpdate+0x254>
      common_system_clock = 0U;
24016928:	2300      	movs	r3, #0
2401692a:	627b      	str	r3, [r7, #36]	; 0x24
    break;
2401692c:	e002      	b.n	24016934 <SystemCoreClockUpdate+0x254>

  default:
    common_system_clock = CSI_VALUE;
2401692e:	4b15      	ldr	r3, [pc, #84]	; (24016984 <SystemCoreClockUpdate+0x2a4>)
24016930:	627b      	str	r3, [r7, #36]	; 0x24
    break;
24016932:	bf00      	nop
  }

  /* Compute SystemClock frequency --------------------------------------------------*/
#if defined (RCC_D1CFGR_D1CPRE)
  tmp = D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos];
24016934:	4b11      	ldr	r3, [pc, #68]	; (2401697c <SystemCoreClockUpdate+0x29c>)
24016936:	699b      	ldr	r3, [r3, #24]
24016938:	0a1b      	lsrs	r3, r3, #8
2401693a:	f003 030f 	and.w	r3, r3, #15
2401693e:	4a16      	ldr	r2, [pc, #88]	; (24016998 <SystemCoreClockUpdate+0x2b8>)
24016940:	5cd3      	ldrb	r3, [r2, r3]
24016942:	607b      	str	r3, [r7, #4]

  /* common_system_clock frequency : CM7 CPU frequency  */
  common_system_clock >>= tmp;
24016944:	6a7a      	ldr	r2, [r7, #36]	; 0x24
24016946:	687b      	ldr	r3, [r7, #4]
24016948:	fa22 f303 	lsr.w	r3, r2, r3
2401694c:	627b      	str	r3, [r7, #36]	; 0x24

  /* SystemD2Clock frequency : CM4 CPU, AXI and AHBs Clock frequency  */
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
2401694e:	4b0b      	ldr	r3, [pc, #44]	; (2401697c <SystemCoreClockUpdate+0x29c>)
24016950:	699b      	ldr	r3, [r3, #24]
24016952:	f003 030f 	and.w	r3, r3, #15
24016956:	4a10      	ldr	r2, [pc, #64]	; (24016998 <SystemCoreClockUpdate+0x2b8>)
24016958:	5cd3      	ldrb	r3, [r2, r3]
2401695a:	f003 031f 	and.w	r3, r3, #31
2401695e:	6a7a      	ldr	r2, [r7, #36]	; 0x24
24016960:	fa22 f303 	lsr.w	r3, r2, r3
24016964:	4a0d      	ldr	r2, [pc, #52]	; (2401699c <SystemCoreClockUpdate+0x2bc>)
24016966:	6013      	str	r3, [r2, #0]
#endif

#if defined(DUAL_CORE) && defined(CORE_CM4)
  SystemCoreClock = SystemD2Clock;
#else
  SystemCoreClock = common_system_clock;
24016968:	4a0d      	ldr	r2, [pc, #52]	; (240169a0 <SystemCoreClockUpdate+0x2c0>)
2401696a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
2401696c:	6013      	str	r3, [r2, #0]
#endif /* DUAL_CORE && CORE_CM4 */
}
2401696e:	bf00      	nop
24016970:	372c      	adds	r7, #44	; 0x2c
24016972:	46bd      	mov	sp, r7
24016974:	f85d 7b04 	ldr.w	r7, [sp], #4
24016978:	4770      	bx	lr
2401697a:	bf00      	nop
2401697c:	58024400 	.word	0x58024400
24016980:	03d09000 	.word	0x03d09000
24016984:	003d0900 	.word	0x003d0900
24016988:	017d7840 	.word	0x017d7840
2401698c:	46000000 	.word	0x46000000
24016990:	4a742400 	.word	0x4a742400
24016994:	4bbebc20 	.word	0x4bbebc20
24016998:	24016b70 	.word	0x24016b70
2401699c:	240004bc 	.word	0x240004bc
240169a0:	240004b8 	.word	0x240004b8

240169a4 <Reset_Handler>:

    .section  .text.Reset_Handler
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler:  
  ldr   sp, =_estack      /* set stack pointer */
240169a4:	f8df d034 	ldr.w	sp, [pc, #52]	; 240169dc <LoopFillZerobss+0x14>

/* Copy the data segment initializers from flash to SRAM */  
  movs  r1, #0
240169a8:	2100      	movs	r1, #0
  b  LoopCopyDataInit
240169aa:	e003      	b.n	240169b4 <LoopCopyDataInit>

240169ac <CopyDataInit>:

CopyDataInit:
  ldr  r3, =_sidata
240169ac:	4b0c      	ldr	r3, [pc, #48]	; (240169e0 <LoopFillZerobss+0x18>)
  ldr  r3, [r3, r1]
240169ae:	585b      	ldr	r3, [r3, r1]
  str  r3, [r0, r1]
240169b0:	5043      	str	r3, [r0, r1]
  adds  r1, r1, #4
240169b2:	3104      	adds	r1, #4

240169b4 <LoopCopyDataInit>:
    
LoopCopyDataInit:
  ldr  r0, =_sdata
240169b4:	480b      	ldr	r0, [pc, #44]	; (240169e4 <LoopFillZerobss+0x1c>)
  ldr  r3, =_edata
240169b6:	4b0c      	ldr	r3, [pc, #48]	; (240169e8 <LoopFillZerobss+0x20>)
  adds  r2, r0, r1
240169b8:	1842      	adds	r2, r0, r1
  cmp  r2, r3
240169ba:	429a      	cmp	r2, r3
  bcc  CopyDataInit
240169bc:	d3f6      	bcc.n	240169ac <CopyDataInit>
  ldr  r2, =_sbss
240169be:	4a0b      	ldr	r2, [pc, #44]	; (240169ec <LoopFillZerobss+0x24>)
  b  LoopFillZerobss
240169c0:	e002      	b.n	240169c8 <LoopFillZerobss>

240169c2 <FillZerobss>:
/* Zero fill the bss segment. */  
FillZerobss:
  movs  r3, #0
240169c2:	2300      	movs	r3, #0
  str  r3, [r2], #4
240169c4:	f842 3b04 	str.w	r3, [r2], #4

240169c8 <LoopFillZerobss>:
    
LoopFillZerobss:
  ldr  r3, = _ebss
240169c8:	4b09      	ldr	r3, [pc, #36]	; (240169f0 <LoopFillZerobss+0x28>)
  cmp  r2, r3
240169ca:	429a      	cmp	r2, r3
  bcc  FillZerobss
240169cc:	d3f9      	bcc.n	240169c2 <FillZerobss>

/* Call the clock system intitialization function.*/
  bl  SystemInit   
240169ce:	f7ff fe25 	bl	2401661c <SystemInit>
/* Call static constructors */
    bl __libc_init_array
240169d2:	f000 f82b 	bl	24016a2c <__libc_init_array>
/* Call the application's entry point.*/
  bl  Init
240169d6:	f7fe fdaf 	bl	24015538 <Init>
  bx  lr    
240169da:	4770      	bx	lr
  ldr   sp, =_estack      /* set stack pointer */
240169dc:	24080004 	.word	0x24080004
  ldr  r3, =_sidata
240169e0:	240004a8 	.word	0x240004a8
  ldr  r0, =_sdata
240169e4:	240004a8 	.word	0x240004a8
  ldr  r3, =_edata
240169e8:	24000524 	.word	0x24000524
  ldr  r2, =_sbss
240169ec:	24000524 	.word	0x24000524
  ldr  r3, = _ebss
240169f0:	240005b4 	.word	0x240005b4

240169f4 <ADC3_IRQHandler>:
 * @retval None       
*/
    .section  .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b  Infinite_Loop
240169f4:	e7fe      	b.n	240169f4 <ADC3_IRQHandler>
	...

240169f8 <__errno>:
240169f8:	4b01      	ldr	r3, [pc, #4]	; (24016a00 <__errno+0x8>)
240169fa:	6818      	ldr	r0, [r3, #0]
240169fc:	4770      	bx	lr
240169fe:	bf00      	nop
24016a00:	240004c0 	.word	0x240004c0

24016a04 <exit>:
24016a04:	b508      	push	{r3, lr}
24016a06:	4b07      	ldr	r3, [pc, #28]	; (24016a24 <exit+0x20>)
24016a08:	4604      	mov	r4, r0
24016a0a:	b113      	cbz	r3, 24016a12 <exit+0xe>
24016a0c:	2100      	movs	r1, #0
24016a0e:	f3af 8000 	nop.w
24016a12:	4b05      	ldr	r3, [pc, #20]	; (24016a28 <exit+0x24>)
24016a14:	6818      	ldr	r0, [r3, #0]
24016a16:	6a83      	ldr	r3, [r0, #40]	; 0x28
24016a18:	b103      	cbz	r3, 24016a1c <exit+0x18>
24016a1a:	4798      	blx	r3
24016a1c:	4620      	mov	r0, r4
24016a1e:	f7ff fce6 	bl	240163ee <_exit>
24016a22:	bf00      	nop
24016a24:	00000000 	.word	0x00000000
24016a28:	24016b80 	.word	0x24016b80

24016a2c <__libc_init_array>:
24016a2c:	b570      	push	{r4, r5, r6, lr}
24016a2e:	4e0d      	ldr	r6, [pc, #52]	; (24016a64 <__libc_init_array+0x38>)
24016a30:	4c0d      	ldr	r4, [pc, #52]	; (24016a68 <__libc_init_array+0x3c>)
24016a32:	1ba4      	subs	r4, r4, r6
24016a34:	10a4      	asrs	r4, r4, #2
24016a36:	2500      	movs	r5, #0
24016a38:	42a5      	cmp	r5, r4
24016a3a:	d109      	bne.n	24016a50 <__libc_init_array+0x24>
24016a3c:	4e0b      	ldr	r6, [pc, #44]	; (24016a6c <__libc_init_array+0x40>)
24016a3e:	4c0c      	ldr	r4, [pc, #48]	; (24016a70 <__libc_init_array+0x44>)
24016a40:	f000 f822 	bl	24016a88 <_init>
24016a44:	1ba4      	subs	r4, r4, r6
24016a46:	10a4      	asrs	r4, r4, #2
24016a48:	2500      	movs	r5, #0
24016a4a:	42a5      	cmp	r5, r4
24016a4c:	d105      	bne.n	24016a5a <__libc_init_array+0x2e>
24016a4e:	bd70      	pop	{r4, r5, r6, pc}
24016a50:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
24016a54:	4798      	blx	r3
24016a56:	3501      	adds	r5, #1
24016a58:	e7ee      	b.n	24016a38 <__libc_init_array+0xc>
24016a5a:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
24016a5e:	4798      	blx	r3
24016a60:	3501      	adds	r5, #1
24016a62:	e7f2      	b.n	24016a4a <__libc_init_array+0x1e>
24016a64:	240004a0 	.word	0x240004a0
24016a68:	240004a0 	.word	0x240004a0
24016a6c:	240004a0 	.word	0x240004a0
24016a70:	240004a4 	.word	0x240004a4

24016a74 <memset>:
24016a74:	4402      	add	r2, r0
24016a76:	4603      	mov	r3, r0
24016a78:	4293      	cmp	r3, r2
24016a7a:	d100      	bne.n	24016a7e <memset+0xa>
24016a7c:	4770      	bx	lr
24016a7e:	f803 1b01 	strb.w	r1, [r3], #1
24016a82:	e7f9      	b.n	24016a78 <memset+0x4>

24016a84 <__EH_FRAME_BEGIN__>:
24016a84:	0000 0000                                   ....

24016a88 <_init>:
24016a88:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
24016a8a:	bf00      	nop
24016a8c:	bcf8      	pop	{r3, r4, r5, r6, r7}
24016a8e:	bc08      	pop	{r3}
24016a90:	469e      	mov	lr, r3
24016a92:	4770      	bx	lr

24016a94 <_fini>:
24016a94:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
24016a96:	bf00      	nop
24016a98:	bcf8      	pop	{r3, r4, r5, r6, r7}
24016a9a:	bc08      	pop	{r3}
24016a9c:	469e      	mov	lr, r3
24016a9e:	4770      	bx	lr
